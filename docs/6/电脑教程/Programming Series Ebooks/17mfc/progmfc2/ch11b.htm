<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>MFC and the Multiple Document Interface</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11a.htm", "ch11c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="327"><H1>MFC and the Multiple Document Interface</H1></A>

<p>From a user's point of view, five fundamental characteristics distinguish MDI 
applications from SDI applications:
</p>

<UL>
<p><LI>MDI applications permit the user to have two or more documents open for editing at once. SDI applications, by contrast, require the user to close the currently open document before opening another.</li></p>


 
<p><li>MDI applications sometimes support multiple document types. For example, an all-in-one word processing, spreadsheet, and charting program might be implemented as an MDI application that supports three document types: word processing documents containing text, spreadsheet 
documents containing spreadsheets, and chart documents containing charts.
</li></p>

<p><li>MDI applications feature a Window menu with a New Window command for opening secondary views of a document and commands for arranging the windows in which the views appear. The Window menu also contains a list of open views. Selecting a view from this menu makes that view the active view and the document associated with that view the active document.
</li></p>

<p><li>SDI applications generally feature just one menu. MDI applications have at least two: one that's displayed when no documents are open and another that's displayed when at least one document is open. Some MDI applications have more than two menus. An MDI application that supports multiple document types generally implements one menu per document type.</li></p>

<p><li>SDI applications use just one frame window&#8212;the top-level frame window that serves as the application's main window and frames views of open documents. MDI applications use two: a top-level frame window and <I>child frames</I> or <I>document frames</I> that float within the top-level frame 
window and frame views of open documents.</li></p>
</UL>

<p>Without help from a framework such as MFC, MDI applications require more effort to create than SDI applications. For example, it's the developer's responsi-bility to update the menu that appears in the top-level frame window as 
documents are opened, closed, and switched between. It's the developer's responsibility to implement the Window menu. And it's the developer's responsibility to create and manage the document frames that float within the top-level frame window. 
Under the hood, these and other features of the MDI user interface model translate into dozens of annoying little implementation details that you (or someone) 
must account for.
</p>

<p>That's the bad news. The good news is that MFC's document/view architecture abstracts the user interface model so that writing MDI applications is only slightly different than writing SDI applications. Like their SDI counterparts, MDI document/view applications store data in document objects based on <I>CDocument</I> and present views of that data in view objects based on <I>CView</I> or one of its derivatives. The chief structural differences between MDI and SDI applications built with MFC are as follows:
</p>

<UL>

<p><LI>MDI applications derive their top-level frame window classes from <I>CMDI-FrameWnd</I> rather than <I>CFrameWnd</I>.</li></p>

 
<p><li>MDI applications use classes based on 
<I>CMDIChildWnd</I> to represent the child frame windows that frame views of their documents.</li></p>

<p><li>MDI applications use <I>CMultiDocTemplate</I> rather than <I>CSingleDocTemplate</I> to create document templates. The frame window class referenced in <I>CMultiDocTemplate</I>'s constructor is the child frame window class rather than the top-level frame window class.
</li></p>

<p><li>MDI applications have at least two menu resources, as opposed to SDI's one. One is displayed when no documents are open; the other is displayed when at least one document is open.
</li></p>
</ul>

<p>These are the differences that you see. On the inside, MFC devotes hundreds of lines of code to MDI-specific chores such as dynamically switching menus and creating new views of open documents. In short, the framework manages almost every 
aspect of an MDI application's user interface to spare you the chore of having to do it yourself. And to a large extent, details that aren't automatically handled for you by MFC are handled by AppWizard. If you choose Multiple Documents instead of Single Documents in AppWizard's Step 1 dialog box (shown in Figure 11-1), AppWizard emits an MDI application skeleton. From that point on, writing an MDI application is 
just like writing an SDI application. You just write a document/view application; MFC handles all the rest.
</p>

<p>Well, MFC handles <I>almost</I> all the rest. You mustn't forget one important implementation detail. That &quot;detail&quot; is the subject of the next section.
</p>

<p>
<A HREF="javascript:fullSize('F11mg01x.htm')"> <img src="images/F11mg01.JPG" width=404 height=325 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 11-1.</B> <I>Using AppWizard to create an MDI application.</I><!-- /CAPTION -->
</p>

<A NAME="328"><H2>Synchronizing Multiple Views of a Document</H2></A>

<p>When you elect to use the MDI user interface model, you implicitly afford your users the freedom to display multiple concurrent views of a document. A user editing a 100-page document might use this feature of your application to display pages 1 and 100 side by side for comparison.
</p>

<p>When the New Window command is selected from the Window menu, an MFC-provided command handler pulls up the document template, extracts <I>CRuntimeClass</I> pointers identifying the view class and the frame window class, and instantiates a 
new view and a new frame window (a child frame, not a top-level frame) to go with it. Under the hood, the secondary view's address is added to the linked list of views maintained by the document object so that the document is aware that two 
independent views of it are visible on the screen. If either view is asked to repaint, it calls <I>GetDocument</I> to acquire a pointer to the document object, queries the document 
for the data it needs, and repaints. Because both views are connected to the same document object (that is, <I>GetDocument</I> returns the same pointer in either view), each enjoys access to the same set of document data. Moreover, the architecture is scalable: it works just as well for hundreds of open views as it does for two.
</p>

<p>So far, so good. Now consider what happens if the user edits the document in one of the views. If the change is visible (or has consequences that are visible) in the other views, the other views should be updated to reflect the change. The catch is that the update doesn't happen automatically; it's up to you to make sure that when the document is edited in one view, other views&#8212;if they exist&#8212;are updated, too. The framework provides the mechanism to make this happen in the form of <I>CDocument::UpdateAllViews</I> and <I>CView::OnUpdate</I>, which were briefly discussed in Chapter 9. It's now time to examine these functions more closely.
</p>

<p>Suppose you write a program editor that uses the MDI architecture to allow the user to display multiple views of a source code file. If a change made to a file in one view is visible in the others, all views of that file should be updated to reflect the change. That's what <I>UpdateAllViews</I> is for. When a document's data is modified in a multiple-view application, someone&#8212;either the object that made the modification (usually a view object) or the document object&#8212;should call 
<I>UpdateAllViews</I> to update the views. 
<I>UpdateAllViews</I> iterates through the list of views associated with the document, calling each view's virtual 
<I>OnUpdate</I> function.
</p>

<p><I>CView</I> provides a trivial implementation of 
<I>OnUpdate</I> that invalidates the view and forces a call to 
<I>OnDraw</I>. If a full repaint is what you want, there's no need to override <I>OnUpdate</I>. If, however, you want to make updates as efficient as possible by repainting only the part of the view that changed, you can override <I>OnUpdate</I> in the view class and make use of hint information passed to <I>UpdateAllViews</I>. 
<I>UpdateAllViews</I> is prototyped as follows:
</p>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>void UpdateAllViews (CView* pSender, LPARAM lHint = 0L,
    CObject* pHint = NULL)
</PRE>
</td></tr></table></p>

<p>The function prototype for <I>OnUpdate</I> looks very similar:</p>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>virtual void OnUpdate (CView* pSender, LPARAM lHint,
    CObject* pHint)
</PRE>
</td></tr></table></p>

<p><I>lHint</I> and <I>pHint</I> carry hint information from 
<I>UpdateAllViews</I> to <I>OnUpdate</I>. How you use these parameters is highly application-specific. A simple use for hint information is to pass the address of a RECT structure or a <I>CRect</I> object specifying what part of the view needs updating. <I>OnUpdate</I> can use that information in a call to <I>InvalidateRect</I>, as demonstrated here:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>// In the document class
UpdateAllViews (NULL, 1, (CObject*) pRect);

    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">  

// In the view class
void CMyView::OnUpdate (CView* pSender, LPARAM lHint, CObject* pHint)
{
    if (lHint == 1) {
        CRect* pRect = (CRect*) pHint;
        InvalidateRect (pRect);
        return;
    }
    CView::OnUpdate (pSender, lHint, pHint);
}
</PRE>
</td></tr></table>
</p>

<p>If the document's data consists of an array of 
<I>CObject</I>s and <I>UpdateAllViews</I> is 
called because a new <I>CObject</I> was added to the document, 
<I>pHint</I> might be used to pass the new 
<I>CObject</I>'s address. The following example assumes that 
<I>pLine</I> holds a pointer to an instance of a 
<I>CObject</I>-derived class named <I>CLine</I> and that 
<I>CLine</I> includes a public member function named 
<I>Draw</I> that can be called to render the 
<I>CLine</I> on the screen:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>// In the document class
UpdateAllViews (NULL, 1, pLine);

    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">

// In the view class
void CMyView::OnUpdate (CView* pSender, LPARAM lHint, CObject* pHint)
{
    if (lHint == 1) {
        CLine* pLine = (CLine*) pHint;
        CClientDC dc (this);
        pLine-&gt;Draw (&amp;dc);
        return;
    }
    CView::OnUpdate (pSender, lHint, pHint);
}
</PRE>
</td></tr></table>
</p>

<p>In both examples, <I>OnUpdate</I> forwards the call to the base class if <I>lHint</I> is anything other than the application-specific value passed to <I>UpdateAllViews</I>. That's important, because MFC sometimes calls <I>OnUpdate</I> itself with <I>lHint</I> equal to 0. You can use any nonzero value that you like for <I>lHint</I>. You can even define multiple &quot;hint sets&quot; that assign different meanings to <I>pHint</I> and use <I>lHint</I> to identify the hint type.
</p>

<p>You can use <I>UpdateAllViews</I>' first parameter, 
<I>pSender</I>, to omit a view from 
the update cycle. If <I>pSender</I> is NULL, 
<I>UpdateAllViews</I> calls each view's 
<I>OnUpdate</I> function. If <I>pSender</I> is non-NULL, 
<I>UpdateAllViews</I> calls <I>OnUpdate</I> on every 
view <I>except</I> the one identified by 
<I>pSender</I>. When a function in the document class 
calls <I>UpdateAllViews</I>, it typically sets 
<I>pSender</I> to NULL so that all the views will be 
updated. If a view calls <I>UpdateAllViews</I>, however, it can set <I>pSender</I> to <I>this</I> to prevent its own 
<I>OnUpdate</I> function from being called. If the view has already updated itself in response to user input, its <I>OnUpdate</I> function doesn't need to be called. If, however, the view hasn't already updated itself because it performs all of its updating in <I>OnUpdate</I>, it should pass <I>UpdateAllViews</I> a NULL first parameter.
</p>

<p>The sample program in the next section makes trivial use of 
<I>UpdateAllViews</I> by calling it without hint parameters. Secondary views are updated by the default implementation of <I>OnUpdate</I>. Later in this chapter, we'll develop a more ambitious multiple-view application that passes hint information to <I>UpdateAllViews</I> and makes use of that information in <I>OnUpdate</I>.
</p>

<A NAME="329"><H2>The MdiSquares Application</H2></A>

<p>The MdiSquares application shown in Figure 11-2 is an MDI version of Chapter 9's SdiSquares. The document and view classes that it uses are identical to those used in SdiSquares, save for the fact that MdiSquares' view class draws the squares slightly smaller to conserve screen space.
</p>

<p>
<A HREF="javascript:fullSize('F11mg02x.htm')"> <img src="images/F11mg02.JPG" width=404 height=333 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 11-2.</B> <I>MdiSquares with two documents open.</I><!-- /CAPTION -->
</p>

<p>When you run MdiSquares, the first document is opened automatically. You can open additional documents by selecting New from the File menu. To open another view of a document, select New Window from the Window menu. Observe that if you have two views of a document displayed and you click a square in one view, the square's color changes in both views. That's because the document's <I>SetSquare</I> function, which the view calls to add a color to a square, calls <I>UpdateAllViews</I> after recording the square's color in 
<I>m_clrGrid</I>. Here's the relevant statement in SquaresDoc.cpp:
</p>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>UpdateAllViews (NULL);
</PRE>
</td></tr></table></p>

<p>Because no hint information is passed in the call, and because <I>CSquaresView</I> doesn't override <I>OnUpdate</I>, each view is repainted in its entirety when <I>SetSquare</I> is called. If you look closely, you can see the views flash each time you click a square. The flashing is a consequence of the fact that the entire view is being erased and repainted each time <I>UpdateAllViews</I> is called.
</p>

<p>SquaresDoc.cpp and other MdiSquares source code files are shown in Figure 11-3.  The main frame window class, <I>CMainFrame</I>, represents the application's top-level window. Views are displayed in instances of the child frame window class, <I>CChildFrame</I>. Notice that in 
<I>InitInstance</I>, <I>CChildFrame</I>, not <I>CMainFrame</I>, is identified as the frame window class when the document template is initialized:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>CMultiDocTemplate* pDocTemplate;
pDocTemplate = new CMultiDocTemplate(
    IDR_MDISQUTYPE,
    RUNTIME_CLASS(CSquaresDoc),
    RUNTIME_CLASS(CChildFrame), // custom MDI child frame
    RUNTIME_CLASS(CSquaresView));
</PRE>
</td></tr></table></p>

<p>Consequently, calling 
<I>ProcessShellCommand</I> in an MDI application creates a new 
child frame but not a top-level frame window. As a result, an MDI application must create the top-level frame window itself before calling <I>ProcessShellCommand</I>. The code that creates MdiSquares' main window is found elsewhere in 
<I>InitInstance</I>:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<PRE>CMainFrame* pMainFrame = new CMainFrame;
if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
    return FALSE;
m_pMainWnd = pMainFrame;
</PRE>
</td></tr></table>
</p>

<p>This code and all the other code in 
<I>CMdiSquaresApp</I>, <I>CMainFrame</I>, and 
<I>CChildFrame</I> was generated by AppWizard. Unless you code an MDI application by hand, you'll perform the bulk of your work in the document and view classes.
</p>

<p>If you open MdiSquares in Visual C++ and browse its list of resources, you'll see that it has two icons, two menus, and two document strings. Their resource IDs are IDR_MAINFRAME and IDR_MDISQUTYPE. Here's how these resources are used:
</p>

<UL>
<p><LI>The IDR_MAINFRAME icon is displayed in the title bar of the top-level window. The IDR_MDISQUTYPE icon is displayed in the title bars of the child frames. You can use the same icon for both if you like, but most MDI applications use a different icon for document windows.</li></p>
 
<p><li>The IDR_MAINFRAME menu is displayed when no documents are open. The IDR_MDISQUTYPE menu is displayed when at least one document is open. The IDR_MAINFRAME menu is a minimal menu that features a File menu with New, Open, and Exit commands and a recently used file list, but little else. IDR_MDISQUTYPE, on the other hand, is a full-blown menu with all the commands that pertain to MdiSquares documents.
</li></P>

<p><li>The IDR_MAINFRAME document string contains nothing more than the title that appears in the main window's title bar. The IDR_MDISQUTYPE document string contains all relevant information about the document type, including the default file name extension.
</li></p>
</UL>

<p>Except for the relatively minor differences discussed in this section, MdiSquares and SdiSquares are virtually identical. That's one of the benefits of using MFC's 
document/view architecture: once you know how to write SDI applications, you know how to write MDI applications, too.
</p>

<p><b>Figure 11-3.</b> <i>The MdiSquares application.</i></p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="330"><H3>MdiSquares.h</H3></A>
<PRE>// MdiSquares.h : main header file for the MDISQUARES application
//

#if !defined(AFX_MDISQUARES_H__36D513DB_9CA0_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MDISQUARES_H__36D513DB_9CA0_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
    #error include `stdafx.h' before including this file for PCH
#endif

#include &quot;resource.h&quot;       // main symbols

///////////////////////////////////////////////////////////////////////////

/ CMdiSquaresApp:
// See MdiSquares.cpp for the implementation of this class
//

class CMdiSquaresApp : public CWinApp
{
public:
    CMdiSquaresApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMdiSquaresApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL


	// Implementation
    //{{AFX_MSG(CMdiSquaresApp)
    afx_msg void OnAppAbout();
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_MDISQUARES_H__36D513DB_9CA0_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="331"><H3>MdiSquares.cpp</H3></A>
<PRE>// MdiSquares.cpp : Defines the class behaviors for the application.
//

#include &quot;stdafx.h&quot;
#include &quot;MdiSquares.h&quot;

#include &quot;MainFrm.h&quot;
#include &quot;ChildFrm.h&quot;
#include &quot;SquaresDoc.h&quot;
#include &quot;SquaresView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMdiSquaresApp

BEGIN_MESSAGE_MAP(CMdiSquaresApp, CWinApp)
    //{{AFX_MSG_MAP(CMdiSquaresApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMdiSquaresApp construction

CMdiSquaresApp::CMdiSquaresApp()
{
}

///////////////////////////////////////////////////////////////////////////
// The one and only CMdiSquaresApp object

CMdiSquaresApp theApp;

///////////////////////////////////////////////////////////////////////////
// CMdiSquaresApp initialization

BOOL CMdiSquaresApp::InitInstance()
{
    SetRegistryKey(_T(&quot;Local AppWizard-Generated Applications&quot;));

    LoadStdProfileSettings();  // Load standard INI file 
                               // options (including MRU)

    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_MDISQUTYPE,
        RUNTIME_CLASS(CSquaresDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CSquaresView));
    AddDocTemplate(pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Enable drag/drop open
    m_pMainWnd-&gt;DragAcceptFiles();
   // Enable DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes(TRUE);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The main window has been initialized, so show and update it.
    pMainFrame-&gt;ShowWindow(m_nCmdShow);
    pMainFrame-&gt;UpdateWindow();

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMdiSquaresApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

///////////////////////////////////////////////////////////////////////////
// CMdiSquaresApp message handlers
</pre>
</td></tr></table></p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="332"><H3>MainFrm.h</H3></A>
<PRE>// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__36D513DF_9CA0_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__36D513DF_9CA0_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CMainFrame : public CMDIFrameWnd

    DECLARE_DYNAMIC(CMainFrame)
public:
    CMainFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
// AFX_MAINFRM_H__36D513DF_9CA0_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table></p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="333"><H3>MainFrm.cpp</H3></A>
<PRE>// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;MdiSquares.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CMDIFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
</pre>
</td></tr></table></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="334"><H3>ChildFrm.h</H3></A>
<PRE>// ChildFrm.h : interface of the CChildFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__36D513E1_9CA0_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_CHILDFRM_H__36D513E1_9CA0_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CChildFrame : public CMDIChildWnd
{
    DECLARE_DYNCREATE(CChildFrame)
public:
    CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CChildFrame)
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
// AFX_CHILDFRM_H__36D513E1_9CA0_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table></p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="335"><H3>ChildFrm.cpp</H3></A>
<PRE>// ChildFrm.cpp : implementation of the CChildFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;MdiSquares.h&quot;

#include &quot;ChildFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CMDIChildWnd::PreCreateWindow(cs) )
        return FALSE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
    CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext&amp; dc) const
{
    CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
</pre>
</td></tr></table></p>


<p>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="336"><H3>SquaresDoc.h</H3></A>
<PRE>// SquaresDoc.h : interface of the CSquaresDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SQUARESDOC_H__36D513E3_9CA0_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_SQUARESDOC_H__36D513E3_9CA0_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CSquaresDoc : public CDocument
{
protected: // create from serialization only
    CSquaresDoc();
    DECLARE_DYNCREATE(CSquaresDoc)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSquaresDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive&amp; ar);
    //}}AFX_VIRTUAL

// Implementation
public:
    void SetSquare (int i, int j, COLORREF color);
    COLORREF GetSquare (int i, int j);
    COLORREF GetCurrentColor();
    virtual ~CSquaresDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    COLORREF m_clrCurrentColor;
    COLORREF m_clrGrid[4][4];
    //{{AFX_MSG(CSquaresDoc)
    afx_msg void OnColorRed();
    afx_msg void OnColorYellow();
    afx_msg void OnColorGreen();
    afx_msg void OnColorCyan();
    afx_msg void OnColorBlue();
    afx_msg void OnColorWhite();
    afx_msg void OnUpdateColorRed(CCmdUI* pCmdUI);
    afx_msg void OnUpdateColorYellow(CCmdUI* pCmdUI);
    afx_msg void OnUpdateColorGreen(CCmdUI* pCmdUI);
    afx_msg void OnUpdateColorCyan(CCmdUI* pCmdUI);
    afx_msg void OnUpdateColorBlue(CCmdUI* pCmdUI);
    afx_msg void OnUpdateColorWhite(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_SQUARESDOC_H__36D513E3_9CA0_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>	
<A NAME="337"><H3>SquaresDoc.cpp</H3></A>
<PRE>// SquaresDoc.cpp : implementation of the CSquaresDoc class
//

#include &quot;stdafx.h&quot;
#include &quot;MdiSquares.h&quot;

#include &quot;SquaresDoc.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CSquaresDoc

IMPLEMENT_DYNCREATE(CSquaresDoc, CDocument)

BEGIN_MESSAGE_MAP(CSquaresDoc, CDocument)
    //{{AFX_MSG_MAP(CSquaresDoc)
    ON_COMMAND(ID_COLOR_RED, OnColorRed)
    ON_COMMAND(ID_COLOR_YELLOW, OnColorYellow)
    ON_COMMAND(ID_COLOR_GREEN, OnColorGreen)
    ON_COMMAND(ID_COLOR_CYAN, OnColorCyan)
    ON_COMMAND(ID_COLOR_BLUE, OnColorBlue)
    ON_COMMAND(ID_COLOR_WHITE, OnColorWhite)
    ON_UPDATE_COMMAND_UI(ID_COLOR_RED, OnUpdateColorRed)
    ON_UPDATE_COMMAND_UI(ID_COLOR_YELLOW, OnUpdateColorYellow)
    ON_UPDATE_COMMAND_UI(ID_COLOR_GREEN, OnUpdateColorGreen)
    ON_UPDATE_COMMAND_UI(ID_COLOR_CYAN, OnUpdateColorCyan)
    ON_UPDATE_COMMAND_UI(ID_COLOR_BLUE, OnUpdateColorBlue)
    ON_UPDATE_COMMAND_UI(ID_COLOR_WHITE, OnUpdateColorWhite)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CSquaresDoc construction/destruction

CSquaresDoc::CSquaresDoc()
{
}

CSquaresDoc::~CSquaresDoc()
{
}

BOOL CSquaresDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    for (int i=0; i&lt;4; i++)
        for (int j=0; j&lt;4; j++)
            m_clrGrid[i][j] = RGB (255, 255, 255);

    m_clrCurrentColor = RGB (255, 0, 0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CSquaresDoc serialization

void CSquaresDoc::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        for (int i=0; i&lt;4; i++)
            for (int j=0; j&lt;4; j++)
                ar &lt;&lt; m_clrGrid[i][j];
        ar &lt;&lt; m_clrCurrentColor;
    }
    else
    {
        for (int i=0; i&lt;4; i++)
            for (int j=0; j&lt;4; j++)
                ar &gt;&gt; m_clrGrid[i][j];
        ar &gt;&gt; m_clrCurrentColor;
    }
}

///////////////////////////////////////////////////////////////////////////
// CSquaresDoc diagnostics

#ifdef _DEBUG
void CSquaresDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CSquaresDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CSquaresDoc commands

COLORREF CSquaresDoc::GetCurrentColor()
{
    return m_clrCurrentColor;
}

COLORREF CSquaresDoc::GetSquare(int i, int j)
{
    ASSERT (i &gt;= 0 &amp;&amp; i &lt;= 3 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt;= 3);
    return m_clrGrid[i][j];
}

void CSquaresDoc::SetSquare(int i, int j, COLORREF color)
{
    ASSERT (i &gt;= 0 &amp;&amp; i &lt;= 3 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt;= 3);
    m_clrGrid[i][j] = color;
    SetModifiedFlag (TRUE);
    UpdateAllViews (NULL);
}

void CSquaresDoc::OnColorRed() 
{
    m_clrCurrentColor = RGB (255, 0, 0);    
}

void CSquaresDoc::OnColorYellow() 
{
    m_clrCurrentColor = RGB (255, 255, 0);    
}


{
    m_clrCurrentColor = RGB (0, 255, 0);    
}

void CSquaresDoc::OnColorCyan() 
{
    m_clrCurrentColor = RGB (0, 255, 255);    
}

void CSquaresDoc::OnColorBlue() 
{
    m_clrCurrentColor = RGB (0, 0, 255);    
}

void CSquaresDoc::OnColorWhite() 
{
    m_clrCurrentColor = RGB (255, 255, 255);    
}

void CSquaresDoc::OnUpdateColorRed(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetRadio (m_clrCurrentColor == RGB (255, 0, 0));    
}

void CSquaresDoc::OnUpdateColorYellow(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetRadio (m_clrCurrentColor == RGB (255, 255, 0));    
}

void CSquaresDoc::OnUpdateColorGreen(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetRadio (m_clrCurrentColor == RGB (0, 255, 0));    
}

void CSquaresDoc::OnUpdateColorCyan(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetRadio (m_clrCurrentColor == RGB (0, 255, 255));    
}

void CSquaresDoc::OnUpdateColorBlue(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetRadio (m_clrCurrentColor == RGB (0, 0, 255));    
}

void CSquaresDoc::OnUpdateColorWhite(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetRadio (m_clrCurrentColor == RGB (255, 255, 255));    
}
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>	
<A NAME="338"><H3>SquaresView.h</H3></A>
<PRE>// SquaresView.h : interface of the CSquaresView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SQUARESVIEW_H__36D513E5_9CA0_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_SQUARESVIEW_H__36D513E5_9CA0_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CSquaresView : public CView
{
protected: // create from serialization only
    CSquaresView();
    DECLARE_DYNCREATE(CSquaresView)

// Attributes
public:
    CSquaresDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSquaresView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSquaresView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CSquaresView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in SquaresView.cpp
inline CSquaresDoc* CSquaresView::GetDocument()
   { return (CSquaresDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_SQUARESVIEW_H__36D513E5_9CA0_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>	
<A NAME="339"><H3>SquaresView.cpp</H3></A>
<PRE>// SquaresView.cpp : implementation of the CSquaresView class
//

#include &quot;stdafx.h&quot;
#include &quot;MdiSquares.h&quot;

#include &quot;SquaresDoc.h&quot;
#include &quot;SquaresView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CSquaresView

IMPLEMENT_DYNCREATE(CSquaresView, CView)

BEGIN_MESSAGE_MAP(CSquaresView, CView)
    //{{AFX_MSG_MAP(CSquaresView)
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CSquaresView construction/destruction

CSquaresView::CSquaresView()
{
}

CSquaresView::~CSquaresView()
{
}

BOOL CSquaresView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    return CView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////////
// CSquaresView drawing

void CSquaresView::OnDraw(CDC* pDC)
{
    CSquaresDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    //
    // Set the mapping mode to MM_LOENGLISH.
    //
    pDC-&gt;SetMapMode (MM_LOENGLISH);
    //
    // Draw the 16 squares.
    //
    for (int i=0; i&lt;4; i++) {
        for (int j=0; j&lt;4; j++) {
            COLORREF color = pDoc-&gt;GetSquare (i, j);
            CBrush brush (color);
            int x1 = (j * 70) + 35;
            int y1 = (i * -70) - 35;
            int x2 = x1 + 70;
            int y2 = y1 - 70;
            CRect rect (x1, y1, x2, y2);
            pDC-&gt;FillRect (rect, &amp;brush);
        }
    }

    //
    // Then draw the grid lines surrounding them.
    //
    for (int x=35; x&lt;=315; x+=70) {
        pDC-&gt;MoveTo (x, -35);
        pDC-&gt;LineTo (x, -315);
    }

    for (int y=-35; y&gt;=-315; y-=70) {
        pDC-&gt;MoveTo (35, y);
        pDC-&gt;LineTo (315, y);
    }
}

///////////////////////////////////////////////////////////////////////////
// CSquaresView diagnostics

#ifdef _DEBUG
void CSquaresView::AssertValid() const
{
    CView::AssertValid();
}

void CSquaresView::Dump(CDumpContext&amp; dc) const
{
    CView::Dump(dc);
}

CSquaresDoc* CSquaresView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CSquaresDoc)));
    return (CSquaresDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CSquaresView message handlers

void CSquaresView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    CView::OnLButtonDown(nFlags, point);

    //
    // Convert click coordinates to MM_LOENGLISH units.
    //
    CClientDC dc (this);
    dc.SetMapMode (MM_LOENGLISH);
    CPoint pos = point;
    dc.DPtoLP (&amp;pos);

    //
    // If a square was clicked, set its color to the current color.
    //
    if (pos.x &gt;= 35 &amp;&amp; pos.x &lt;= 315 &amp;&amp; pos.y &lt;= -35 &amp;&amp; pos.y &gt;= -315) {
        int i = (-pos.y - 35) / 70;
        int j = (pos.x - 35) / 70;
        CSquaresDoc* pDoc = GetDocument ();
        COLORREF clrCurrentColor = pDoc-&gt;GetCurrentColor ();
        pDoc-&gt;SetSquare (i, j, clrCurrentColor);
    }
}
</pre>
</td></tr></table></p>

<A NAME="340"><H2>Supporting Multiple Document Types</H2></A>

<p>An MDI application written with MFC supports multiple document instances by default. A new document instance is created each time the user executes a File/New command. MDI applications can also support multiple document <I>types,</I> each characterized by a unique document template.
</p>

<p>Suppose you want to add a second document type&#8212;say, circles documents&#8212;to MdiSquares so that when File/New is selected, the user is given a choice of whether to create a squares document or a circles document. Here's how you'd do it.
</p>

<OL>
<P><LI>Derive a new document class and a new view class to serve the new document type. For the sake of this example, assume the classes are named <I>CCirclesDoc</I> and <I>CCirclesView</I>. Make the classes dynamically creatable, just like the document and view classes AppWizard generates.
</li></p>

<p><li>Add four new resources to the project for circles documents: an icon, a menu, an accelerator (optional), and a document string. Assign all four resources the same resource ID&#8212;for example, IDR_CIRCLETYPE.</li></p>

<p><li>Modify <I>InitInstance</I> to create a new document template containing the resource ID and <I>CRuntimeClass</I> pointers for the document, view, and frame window classes. Then call <I>AddDocTemplate</I> and pass in the address of the document template object.</li></p>
</ol>

<p>
Here's an excerpt from an <I>InitInstance</I> function modified to register two document templates:
</p>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>// AppWizard-generated code
CMultiDocTemplate* pDocTemplate;
pDocTemplate = new CMultiDocTemplate(
    IDR_MDISQUTYPE,
    RUNTIME_CLASS(CSquaresDoc),
    RUNTIME_CLASS(CChildFrame), // custom MDI child frame
    RUNTIME_CLASS(CSquaresView));
AddDocTemplate(pDocTemplate);

// Your code
pDocTemplate = new CMultiDocTemplate(
    IDR_CIRCLETYPE,
    RUNTIME_CLASS(CCirclesDoc),
    RUNTIME_CLASS(CChildFrame),
    RUNTIME_CLASS(CCirclesView));
AddDocTemplate(pDocTemplate);
</PRE>
</td></tr></table></p>

<p>That's basically all there is to it. This example uses 
<I>CChildFrame</I> as the child frame class for both document types, but you can derive a separate child frame class 
if you'd prefer.
</p>

<p>
When multiple document types are registered in this manner, MFC's 
File-New command handler displays a dialog box presenting the user with a choice of 
document types. The string that identifies each document type in the dialog box 
comes from the document string&#8212;specifically, from the third of the document string's 
seven possible substrings. With this infrastructure in place, it's relatively simple to 
write multifunction MDI applications that permit users to create and edit different kinds 
of documents. You can write SDI applications that support two or more document 
types, too, but the multiple document type paradigm is rarely used in single 
document applications.
</p>

<A NAME="341"><H2>Alternatives to MDI</H2></A>

<p>The multiple document interface isn't the only game in town if you want to give your users the ability to edit several documents at once in one instance of your application. <I>The Windows Interface Guidelines for Software Design</I> outlines three alternatives to the MDI programming model:
</p>

<UL>

<p><LI>A workspace-based model that groups related documents in objects called <I>workspaces</I> and allows documents contained in a workspace to be viewed and edited in MDI-like document frames that are children of a top-level frame window. Visual C++ is one example of an application that uses the workspace containment model.</li></p>
 
<p><li>A workbook model in which individual views occupy the full client area of a top-level frame window but only one view at a time is visible. The appearance is similar to that of a maximized document frame in an MDI application. Each view is tabbed so that the user can switch from one view to another with a button click as if the views were pages in a property sheet.</li></p>

<p><li>A project model that groups related documents in projects but allows individual documents to be edited in SDI-like frame windows. The primary difference between the project model and the MDI and workspace models is that in the project model there is no top-level frame window providing containment for document frames. 
</li></p>
</UL>

<p>
MFC doesn't support any of these alternatives directly, but you can always code them yourself. Alternative user interface models are on the radar screen of the MFC team at Microsoft, so it's very possible that a future version of MFC will support user interface models other than SDI and MDI.
</p>

</BODY>
</HTML>




