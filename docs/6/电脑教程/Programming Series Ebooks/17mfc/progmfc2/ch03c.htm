<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Getting Input from the Keyboard</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03b.htm", "ch03d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="88"><H1>Getting Input from the Keyboard</H1></A>

<P>A Windows application learns of keyboard events the same way it learns about 
mouse events: through messages. A program receives a message whenever a key is 
pressed or released. If you want to know when the Page Up or Page Down key is pressed 
so that your application can react accordingly, you process WM_KEYDOWN 
messages and check for key codes identifying the Page Up or Page Down key. If you'd 
rather know when a key is released, you process WM_KEYUP messages instead. For 
keys that produce printable characters, you can ignore key-down and key-up 
messages and process WM_CHAR messages that denote characters typed at the keyboard. 
Relying on WM_CHAR messages instead of WM_KEYUP/DOWN messages 
simplifies character processing by enabling Windows to factor in events and 
circumstances surrounding the keystroke, such as whether the Shift key is pressed, whether 
Caps Lock is on or off, and differences in keyboard layouts.</P>

<A NAME="89"><H2>The Input Focus</H2></A>

<P>Like the mouse, the keyboard is a global hardware resource shared by all 
applications. Windows decides which window to send mouse messages to by 
identifying the window under the cursor. Keyboard messages are targeted differently. 
Windows directs keyboard messages to the window with the &quot;input focus.&quot; At any given 
time, no more than one window has the input focus. Often the window with the input 
focus is the main window of the active application. However, the input focus might 
belong to a child of the main window or to a control in a dialog box. Regardless, 
Windows <I>always</I> sends keyboard messages to the window that owns the focus. If your 
application's window has no child windows, keyboard processing is relatively 
straightforward: When your application is active, its main window receives keyboard 
messages. If the focus shifts to a child window, keyboard messages go to the child window 
instead and the flow of messages to the main window ceases.</P>

<P>Windows notifies a window that it is about to receive or lose the input 
focus with WM_SETFOCUS and WM_KILLFOCUS messages, which MFC programs 
process as shown here:</P>


<table cellpadding=5 width="95%"><tr><td>
<pre>// In CMainWindow's message map
ON_WM_SETFOCUS ()
ON_WM_KILLFOCUS ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnSetFocus (CWnd* pOldWnd)
{
    // CMainWindow now has the input focus. pOldWnd
    // identifies the window that lost the input focus.
    // pOldWnd will be NULL if the window that lost the
    // focus was created by another thread.
}

void CMainWindow::OnKillFocus (CWnd* pNewWnd)
{
    // CMainWindow is about to lose the input focus.
    // pNewWnd identifies the window that will receive
    // the input focus. pNewWnd will be NULL if the
    // window that's receiving the focus is owned by
    // another thread.
}
</pre>
</td></tr></table>

<P>An application can shift the input focus to another window with 
<I>CWnd::SetFocus</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
pWnd-&gt;SetFocus ();
</pre>
</td></tr></table>

<P>Or it can use the static <I>CWnd::GetFocus</I> function to find out who currently has 
the input focus:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CWnd* pFocusWnd = CWnd::GetFocus ();
</pre>
</td></tr></table>

<P>In the Win32 environment, <I>GetFocus</I> returns NULL if the window that owns the 
focus was not created by the calling thread. You can't use 
<I>GetFocus</I> to get a pointer to a window created by another application, but you 
<I>can</I> use it to identify windows that belong to your application.</P>

<A NAME="90"><H2>Keystroke Messages</H2></A>

<P>Windows reports key presses and releases by sending WM_KEYDOWN and 
WM_KEYUP messages to the window with the input focus. These messages are 
commonly referred to as <I>keystroke messages</I>. When a key is pressed, the window with the 
input focus receives a WM_KEYDOWN message with a virtual key code identifying the 
key. When the key is released, the window receives a WM_KEYUP message. If other 
keys are pressed and released while the key is held down, the resultant 
WM_KEYDOWN and WM_KEYUP messages separate the WM_KEYDOWN and WM_KEYUP 
messages generated by the key that's held down. Windows reports keyboard events as 
they happen in the order in which they happen, so by examining the stream of 
keystroke messages coming into your application, you can tell exactly what was typed and when.</P>

<P>All keys but two generate WM_KEYDOWN and WM_KEYUP messages. The 
two exceptions are Alt and F10, which are &quot;system&quot; keys that have a special meaning 
to Windows. When either of these keys is pressed and released, a window receives 
a WM_SYSKEYDOWN message followed by a WM_SYSKEYUP message. If other 
keys are pressed while the Alt key is held down, they, too, generate 
WM_SYSKEYDOWN and WM_SYSKEYUP messages instead of WM_KEYDOWN and WM_KEYUP 
messages. Pressing F10 puts Windows in a special modal state that treats the next keypress as 
a menu shortcut. Pressing F10 followed by the F key, for example, pulls down the 
File menu in most applications.</P>

<P>An application processes keystroke messages by providing 
message-map entries and message handling functions for the messages it is interested in. 
WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, and WM_SYSKEYUP messages are processed 
by a class's <I>OnKeyDown</I>, <I>OnKeyUp</I>, 
<I>OnSysKeyDown</I>, and <I>OnSysKeyUp</I> member 
functions, respectively. The corresponding message-map macros are 
ON_WM_KEYDOWN, ON_WM_KEYUP, ON_WM_SYSKEYDOWN, and ON_WM_SYSKEYUP. When 
activated, a keystroke handler receives a wealth of information about the 
keystroke, including a code identifying the key that was pressed or released.</P>

<P>Keystroke message handlers are prototyped as follows:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
afx_msg void On<I>MsgName</I> (UINT nChar, UINT nRepCnt, UINT nFlags)
</pre>
</td></tr></table>

<P><I>nChar</I> is the virtual key code of the key that was pressed or released. 
<I>nRepCnt</I> is the repeat count&#8212;the number of keystrokes encoded in the message. 
<I>nRepCnt</I> is usually equal to 1 for WM_KEYDOWN or WM_SYSKEYDOWN messages and is 
always 1 for WM_KEYUP or WM_SYSKEYUP messages. If key-down messages arrive so 
fast that your application can't keep up, Windows combines two or more 
WM_KEYDOWN or WM_SYSKEYDOWN messages into one and increases the repeat count 
accordingly. Most programs ignore the repeat count and treat combinatorial 
key-down messages (messages in which 
<I>nRepCnt</I> is greater than 1) as a single keystroke 
to prevent overruns&#8212;situations in which a program continues to scroll or 
otherwise respond to keystroke messages after the user's finger has released the key. In 
contrast to the PC's keyboard BIOS, which buffers incoming keystrokes and reports 
each one individually, the Windows method of reporting consecutive presses of the 
same key to your application provides a built-in hedge against keyboard overruns.</P>

<P>The <I>nFlags</I> parameter contains the key's scan code and zero or more of the 
bit flags described here:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Bit(s)</I></th>     
<th valign="top"><I>Meaning</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">0_7</td>     
<td valign="top">OEM scan code</td>     
<td valign="top">8-bit OEM scan code</td>
</tr>
<tr>
<td valign="top">8</td>     
<td valign="top">Extended key flag</td>     
<td valign="top">1 if the key is an extended key, 0 if it is not</td>
</tr>
<tr>
<td valign="top">9_12</td>     
<td valign="top">Reserved</td>     
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">13</td>     
<td valign="top">Context code</td>     
<td valign="top">1 if the Alt key is pressed, 0 if it is not</td>
</tr>
<tr>
<td valign="top">14</td>     
<td valign="top">Previous key state</td>     
<td valign="top">1 if the key was previously pressed, 0 if it was up</td>
</tr>
<tr>
<td valign="top">15</td>     
<td valign="top">Transition state</td>     
<td valign="top">0 if the key is being pressed, 1 if it is being released</td>
</tr></table></p>

<P>The extended key flag allows an application to differentiate between the 
duplicate keys that appear on most keyboards. On the 101-key and 102-key 
keyboards used with the majority of IBM-compatible PCs, the extended key flag is set for 
the Ctrl and Alt keys on the right side of the keyboard; the Home, End, Insert, 
Delete, Page Up, Page Down, and arrow keys that are clustered between the main part 
of the keyboard and the numeric keypad; and the keypad's Enter and forward-slash 
(/) keys. For all other keys, the extended key flag is 0. The OEM scan code is an 
8-bit value that identifies the key to the keyboard BIOS. Most Windows applications 
ignore this field because it is inherently hardware dependent. (If needed, scan 
codes can be translated into virtual key codes with the 
<I>::MapVirtualKey</I> API function.) The transition state, previous key state, and context code are generally disregarded 
too, but they are occasionally useful. A previous key state value equal to 1 
identifies <I>typematic keystrokes</I>&#8212;keystrokes generated when a key is pressed and held 
down for some length of time. Holding down the Shift key for a second or so, for 
instance, generates the following sequence of messages:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>
<th valign="top"><I>Virtual Key Code</I></th>
<th valign="top"><I>Previous Key State</I></th>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">0</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>    
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr>
<tr>
<td valign="top">WM_KEYUP</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top">1</td>
</tr></table></p>

<P>If you want your application to disregard keystrokes generated as a result 
of typematic action, simply have it ignore WM_KEYDOWN messages with previous 
key state values equal to 1. The transition state value is 0 for WM_KEYDOWN and 
WM_SYSKEYDOWN messages and 1 for WM_KEYUP and WM_SYSKEYUP messages. 
Finally, the context code indicates whether the Alt key was pressed when the message 
was generated. With certain (usually unimportant) exceptions, the code is 1 for 
WM_SYSKEYDOWN and WM_SYSKEYUP messages and 0 for WM_KEYDOWN and 
WM_KEYUP messages.</P>

<P>In general, applications shouldn't process WM_SYSKEYDOWN and 
WM_SYSKEYUP messages; they should let Windows process them instead. If these 
messages don't eventually find their way to 
<I>::DefWindowProc</I>, system keyboard commands 
such as Alt-Tab and Alt-Esc will stop working. Windows puts a tremendous amount of 
power in your hands by routing all mouse and keyboard messages through your 
application first, even though many of these messages are meaningful first and foremost 
to the operating system. As with nonclient-area mouse messages, the improper 
handling of system keystroke messages&#8212;in particular, the failure to pass these messages on 
to the operating system&#8212;can result in all sorts of quirky behavior.</P>

<A NAME="91"><H2>Virtual Key Codes</H2></A>

<P>The most important value by far that gets passed to a keystroke message handler 
is the <I>nChar</I> value identifying the key that was pressed or released. Windows 
identifies keys with the virtual key codes shown in the table below so 
that applications won't have to rely on hardcoded values or OEM scan codes that 
might differ from keyboard to keyboard.</P>

<P>Conspicuously missing from this table are virtual key codes for the letters 
A through Z and a through z and for the numerals 0 through 9. The virtual key 
codes for these keys are the same as the corresponding characters' ANSI codes: 0x41 
through 0x5A for A through Z, 0x61 through 0x7A for a through z, and 0x30 through 0x39 
for 0 through 9.</P>

<P>If you look inside Winuser.h, where the virtual key codes are defined, 
you'll find a few key codes that aren't listed in the following table, including 
VK_SELECT, VK_EXECUTE, and VK_F13 through VK_F24. These codes are provided for use 
on other platforms and can't be generated on conventional IBM keyboards. 
Nonletter and nonnumeric keys for which Windows does not provide virtual key 
codes&#8212;for example, the semicolon (;) and square bracket 
([]) keys&#8212;are best avoided when processing key-down and key-up messages because their IDs can vary on 
international keyboards. This doesn't mean that your program can't process 
punctuation symbols and other characters for which no VK_ identifiers exist; it simply means 
that there's a better way to do it than relying on key-up and key-down messages. 
That &quot;better way&quot; is WM_CHAR messages, which we'll discuss in a moment.</P>


<P><B>Virtual Key Codes</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Virtual Key Code(s)</I></th>
<th valign="top"><I>Corresponding Key(s)</I></th>
</tr>
<tr>
<td valign="top">VK_F1_VK_F12</td>     
<td valign="top">Function keys F1_F12</td>
</tr>
<tr>
<td valign="top">VK_NUMPAD0_VK_NUMPAD9</td>     
<td valign="top">Numeric keypad 0_9 with Num Lock on</td>
</tr>
<tr>
<td valign="top">VK_CANCEL</td>     
<td valign="top">Ctrl-Break</td>
</tr>
<tr>
<td valign="top">VK_RETURN</td>    
<td valign="top">Enter</td>
</tr>
<tr>
<td valign="top">VK_BACK</td>     
<td valign="top">Backspace</td>
</tr>
<tr>
<td valign="top">VK_TAB</td>     
<td valign="top">Tab</td>
</tr>
<tr>
<td valign="top">VK_CLEAR</td>     
<td valign="top">Numeric keypad 5 with Num Lock off</td>
</tr>
<tr>
<td valign="top">VK_SHIFT</td>     
<td valign="top">Shift</td>
</tr>
<tr>
<td valign="top">VK_CONTROL</td>     
<td valign="top">Ctrl</td>
</tr>
<tr>
<td valign="top">VK_MENU</td>     
<td valign="top">Alt</td>
</tr>
<tr>
<td valign="top">VK_PAUSE</td>     
<td valign="top">Pause</td>
</tr>
<tr>
<td valign="top">VK_ESCAPE</td>     
<td valign="top">Esc</td>
</tr>
<tr>
<td valign="top">VK_SPACE</td>     
<td valign="top">Spacebar</td>
</tr>
<tr>
<td valign="top">VK_PRIOR</td>     
<td valign="top">Page Up and PgUp</td>
</tr>
<tr>
<td valign="top">VK_NEXT</td>    
<td valign="top">Page Down and PgDn</td>
</tr>
<tr>
<td valign="top">VK_END</td>     
<td valign="top">End</td>
</tr>
<tr>
<td valign="top">VK_HOME</td>     
<td valign="top">Home</td>
</tr>
<tr>
<td valign="top">VK_LEFT</td>     
<td valign="top">Left arrow</td>
</tr>
<tr>
<td valign="top">VK_UP</td>     
<td valign="top">Up arrow</td>
</tr>
<tr>
<td valign="top">VK_RIGHT</td>     
<td valign="top">Right arrow</td>
</tr>
<tr>
<td valign="top">VK_DOWN</td>     
<td valign="top">Down arrow</td>
</tr>
<tr>
<td valign="top">VK_SNAPSHOT</td>     
<td valign="top">Print Screen</td>
</tr>
<tr>
<td valign="top">VK_INSERT</td>     
<td valign="top">Insert and Ins</td>
</tr>
<tr>
<td valign="top">VK_DELETE</td>     
<td valign="top">Delete and Del</td>
</tr>
<tr>
<td valign="top">VK_MULTIPLY</td>     
<td valign="top">Numeric keypad *</td>
</tr>
<tr>
<td valign="top">VK_ADD</td>     
<td valign="top">Numeric keypad +</td>
</tr>
<tr>
<td valign="top">VK_SUBTRACT</td>     
<td valign="top">Numeric keypad -</td>
</tr>
<tr>
<td valign="top">VK_DECIMAL</td>     
<td valign="top">Numeric keypad .</td>
</tr>
<tr>
<td valign="top">VK_DIVIDE</td>     
<td valign="top">Numeric keypad /</td>
</tr>
<tr>
<td valign="top">VK_CAPITAL</td>     
<td valign="top">Caps Lock</td>
</tr>
<tr>
<td valign="top">VK_NUMLOCK</td>     
<td valign="top">Num Lock</td>
</tr>
<tr>
<td valign="top">VK_SCROLL</td>     
<td valign="top">Scroll Lock</td>
</tr>
<tr>
<td valign="top">VK_LWIN</td>     
<td valign="top">Left Windows key <img src="images/windows.jpg" width=33 height=26 BORDER=0></td>
</tr>
<tr>
<td valign="top">VK_RWIN</td>     
<td valign="top">Right Windows key <img src="images/windows.jpg" width=33 height=26 BORDER=0></td>
</tr>

<tr>
<td valign="top">VK_APPS</td>     
<td valign="top">Menu key (<img src="images/G03mg01.JPG" width=35 height=34 border="0">)
</td>
</tr></table></p>

<A NAME="92"><H2>Shift States and Toggles</H2></A>

<P>When you write handlers for WM_KEYDOWN, WM_KEYUP, 
WM_SYSKEYDOWN, or WM_SYSKEYUP messages, you might need to know whether the Shift, Ctrl, or 
Alt key is held down before deciding what to do. Information about the shift states 
of the Shift and Ctrl keys is not encoded in keyboard messages as it is in mouse 
messages, so Windows provides the 
<I>::GetKeyState</I> function. Given a virtual key 
code, <I>::GetKeyState</I> reports whether the key in question is held down. The expression</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetKeyState (VK_SHIFT)
</pre>
</td></tr></table>

<P>returns a negative value if the Shift key is held down or a nonnegative value if it is not. Similarly, the expression</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetKeyState (VK_CONTROL)
</pre>
</td></tr></table>

<P>returns a negative value if the Ctrl key is held down. Thus, the bracketed 
statements in the following code fragment taken from an 
<I>OnKeyDown</I> handler are executed only when Ctrl-Left (the left arrow key in combination with the Ctrl key) is pressed:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
if ((nChar == VK_LEFT) &amp;&amp; (::GetKeyState (VK_CONTROL) &lt; 0)) {
  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
}
</pre>
</td></tr></table>

<P>To inquire about the Alt key, you can call 
<I>::GetKeyState</I> with a VK_MENU parameter or simply check the context code bit in the 
<I>nFlags</I> parameter. Usually even that amount of effort isn't necessary because if the Alt key is pressed, your window 
will receive a WM_SYSKEYDOWN or WM_SYSKEYUP message instead of a 
WM_KEYDOWN or WM_KEYUP message. In other words, the message ID generally tells you all 
you need to know about the Alt key. As a bonus, you can use the identifiers 
VK_LBUTTON, VK_MBUTTON, and VK_RBUTTON in conjunction with 
<I>::GetKeyState</I> to determine if any of the mouse buttons is held down.</P>

<P>An application can also use 
<I>::GetKeyState</I> to determine whether Num Lock, 
Caps Lock, and Scroll Lock are on or off. While the high bit of the return code 
indicates whether a key is currently pressed (yielding a negative number when the high bit is 
1), the low bit&#8212;bit 0&#8212;indicates the state of the toggle. The expression</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetKeyState (VK_NUMLOCK) &amp; 0x01
</pre>
</td></tr></table>

<P>evaluates to nonzero if Num Lock is on and evaluates to 0 if it is not. The same 
technique works for the VK_CAPITAL (Caps Lock) and VK_SCROLL (Scroll Lock) 
keys. It's important to mask off all but the lowest bit of the return code before testing 
because the high bit still indicates whether the key itself is up or down.</P>

<P>In all cases, <I>::GetKeyState</I> reports the state of the key or the mouse button 
<I>at the time the keyboard message was 
generated,</I> not at the precise moment that the function is called. This is a feature, not a bug, because it means you don't have 
to worry about a key being released before your message handler gets around to 
inquiring about the key state. The 
<I>::GetKeyState</I> function should never be called 
outside a keyboard message handler because the information it returns is valid only 
after a keyboard message has been retrieved from the message queue. If you really need 
to know the current state of a key or a mouse button, or if you want to check a key or 
a mouse button outside a keyboard message handler, use 
<I>::GetAsyncKeyState</I> instead.</P>

<A NAME="93"><H2>Character Messages</H2></A>

<P>One problem you'll encounter if you rely exclusively on key-up and key-down 
messages for keyboard input is shown in the following scenario. Suppose you're 
writing a text editor that turns messages reporting presses of the character keys into 
characters on the screen. The A key is pressed, and a WM_KEYDOWN message arrives 
with a virtual key code equal to 0x41. Before you put an A on the screen, you call 
<I>::GetKeyState</I> to determine whether the Shift key is held down. If it is, you output an 
uppercase &quot;A&quot;; otherwise, you output a lowercase &quot;a.&quot; So far, so good. But what if Caps Lock 
is enabled too? Caps Lock undoes the effect of the Shift key, converting &quot;A&quot; to &quot;a&quot; 
and &quot;a&quot; to &quot;A.&quot; Now you have four different permutations of the letter A to consider:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Virtual Key Code</I></th>     
<th valign="top"><I>VK_SHIFT</I></th>     
<th valign="top"><I>Caps Lock</I></th>     
<th valign="top"><I>Result</I></th>
</tr>
<tr>
<td valign="top">0x41</td>     
<td valign="top">No</td>     
<td valign="top">Off</td>     
<td valign="top">a</td>
</tr>
<tr>
<td valign="top">0x41</td>     
<td valign="top">Yes</td>     
<td valign="top">Off</td>     
<td valign="top">A</td>
</tr>
<tr>
<td valign="top">0x41</td>     
<td valign="top">No</td>     
<td valign="top">On</td>     
<td valign="top">A</td>
</tr>
<tr>
<td valign="top">0x41</td>     
<td valign="top">Yes</td>     
<td valign="top">On</td>     
<td valign="top">a</td>
</tr></table></p>

<P>While you might reasonably expect to overcome this problem by writing 
code to sense all the possible shift and toggle states, your work is complicated by the 
fact that the user might also have the Ctrl key held down. And the problem is only 
compounded when your application is run outside the United States, where 
keyboard layouts typically differ from the U.S. keyboard layout. A U.S. user presses Shift-0 
to enter a right parenthesis symbol. But Shift-0 produces an equal sign on most 
international keyboards and an apostrophe on Dutch keyboards. Users won't 
appreciate it much if the characters your program displays don't match the characters they type.</P>

<P>That's why Windows provides the 
<I>::TranslateMessage</I> API function. 
<I>::TranslateMessage</I> converts keystroke messages involving character keys into 
WM_CHAR messages.The message loop provided by MFC calls 
<I>::TranslateMessage</I> for you, so in an MFC application you don't have to do anything special to translate 
keystroke messages into WM_CHAR messages. When you use WM_CHAR messages for 
keyboard input, you needn't worry about virtual key codes and shift states because 
each WM_CHAR message includes a character code that maps directly to a symbol in 
the ANSI character set (Windows 98) or Unicode character set (Windows 2000). 
Assuming that Caps Lock is not turned on, pressing Shift-A produces the following 
sequence of messages:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>     
<th valign="top"><I>Virtual Key Code</I></th>  
<th valign="top"><I>Character Code</I></th>
</tr>
<tr>
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">VK_SHIFT</td>
<td valign="top"></td>
</tr>
<tr>   
<td valign="top">WM_KEYDOWN</td>     
<td valign="top">0x41</td>     
<td valign="top"></td>
</tr>
<tr>
<td valign="top">WM_CHAR</td>          
<td valign="top"></td>
<td valign="top">0x41 (&quot;A&quot;)</td>
</tr>
<tr>
<td valign="top">WM_KEYUP</td>     
<td valign="top">0x41</td>     
<td valign="top"></td>
</tr>
<tr>
<td valign="top">WM_KEYUP</td>     
<td valign="top">VK_SHIFT</td>     
<td valign="top"></td>
</tr></table></p>

<P>Now you can safely ignore key-up and key-down messages because 
everything you need to know about the keystroke is encoded in the WM_CHAR message. If the 
Alt key had been held down while Shift-A was pressed, your application would 
have received a WM_SYSCHAR message instead:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>     
<th valign="top"><I>Virtual Key Code</I></th>  
<th valign="top"><I>Character Code</I></th>
</tr>
<tr>
<td valign="top">WM_SYSKEYDOWN</td>     
<td valign="top">VK_SHIFT</td> 
<td valign="top"></td>    
</tr>
<tr>
<td valign="top">WM_SYSKEYDOWN</td>     
<td valign="top">0x41</td>
<td valign="top"></td>    
</tr>
<tr>
<td valign="top">WM_SYSCHAR</td>
<td valign="top"></td>          
<td valign="top">0x41 (&quot;A&quot;)</td>
</tr>
<tr>
<td valign="top">WM_SYSKEYUP</td>     
<td valign="top">0x41</td>     
<td valign="top"></td>
</tr>
<tr>
<td valign="top">WM_SYSKEYUP</td>      
<td valign="top">VK_SHIFT</td>     
<td valign="top"></td>
</tr></table></p>

<P>Since Alt-key combinations are generally used for special purposes, most 
applications ignore WM_SYSCHAR messages and process WM_CHAR messages instead.</P>

<P>Figure 3-6 shows the characters in the ANSI character set. Since ANSI codes 
are only 8 bits wide, there are only 256 possible characters. Unicode uses 16-bit 
character codes, expanding the possible character count to 65,536. Fortunately, the first 
256 characters in the Unicode character set and the 256 characters in the ANSI 
character set are identical. Thus, code like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
case _T (`a'):
case _T (`A'):
</pre>
</td></tr></table>

<P>works fine with either character set.</P>

<P>
<A HREF="javascript:fullSize('F03mg06x.htm')"> <img src="images/F03mg06.JPG" width=404 height=459 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 3-6.</B> <I>The ANSI character set.</I><!-- /CAPTION -->
</p>

<P>An ON_WM_CHAR entry in a class's message map routes WM_CHAR 
messages to the member function <I>OnChar</I>, which is prototyped as follows:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
afx_msg void OnChar (UINT nChar, UINT nRepCnt, UINT nFlags)
</pre>
</td></tr></table>

<P><I>nRepCnt</I> and <I>nFlags</I> have the same meanings that they have in keystroke 
messages. <I>nChar</I> holds an ANSI or Unicode character code. The following code fragment 
traps presses of the letter keys, the Enter key, and the Backspace key, all of which 
produce WM_CHAR messages:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_WM_CHAR ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnChar (UINT nChar, UINT nRepCnt, UINT nFlags)

{
    if (((nChar &gt;= _T (`A')) &amp;&amp; (nChar &lt;= _T (`Z'))) ||
        ((nChar &gt;= _T (`a')) &amp;&amp; (nChar &lt;= _T (`z')))) {
        // Display the character
    }
    else if (nChar == VK_RETURN) {
        // Process the Enter key
    }
    else if (nChar == VK_BACK) {
        // Process the Backspace key
    }
}
</pre>
</td></tr></table>

<P>If it's unclear to you whether a particular key produces a WM_CHAR 
message, there's an easy way to find out. Simply run the VisualKB application that comes 
with this book and press the key. If the key produces a WM_CHAR message, the 
message will appear in VisualKB's window.</P>

<A NAME="94"><H2>Dead-Key Messages</H2></A>

<P>There are two keyboard messages I didn't mention because they are rarely used 
by application programs. Many international keyboard drivers allow users to enter 
a character accented with a diacritic by typing a &quot;dead key&quot; representing the 
diacritic and then typing the character itself. 
<I>::TranslateMessage</I> translates WM_KEYUP messages corresponding to dead keys into WM_DEADCHAR messages, and it 
translates WM_SYSKEYUP messages generated by dead keys into WM_SYSDEADCHAR 
messages. Windows provides the logic that combines these messages with 
character messages to produce accented characters, so dead-key messages are usually 
passed on for default processing. Some applications go the extra mile by intercepting 
dead-key messages and displaying the corresponding diacritics. The keystroke 
following the dead key then replaces the diacritic with an accented character. This 
provides visual feedback to the user and prevents dead keys from having to be typed &quot;blind.&quot;</P>

<P>You can process dead-key messages in an MFC application by including 
an ON_WM_DEADCHAR or ON_WM_SYSDEADCHAR entry in a message map and 
supplying handling functions named 
<I>OnDeadChar</I> and <I>OnSysDeadChar</I>. You'll 
find descriptions of these functions in the MFC documentation.</P>

<A NAME="95"><H2>The Caret</H2></A>

<P>The flashing vertical bar that word processors and other Windows applications 
use to mark the point where the next character will be inserted is called the 
<I>caret</I>. The caret serves the same purpose in a Windows application that the blinking 
underscore cursor does in a character-mode application. MFC's 
<I>CWnd</I> class provides the seven caret-handling functions shown below. The one essential function missing from 
this table, <I>::DestroyCaret</I>, must be called directly from the Windows API because there 
is no MFC equivalent.</P>

<P><B><I>CWnd</I> Caret Handling Functions</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Function</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>CreateCaret</I></td>     
<td valign="top">Creates a caret from a bitmap</td>
</tr>
<tr>
<td valign="top"><I>CreateSolidCaret</I></td>     
<td valign="top">Creates a solid line caret or a block caret</td>
</tr>
<tr>
<td valign="top"><I>CreateGrayCaret</I></td>     
<td valign="top">Creates a gray line caret or a block caret</td>
</tr>
<tr>
<td valign="top"><I>GetCaretPos</I></td>     
<td valign="top">Retrieves the current caret position</td>
</tr>
<tr>
<td valign="top"><I>SetCaretPos</I></td>     
<td valign="top">Sets the caret position</td>
</tr>
<tr>
<td valign="top"><I>ShowCaret</I></td>     
<td valign="top">Displays the caret</td>
</tr>
<tr>
<td valign="top"><I>HideCaret</I></td>     
<td valign="top">Hides the caret</td>
</tr></table></p>

<P>The caret, like the mouse cursor, is a shared resource. However, unlike the 
cursor, which is a global resource shared by everyone, the caret is a per-thread resource 
that's shared by all windows running on the same thread. To ensure proper handling, 
applications that use the caret should follow these simple rules:</P>

<UL>
<P><LI>
A window that uses the caret should &quot;create&quot; a caret when it receives 
the input focus and should &quot;destroy&quot; the caret when it loses the input focus. A caret is created with <I>CreateCaret</I>, 
<I>CreateSolidCaret</I>, or <I>CreateGrayCaret</I> and is destroyed with 
<I>::DestroyCaret</I>.
</LI></P>

<P><LI>
Once a caret is created, it isn't visible until <I>ShowCaret</I> is called to make it visible. The caret can be hidden again with a call to 
<I>HideCaret</I>. If calls to <I>HideCaret</I> are nested&#8212;that is, if 
<I>HideCaret</I> is called twice or more in succession&#8212;<I>ShowCaret</I> must be called an equal number of times to make the caret visible again.
</LI></P>

<P><LI>
When you draw in the area of a window that contains the caret 
outside an <I>OnPaint</I> handler, you should hide the caret to avoid corrupting the display. You can redisplay the caret after drawing is complete. You don't need to hide and redisplay the caret in an <I>OnPaint</I> handlerbecause <I>::BeginPaint</I> and <I>::EndPaint</I> do that for you.
</LI></P>

<P><LI>
A program moves the caret by calling <I>SetCaretPos</I>. Windows doesn't move the caret for you; it's your program's job to process incoming 
keyboard messages (and perhaps mouse messages) and manipulate the caret 
accordingly. <I>GetCaretPos</I> can be called to retrieve the caret's current position.
</LI></P>
</UL>

<P>As you know, a window receives a WM_SETFOCUS message when it 
receives the input focus and a WM_KILLFOCUS message when it loses the input focus. 
The following WM_SETFOCUS handler creates a caret, positions it, and displays it 
when a window gains the input focus:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnSetFocus (CWnd* pWnd)
{
    CreateSolidCaret (2, m_cyChar);
    SetCaretPos (m_ptCaretPos);
    ShowCaret ();
}
</pre>
</td></tr></table>

<P>And this WM_KILLFOCUS handler saves the caret position and hides and 
destroys the caret when the input focus is lost:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnKillFocus (CWnd* pWnd)
{
    HideCaret ();
    m_ptCaretPos = GetCaretPos ();
    ::DestroyCaret ();
}
</pre>
</td></tr></table>

<P>In these examples, <I>m_cyChar</I> holds the caret height and 
<I>m_ptCaretPos</I> holds the caret position. The caret position is saved when the focus is lost, and it is restored 
when the focus is regained. Since only one window can have the input focus at a time 
and keyboard messages are directed to the window with the input focus, this 
approach to caret handling ensures that the window that &quot;owns&quot; the keyboard also owns 
the caret.</P>

<P>The caret-create functions serve two purposes: defining the look of the 
caret and claiming ownership of the caret. The caret is actually a bitmap, so you can 
customize its appearance by supplying a bitmap to 
<I>CWnd::CreateCaret</I>. But more often than not you'll find that the easier-to-use 
<I>CreateSolidCaret</I> function (it's easier to 
use because it doesn't require a bitmap) does the job nicely. 
<I>CreateSolidCaret</I> creates a solid block caret that, depending on how you shape it, can look like a rectangle, 
a horizontal or vertical line, or something in between. In the 
<I>OnSetFocus</I> example above, the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CreateSolidCaret (2, m_cyChar);
</pre>
</td></tr></table>

<P>creates a vertical-line caret 2 pixels wide whose height equals the character height 
of the current font (<I>m_cyChar</I>). This is the traditional way of creating a caret for 
use with a proportional font, although some programs key the width of the caret to 
the width of a window border. You can obtain the border width by calling 
<I>::GetSystemMetrics</I> with the value SM_CXBORDER. For fixed-pitch fonts, you might prefer 
to use a block caret whose width and height equal the width and height of one 
character, as in</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CreateSolidCaret (m_cxChar, m_cyChar);
</pre>
</td></tr></table>

<P>A block caret doesn't make sense for a proportionally spaced font because 
of the varying character widths. <I>CWnd</I>'s<I> 
CreateGrayCaret</I> function works just as 
<I>CreateSolidCaret</I> does except that it creates a gray caret rather than a solid black 
caret. Caret dimensions are expressed in logical units, so if you change the mapping 
mode before creating a caret, the dimensions you specify will be transformed accordingly.</P>

<P>As mentioned above, it's your job to move the caret. 
<I>CWnd::SetCaretPos</I> repositions the caret, accepting a 
<I>CPoint</I> object that contains the <I>x</I> and 
<I>y</I> client-area coordinates of the new cursor position. Positioning the caret in a string of text is 
fairly straightforward if you're using a fixed-pitch font because you can calculate a 
new <I>x</I> offset into the string by multiplying the character position by the character 
width. If the font is proportionally spaced, you'll have to do a little more work. 
MFC's <I>CDC::GetTextExtent</I> and 
<I>CDC::GetTabbedTextExtent</I> functions enable an 
application to determine the width, in logical units, of a string of characters rendered in a 
proportional font. (Use <I>GetTabbedTextExtent</I> if the string contains tab characters.) 
Given a character position <I>n</I>, you can compute the corresponding caret position by 
calling <I>GetTextExtent</I> or 
<I>GetTabbedTextExtent</I> to find the cumulative width of the first 
<I>n</I> characters. If the string &quot;Hello, world&quot; is displayed at the position specified by a 
<I>CPoint</I> object named <I>point</I> and 
<I>dc</I> is a device context object, the following statements 
position the caret between the &quot;w&quot; and &quot;o&quot; in &quot;world&quot;:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CSize size = dc.GetTextExtent (_T (&quot;Hello, w&quot;), 8);
SetCaretPos (CPoint (point.x + size.cx, point.y));
</pre>
</td></tr></table>

<P><I>GetTextExtent</I> returns a <I>CSize</I> object whose 
<I>cx</I> and <I>cy</I> members reflect the 
string's width and height.</P>

<P>Caret positioning gets slightly more complicated if you're using a 
proportional font and don't have a character offset to work with, which is exactly the situation 
you'll find yourself in when you write an 
<I>OnLButtonDown</I> handler that repositions the 
caret when the left mouse button is clicked. Suppose your application maintains a variable named <I>m_nCurrentPos</I> that denotes the current character position&#8212;the 
position within a string at which the next typed character will be inserted. It's easy 
to calculate the new caret position when the left or right arrow key is pressed: You 
just decrement or increment <I>m_nCurrentPos</I> and call 
<I>GetTextExtent</I> or <I>GetTabbedTextExtent</I> with the new character position to compute a new offset. But what if the 
left mouse button is clicked at some arbitrary location in the string? There is no 
relationship between where the mouse click occurred and 
<I>m_nCurrentPos</I>, so you must use the horizontal difference between the cursor position and the beginning of the 
string to work backward to a character position, and 
<I>then</I> calculate the final caret position. This inevitably involves some iteration since there is neither a Windows API 
function nor an MFC class member function that accepts a string and a pixel offset and 
returns the character at that offset. Fortunately, it's not terribly difficult to write that 
function yourself. You'll see how it's done in the next section.</P>

</BODY>
</HTML>




