<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Document/View Fundamentals</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09a.htm", "ch09c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="268"><H1>Document/View Fundamentals</H1></A>

<P>Let's begin our exploration of the document/view 
architecture with a conceptual look at the various objects involved and the 
relationships they share with one another. Figure 9-1 shows a schematic 
representation of an SDI document/view application. The frame window is the 
application's top-level window. It's normally a WS_OVERLAPPEDWINDOW-style window 
with a resizing border, a title bar, a system menu, and minimize, maximize, and 
close buttons. The view is a child window sized to fit the frame window so that 
it becomes, for all practical purposes, the frame window's client area. The 
application's data is stored in the document object, a visible representation of 
which appears in the view. For an SDI application, the frame window class is 
derived from <I>CFrameWnd</I>, the document class is 
derived from 
<I>CDocument</I>, and the view class is 
derived from 
<I>CView</I> or a related class such as<I> CScrollView</I>.</P>

<P>
<A HREF="javascript:fullSize('F09mg01x.htm')"> <img src="images/F09mg01.JPG" width=404 height=294 border=0 ALT="Click to view at full size."></A>
</P><p>
<!-- CAPTION --><B>Figure 9-1.</B> <I>The SDI 
document/view architecture.</I><!-- /CAPTION --> 
</p>

<P>The arrows represent data flow. The application object 
provides the message loop that pumps messages to the frame window and the view. 
The view object translates mouse and keyboard input into commands that operate 
on the data stored in the document object, and the document object provides the 
data that the view needs to render its output. The individual objects interact 
in other ways, too, but you'll find the big picture easier to grasp after you've 
learned more about the role each object plays in a program's operation and have 
written a document/view application or two of your own.</P>
<P>The architecture depicted in Figure 9-1 has very real 
implications for the design and operation of an application program. In an MFC 
1.0_style application, a program's data is often stored in member variables 
declared in the frame window class. The frame window draws &quot;views&quot; of 
that data by accessing its own member variables and using GDI functions 
encapsulated in the 
<I>CDC</I> class to draw into its 
client area. The document/view architecture enforces a modular program design by 
encapsulating data in a stand-alone document object and providing a view object 
for the program's screen output. A document/view application never grabs a 
client-area device context for its frame window and draws into it; instead, it 
draws into the view. It 
<I>looks</I> as if the drawing is 
being done in the frame window, but in reality all output goes to the view. You 
can draw into the frame window if you want to, but you won't see the output 
because the client area of an SDI frame window is completely obscured by the 
view.</P>

<A NAME="269"><H2>The <I>InitInstance</I> Function 
Revisited</H2></A>
<P>One of the most interesting aspects of an SDI 
document/view application is the way in which the frame window, document, and 
view objects are created. If you look at the <I>InitInstance</I> function for an SDI application generated by AppWizard, 
you'll see something like this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
CSingleDocTemplate* pDocTemplate;
pDocTemplate = new CSingleDocTemplate (
    IDR_MAINFRAME,
    RUNTIME_CLASS (CMyDoc),
    RUNTIME_CLASS (CMainFrame),
    RUNTIME_CLASS (CMyView)
);
AddDocTemplate (pDocTemplate);
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
CCommandLineInfo cmdInfo;
ParseCommandLine (cmdInfo);

if (!ProcessShellCommand (cmdInfo))
    return FALSE;

m_pMainWnd-&gt;ShowWindow (SW_SHOW);
m_pMainWnd-&gt;UpdateWindow ();
</PRE>
</td></tr></table>
</P>

<P>This code is quite different from the startup code in 
the sample programs in Part I of this book. Let's look more closely at this 
<I>InitInstance</I> function to see what it takes to get a 
document/view application up and running. To begin with, the statements</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
CSingleDocTemplate* pDocTemplate;
pDocTemplate = new CSingleDocTemplate (
    IDR_MAINFRAME,
    RUNTIME_CLASS (CMyDoc),
    RUNTIME_CLASS (CMainFrame),
    RUNTIME_CLASS (CMyView)
);
</PRE>
</td></tr></table>
</P>

<P>create an SDI document template from MFC's 
<I>CSingleDocTemplate</I> class. The SDI document template is 
a crucial element of an SDI document/view application. It identifies the 
document class used to manage the application's data, the frame window class 
that encloses views of that data, and the view class used to draw visual 
representations of the data. The document template also stores a resource ID 
that the framework uses to load menus, accelerators, and other resources that 
shape the application's user interface. AppWizard uses the resource ID 
IDR_MAINFRAME in the code that it generates. The RUNTIME_CLASS macro surrounding 
the class names returns a pointer to a <I>CRuntimeClass</I> 
structure for the specified class, which enables the framework to create objects 
of that class at run time. This dynamic creation mechanism is another important 
element of the document/view architecture. I'll describe how it works a little 
later in this chapter.</P>

<P>After the document template is created, the 
statement</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
AddDocTemplate (pDocTemplate);
</PRE>
</td></tr></table>
</P>


<P>adds it to the list of document templates maintained by 
the application object. Each template registered in this way defines one 
document type the application supports. SDI applications register just one 
document type, but MDI applications can&mdash;and sometimes do&mdash;register 
several types.</P>
<P>The statements</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
CCommandLineInfo cmdInfo;
ParseCommandLine (cmdInfo);
</PRE>
</td></tr></table>
</P>

<P>use <I>CWinApp::ParseCommandLine</I> to initialize a 
<I>CCommandLineInfo</I> object with values reflecting the parameters entered 
on the command line, which often include a document file name. The 
statements</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
if (!ProcessShellCommand (cmdInfo))
    return FALSE;
</PRE>
</td></tr></table>
</P>

<P>&quot;process&quot; the command line parameters. Among 
other things, 
<I>ProcessShellCommand</I> calls 
<I>CWinApp::OnFileNew</I> to start the application with an 
empty document if no file name was entered on the command line, or 
<I>CWinApp::OpenDocumentFile</I> to load a document if a 
document name was specified. It's during this phase of the program's execution 
that the framework creates the document, frame window, and view objects using 
the information stored in the document template. (In case you're wondering, the 
document object is created first, followed by the frame window and then the 
view.) <I>ProcessShellCommand</I> returns TRUE if the 
initialization succeeds and FALSE if it doesn't. If initialization is 
successful, the statements</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
m_pMainWnd-&gt;ShowWindow (SW_SHOW);
m_pMainWnd-&gt;UpdateWindow ();
</PRE>
</td></tr></table>
</P>

<P>display the application's frame window (and by 
extension, the view) on the screen.</P>
<P>After the application is started and the document, frame 
window, and view objects are created, the message loop kicks in and the 
application begins to retrieve and process messages. Unlike MFC 1.0_type 
applications, which typically map all messages to member functions of the frame 
window class, document/view applications divide message processing among the 
application, document, view, and frame window objects. The framework does a lot 
of work in the background to make this division of labor possible. In Windows, 
only windows can receive messages, so MFC implements a sophisticated 
command-routing mechanism that sends certain types of messages from one object 
to another in a predefined order until one of the objects processes the message 
or the message is passed to 
<I>::DefWindowProc</I> for 
default processing. When we discuss command routing later in this chapter, it 
will become abundantly clear why command routing is a powerful feature of MFC 
whose absence would severely inhibit the usefulness of the document/view 
architecture.</P>

<A NAME="270"><H2>The Document Object</H2></A>

<P>In a document/view application, data is stored in a 
document object. The document object is created when the framework instantiates 
a class derived from 
<I>CDocument</I>. The term <I>document</I> is somewhat misleading because it stirs up 
visions of word processors and spreadsheet programs and other types of 
applications that deal with what we traditionally think of as documents. In 
reality, the &quot;document&quot; part of document/view is much more general 
than that. A document can be almost anything, from a deck of cards in a poker 
simulation to an online connection to a remote data source; it is an abstract 
representation of a program's data that draws a clear boundary between how the 
data is stored and how it is presented to the user. Typically, the document 
object provides public member functions that other objects, primarily views, can 
use to access the document's data. All handling of the data is performed by the 
document object itself.</P>
<P>A document's data is often stored in member variables of 
the derived document class. The Scribble tutorial supplied with Microsoft Visual 
C++ exposes its data directly to other objects by declaring its data members 
public, but stricter encapsulation is achieved by making document data private 
and providing public member functions for accessing it. The document object in a 
text editing program, for example, might store characters in a <I>CByteArray</I> object and provide 
<I>AddChar</I> and <I>RemoveChar</I> functions so that the view can convert 
the mouse and keyboard messages it receives into commands to add and remove 
characters. Other functions, such as 
<I>AddLine</I> and <I>DeleteLine</I>, could further enrich the interface between 
the document object and the views connected to it.</P>

<A NAME="271"><H3><I>CDocument</I> 
Operations</H3></A>
<P>In MFC literature, &quot;operation&quot; is the term 
used to describe nonvirtual class member functions. A derived document class 
inherits several important operations from <I>CDocument</I>, some of which are listed in the following table.</P>

<P><b>Key <I>CDocument</I> Operations</b></P>

<P>
<table valign = "top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Function</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>GetFirstViewPosition</I></td>
<td valign="top">Returns a POSITION value that 
            can be passed to <I>GetNextView</I> to begin 
            enumerating the views associated with this document</td>
</tr>
<tr>
<td valign="top"><I>GetNextView</I></td>
<td valign="top">Returns a <I>CView</I> pointer to the next view in the list of views 
            associated with this document</td>
</tr>
<tr>
<td valign="top"><I>GetPathName</I></td>
<td valign="top">Retrieves the document's file 
            name and path&mdash;for example, 
            &quot;C:\Documents\Personal\MyFile.doc&quot;; returns an empty 
            string if the document hasn't been named</td>
</tr>
<tr>
<td valign="top"><I>GetTitle</I></td>
<td valign="top">Retrieves the document's 
            title&mdash;for example, &quot;MyFile&quot;; returns an empty string 
            if the document hasn't been named</td>
</tr>
<tr>
<td valign="top"><I>IsModified</I></td>
<td valign="top">Returns a nonzero value if the 
            document contains unsaved data or 0 if it doesn't</td>
</tr>
<tr>
<td valign="top"><I>SetModifiedFlag</I>S</td>
<td valign="top">Sets or clears the document's 
            modified flag, which indicates whether the document contains unsaved 
            data</td>
</tr>
<tr>
<td valign="top"><I>UpdateAllViews</I></td>
<td valign="top">Updates all views associated 
            with the document by calling each view's <I>OnUpdate</I> function</td>
</tr>
</table>
</P>
      
<P>Of these functions, <I>SetModifiedFlag</I> and 
<I>UpdateAllViews</I> are the 
two that you'll use the most. You should call 
<I>SetModifiedFlag</I> whenever the document's data is modified. This 
function sets a flag inside the document object that tells MFC the document 
contains unsaved data, which allows MFC to prompt the user before closing a 
document that contains unsaved changes. You can determine for yourself whether a 
document is &quot;dirty&quot; with 
<I>IsModified</I>. <I>UpdateAllViews</I> commands all the views attached to a 
document to update themselves. Under the hood, 
<I>UpdateAllViews</I> calls each view's 
<I>OnUpdate</I> 
function, whose default action is to invalidate the view to force a repaint. In 
an application that supports multiple views of its documents, calling 
<I>UpdateAllViews</I> whenever the document's data changes 
keeps all the different views in sync. Even a single-view application can call 
<I>UpdateAllViews</I> to refresh the view based on the data 
currently contained in the document.</P>
<P>A document object can enumerate its views and 
communicate with each view individually by using 
<I>GetFirstViewPosition</I> and <I>GetNextView</I> to 
walk the list of views. The excerpt below from the MFC source code file 
Doccore.ccp demonstrates how <I>UpdateAllViews</I> uses 
<I>GetFirstViewPosition</I> and <I>GetNextView</I> to call each view's <I>OnUpdate</I> 
function.</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
POSITION pos = GetFirstViewPosition();
while (pos != NULL)
{
    CView* pView = GetNextView(pos);
        <img src="images/grayvellip.JPG" width=3 height=13 border="0">
    pView-&gt;OnUpdate(pSender, lHint, pHint);
}
</PRE>
</td></tr></table>
</P>

<P>Given that <I>OnUpdate</I> is a 
protected member function of 
<I>CView</I>, you might wonder 
how this code can even compile. The answer is that 
<I>CDocument</I> is declared a friend of 
<I>CView</I> in 
Afxwin.h. You can freely call 
<I>GetFirstViewPosition</I> 
and <I>GetNextView</I> from your own code, but you can call 
<I>OnUpdate</I> from your document class only if you, too, 
declare the document to be a friend of the view.</P>

<A NAME="272"><H3><I>CDocument</I> 
Overridables</H3></A>
<P><I>CDocument</I> also includes 
several virtual functions, or &quot;overridables,&quot; that can be overridden 
to customize a document's behavior. Some of these functions are almost always 
overridden in a derived document class. The four most commonly used overridables 
are shown in the following table.</P>

<P><b>Key <I>CDocument</I> Overridables</b></P>

<P>
<table valign = "top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Function</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>OnNewDocument</I></td>
<td valign="top">Called by the framework when a 
            new document is created. Override to apply specific initializations 
            to the document object each time a new document is created.</td>
</tr>
<tr>
<td valign="top"><I>OnOpenDocument</I></td>
<td valign="top">Called by the framework when a 
            document is loaded from disk. Override to apply specific 
            initializations to the document object each time a document is 
            loaded.</td>
</tr>
<tr>
<td valign="top"><I>DeleteContents</I></td>
<td valign="top">Called by the framework to 
            delete the document's contents. Override to free memory and other 
            resources allocated to the document before it is closed.</td>
</tr>
<tr>
<td valign="top"><I>Serialize</I></td>
<td valign="top">Called by the framework to 
            serialize the document to or from disk. Override to provide 
            document-specific serialization code so that documents can be loaded 
            and saved.</td>
</tr>
</table>
</P>
    
<P>In an SDI application, MFC instantiates the document 
object once&mdash;when the application starts up&mdash;and reuses that object 
over and over as document files are opened and closed. Because the document 
object is created just one time, initializations performed by the document's 
class constructor are executed only once, too. But what if your derived document 
class contains member variables that you want to reinitialize whenever a new 
document is created or an existing document is loaded from disk?</P>

<P>That's where <I>OnNewDocument</I> 
and 
<I>OnOpenDocument</I> come in. MFC calls the document's 
<I>OnNewDocument</I> function whenever a new document is 
created. Typically, that occurs when the user chooses New from the File menu. 
MFC calls 
<I>OnOpenDocument</I> when a document is loaded 
from disk&mdash;that is, whenever the user selects Open from the File menu. You 
can perform one-time initializations in an SDI document class's constructor. But 
if you want to perform certain initializations anytime a document is created or 
opened, you must override 
<I>OnNewDocument</I> or <I>OnOpenDocument</I>.</P>
<P>MFC provides default implementations of 
<I>OnNewDocument</I> and <I>OnOpenDocument</I> that 
shoulder the burden of creating new documents and opening existing documents. If 
you override 
<I>OnNewDocument</I> and <I>OnOpenDocument</I>, you should call the equivalent functions in the base 
class, as shown here:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL CMyDoc::OnNewDocument ()
{
    if (!CDocument::OnNewDocument ())
        return FALSE;
    // Insert application-specific initialization code here.
    return TRUE;
}

BOOL CMyDoc::OnOpenDocument (LPCTSTR lpszPathName)
{
    if (!CDocument::OnOpenDocument (lpszPathName))
        return FALSE;
    // Insert application-specific initialization code here.
    return TRUE;
}
</PRE>
</td></tr></table>
</P>

<P>Generally speaking, MFC applications more commonly 
override 
<I>OnNewDocument</I> than <I>OnOpenDocument</I>. Why? Because 
<I>OnOpenDocument</I> indirectly calls the document's 
<I>Serialize</I> function, which initializes a document's persistent data 
members with values retrieved from a document file. Only nonpersistent data 
members&mdash;those that aren't initialized by 
<I>Serialize</I>&mdash;need to be initialized in 
<I>OnOpenDocument</I>. <I>OnNewDocument</I>, by 
contrast, performs no default initialization of the document's data members. If 
you add data members to a document class and want those data members 
reinitialized whenever a new document is created, you need to override <I>OnNewDocument</I>.</P>

<P>Before a new document is created or opened, the 
framework calls the document object's virtual <I>DeleteContents</I> function to delete the document's existing data. 
Therefore, an SDI application can override 
<I>CDocument::DeleteContents</I> and take the opportunity to free any 
resources allocated to the document and perform other necessary cleanup chores 
in preparation for reusing the document object. MDI applications generally 
follow this model also, although MDI document objects differ from SDI document 
objects in that they are individually created and destroyed as the user opens 
and closes documents.</P>
<P>When a document is opened or saved, the framework calls 
the document object's <I>Serialize</I> function to 
serialize the document's data. You implement the 
<I>Serialize</I> function so that it streams the document's data in and out; 
the framework does everything else, including opening the file for reading or 
writing and providing a 
<I>CArchive</I> object to insulate 
you from the vagaries of physical disk I/O. A derived document class's <I>Serialize</I> function is typically structured like 
this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
void CMyDoc::Serialize (CArchive&amp; ar)
{
    if (ar.IsStoring ()) {
        // Write the document's persistent data to the archive.
    }
    else { // Loading, not storing
        // Read the document's persistent data from the archive.
    }
}
</PRE>
</td></tr></table>
</P>

<P>In place of the comments, you include code that streams 
the document's persistent data to or from an archive using the serialization 
mechanism described in <a href="ch06a.htm">Chapter 6</a>. 
For a simple document class whose data consists of two strings stored in 
<I>CString</I> member variables named 
<I>m_strName</I> and <I>m_strPhone</I>, you could write 
<I>Serialize</I> like this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
void CMyDoc::Serialize (CArchive&amp; ar)
{
    if (ar.IsStoring ()) {
        ar &lt;&lt; m_strName &lt;&lt; m_strPhone;
    }
    else { // Loading, not storing.
        ar &gt;&gt; m_strName &gt;&gt; m_strPhone;
    }
}
</PRE>
</td></tr></table>
</P>

<P>If your document's data is composed of primitive data 
types and serializable classes like <I>CString</I>, writing 
a 
<I>Serialize</I> function is exceedingly easy because all 
input and output can be performed with the &lt;&lt; and &gt;&gt; operators. For 
structures and other nonserializable data types, you can use the 
<I>CArchive</I> functions <I>Read</I> and 
<I>Write</I>. <I>CArchive</I> even 
includes 
<I>ReadString</I> and <I>WriteString</I> functions for serializing raw strings. If all else fails, 
you can call 
<I>CArchive::GetFile</I> to get a <I>CFile</I> pointer for interacting directly with the file 
attached to the archive. You'll see this technique used in <a href="ch13a.htm">Chapter 13</a>'s HexDump program.</P>
<P>Other <I>CDocument</I> overridables 
that aren't used as often but that can be useful include <I>OnCloseDocument</I>, which is called when a document is closed; 
<I>OnSaveDocument</I>, which is called when a document is 
saved; 
<I>SaveModified</I>, which is called before a 
document containing unsaved data is closed to ask the user whether changes 
should be saved; and 
<I>ReportSaveLoadException</I>, which 
is called when an error occurs during serialization. There are others, but for 
the most part they constitute advanced overridables that you'll rarely find 
occasion to use.</P>

<A NAME="273"><H2>The View Object</H2></A>

<P>Whereas the sole purpose of a document object is to 
manage an application's data, view objects exist for two purposes: to render 
visual representations of a document on the screen and to translate the user's 
input&mdash;particularly mouse and keyboard messages&mdash;into commands that 
operate on the document's data. Thus, documents and views are tightly 
interrelated, and information flows between them in both directions.</P>
<P>MFC's <I>CView</I> class defines 
the basic properties of a view. MFC also includes a family of view classes 
derived from <I>CView</I> that add functionality to views. 
<I>CScrollView</I>, for example, adds scrolling 
capabilities to 
<I>CView</I>. <I>CScrollView</I> and other 
<I>CView</I> derivatives 
are discussed in <a href="ch10a.htm">Chapter 10</a>.</P>

<A NAME="274"><H3>The <I>GetDocument</I> 
Function</H3></A>
<P>A document object can have any number of views 
associated with it, but a view always belongs to just one document. The 
framework stores a pointer to the associated document object in a view's 
<I>m_pDocument</I> data member and exposes that pointer 
through the view's <I>GetDocument</I> member function. Just 
as a document object can identify its views using 
<I>GetFirstViewPosition</I> and <I>GetNextView</I>, a 
view can identify its document by calling <I>GetDocument</I>.</P>
<P>When AppWizard generates the source code for a view 
class, it overrides the base class's <I>GetDocument</I> 
function with one that casts 
<I>m_pDocument</I> to the 
appropriate document type and returns the result. This override allows type-safe 
access to the document object and eliminates the need for an explicit cast each 
time 
<I>GetDocument</I> is called.</P>

<A NAME="275"><H3><I>CView</I> Overridables</H3></A>
<P>Like the <I>CDocument</I> class, <I>CView</I> includes several virtual member functions that 
you can override in a derived class to customize a view's behavior. The key 
overridables are shown in the following table. The most important is a pure 
virtual function named <I>OnDraw</I>, which is called each 
time the view receives a WM_PAINT message. In non-document/view applications, 
WM_PAINT messages are processed by 
<I>OnPaint</I> handlers 
that use <I>CPaintDC</I> objects to do their drawing. In 
document/view applications, the framework fields the WM_PAINT message, creates a 
<I>CPaintDC</I> object, and calls the view's 
<I>OnDraw</I> function with a pointer to the 
<I>CPaintDC</I> object. The following implementation of 
<I>OnDraw</I> retrieves a <I>CString</I> from the 
document object and displays it in the center of the view:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
void CMyView::OnDraw (CDC* pDC)
{
    CMyDoc* pDoc = GetDocument ();
    CString string = pDoc-&gt;GetString ();
    CRect rect;
    GetClientRect (&amp;rect);
    pDC-&gt;DrawText (string, rect,
        DT_SINGLELINE &brvbar; DT_CENTER &brvbar; DT_VCENTER);
}
</PRE>
</td></tr></table>
</P>

<P>Notice that <I>OnDraw</I> uses the 
supplied device context pointer rather than instantiate a device context of its 
own.</P>

<P><b>Key <I>CView</I> Overridables</b></P>
<P>
<table valign = "top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Function</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>OnDraw</I></td>
<td valign="top">Called to draw the document's 
            data. Override to paint views of a document.</td>
</tr>
<tr>
<td valign="top"><I>OnInitialUpdate</I></td>
<td valign="top">Called when a view is first 
            attached to a document. Override to initialize the view object each 
            time a document is created or loaded.</td>
</tr>
<tr>
<td valign="top"><I>OnUpdate</I></td>
<td valign="top">Called when the document's data 
            has changed and the view needs to be updated. Override to implement 
            &quot;smart&quot; update behavior that redraws only the part of the 
            view that needs redrawing rather than the entire 
view.</td>
</tr>
</table>
</P>
    
<P>The fact that the view doesn't have to construct its own 
device context object is a minor convenience. The real reason the framework uses 
<I>OnDraw</I> is so that the same code can be used for 
output to a window, for printing, and for print previewing. When a WM_PAINT 
message arrives, the framework passes the view a pointer to a screen device 
context so that output will go to the window. When a document is printed, the 
framework calls the same 
<I>OnDraw</I> function and passes 
it a pointer to a printer device context. Because the GDI is a 
device-independent graphics system, the same code can produce identical (or 
nearly identical) output on two different devices if it uses two different 
device contexts. MFC takes advantage of this fact to make printing&mdash;usually 
a chore in Windows&mdash;a less laborious undertaking. In fact, printing from a 
document/view application is typically 
<I>much</I> easier 
than printing from a conventional application. You'll learn all about MFC's 
print architecture in <a href="ch13a.htm">Chapter 
13</a>.</P>
<P>Two other <I>CView</I> functions 
you'll frequently override in derived view classes are <I>OnInitialUpdate</I> and 
<I>OnUpdate</I>. Views, like 
documents, are constructed once and then reused over and over in SDI 
applications. An SDI view's 
<I>OnInitialUpdate</I> function 
gets called whenever a document is opened or created. The default implementation 
of <I>OnInitialUpdate</I> calls 
<I>OnUpdate</I>, and the default implementation of 
<I>OnUpdate</I> in turn invalidates the view's client area to force a 
repaint. Use 
<I>OnInitialUpdate</I> to initialize data 
members of the view class, and perform other view-related initializations on a 
per-document basis. In a 
<I>CScrollView</I>-derived class, 
for example, it's common for <I>OnInitialUpdate</I> to call 
the view's 
<I>SetScrollSizes</I> function to initialize 
scrolling parameters. It's important to call the<I> 
 </I>base class version of 
<I>OnInitialUpdate</I> from an 
overridden version, or the view won't be updated when a new document is opened 
or created.</P>
<P><I>OnUpdate</I> is called when a 
document's data is modified and someone&mdash;usually either the document object 
or one of the views&mdash;calls 
<I>UpdateAllViews</I>. You 
never <I>have</I> to override 
<I>OnUpdate</I> because the default implementation calls 
<I>Invalidate</I>. But in practice, you'll often override 
<I>OnUpdate</I> to optimize performance by repainting just the part of the 
view that needs updating rather than repainting the entire view. These so-called 
intelligent updates are especially helpful in multiple-view applications because 
they eliminate unsightly flashing in secondary views. You'll see what I mean in 
the <a href="ch11a.htm">Chapter 11</a> sample program named 
Sketch.</P>
<P>At any given time in a multiple-view application, one 
view is the 
<I>active </I>view and other views are said to 
be 
<I>inactive</I>. Generally, the active view is the one 
with the input focus. A view can determine when it is activated and deactivated 
by overriding <I>CView::OnActivateView</I>. The first 
parameter to 
<I>OnActivateView</I> is nonzero if the view 
is being activated and 0 if it is being deactivated. The second and third 
parameters are <I>CView</I> pointers identifying the views 
that are being activated and deactivated, respectively. If the pointers are 
equal, the application's frame window was activated without causing a change in 
the active view. View objects sometimes use this feature of the <I>OnActivateView</I> function to realize a palette. A frame window can get 
and set the active view with the functions 
<I>CFrameWnd::GetActiveView</I> and 
<I>CFrameWnd::SetActiveView</I>.</P>

<A NAME="276"><H2>The Frame Window Object</H2></A>

<P>So far, we've looked at the roles that application 
objects, document objects, and view objects play in document/view applications. 
But we've yet to consider the frame window object, which defines the 
application's physical workspace on the screen and serves as a container for a 
view. An SDI application uses just one frame window&mdash;a <I>CFrameWnd</I> that serves as the application's top-level window and frames 
the view. As you'll discover in the next chapter, an MDI application uses two 
different types of frame windows&mdash;a <I>CMDIFrameWnd</I> that acts as a top-level window and 
<I>CMDIChildWnd</I> windows that float within the top-level frame window and 
frame views of the application's documents.</P>
<P>Frame windows play an important and often misunderstood 
role in the operation of document/view applications. Beginning MFC programmers 
often think of a frame window as simply a window. In fact, a frame window is an 
intelligent object that orchestrates much of what goes on behind the scenes in a 
document/view application. For example, MFC's 
<I>CFrameWnd</I> class provides <I>OnClose</I> and 
<I>OnQueryEndSession</I> handlers that make sure the user gets 
a chance to save a dirty document before the application terminates or Windows 
shuts down. 
<I>CFrameWnd</I> also handles the all-important 
task of resizing a view when the frame window is resized, and it knows how to 
work with toolbars, status bars, and other user interface objects. It also 
includes member functions for manipulating toolbars and status bars, identifying 
active documents and views, and more.</P>
<P>Perhaps the best way to understand the contribution the 
<I>CFrameWnd</I> class makes is to compare it to the more 
generic 
<I>CWnd </I>class. The <I>CWnd</I> class is basically a C++ wrapper around an ordinary window. 
<I>CFrameWnd</I> is derived from <I>CWnd</I> and adds all the bells and whistles a frame window needs to 
assume a proactive role in the execution of a document/view application.</P>

<A NAME="277"><H2>Dynamic Object Creation</H2></A>

<P>If the framework is to create document, view, and frame 
window objects during the course of a program's execution, the classes from 
which those objects are constructed must support a feature known as <I>dynamic creation</I>. MFC's DECLARE_DYNCREATE and 
IMPLEMENT_DYNCREATE macros make it easy to write dynamically creatable classes. 
Here's all you have to do:</P>
<OL>
<P><LI>Derive the class from 
<I>CObject</I>.
    <P></P>
<P></P><LI>Call DECLARE_DYNCREATE in the class declaration. 
    DECLARE_DYNCREATE accepts just one parameter&mdash;the name of the 
    dynamically creatable class.
    <P></P>
<P></P><LI>Call IMPLEMENT_DYNCREATE from outside the class 
    declaration. IMPLEMENT_DYNCREATE accepts two parameters&mdash;the name of 
    the dynamically creatable class and the name of its base class.
    <P></P></LI>
</OL>

<P>You can create an instance of a class that uses these 
macros at run time with a statement like this one:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
RUNTIME_CLASS (CMyClass)-&gt;CreateObject ();
</PRE>
</td></tr></table>
</P>

<P>Using this statement is basically no different than 
using the 
<I>new</I> operator to create a <I>CMyClass</I> object, but it circumvents a shortcoming of the C++ language 
that prevents statements like these from working:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
CString strClassName = _T (&quot;CMyClass&quot;);
CMyClass* ptr = new strClassName;
</PRE>
</td></tr></table>
</P>

<P>The compiler, of course, will try to construct an object 
from a class named &quot;strClassName&quot; because it doesn't realize that 
<I>strClassName</I> is a variable name and not a literal class 
name. What MFC's dynamic object creation mechanism amounts to is a means for 
applications to register classes in such a way that the framework can create 
objects of those classes.</P>
<P>What happens under the hood when you write a class 
that's dynamically creatable? The DECLARE_DYNCREATE macro adds three members to 
the class declaration: a static <I>CRuntimeClass</I> data 
member, a virtual function named 
<I>GetRuntimeClass</I>, 
and a static function named 
<I>CreateObject</I>. When you 
write</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
DECLARE_DYNCREATE (CMyClass)
</PRE>
</td></tr></table>
</P>

<P>the C++ preprocessor outputs this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
public:
    static const AFX_DATA CRuntimeClass classCMyClass;
    virtual CRuntimeClass* GetRuntimeClass() const;
    static CObject* PASCAL CreateObject();
</PRE>
</td></tr></table>
</P>

<P>IMPLEMENT_DYNCREATE initializes the 
<I>CRuntimeClass</I> structure with information such as the class name and 
the size of each class instance. It also provides the 
<I>GetRuntimeClass</I> and <I>CreateObject</I> 
functions. If IMPLEMENT_DYNCREATE is called like this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
IMPLEMENT_DYNCREATE (CMyClass, CBaseClass)
</PRE>
</td></tr></table>
</P>

<P><I>CreateObject</I> is implemented 
like this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
CObject* PASCAL CMyClass::CreateObject()
    { return new CMyClass; }
</PRE>
</td></tr></table>
</P>

<P>Early versions of MFC used a different implementation of 
<I>CreateObject</I> that allocated memory using the size 
information stored in the class's 
<I>CRuntimeClass</I> 
structure and manually initialized an object in that memory space. Today's 
implementation of <I>CreateObject</I> is truer to the C++ 
language because if a dynamically creatable class overloads the <I>new</I> operator, 
<I>CreateObject</I> will use the 
overloaded operator.</P>

<A NAME="278"><H2>More on the SDI Document Template</H2></A>

<P>Earlier in this chapter, you saw how an SDI document 
template object is created from the <I>CSingleDocTemplate</I> class. The template's constructor was passed four 
parameters: an integer value equal to IDR_MAINFRAME and three RUNTIME_CLASS 
pointers. The purpose of the three RUNTIME_CLASS macros should be clear by now, 
so let's look more closely at the integer passed in the first parameter, which 
is actually a multipurpose resource ID that identifies the following four 
resources:</P>
<UL>
<P><LI>The application icon
    <P></P>
<P></P><LI>The application's menu
    <P></P>
<P></P><LI>The accelerator table that goes with the menu
    <P></P>
<P></P><LI>A <I>document string</I> that 
    specifies, among other things, the default file name extension for documents 
    created by this application and the default name for untitled documents
    <P></P></LI>
</UL>

<P>In an SDI document/view application, the framework 
creates the top-level window by creating a frame window object using run-time 
class information stored in the document template and then calling that object's 
<I>LoadFrame </I>function. One of the parameters 
<I>LoadFrame </I>accepts is a resource ID identifying the four 
resources listed above. Not surprisingly, the resource ID that the framework 
passes to 
<I>LoadFrame</I> is the same one supplied to the 
document template. 
<I>LoadFrame</I> creates a frame window 
and loads the associated menu, accelerators, and icon all in one step, but if 
the process is to work, you must assign all these resources the same ID. That's 
why the RC file that AppWizard generates for a document/view application uses 
the same ID for a variety of different resources.</P>

<P>The document string is a string resource formed from a 
combination of as many as seven substrings separated by &quot;\n&quot; 
characters. Each substring describes one characteristic of the frame window or 
document type. In left-to-right order, the substrings have the following meaning 
for an SDI application:</P>
<UL>
<P><LI>The title that appears in the frame window's title 
    bar. This is usually the name of the application&mdash;for example, 
    &quot;Microsoft Draw.&quot;
    <P></P>
<P></P><LI>The title assigned to new documents. If this 
    substring is omitted, the default is &quot;Untitled.&quot;
    <P></P>
<P></P><LI>A descriptive name for the document type that 
    appears along with other document types in a dialog box when the user 
    selects New from the File menu in an MDI application that registers two or 
    more document types. This substring isn't used in SDI applications.
    <P></P>
<P></P><LI>A descriptive name for the document type combined 
    with a wildcard file specification that includes the default file name 
    extension&mdash;for example, &quot;Drawing Files (*.drw).&quot; This string 
    is used in Open and Save As dialog boxes.
    <P></P>
<P></P><LI>The default file name extension for documents of 
    this type&mdash;for example, &quot;.drw.&quot;
    <P></P>
<P></P><LI>A name with no spaces that identifies the document 
    type in the registry&mdash;for example, &quot;Draw.Document.&quot; If the 
    application calls 
<I>CWinApp::Register- 
    ShellFileTypes</I> to register its document types, this substring becomes 
    the default value for the HKEY_CLASSES_ROOT subkey named after the 
    document's file name extension.
    <P></P>
<P></P><LI>A descriptive name for the document type&mdash;for 
    example, &quot;Microsoft Draw Document.&quot; Unlike the substring preceding 
    it in the document string, this substring can include spaces. If the 
    application uses 
<I>CWinApp::Register- 
    ShellFileTypes</I> to register its document types, this substring is the 
    human-readable name the shell displays in property sheets.
    <P></P></LI>
</UL>

<P>You don't have to supply all seven substrings; you can 
omit individual substrings by following a &quot;\n&quot; separator character 
with another &quot;\n,&quot; and you can omit trailing null substrings 
altogether. If you build an application with AppWizard, AppWizard creates the 
document string for you using information entered in the Advanced Options dialog 
box that's displayed when you click the Advanced button in AppWizard's Step 4 
dialog box. The resource statements for a typical SDI document string look like 
this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
STRINGTABLE
BEGIN
    IDR_MAINFRAME &quot;Microsoft Draw\n\n\nDraw Files(*.drw)\n.drw\n
        Draw.Document\nMicrosoft Draw Document&quot;
END
</PRE>
</td></tr></table>
</P>

<P>STRINGTABLE creates a string table resource (a resource 
consisting of one or more text strings, each identifiable by a unique resource 
ID) just as DIALOG creates a dialog resource and MENU creates a menu resource. 
When this application is started with an empty document, its frame window will 
have the title &quot;Untitled - Microsoft Draw.&quot; The default file name 
extension for documents saved by this application is &quot;.drw,&quot; and 
&quot;Draw Files (*.drw)&quot; will be one of the file type choices listed in 
the Open and Save As dialog boxes.</P>

<p>Should the need ever arise, you can retrieve individual 
substrings from a document string with MFC's 
<I>CDocTemplate::GetDocString</I> function. For example, the statements</p>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
CString strDefExt;
pDocTemplate-&gt;GetDocString (strDefExt, CDocTemplate::filterExt);
</PRE>
</td></tr></table>
</P>

<P>copy the document's default file name extension to the 
<I>CString</I> variable named <I>strDefExt</I>.</P>

<A NAME="279"><H2>Registering Document Types with the Operating System 
Shell</H2></A>

<P>In Windows, you can double-click a document icon or 
right-click it and select Open from the context menu to open the document along 
with the application that created it. In addition, you can print a document by 
selecting Print from its context menu or dragging the document icon and dropping 
it over a printer icon.</P>
<P>For these operations to work, an application must 
register its document types with the operating system shell, which involves 
writing a series of entries to the HKEY_CLASSES_ROOT branch of the registry that 
identify each document type's file name extension and the commands used to open 
and print files of that type. Some applications perform this registration by 
supplying a REG file the user can merge into the registry or by writing the 
necessary entries into the registry programmatically with <I>::RegCreateKey</I>, <I>::RegSetValue</I>, and other 
Win32 registry functions. An MFC application, however, can make one simple 
function call and register every document type it supports. Calling 
<I>CWinApp::RegisterShellFileTypes</I> and passing in a TRUE 
parameter after calling <I>AddDocTemplate</I> forges 
critical links between the application, the documents it creates, and the 
operating system shell. When it creates a document/view application, AppWizard 
automatically includes a call to 
<I>RegisterShellFileTypes</I> in the application class's 
<I>InitInstance</I> function.</P>

<P>A related <I>CWinApp</I> function 
named 
<I>EnableShellOpen</I> adds a nifty feature to MDI 
document/view applications. If an MDI application registers its document type(s) 
with <I>RegisterShellFileTypes</I> and 
<I>EnableShellOpen</I> and the user double-clicks a document icon while the 
application is running, the shell doesn't automatically start a second instance 
of the application; first, it uses Dynamic Data Exchange (DDE) to send an 
&quot;open&quot; command to the existing instance and passes along the 
document's file name. A DDE handler built into MFC's 
<I>CDocManager</I> class responds by calling 
<I>OnOpenDocument</I> to open the document. Thus, the document appears in a 
new window inside the top-level MDI frame, just as if it had been opened with 
the application's File-Open command. Similar DDE commands allow running 
application instances to fulfill print requests placed through the operating 
system shell.</P>

<A NAME="280"><H2>Command Routing</H2></A>

<P>One of the most remarkable features of the document/view 
architecture is that an application can handle command messages<I> </I>almost anywhere. 
<I>Command messages</I> is 
MFC's term for the WM_COMMAND messages that are generated when items are 
selected from menus, keyboard accelerators are pressed, and toolbar buttons are 
clicked. The frame window is the physical recipient of most command messages, 
but command messages can be handled in the view class, the document class, or 
even the application class by simply including entries for the messages you want 
to handle in the class's message map. Command routing lets you put command 
handlers where it makes the most sense to put them rather than relegate them all 
to the frame window class. Update commands for menu items, toolbar buttons, and 
other user interface objects are also subject to command routing, so you can put 
ON_UPDATE_COMMAND_UI handlers in nonframe window classes as well.</P>
<P>The mechanism that makes command routing work lies deep 
within the bowels of MFC. When a frame window receives a WM_COMMAND message, it 
calls the virtual <I>OnCmdMsg</I> function featured in all 
<I>CCmdTarget</I>-derived classes to begin the routing 
process. The 
<I>CFrameWnd</I> implementation of <I>OnCmdMsg</I> looks like this:</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL CFrameWnd::OnCmdMsg(...)
{
    // Pump through current view FIRST.
    CView* pView = GetActiveView();
    if (pView != NULL &amp;&amp; pView-&gt;OnCmdMsg(...))
        return TRUE;

    // Then pump through frame.
    if (CWnd::OnCmdMsg(...))
        return TRUE;

    // Last but not least, pump through application.
    CWinApp* pApp = AfxGetApp();
    if (pApp != NULL &amp;&amp; pApp-&gt;OnCmdMsg(...))
        return TRUE;

    return FALSE;
}
</PRE>
</td></tr></table>
</P>

<P><I>CFrameWnd::OnCmdMsg</I> first 
routes the message to the active view by calling the view's <I>OnCmdMsg</I> function. If 
<I>pView-&gt;OnCmdMsg</I> 
returns 0, indicating that the view didn't process the message (that is, that 
the view's message map doesn't contain an entry for this particular message), 
the frame window tries to handle the message itself by calling <I>CWnd::OnCmdMsg</I>. If that, too, fails, the frame window then tries the 
application object. Ultimately, if none of the objects processes the message, <I>CFrameWnd::OnCmdMsg</I> returns FALSE and the framework 
passes the message to <I>::DefWindowProc</I> for default 
processing.</P>
<P>This explains how a command message received by a frame 
window gets routed to the active view and the application object, but what about 
the document object? When <I>CFrameWnd::OnCmdMsg</I> calls 
the active view's 
<I>OnCmdMsg</I> function, the view first 
tries to handle the message itself. If it doesn't have a handler for the 
message, the view calls the document's 
<I>OnCmdMsg</I> 
function. If the document can't handle the message, it passes it up the ladder 
to the document template. Figure 9-2 shows the path that a command message 
travels when it's delivered to an SDI frame window. The active view gets first 
crack at the message, followed by the document associated with that view, the 
document template, the frame window, and finally the application object. The 
routing stops if any object along the way processes the message, but it 
continues all the way up to 
<I>::DefWindowProc</I> if none 
of the objects' message maps contains an entry for the message. Routing is much 
the same for command messages delivered to MDI frame windows, with the framework 
making sure that all the relevant objects, including the child window frame that 
surrounds the active MDI view, get the opportunity to weigh in.</P>
<P>The value of command routing becomes apparent when you 
look at how a typical document/view application handles commands from menus, 
accelerators, and toolbar buttons. By convention, the File-New, File-Open, and 
File-Exit commands are mapped to the application object, where 
<I>CWinApp</I> provides <I>OnFileNew</I>, 
<I>OnFileOpen</I>, and <I>OnAppExit</I> 
command handlers for them. File-Save and File-Save As are normally handled by 
the document object, which provides default command handlers named <I>CDocument::OnFileSave</I> and 
<I>CDocument::OnFileSaveAs</I>. Commands to show and hide toolbars and status 
bars are handled by the frame window using 
<I>CFrameWnd</I> 
member functions, and most other commands are handled by either the document or 
the view.</P>
<P>An important point to keep in mind as you consider where 
to put your message handlers is that only command messages and user interface 
updates are subject to routing. Standard Windows messages such as WM_CHAR, 
WM_LBUTTONDOWN, WM_CREATE, and WM_SIZE must be handled by the window that 
receives the message. Mouse and keyboard messages generally go to the view, and 
most other messages go to the frame window. Document objects and application 
objects never receive noncommand messages.</P>

<P>
<A HREF="javascript:fullSize('F09mg02x.htm')"> <img src="images/F09mg02.JPG" width=404 height=328 border=0 ALT="Click to view at full size."></A>
</P><p>
<!-- CAPTION --><B>Figure 9-2.</B> <I>Routing of command 
messages sent to an SDI frame window.</I><!-- /CAPTION --> 
</p>

<A NAME="281"><H2>Predefined Command IDs and Command Handlers</H2></A>

<P>When you write a document/view application, you 
typically don't write the handlers for all the menu commands yourself. 
<I>CWinApp</I>, <I>CDocument</I>, <I>CFrameWnd</I>, and other MFC classes provide default 
handlers for common menu commands such as File-Open and File-Save. In addition, 
the framework provides an assortment of standard menu item command IDs, such as 
ID_FILE_OPEN and ID_FILE_SAVE, many of which are &quot;prewired&quot; into the 
message maps of classes that use them.</P>
<P>The table below lists the most commonly used predefined 
command IDs and their associated command handlers. The &quot;Prewired?&quot; 
column indicates whether the handler is called automatically (Yes) or called 
only if a corresponding entry is added to the class's message map (No). You 
enable a prewired handler by assigning the corresponding ID to a menu item; a 
handler that isn't prewired is enabled only if you link the menu item ID to the 
function with a message-map entry. For example, you'll find default 
implementations of the File-New and File-Open commands in <I>CWinApp</I>'s<I> OnFileNew</I> and 
<I>OnFileOpen</I> functions, but neither function is connected to the 
application unless you provide an ON_COMMAND message-map entry for it. <I>CWinApp::OnAppExit</I>, on the other hand, works all by 
itself and requires no message-map entry. All you have to do is assign the 
File-Exit menu item the ID ID_APP_EXIT, and 
<I>OnAppExit</I> will magically be called to end the application when the 
user selects Exit from the File menu. Why? Because 
<I>CWinApp</I>'s message map contains an</P>

<P>
<table valign = "top" cellpadding=5 width="95%"><tr><td>
<PRE>
ON_COMMAND (ID_APP_EXIT, OnAppExit)
</PRE>
</td></tr></table>
</P>

<P>entry, and message maps, like other class members, are 
passed on by inheritance.</P>
<P><b>Predefined Command IDs and 
Command Handlers</b></P>

<P>
<table valign = "top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Command 
            ID</I></th>
<th valign="top"><I>Menu 
            Item</I></th>
<th valign="top"><I>Default 
            Handler</I></th>
<th valign="top"><I>Prewired?</I></th>
</tr>
<tr>
<td colspan="4" valign="top"><B>File menu</B></td>
</tr>
<tr>
<td valign="top">ID_FILE_NEW</td>
<td valign="top">New</td>
<td valign="top"><I>CWinApp::OnFileNew</I></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">ID_FILE_OPEN</td>
<td valign="top">Open</td>
<td valign="top"><I>CWinApp::OnFileOpen</I></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">ID_FILE_SAVE</td>
<td valign="top">Save</td>
<td valign="top"><I>CDocument::OnFileSave</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_FILE_SAVE_AS</td>
<td valign="top">Save As</td>
<td valign="top"><I>CDocument::OnFileSaveAs</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_FILE_PAGE_SETUP</td>
<td valign="top">Page Setup</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_FILE_PRINT_SETUP</td>
<td valign="top">Print Setup</td>
<td valign="top"><I>CWinApp::OnFilePrintSetup</I></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">ID_FILE_PRINT</td>
<td valign="top">Print</td>
<td valign="top"><I>CView::OnFilePrint</I></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">ID_FILE_PRINT_PREVIEW</td>
<td valign="top">Print Preview</td>
<td valign="top"><I>CView::OnFilePrintPreview</I></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">ID_FILE_SEND_MAIL </td>
<td valign="top">Send Mail</td>
<td valign="top"><I>CDocument::OnFileSendMail</I></td>
<td valign="top">No</td>
</tr>
<tr>
<td valign="top">ID_FILE_MRU_FILE1_ </td>
<td valign="top">N/A</td>
<td valign="top"><I>CWinApp::OnOpenRecentFile</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_FILE_MRU_FILE16</td>
<td valign="top"> </td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>
<tr>
<td valign="top">ID_APP_EXIT </td>
<td valign="top">Exit</td>
<td valign="top"><I>CWinApp::OnAppExit</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td colspan="4" valign="top"><B>Edit menu</B></td>
</tr>
<tr>
<td valign="top">ID_EDIT_CLEAR</td>
<td valign="top">Clear</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_CLEAR_ALL </td>
<td valign="top">Clear All</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_CUT </td>
<td valign="top">Cut</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_COPY</td>
<td valign="top">Copy</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_PASTE</td>
<td valign="top">Paste</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_PASTE_LINK</td>
<td valign="top">Paste Link</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_PASTE_SPECIAL</td>
<td valign="top">Paste Special</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_FIND</td>
<td valign="top">Find</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_REPLACE </td>
<td valign="top">Replace</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_UNDO</td>
<td valign="top">Undo</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_REDO</td>
<td valign="top">Redo</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_REPEAT</td>
<td valign="top">Repeat</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td valign="top">ID_EDIT_SELECT_ALL</td>
<td valign="top">SelectAll</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
<tr>
<td colspan="4" valign="top"><B>View menu</B></td>
</tr>
<tr>
<td valign="top">ID_VIEW_TOOLBAR</td>
<td valign="top">Toolbar</td>
<td valign="top"><I>CFrameWnd::OnBarCheck</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_VIEW_STATUS_BAR</td>
<td valign="top">Status Bar</td>
<td valign="top"><I>CFrameWnd::OnBarCheck</I> </td>
<td valign="top">Yes</td>
</tr>
<tr>
<td colspan="4" valign="top"><B>Window menu (MDI applications only)</B></td>
</tr>
<tr>
<td valign="top">ID_WINDOW_NEW</td>
<td valign="top">New Window </td>
<td valign="top"><I>CMDIFrameWnd::OnWindowNew</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_WINDOW_ARRANGE</td>
<td valign="top">Arrange All</td>
<td valign="top"><I>CMDIFrameWnd::OnMDIWindowCmd</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_WINDOW_CASCADE</td>
<td valign="top">Cascade</td>
<td valign="top"><I>CMDIFrameWnd::OnMDIWindowCmd</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_WINDOW_TILE_HORZ</td>
<td valign="top">Tile Horizontal</td>
<td valign="top"><I>CMDIFrameWnd::OnMDIWindowCmd</I></td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">ID_WINDOW_TILE_VERT</td>
<td valign="top">Tile Vertical</td>
<td valign="top"><I>CMDIFrameWnd::OnMDIWindowCmd</I></td>
<td valign="top"> Yes</td>
</tr>
<tr>
<td colspan="4" valign="top"><B>Help menu</B></td>
</tr>
<tr>
<td valign="top">ID_APP_ABOUT</td>
<td valign="top">About AppName</td>
<td valign="top">None</td>
<td valign="top">N/A</td>
</tr>
</table>
</P>
             
<P>MFC also provides update handlers for some commands, 
including these:</P>
<UL>
<P><LI><I>CFrameWnd::OnUpdateControlBarMenu</I> for the ID_VIEW_TOOLBAR and 
    ID_VIEW_STATUS_BAR commands
    <P></P>
<P></P><LI><I>CMDIFrameWnd::OnUpdateMDIWindowCmd</I> for the ID_WINDOW- _ARRANGE, 
    ID_WINDOW_CASCADE, ID_WINDOW_TILE_HORZ, ID- _WINDOW_TILE_VERT, and 
    ID_WINDOW_NEW commands
    <P></P>
<P></P><LI><I>CDocument::OnUpdateFileSendMail</I> for the ID_FILE_SEND_MAIL command
    <P></P></LI>
</UL>
<P>MFC's <I>CEditView</I> and <I>CRichEditView</I> classes include command handlers for some 
of the items in the Edit menu, but other views must provide their own.</P>
<P>You don't have to use the predefined command IDs or 
command handlers the framework provides. You can always strike out on your own 
and define custom command IDs, perhaps supplying message map entries to 
correlate your command IDs with default command handlers. You can even replace 
the default command handlers with handlers of your own. In short, you can use as 
much or as little of the framework's support as you want to. But the more you 
lean on the framework, the less code you'll have to write 
yourself.</P>

</BODY>
</HTML>




