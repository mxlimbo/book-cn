<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Image Lists and ComboBoxEx Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16c.htm", "ch16e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="508"><H1>Image Lists and ComboBoxEx Controls</H1></A>

<P>Chapter 10's DriveTree and WinDir programs used image lists to provide 
iconlike images to a tree view and a list view. At the time, I didn't say much about image 
lists other than that they hold collections of bitmapped images and that MFC wraps 
them with the class <I>CImageList</I>. As it turns out, image lists are extraordinarily useful 
not only for supplying images to other controls, but also for blitting bitmaps with 
special effects such as transparency and blending. We'll examine these and other features 
of image lists in the next section.</p>

<p>When Internet Explorer 3.0 or later is installed, it replaces Comctl32.dll with 
a newer version that includes enhanced versions of the existing controls as well as 
several new common control types. One of those new control types is the extended 
combo box control, better known as the ComboBoxEx control. A ComboBoxEx control 
differs from a standard combo box control in several important respects, most 
notably in the fact that it can display images next to each item. Not surprisingly, the 
images come from an image list. You can combine image lists and ComboBoxEx controls 
to create drop-down lists containing both graphics and text.</p>

<p>In the sections that follow, I'll use a broad brush to paint a picture of image 
lists and ComboBoxEx controls and introduce the fundamental principles involved 
in programming them. Then you'll see just how powerful image lists and 
ComboBoxEx controls can be by developing a combo box that depicts path names visually.</p>

<A NAME="509"><H2>Image Lists</H2></A>

<P>An image list is a collection of identically sized bitmap images joined together to 
form one logical unit. MFC's <I>CImageList</I> class provides functions for creating image 
lists, adding and deleting images, drawing images on the screen, writing image lists to 
an archive and reading them back, and more. Image lists are useful in and of 
themselves because many of the functions that operate on them have no direct counterparts 
elsewhere in Windows. But image lists were added to the operating system in the 
first place so that bitmaps could be grouped and passed as a unit to other common 
controls. When you supply images to a tree view control, for example, you don't pass it 
an array of <I>CBitmap</I>s; you pass it a handle to an image list (an HIMAGELIST) or a 
pointer to a <I>CImageList</I> object. Individual images are then referenced with 0-based indexes.</p>

<p>The best way to picture an image list is to think of a filmstrip with images 
laid horizontally from end to end. The leftmost image is image number 0, the one to 
its right is image number 1, and so on. The images can be any height and width, 
but they must all be the same height and width.</p>

<p>MFC provides three ways to create an image list. You can create an empty 
image list and add images to it with 
<I>CImageList::Add</I>; you can create an initialized 
image list from an existing bitmap containing an array of images; or you can create 
an initialized image list by merging images from existing image lists. 
<I>CImageList::Create</I> is overloaded to support all three creation methods. The second (and probably 
the most common) of these methods is illustrated in the following example. 
Suppose IDB_BITMAP is the resource ID of a bitmap that contains five images, each 
measuring 18 pixels wide and 16 pixels high. The bitmap itself is 90 pixels wide (5 times 
18) and 16 pixels high. These statements create an image list from the bitmap:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
CImageList il;
il.Create (IDB_BITMAP, 18, 1, CLR_NONE);
</pre></td></tr></table></p>

<P>The first parameter passed to <I>Create</I> is the bitmap's resource ID. You can also pass 
a string resource ID for this parameter. The second parameter is the width, in pixels, 
of the individual images. Windows determines how many images to add to the list 
by dividing the bitmap width by the image width. The third parameter is the 
<I>grow size</I>. Image lists are sized dynamically just as arrays created from MFC collection 
classes are, and the grow size tells the image list how many additional images to make 
room for when more memory must be allocated to accommodate new images. The 
final parameter&#8212;CLR_NONE&#8212;creates an 
<I>unmasked</I> image list. Unmasked images are ordinary bitmaps that are blitted directly to the destination when they're drawn 
on the screen.</p>

<p>Passing <I>CImageList::Create</I> a COLORREF value instead of CLR_NONE creates 
a <I>masked</I> image list. In addition to storing color information for a masked 
image, Windows also stores a monochrome bit mask that allows it to distinguish 
between foreground and background pixels. The COLORREF value passed to 
<I>CImageList::Create</I> specifies the background color, and any pixel set to that color is assumed to be 
a background pixel. What's cool about masked images is the fact that you can 
call <I>CImageList::SetBkColor</I> before drawing from an image list and set the 
background color to any color you like. The background color in the original bitmap might 
be magenta, but if you set the background color to red and draw the image, all 
the magenta pixels will come out red. What's 
<I>really</I> cool is that you can pass 
<I>CImageList::SetBkColor</I> a CLR_NONE parameter and background pixels won't be drawn 
at all. Consequently, image lists provide a simple means of drawing bitmaps with 
transparent pixels. Remember the 
<I>DrawTransparent</I> function we developed in 
Chapter 15 for drawing nonrectangular bitmaps? An image list lets you do the same thing 
with less code. The image list method is faster, too, because the masks don't have to 
be generated anew each time the image is blitted to the screen.</p>

<p><I>CImageList::Draw </I>draws images on the screen. The following statement 
draws the third image in the list (image number 2) to the screen DC referenced by the 
<I>CDC</I> pointer <I>pDC</I>:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
il.Draw (pDC, 2, point, ILD_NORMAL);
</pre></td></tr></table></p>

<P><I>point</I> is a POINT structure containing the 
<I>x</I> and <I>y</I> coordinates of the point in 
the destination DC where the upper left corner of the image will be drawn. 
ILD_NORMAL is a flag that tells the <I>Draw</I> function to draw a masked image using the current 
background color. (This flag has no effect on unmasked images.) If you'd like 
background pixels to be transparent regardless of what the current background color happens 
to be, you can use an ILD_TRANSPARENT flag instead:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
il.Draw (pDC, 2, point, ILD_TRANSPARENT);
</pre></td></tr></table></p>

<P>For some truly interesting effects, try drawing a masked image with an 
ILD_BLEND25 or ILD_BLEND50 flag to blend in the system highlight color 
(COLOR_HIGHLIGHT). <I>CImageList::Draw</I> also accepts ILD_SELECTED and ILD_FOCUS flags, but 
they're nothing more than ILD_BLEND50 and ILD_BLEND25 in disguise. To see blending 
at work, select an icon on the Windows desktop. To show the icon in a selected 
state, the system dithers the icon with the system highlight color by drawing it with 
an ILD_BLEND50 flag.</p>

<p>An aside: Drawing with an ILD_TRANSPARENT flag or with the background 
color set to CLR_NONE is always a little slower than drawing an unmasked image. If 
an image contains transparent pixels but is being blitted to a solid background, 
use <I>CImageList::SetBkColor</I> to set the image list's background color to the color of 
the solid background and then call 
<I>CImageList::Draw</I> with an ILD_NORMAL flag. 
You'll improve performance and still get those transparent pixels you wanted.</p>

<A NAME="510"><H2>ComboBoxEx Controls</H2></A>

<P>ComboBoxEx controls exist to simplify the task of including images as well as text 
in combo boxes. Assuming that <I>m_wndCBEx</I> is a 
<I>ComboBoxEx</I> data member of a dialog class, that 
<I>m_wndCBEx</I> is mapped to a ComboBoxEx control in the dialog, 
and that <I>m_il</I> is an instance of 
<I>CImageList</I>, the following statements initialize the 
control with items labeled &quot;Item 1&quot; through &quot;Item 5.&quot; Next to each item appears a folder 
image extracted from the image list. The image list, in turn, acquires the image from the 
bitmap resource IDB_IMAGE:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_il.Create (IDB_IMAGE, 16, 1, RGB (255, 0, 255));
m_wndCBEx.SetImageList (&amp;m_il);

for (int i=0; i&lt;5; i++) {
    CString string;
    string.Format (_T (&quot;Item %d&quot;), i);

    COMBOBOXEXITEM cbei;
    cbei.mask = CBEIF_IMAGE &#166; CBEIF_SELECTEDIMAGE &#166; CBEIF_TEXT;
    cbei.iItem = i;
    cbei.pszText = (LPTSTR) (LPCTSTR) string;
    cbei.iImage = 0;
    cbei.iSelectedImage = 0;

    m_wndCBEx.InsertItem (&amp;cbei);
}
</pre></td></tr></table></p>

<P>The key functions used in this sample include 
<I>CComboBoxEx::SetImageList</I>, which associates an image list with a ComboBoxEx control, and 
<I>CComboBoxEx::InsertItem</I>, which adds an item to the control. 
<I>InsertItem</I> accepts a pointer to a COMBOBOXEXITEM structure containing pertinent information about the item, including 
the item's text and the 0-based indexes of the images (if any) associated with the 
item. <I>iImage</I> identifies the image displayed next to the item when the item isn't 
selected, and <I>iSelectedImage</I> identifies the image that's displayed when the item is 
selected. Figure 16-7 shows the resulting control with its drop-down list displayed.</p>

<p>
<img src="images/F16mg07.GIF" width=262 height=137 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-7.</B> <I>A ComboBoxEx control containing both text and images.</I><!-- /CAPTION -->
</p>

<p>You can indent an item in a ComboBoxEx control by specifying a 
nonzero number of &quot;spaces&quot; in COMBOBOXEXITEM's 
<I>iIndent</I> field. Each space equals 10 pixels. The following example initializes a ComboBoxEx control that's identical 
to the one in the preceding example except for the fact that each successive item 
is indented one space more than the previous item:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_il.Create (IDB_IMAGE, 16, 1, RGB (255, 0, 255));
m_wndCBEx.SetImageList (&amp;m_il);

for (int i=0; i&lt;5; i++) {
    CString string;
    string.Format (_T (&quot;Item %d&quot;), i);

    COMBOBOXEXITEM cbei;
    cbei.mask = CBEIF_IMAGE &#166; CBEIF_SELECTEDIMAGE &#166; CBEIF_TEXT &#166;
        CBEIF_INDENT;
    cbei.iItem = i;
    cbei.pszText = (LPTSTR) (LPCTSTR) string;
    cbei.iImage = 0;
    cbei.iSelectedImage = 0;
    cbei.iIndent = i;

    m_wndCBEx.InsertItem (&amp;cbei);
}
</pre></td></tr></table></p>

<P>The result is shown in Figure 16-8. The ability to indent items an arbitrary number 
of spaces comes in handy when you use a ComboBoxEx control to display items 
that share a hierarchical relationship, such as the names of the individual directories 
comprising a path name.</p>

<p>
<img src="images/F16mg08.GIF" width=262 height=137 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-8.</B> <I>A ComboBoxEx control containing indented items.</I><!-- /CAPTION -->
</p>

<p><I>InsertItem</I> is one of four <I>CComboBoxEx</I> member functions that you can use 
to manipulate items in a ComboBoxEx control. The others are 
<I>DeleteItem</I>, which removes an item; 
<I>GetItem</I>, which copies the information about an item to a 
COMBOBOXEXITEM structure; and <I>SetItem</I>, which modifies an item using information supplied in 
a COMBOBOXEXITEM structure.</p>

<p><I>CComboBoxEx</I> has just a handful of member functions of its own. 
Common operations such as selecting an item or retrieving the index of the selected item 
are performed with <I>CComboBox</I> member functions. Because 
<I>CComboBoxEx</I> derives from <I>CComboBox</I>, you can call 
<I>CComboBox</I> functions on a <I>CComboBoxEx</I>. For 
example, the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndCBEx.SetCurSel (nIndex);
</pre></td></tr></table></p>

<P>selects the item whose 0-based index is 
<I>nIndex</I>, and the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
int nIndex = m_wndCBEx.GetCurSel ();
</pre></td></tr></table></p>

<P>sets <I>nIndex</I> equal to the index of the currently selected item.</p>

<p>Like conventional combo boxes, ComboBoxEx controls come in three 
varieties: simple, drop-down, and drop-down list. You pick the type by choosing one of 
the three primary combo box styles: CBS_SIMPLE, CBS_DROPDOWN, or 
CBS_DROPDOWNLIST. Other CBS styles, such as CBS_SORT, don't apply to ComboBoxEx 
controls and are ignored if you use them. ComboBoxEx controls do support a few 
styles of their own, however. These styles are known as 
<I>extended styles</I> and can't be applied in a dialog template or a 
<I>Create</I> statement; instead, you must apply them 
programmatically with 
<I>CComboBoxEx::SetExtendedStyle</I> after the control is created. 
The following table lists the extended styles that are supported on all platforms. To 
configure the control to treat text as case-sensitive, for example, you would write:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndCBEx.SetExtendedStyle (CBES_EX_CASESENSITIVE, 
    CBES_EX_CASESENSITIVE);
</pre></td></tr></table></p>

<P>The second parameter you pass to 
<I>SetExtendedStyle</I> specifies the style or styles 
that you want to apply. The first parameter is a style mask that you can use to 
prevent other styles from being affected, too. Passing zero in parameter 1 effectively 
eliminates the mask.</p>


<p><b>ComboBoxEx Control Extended Styles</b></p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><i>Style</i></th>
<th valign="top"><i>Description</i></th>
</tr><tr>
<td valign="top">CBES_EX_CASESENSITIVE</td>
<td valign="top">Makes string searches case-sensitive</td>
</tr><tr>
<td valign="top">CBES_EX_NOEDITIMAGE</td>
<td valign="top">Suppresses item images</td>
</tr><tr>
<td valign="top">CBES_EX_NOEDITIMAGEINDENT</td>
<td valign="top">Suppresses item images and left-indents each item to remove the space normally reserved for the item image</td>
</tr><tr>
<td valign="top">CBES_EX_NOSIZELIMIT</td>
<td valign="top">Allows the ComboBoxEx control's height to be less than the height of the combo box contained inside the control</td>
</tr>
</table></p>

<P>A ComboBoxEx control sends the same CBN notifications to its parent that 
a conventional combo box sends. It also supports the notifications of its own that 
are listed in the following table.</p>


<p><b>ComboBoxEx Notifications</b></p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><i>Notification</i></th>
<th valign="top"><i>Sent When</i></th>
</tr><tr>
<td valign="top">CBEN_BEGINEDIT</td>
<td valign="top">The user displays the control's drop-down list or clicks the edit control to begin editing.</td>
</tr><tr>
<td valign="top">CBEN_ENDEDIT</td>
<td valign="top">The user selects an item from the control's list box or edits the control's text directly.</td>
</tr><tr>
<td valign="top">CBEN_DRAGBEGIN</td>
<td valign="top">The user drags an item in the control to begin a drag-and-drop operation.</td>
</tr><tr>
<td valign="top">CBEN_INSERTITEM</td>
<td valign="top">An item is added to the control.</td>
</tr><tr>
<td valign="top">CBEN_DELETEITEM</td>
<td valign="top">An item is removed from the control.</td>
</tr><tr>
<td valign="top">CBEN_GETDISPINFO</td>
<td valign="top">The control needs additional information&#8212;a text string, an image, an indentation level, or some combination thereof&#8212;about an item before displaying that item.</td>
</tr><tr>
<td valign="top">NM_SETCURSOR</td>
<td valign="top">The control is about to set the cursor in response to a WM_SETCURSOR message.</td>
</tr></table></p>

<P>MFC applications use ON_NOTIFY macros to map CBEN notifications to 
handling functions in the parent's window class. CBEN_GETDISPINFO notifications 
are sent only if the <I>pszText</I> field of a COMBOBOXEXITEM structure passed to 
<I>InsertItem</I> contains LPSTR_TEXTCALLBACK, the 
<I>iImage</I> or <I>iSelectedImage</I> field 
contains I_IMAGECALLBACK, or the <I>iIndent</I> field contains I_INDENTCALLBACK. You can 
use these special values to create dynamic ComboBoxEx controls that supply text, 
images, and indentation levels on the fly rather than at the time the items are inserted.</p>

<A NAME="511"><H2>The PathList Application</H2></A>

<P>PathList, shown in Figure 16-9, is a dialog-based MFC application that uses a 
ComboBoxEx control to depict path names. The control is an instance of 
<I>CPathComboBox</I>, which I derived from 
<I>CComboBoxEx</I>. <I>CPathComboBox</I> has two public member 
functions: <I>SetPath</I> and <I>GetPath</I>. When passed a fully qualified path name, 
<I>SetPath</I> parses the path name and adds indented items representing the individual directories 
that make up the path. (<I>SetPath</I> checks the drive letter but doesn't validate the 
remainder of the path name.) <I>GetPath</I> returns a fully qualified path name that corresponds 
to the drive or directory that is currently selected in the control.</p>

<P>
<img src="images/F16mg09.GIF" width=378 height=274 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-9.</B> <I>The PathList window.</I><!-- /CAPTION -->
</p>

<P>The source code for PathList's dialog and ComboBoxEx classes is shown in 
Figure 16-10. PathList's dialog window does very little with the ComboBoxEx control 
other than host it. It calls <I>SetPath</I> with the path to the current directory when it starts 
up, and it displays the path name returned by 
<I>GetPath</I> when an item is selected. The 
control class <I>CPathComboBox</I> contains most of the interesting stuff, including the code 
that parses path names passed to <I>SetPath</I>, adds items to the control, removes the old 
items when the path name changes, and so on. Take the time to understand how it 
works and you'll be well on your way to understanding ComboBoxEx controls, too.</p>


<P><B>Figure 16-10.</B> <I>The PathList application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="512"><H3>PathListDlg.h</H3></A>
<pre>
// PathListDlg.h : header file
//

#if !defined(
    AFX_PATHLISTDLG_H__710413E6_AC66_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_PATHLISTDLG_H__710413E6_AC66_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CPathListDlg dialog

class CPathListDlg : public CDialog
{
// Construction
public:
    CPathListDlg(CWnd* pParent = NULL);    // standard constructor
// Dialog Data
    //{{AFX_DATA(CPathListDlg)
    enum { IDD = IDD_PATHLIST_DIALOG };
    CPathComboBox    m_wndCBEx;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPathListDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CPathListDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnSelEndOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_PATHLISTDLG_H__710413E6_AC66_11D2_8E53_006008A82731__INCLUDED_)
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="513"><H3>PathListDlg.cpp</H3></A>
<pre>
// PathListDlg.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;PathList.h&quot;
#include &quot;PathComboBox.h&quot;
#include &quot;PathListDlg.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CPathListDlg dialog

CPathListDlg::CPathListDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CPathListDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPathListDlg)
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
}

void CPathListDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPathListDlg)
    DDX_Control(pDX, IDC_CBEX, m_wndCBEx);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPathListDlg, CDialog)
    //{{AFX_MSG_MAP(CPathListDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_CBN_SELENDOK(IDC_CBEX, OnSelEndOK)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CPathListDlg message handlers

BOOL CPathListDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    SetIcon(m_hIcon, TRUE);
    SetIcon(m_hIcon, FALSE);
    
    //
    // Initialize the ComboBoxEx control.
    //
    TCHAR szPath[MAX_PATH];
    ::GetCurrentDirectory (sizeof (szPath) / sizeof (TCHAR), szPath);
    m_wndCBEx.SetPath (szPath);
    return TRUE;
}

void CPathListDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&amp;rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

HCURSOR CPathListDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CPathListDlg::OnSelEndOK() 
{
    //
    // Display the path just selected from the ComboBoxEx control.
    //
    MessageBox (m_wndCBEx.GetPath ());
}
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="514"><H3>PathComboBox.h</H3></A>
<pre>
#if !defined(
    AFX_PATHCOMBOBOX_H__710413F1_AC66_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_PATHCOMBOBOX_H__710413F1_AC66_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// PathComboBox.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CPathComboBox window

class CPathComboBox : public CComboBoxEx
{
// Construction
public:
    CPathComboBox();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPathComboBox)
    //}}AFX_VIRTUAL

// Implementation
public:
    CString GetPath();
    BOOL SetPath (LPCTSTR pszPath);
    virtual ~CPathComboBox();

    // Generated message map functions
protected:
    void GetSubstring (int&amp; nStart, CString&amp; string, CString&amp; result);
    int m_nIndexEnd;
    int m_nIndexStart;
    BOOL m_bFirstCall;
    CImageList m_il;
    //{{AFX_MSG(CPathComboBox)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_PATHCOMBOBOX_H__710413F1_AC66_11D2_8E53_006008A82731__INCLUDED_)
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="515"><H3>PathComboBox.cpp</H3></A>
<pre>
// PathComboBox.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;PathList.h&quot;
#include &quot;PathComboBox.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CPathComboBox

CPathComboBox::CPathComboBox()
{
    m_bFirstCall = TRUE;
    m_nIndexStart = -1;
    m_nIndexEnd = -1;
}

CPathComboBox::~CPathComboBox()
{
}

BEGIN_MESSAGE_MAP(CPathComboBox, CComboBoxEx)
    //{{AFX_MSG_MAP(CPathComboBox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CPathComboBox message handlers

BOOL CPathComboBox::SetPath(LPCTSTR pszPath)
{
    if (m_bFirstCall) {
        m_bFirstCall = FALSE;

        //
        // Add an image list containing drive and folder images.
        //
        m_il.Create (IDB_IMAGES, 16, 1, RGB (255, 0, 255));
        SetImageList (&amp;m_il);

        //
        // Add icons representing the drives on the host system.
        //
        int nPos = 0;
        int nCount = 0;
        CString string = _T (&quot;?:\\&quot;);

        DWORD dwDriveList = ::GetLogicalDrives ();

        while (dwDriveList) {
            if (dwDriveList &amp; 1) {
                string.SetAt (0, _T (`A') + nPos);
                CString strDrive = string.Left (2);
                UINT nType = ::GetDriveType (string);

                int nImage = 0;
                switch (nType) {

                case DRIVE_FIXED:
                    nImage = 0;
                    break;

                case DRIVE_REMOVABLE:
                    nImage = 1;
                    break;

                case DRIVE_CDROM:
                    nImage = 2;
                    break;

                case DRIVE_REMOTE:
                    nImage = 3;
                    break;
                }

                COMBOBOXEXITEM cbei;
                cbei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                cbei.iItem = nCount++;
                cbei.pszText = (LPTSTR) (LPCTSTR) strDrive;
                cbei.iImage = nImage;
                cbei.iSelectedImage = nImage;
                InsertItem (&amp;cbei);
            }
            dwDriveList &gt;&gt;= 1;
            nPos++;
        }
    }

    //
    // Find the item that corresponds to the drive specifier in pszPath.
    //
    CString strPath = pszPath;
    CString strDrive = strPath.Left (2);

    int nDriveIndex = FindStringExact (-1, strDrive);
    if (nDriveIndex == CB_ERR)
        return FALSE;

    //
    // Delete previously added folder items (if any).
    //
    if (m_nIndexStart != -1 &amp;&amp; m_nIndexEnd != -1) {
        ASSERT (m_nIndexEnd &gt;= m_nIndexStart);
        int nCount = m_nIndexEnd - m_nIndexStart + 1;
        for (int i=0; i&lt;nCount; i++)
            DeleteItem (m_nIndexStart);
        if (m_nIndexStart &lt; nDriveIndex)
            nDriveIndex -= nCount;
        m_nIndexStart = -1;
        m_nIndexEnd = -1;
    }

    //
    // Add items representing the directories in pszPath.
    //
    int nCount = 0;
    int nStringIndex = strPath.Find (_T (`\\'), 0);

    if (nStringIndex++ != -1) {
        CString strItem;
        GetSubstring (nStringIndex, strPath, strItem);

        while (!strItem.IsEmpty ()) {
            COMBOBOXEXITEM cbei;
            cbei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE |
                CBEIF_INDENT;
            cbei.iItem = nDriveIndex + ++nCount;
            cbei.pszText = (LPTSTR) (LPCTSTR) strItem;
            cbei.iImage = 4;
            cbei.iSelectedImage = 5;
            cbei.iIndent = nCount;
            InsertItem (&amp;cbei);

            GetSubstring (nStringIndex, strPath, strItem);
        }
    }

    //
    // Record the indexes of the items that were added, too.
    //
    if (nCount) {
        m_nIndexStart = nDriveIndex + 1;
        m_nIndexEnd = nDriveIndex + nCount;
    }

    //
    // Finish up by selecting the final item.
    //
    int nResult = SetCurSel (nDriveIndex + nCount);
    return TRUE;
}

void CPathComboBox::GetSubstring(int&amp; nStart, CString &amp;string,
    CString &amp;result)
{
    result = _T (&quot;&quot;);
    int nLen = string.GetLength ();
    if (nStart &gt;= nLen)
        return;

    int nEnd = string.Find (_T (`\\'), nStart);
    if (nEnd == -1) {
        result = string.Right (nLen - nStart);
        nStart = nLen;
    }
    else {
        result = string.Mid (nStart, nEnd - nStart);
        nStart = nEnd + 1;
    }
}

CString CPathComboBox::GetPath()
{
    //
    // Get the index of the selected item.
    //
    CString strResult;
    int nEnd = GetCurSel ();
    int nStart = nEnd + 1;

    //
    // Find the index of the &quot;root&quot; item.
    //
    COMBOBOXEXITEM cbei;
    do {
        cbei.mask = CBEIF_INDENT;
        cbei.iItem = &#8212;nStart;
        GetItem (&amp;cbei);
    } while (cbei.iIndent != 0);

    //
    // Build a path name by combining all the items from the root item to
    // the selected item.
    //
    for (int i=nStart; i&lt;=nEnd; i++) {
        TCHAR szItem[MAX_PATH];
        COMBOBOXEXITEM cbei;
        cbei.mask = CBEIF_TEXT;
        cbei.iItem = i;
        cbei.pszText = szItem;
        cbei.cchTextMax = sizeof (szItem) / sizeof (TCHAR);
        GetItem (&amp;cbei);
        strResult += szItem;
        strResult += _T (&quot;\\&quot;);
    }

    //
    // Strip the trailing backslash.
    //
    int nLen = strResult.GetLength ();
    strResult = strResult.Left (nLen - 1);
    return strResult;
}
</pre></td></tr></table></p>

</BODY>
</HTML>




