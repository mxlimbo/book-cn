<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Palettes</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch15a.htm", "ch15c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="448"><H1>Palettes</H1></A>

<P>Have you ever written a Windows application that makes generous use of color 
only to find that the output looks crummy on 16-color and 256-color video adapters? 
There's not a whole lot you can do about it when the adapter itself supports only 16 
colors, but you can do plenty to improve output on 256-color devices. The key to better 
color output is MFC's <I>CPalette</I> class. Before we get into the specifics of 
<I>CPalette</I>, let's briefly review how color information is encoded in Windows and what Windows does 
with the color information that you provide.</P>

<A NAME="449"><H2>How Windows Uses Color</H2></A>

<P>One of the benefits of a device-independent output model is that you can specify 
the colors an application uses without regard for the physical characteristics of the 
output device. When you pass a color to the Windows GDI, you pass a COLORREF 
value containing 8 bits each for red, green, and blue. The RGB macro combines 
individual red, green, and blue values into a single COLORREF. The statement</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
COLORREF clr = RGB (255, 0, 255);
</PRE>
</td></tr></table></P>

<P>creates a COLORREF value named <I>clr</I> that represents magenta&#8212;the color you get 
when you mix equal parts red and blue. Conversely, you can extract 8-bit red, green, 
and blue values from a COLORREF value with the 
<I>GetRValue</I>, <I>GetGValue</I>, and 
<I>GetBValue</I> macros. A number of GDI functions, including those that create pens and 
brushes, accept COLORREF values.</P>

<P>What the GDI does with the COLORREF values you pass it depends on 
several factors, including the color resolution of the video hardware and the context in 
which the colors are used. In the simplest and most desirable scenario, the video adapter 
is a 24-bits-per-pixel device and COLORREF values translate directly into colors on 
the screen. Video adapters that support 24-bit color, or 
<I>true color,</I> are becoming increasingly common, but Windows still runs on millions of PCs whose video adapters 
are limited to 4 or 8 bits per pixel. Typically, these devices are 
<I>palletized devices,</I> meaning that they support a wide range of colors but can display only a limited number 
of colors at one time. A standard VGA, for example, can display 262,144 different 
colors&#8212;6 bits each for red, green, and blue. However, a VGA running at a resolution 
of 640 by 480 pixels can display only 16 different colors at once because each pixel 
is limited to 4 bits of color information in the video buffer. The more common case is 
a video adapter that can display more than 16.7 million colors but can display only 
256 colors at once. The 256 colors that can be displayed are determined from RGB 
values that are programmed into the adapter's hardware palette.</P>

<P>Windows handles palletized devices by preprogramming a standard 
selection of colors into the adapter's hardware palette. A 256-color adapter is 
preprogrammed with the 20 so-called <I>static 
colors</I> shown in the following table. The four colors 
marked with asterisks are subject to change at the operating system's behest, so you 
shouldn't write code that depends on their presence.</P>

<P><b>Static Palette Colors</b></P>

<P>
<table width="95%" cellpadding="5">
<tr><th valign="TOP"><b><i>Color</i></b></th>
<th valign="TOP"><b><i>R</i></b></th>
<th valign="TOP"><b><i>G</i></b></th>
<th valign="TOP"><b><i>B</i></b></th>
<th valign="TOP"><b><i>Color</i></b></th>
<th valign="TOP"><b><i>R</i></b></th>
<th valign="TOP"><b><i>G</i></b></th>
<th valign="TOP"><b><i>B</i></b></th></tr>
<tr><td valign="TOP">Black</td>
<td valign="TOP">0</td>
<td valign="TOP">0</td>
<td valign="TOP">0</td>
<td valign="TOP">Cream*</td>
<td valign="TOP">255</td>
<td valign="TOP">251</td>
<td valign="TOP">240</td></tr>
<tr><td valign="TOP">Dark red</td>
<td valign="TOP">128</td>
<td valign="TOP">0</td>
<td valign="TOP">0</td>
<td valign="TOP">Intermediate gray*</td>
<td valign="TOP">160</td>
<td valign="TOP">160</td>
<td valign="TOP">164</td></tr>
<tr><td valign="TOP">Dark green</td>
<td valign="TOP">0</td>
<td valign="TOP">128</td>
<td valign="TOP">0</td>
<td valign="TOP">Medium gray</td>
<td valign="TOP">128</td>
<td valign="TOP">128</td>
<td valign="TOP">128</td></tr>
<tr><td valign="TOP">Dark yellow</td>
<td valign="TOP">128</td>
<td valign="TOP">128</td>
<td valign="TOP">0</td>
<td valign="TOP">Red</td>
<td valign="TOP">255</td>
<td valign="TOP">0</td>
<td valign="TOP">0</td></tr>
<tr><td valign="TOP">Dark blue</td>
<td valign="TOP">0</td>
<td valign="TOP">0</td>
<td valign="TOP">128</td>
<td valign="TOP">Green</td>
<td valign="TOP">0</td>
<td valign="TOP">255</td>
<td valign="TOP">0</td></tr>
<tr><td valign="TOP">Dark magenta</td>
<td valign="TOP">128</td>
<td valign="TOP">0</td>
<td valign="TOP">128</td>
<td valign="TOP">Yellow</td>
<td valign="TOP">255</td>
<td valign="TOP">255</td>
<td valign="TOP">0</td></tr>
<tr><td valign="TOP">Dark cyan</td>
<td valign="TOP">0</td>
<td valign="TOP">128</td>
<td valign="TOP">128</td>
<td valign="TOP">Blue</td>
<td valign="TOP">0</td>
<td valign="TOP">0</td>
<td valign="TOP">255</td></tr>
<tr><td valign="TOP">Light gray</td>
<td valign="TOP">192</td>
<td valign="TOP">192</td>
<td valign="TOP">192</td>
<td valign="TOP">Magenta</td>
<td valign="TOP">255</td>
<td valign="TOP">0</td>
<td valign="TOP">255</td></tr>
<tr><td valign="TOP">Money green*</td>
<td valign="TOP">192</td>
<td valign="TOP">220</td>
<td valign="TOP">192</td>
<td valign="TOP">Cyan</td>
<td valign="TOP">0</td>
<td valign="TOP">255</td>
<td valign="TOP">255</td></tr>
<tr><td valign="TOP">Sky blue*</td>
<td valign="TOP">166</td>
<td valign="TOP">202</td>
<td valign="TOP">240</td>
<td valign="TOP">White</td>
<td valign="TOP">255</td>
<td valign="TOP">255</td>
<td valign="TOP">255</td></tr></table></P>

<P>*Denotes default colors that are subject to change.</P>

<P>When you draw on a palletized device, the GDI maps each COLORREF 
value to the nearest static color using a simple color-matching algorithm. If you pass 
a COLORREF value to a function that creates a pen, Windows assigns the pen the 
nearest static color. If you pass a COLOREF value to a function that creates a brush and 
there isn't a matching static color, Windows dithers the brush color using static 
colors. Because the static colors include a diverse (if limited) assortment of hues, 
Windows can do a reasonable job of simulating any COLORREF value you throw at it. A 
picture painted with 100 different shades of red won't come out very well because 
Windows will simulate all 100 shades with just two reds. But you're guaranteed that 
red won't undergo a wholesale transformation to blue, green, or some other color, 
because the static colors are always there and are always available.</P>

<P>For many applications, the primitive form of color mapping that Windows 
performs using static colors is good enough. But for others, accurate color output is a 
foremost concern and 20 colors just won't get the job done. In a single-tasking 
environment such as MS-DOS, a program running on a 256-color adapter can program 
the hardware palette itself and use any 256 colors it wants. In Windows, applications can't be 
allowed to program the hardware palette directly because the video adapter is a 
shared resource. So how do you take advantage of the 236 colors left unused in a 
256-color adapter after Windows adds the 20 static colors? The answer lies in a GDI object 
known as a logical palette.</P>

<A NAME="450"><H2>Logical Palettes and the <I>CPalette</I> Class</H2></A>
<P>A <I>logical palette</I> is a table of RGB color values that tells Windows what colors 
an application would like to display. A related term, 
<I>system palette</I>, refers to the adapter's hardware color palette. At an application's request, the palette manager built 
into Windows will transfer the colors in a logical palette to unused entries in the 
system palette&#8212;a process known as <I>realizing a 
palette</I>&#8212;so that the application can take 
full advantage of the video adapter's color capabilities. With the help of a logical 
palette, an application running on a 256-color video adapter can use the 20 static colors 
plus an additional 236 colors of its choosing. And because all requests to realize a 
palette go through the GDI, the palette manager can serve as an arbitrator between 
programs with conflicting color needs and thus ensure that the system palette is 
used cooperatively.</P>

<P>What happens if two or more applications realize logical palettes and the 
sum total of the colors they request is more than the 236 additional colors a 256-color 
video adapter can handle? The palette manager assigns color priorities based on 
each window's position in the <I>z</I>-order. The window at the top of the 
<I>z</I>-order receives top priority, the window that's second gets the next highest priority, and so on. If 
the foreground window realizes a palette of 200 colors, all 200 get mapped to the 
system palette. If a background window then realizes a palette of, say, 100 colors, 36 
get programmed into the unused slots remaining in the system palette and 64 get 
mapped to the nearest matching colors. That's the worst case. Unless directed to do 
otherwise, the palette manager avoids duplicating entries in the system palette. 
Therefore, if 4 of the foreground window's colors and 10 of the background window's 
colors match static colors, and if another 10 of the background window's colors 
match nonstatic colors in the foreground window, the background window ends up 
getting 60 exact matches in the system palette.</P>

<P>You can see the palette manager at work by switching Windows to 
256-color mode, launching two instances of the Windows Paint applet, loading a different 
256-color bitmap in each, and clicking back and forth between the two. The bitmap 
in the foreground will always look the best because it gets first crack at the system 
palette. The bitmap in the background gets what's left over. If both bitmaps use 
similar colors, the background image won't look too bad. But if the colors are vastly 
different&#8212;for example, if bitmap A contains lots of bright, vibrant colors whereas bitmap B 
uses primarily earth tones&#8212;the image in the background window might be so 
color-corrupted that it's hardly recognizable. The palette manager's role in the process is 
to try to satisfy the needs of both programs. When those needs conflict, the 
foreground window receives priority over all others so that the application the user is 
working with looks the best.</P>

<A NAME="451"><H2>Creating a Logical Palette</H2></A>

<P>Writing an application that uses a logical palette isn't difficult. In MFC, logical 
palettes are represented by the <I>CPalette</I> class and are created and initialized with 
<I>CPalette</I> member functions. Once a logical palette is created, it can be selected into a 
device context and realized with <I>CDC</I> member functions.</P>

<P><I>CPalette</I> provides two member functions for palette creation. 
<I>CreatePalette</I> creates a custom palette from RGB values you specify; 
<I>CreateHalftonePalette</I> creates a &quot;halftone&quot; palette containing a generic and fairly uniform distribution of colors. 
Custom palettes give better results when an image contains few distinctly different 
colors but many subtle variations in tone. Halftone palettes work well for images 
containing a wide range of colors. The statements</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CPalette palette;
palette.CreateHalftonePalette (pDC);
</PRE>
</td></tr></table></P>

<P>create a halftone palette tailored to the device context pointed to by 
<I>pDC</I>. If the device context corresponds to a 256-color device, the halftone palette will also 
contain 256 colors. Twenty of the colors will match the static colors; the other 236 will 
expand the selection of colors available by adding subtler shades of red, green, 
and blue and mixtures of these primary colors. Specifically, a 256-color halftone 
palette includes all the colors in a 6-by-6-by-6-color cube (colors composed of six 
shades each of red, green, and blue), plus an array of grays for gray-scale imaging and 
other colors handpicked by the GDI. Passing a NULL DC handle to 
<I>CreateHalftonePalette</I> creates a 256-color halftone palette independent of the characteristics of the 
output device. However, because 
<I>CPalette::CreateHalftonePalette</I> mistakenly asserts in 
debug builds if passed a NULL DC handle, you must drop down to the Windows API 
to take advantage of this feature:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CPalette palette;
palette.Attach (::CreateHalftonePalette (NULL));
</PRE>
</td></tr></table></P>

<P><I>::CreateHalftonePalette</I> is the API equivalent of <I>CPalette::CreateHalftonePalette</I>.</P>

<P>Creating a custom palette is a little more work because before you call 
<I>CreatePalette</I>, you must initialize a LOGPALETTE structure with entries describing the 
palette's colors. LOGPALETTE is defined as follows.</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct tagLOGPALETTE {
    WORD            palVersion;
    WORD            palNumEntries;
    PALETTEENTRY    palPalEntry[1];
} LOGPALETTE;
</PRE>
</td></tr></table></P>

<P><I>palVersion</I> specifies the LOGPALETTE version number; in all current releases of 
Windows, it should be set to 0x300. 
<I>palNumEntries</I> specifies the number of colors in 
the palette. <I>palPalEntry</I> is an array of PALETTEENTRY structures defining the colors. 
The number of elements in the array should equal the value of 
<I>palNumEntries</I>. PALETTEENTRY is defined like this:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct tagPALETTEENTRY {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
} PALETTEENTRY;
</PRE>
</td></tr></table></P>

<P><I>peRed</I>, <I>peGreen</I>, and <I>peBlue</I> specify a color's 8-bit RGB components. 
<I>peFlags</I> contains zero or more bit flags describing the 
<I>type</I> of palette entry. It can be set to any 
of the values shown here, or to 0 to create a &quot;normal&quot; palette entry:</P>

<P>
<table width="95%" cellpadding="5">
<tr><th valign="top"><B><I>Flag</I></B></th>
<th valign="top"><b><i>Description</i></b></th></tr>
<tr><td valign="top">PC_EXPLICIT</td>
<td valign="top">Creates a palette entry that specifies an index into the system palette rather than an RGB color. Used by programs that display the contents of the system palette.</td></tr>
<tr><td valign="top">PC_NOCOLLAPSE</td>
<td valign="top">Creates a palette entry that's mapped to an unused entry in the system palette even if there's already an entry for that color. Used to ensure the uniqueness of palette colors.</td></tr>
<tr><td valign="top">PC_RESERVED</td>
<td valign="top">Creates a palette entry that's private to this application. When a PC_RESERVED entry is added to the system palette, it isn't mapped to colors in other logical palettes even if the colors match. Used by programs that perform palette animation.</td></tr>
</table></P>

<P>Most of the time, <I>peFlags</I> is simply set to 0. We'll discuss one use for the 
PC_RESERVED flag later in this chapter, in the section on palette animation.</P>

<P>The PALETTEENTRY array in the LOGPALETTE structure is declared with 
just one array element because Windows has no way of anticipating how many colors 
a logical palette will contain. As a result, you can't just declare an instance of 
LOGPALETTE on the stack and fill it in; instead, you have to allocate memory for it 
based on the number of PALETTEENTRY structures it contains. The following code 
allocates a &quot;full&quot; LOGPALETTE structure on the stack and then creates a logical palette 
containing 32 shades of red:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
struct {
    LOGPALETTE lp;
    PALETTEENTRY ape[31];
} pal;

LOGPALETTE* pLP = (LOGPALETTE*) &amp;pal;
pLP-&gt;palVersion = 0x300;
pLP-&gt;palNumEntries = 32;

for (int i=0; i&lt;32; i++) {
    pLP-&gt;palPalEntry[i].peRed = i * 8;
    pLP-&gt;palPalEntry[i].peGreen = 0;
    pLP-&gt;palPalEntry[i].peBlue = 0;
    pLP-&gt;palPalEntry[i].peFlags = 0;
}

CPalette palette;
palette.CreatePalette (pLP);
</PRE>
</td></tr></table></P>

<P>Like other GDI objects, logical palettes should be deleted when they're no 
longer needed. A logical palette represented by a 
<I>CPalette</I> object is automatically deleted when the corresponding 
<I>CPalette</I> object is deleted or goes out of scope.</P>

<P>How many entries can a logical palette contain? As many as you want it to. 
Of course, the number of colors that can be mapped directly to the system palette is 
limited by the capabilities of the video adapter. If you realize a palette containing 1,024 
colors on a 256-color output device, only the first 236 will be mapped directly; the 
remaining colors will be matched as closely as possible to colors already in the 
system palette. When you use logical palettes (especially large ones), it's helpful to 
arrange the colors in order of importance, where 
<I>palPalEntry</I>[0] defines the most important color, 
<I>palPalEntry</I>[1] defines the next most important color, and so on. The 
palette manager maps palette colors in array order, so by putting important colors first, 
you increase the chances that those colors will be displayed in their native form. In 
general, you shouldn't make a logical palette any larger than it has to be. Large 
palettes take longer to realize, and the more palette colors a foreground window uses, 
the fewer colors the palette manager can make available to palette-aware windows 
lower in the <I>z</I>-order.</P>

<P>After a palette is created, you can retrieve individual palette entries with 
<I>CPalette::GetPaletteEntries</I> or change them with 
<I>CPalette::SetPaletteEntries</I>. You can also 
resize a palette with 
<I>CPalette::ResizePalette</I>. If the palette is enlarged, the new palette 
entries initially contain all 0s.</P>

<A NAME="452"><H2>Realizing a Logical Palette</H2></A>

<P>For a logical palette to be effective, it must be selected into a device context and 
realized before any drawing takes place. The current logical palette is a device 
context attribute, just as the current pen and brush are device context attributes. (In case 
you're wondering, a device context's default logical palette is a trivial one whose 
entries correspond to the static colors.) The following 
<I>OnPaint</I> handler selects the logical palette 
<I>m_palette</I> into a paint device context and realizes the palette before 
repainting the screen:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);
    CPalette* pOldPalette = dc.SelectPalette (&amp;m_palette, FALSE);
    dc.RealizePalette ();
    // Do some drawing.
    dc.SelectPalette (pOldPalette, FALSE);
}
</PRE>
</td></tr></table></P>

<P>In this example, the pointer to the default palette is saved and used later to 
select <I>m_palette</I> out of the device context. Note that palettes are selected with 
<I>CDC::SelectPalette</I> instead of 
<I>CDC::SelectObject</I>. The second parameter is a BOOL value that, 
if TRUE, forces the palette to behave as if it were in the background even when 
the window that selected it is in the foreground. Background palettes can be handy 
in applications that use multiple palettes, but normally you'll specify FALSE in calls 
to <I>SelectPalette</I>. 
<I>CDC::RealizePalette</I> realizes the palette that's currently selected into 
the device context by asking the palette manager to map colors from the logical 
palette to the system palette.</P>

<A NAME="453"><H2>Drawing with Palette Colors</H2></A>

<P>Once you create a palette, select it into a device context, and realize it, you're 
ready to start drawing. If you use 
<I>CDC::BitBlt</I> to display a bitmap, the realized colors 
are used automatically. But if you're drawing images with brushes or pens or using 
functions such as <I>CDC::FloodFill</I> that use neither a brush nor a pen directly but do 
accept COLORREF values, there's something else you must consider.</P>

<P>The RGB macro is one of three macros that create COLORREF values. The 
others are PALETTEINDEX and PALETTERGB. Which of the three macros you use 
determines how the GDI treats the resultant COLORREF. When you draw with a 
COLORREF value created with the RGB macro, the GDI ignores the colors that were added to 
the system palette when the logical palette was realized and uses only the static 
colors. If you want the GDI to use <I>all</I> the palette colors, use the PALETTERGB 
macro. PALETTERGB creates a 
<I>palette-relative</I> color. The PALETTEINDEX macro creates 
a COLORREF value that specifies an index into a logical palette rather than an 
RGB color value. This value is called a 
<I>palette-index</I> color value. It's the fastest kind 
of color to draw with because it prevents the GDI from having to match RGB color 
values to colors in the logical palette.</P>

<P>The following code sample demonstrates how all three macros are used:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);

    // Select and realize a logical palette.
    CPalette* pOldPalette = dc.SelectPalette (&amp;m_palette, FALSE);
    dc.RealizePalette ();

    // Create three pens.
    CPen pen1 (PS_SOLID, 16, RGB (242, 36, 204));
    CPen pen2 (PS_SOLID, 16, PALETTERGB (242, 36, 204));
    CPen pen3 (PS_SOLID, 16, PALETTEINDEX (3));

    // Do some drawing.
    dc.MoveTo (0, 0);
    CPen* pOldPen = dc.SelectObject (&amp;pen1);
    dc.LineTo (300, 0);         // Nearest static color
    dc.SelectObject (&amp;pen2);
    dc.LineTo (150, 200);       // Nearest static or palette color
    dc.SelectObject (&amp;pen3);
    dc.LineTo (0, 0);           // Exact palette color
    dc.SelectObject (pOldPen);

    // Select the palette out of the device context.
    dc.SelectPalette (pOldPalette, FALSE);
}
</PRE>
</td></tr></table></P>

<P>Because pens use solid, undithered colors and because its COLORREF value is 
specified with an RGB macro, <I>pen1</I> draws with the static color that most closely 
approximates the RGB value (242, 36, 204). 
<I>pen2</I>, on the other hand, is assigned the 
nearest matching color from the static colors or 
<I>m_palette</I>. <I>pen3</I> uses the color in the 
system palette that corresponds to the fourth color (index=3) in the logical palette, 
regardless of what that color might be.</P>

<A NAME="454"><H2>The WM_QUERYNEWPALETTE and WM_PALETTECHANGED Messages</H2></A>

<P>When you write an application that uses a logical palette, you should include 
handlers  for a pair of messages named WM_QUERYNEWPALETTE 
and WM_PALETTECHANGED. WM_QUERYNEWPALETTE is sent to a top-level window when it or one of its 
children receives the input focus. WM_PALETTECHANGED is sent to all top-level 
windows in the system when a palette realization results in a change to the system palette. 
An application's normal response to either message is to realize its palette and 
repaint itself. Realizing a palette and repainting in response to a 
WM_QUERYNEWPALETTE message enables a window that was just brought to the foreground to put on its 
best face by taking advantage of the fact that it now has top priority in realizing its 
palette. Realizing a palette and repainting in response to a 
WM_PALETTECHANGED message enable background windows to adapt to changes in the system palette 
and take advantage of any unused entries that remain after windows higher in the 
<I>z</I>-order have realized their palettes.</P>

<P>The following message handler demonstrates a typical response to 
a WM_QUERYNEWPALETTE message:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
// In the message map
ON_WM_QUERYNEWPALETTE ()
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
BOOL CMainWindow::OnQueryNewPalette ()
{
    CClientDC dc (this);
    CPalette* pOldPalette = dc.SelectPalette (&amp;m_palette, FALSE);

    UINT nCount;
    if (nCount = dc.RealizePalette ())
        Invalidate ();

    dc.SelectPalette (pOldPalette, FALSE);
    return nCount;
}
</PRE>
</td></tr></table></P>

<P>The general strategy is to realize a palette and force a repaint by invalidating 
the window's client area. The value returned by 
<I>RealizePalette</I> is the number of palette entries that were mapped to entries in the system palette. A 0 return value 
means that realizing the palette had no effect, which should be extremely rare for a 
foreground window. If <I>RealizePalette</I> returns 0, you should skip the call to 
<I>Invalidate</I>. <I>OnQueryNewPalette</I> should return a nonzero value if a logical palette was 
realized and 0 if it wasn't. It should also return 0 if it tried to realize a palette but 
<I>RealizePalette</I> returned 0. The return value isn't used in current versions of Windows.</P>

<P>WM_PALETTECHANGED messages are handled in a similar way. Here's what 
a typical <I>OnPaletteChanged</I> handler looks like:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
// In the message map
ON_WM_PALETTECHANGED ()
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnPaletteChanged (CWnd* pFocusWnd)
{
    if (pFocusWnd != this) {
        CClientDC dc (this);
        CPalette* pOldPalette = dc.SelectPalette (&amp;m_palette,
            FALSE);
        if (dc.RealizePalette ())
            Invalidate ();
        dc.SelectPalette (pOldPalette, FALSE);
    }
}
</PRE>
</td></tr></table></P>

<P>The <I>CWnd</I> pointer passed to 
<I>OnPaletteChanged</I> identifies the window that 
prompted the WM_PALETTECHANGED message by realizing a palette. To avoid 
unnecessary recursion and possible infinite loops, 
<I>OnPaletteChanged</I> should do nothing if 
<I>pFocusWnd</I> points to its own window. That's the reason for the 
<I>if</I> statement that compares <I>pFocusWnd</I> to 
<I>this</I>.</P>

<P>Rather than perform full repaints in response to WM_PALETTECHANGED 
messages, applications can optionally call 
<I>CDC::UpdateColors</I> instead. 
<I>UpdateColors</I> updates a window by matching the color of each pixel to the colors in the system 
palette. It's usually faster than a full repaint, but the results typically aren't as good 
because the color matching is done based on the contents of the system palette 
<I>before</I> it changed. If you use 
<I>UpdateColors</I>, maintain a variable that counts the number of 
times <I>UpdateColors</I> has been called. Then every third or fourth time, do a full repaint 
and reset the counter to 0. This will prevent the colors in a background window 
from becoming too out of sync with the colors in the system palette.</P>

<A NAME="455"><H3>Handling Palette Messages in Document/View Applications</H3></A>

<P>The <I>OnQueryNewPalette</I> and 
<I>OnPaletteChanged</I> handlers in the previous 
section assume that the window to be updated is the application's main window. In a 
document/view application, that's not the case; the views need updating, not the 
top-level window. The ideal solution would be to put the 
<I>OnQueryNewPalette</I> and 
<I>OnPaletteChanged</I> handlers in the view class, but that won't work because views 
don't receive palette messages&#8212;only top-level windows do.</P>

<P>What most document/view applications do instead is have their main 
windows update the views in response to palette messages. The following 
<I>OnQueryNewPalette</I> and 
<I>OnPaletteChanged</I> handlers work well for most SDI applications:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL CMainFrame::OnQueryNewPalette ()
{
    CDocument* pDoc = GetActiveDocument ();
    if (pDoc != NULL)
        GetActiveDocument ()-&gt;UpdateAllViews (NULL);
    return TRUE;
}

void CMainFrame::OnPaletteChanged (CWnd* pFocusWnd)
{
    if (pFocusWnd != this) {
        CDocument* pDoc = GetActiveDocument ();
        if (pDoc != NULL)
            GetActiveDocument ()-&gt;UpdateAllViews (NULL);
    }
}
</PRE>
</td></tr></table></P>

<P>Palettes are a little trickier in MDI applications. If each open document has 
a unique palette associated with it (as is often the case), the active view should be 
redrawn using a foreground palette and inactive views should be redrawn using 
background palettes. Another issue with MDI applications that use multiple palettes is 
the need to update the views' colors as the user clicks among views. The best solution 
is to override <I>CView::OnActivateView</I> so that a view knows when it's activated or 
deactivated and can realize its palette accordingly. For a good example of palette 
handling in MDI applications, see the DIBLOOK sample program provided with Visual C++.</P>

<A NAME="456"><H2>Determining Whether a Logical Palette Is Needed</H2></A>

<P>Now that you understand the mechanics of palette usage, ask yourself this 
question: How do I know if I need a logical palette in the first place? If color accuracy is 
of paramount concern, you'll probably want to use a logical palette when your 
application runs on a palletized 256-color video adapter. But the same application 
doesn't need a logical palette when the hardware color depth is 24 bits because in that 
environment perfect color output comes for free. And if the application runs on a 
standard 16-color VGA, palettes are extraneous because the system palette contains 
16 static colors that leave no room for colors in logical palettes.</P>

<P>You can determine at run time whether a logical palette will improve color 
output by calling <I>CDC::GetDeviceCaps</I> with a RASTERCAPS parameter and checking 
the RC_PALETTE bit in the return value, as demonstrated here:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CClientDC dc (this);
BOOL bUsePalette = FALSE;
if (dc.GetDeviceCaps (RASTERCAPS) &amp; RC_PALETTE)
    bUsePalette = TRUE;
</PRE>
</td></tr></table></P>

<P>RC_PALETTE is set in palettized color modes and clear in nonpalettized modes. 
Generally speaking, the RC_PALETTE bit is set in 8-bit color modes and clear in 4-bit 
and 24-bit color modes. The RC_PALETTE bit is also clear if the adapter is running in 
16-bit color (&quot;high color&quot;) mode, which for most applications produces color output 
every bit as good as true color. Don't make the mistake some programmers have made 
and rely on bit counts to tell you whether to use a palette. As sure as you do, you'll 
run across an oddball video adapter that defies the normal conventions and fools 
your application into using a palette when a palette isn't needed or not using a palette 
when a palette would help.</P>

<P>What happens if you ignore the RC_PALETTE setting and use a logical 
palette regardless of color depth? The application will still work because the palette 
manager works even on nonpalettized devices. If RC_PALETTE is 0, palettes can still 
be created and selected into device contexts, but calls to 
<I>RealizePalette</I> do nothing. PALETTEINDEX values are dereferenced and converted into RGB colors in the 
logical palette, and PALETTERGB values are simply treated as if they were standard 
RGB color values. <I>OnQueryNewPalette</I> and 
<I>OnPaletteChanged</I> aren't called because no WM_QUERYNEWPALETTE and WM_PALETTECHANGED messages are sent. As 
explained in an excellent article, &quot;The Palette Manager: How and Why,&quot; available 
on the Microsoft Developer Network (MSDN), &quot;The goal is to allow applications to 
use palettes in a device-independent fashion and to not worry about the actual 
palette capabilities of the device driver.&quot;</P>

<P>Still, you can avoid wasted CPU cycles by checking the RC_PALETTE flag 
and skipping palette-related function calls if the flag is clear. And if your application 
<I>relies</I> on the presence of hardware palette support and won't work without 
it&#8212;for example, if it uses palette animation, a subject we'll get to in a moment&#8212;you 
can use RC_PALETTE to determine whether your application is even capable of 
running on the current hardware.</P>

<P>An equally important question to ask yourself when considering whether to 
use logical palettes is, &quot;How accurate does my program's color output need to be?&quot; 
Applications that draw using colors that match the static colors don't need palettes 
at all. On the other hand, a bitmap file viewer almost certainly needs palette 
support because without it all but the simplest bitmaps would look terrible on 256-color 
video adapters. Assess your program's color needs, and do as little work as you have 
to. You'll write better applications as a result.</P>

<A NAME="457"><H2>The PaletteDemo Application</H2></A>

<P>The application shown in Figure 15-1 demonstrates basic palette-handling 
technique in a non-document/view application. PaletteDemo uses a series of blue brushes 
to paint a background that fades smoothly from blue to black. Moreover, it produces 
a beautiful gradient fill even on 256-color video adapters. The key to the high 
quality of its output on 256-color screens is PaletteDemo's use of a logical palette 
containing 64 shades of blue, ranging from almost pure black (R=0, G=0, B=3) to 
high-intensity blue (R=0, G=0, B=255). Brush colors are specified using palette-relative 
COLORREF values so that the GDI will match the brush colors to colors in the system 
palette after the logical palette is realized. You can judge the results for yourself by 
running PaletteDemo in both 8-bit and 24-bit color modes and seeing that the output 
is identical. Only when it is run in 16-color mode does PaletteDemo fail to produce 
a smooth gradient fill. But even then the results aren't bad because the GDI dithers 
the brush colors.</P>

<P>
<A HREF="javascript:fullSize('F15mg01x.htm')"> <img src="images/F15mg01.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-1.</B> <I>The PaletteDemo window.</I><!-- /CAPTION -->
</p>

<P>Here are a few points of interest in PaletteDemo's source code, which 
appears in Figure 15-2. For starters, PaletteDemo's main window paints the 
gradient-filled background in response to WM_ERASEBKGND messages. WM_ERASEBKGND 
messages are sent to erase a window's background before a WM_PAINT handler 
paints the foreground. A WM_ERASEBKGND handler that paints a custom window 
background as PaletteDemo does should return a nonzero value to notify Windows 
that the background has been &quot;erased.&quot; (For a cool effect, see what happens when 
a WM_ERASEBKGND handler paints nothing but returns TRUE anyway. What do 
you get? A see-through window!) Otherwise, Windows erases the background itself 
by filling the window's client area with the WNDCLASS's background brush.</P>

<P>PaletteDemo creates the logical palette that it uses to paint the window 
background in <I>CMainWindow::OnCreate</I>. The palette itself is a 
<I>CPalette</I> data member named <I>m_palette</I>. Before creating the palette, 
<I>OnCreate</I> checks <I>CDC::GetDeviceCaps</I>'s return value for an RC_PALETTE bit. If the bit isn't set, 
<I>OnCreate</I> leaves <I>m_palette</I> uninitialized. Before selecting and realizing the palette, 
<I>CMainWindow::OnEraseBkgnd</I> checks 
<I>m_palette</I> to determine whether a palette exists:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
if ((HPALETTE) m_palette != NULL) {
    pOldPalette = pDC-&gt;SelectPalette (&amp;m_palette, FALSE);
    pDC-&gt;RealizePalette ();
}
</PRE>
</td></tr></table></P>

<P><I>CPalette</I>'s HPALETTE operator returns the handle of the palette attached to a 
<I>CPalette</I> object. A NULL handle means 
<I>m_palette</I> is uninitialized. 
<I>OnEraseBkgnd</I> adapts itself to the environment it's run in by selecting and realizing a logical palette if and only 
if the video hardware is palettized. The 
<I>DoGradientFill</I> function that draws the window background works with or without a palette because brush colors are 
specified with PALETTERGB macros.</P>

<P>One consideration that PaletteDemo doesn't address is what happens if the 
color depth changes while the application is running. You can account for such 
occurrences by processing WM_DISPLAYCHANGE messages, which are sent when the user 
changes the screen's resolution or color depth, and reinitializing the palette based on the 
new settings. There is no ON_WM_DISPLAYCHANGE macro, so you have to do the 
message mapping manually with ON_MESSAGE. The 
<I>wParam</I> parameter encapsulated in a WM_DISPLAYCHANGE message contains the new color depth expressed as 
the number of bits per pixel, and the low and high words of 
<I>lParam</I> contain the latest horizontal and vertical screen resolution in pixels.</P>

<P>WM_DISPLAYCHANGE isn't only for applications that use palettes. You 
should also use it if, for example, you initialize variables with the average width and 
height of a character in the system font when the application starts and later use those 
variables to size and position your output. If the variables aren't reinitialized when 
the screen resolution changes, subsequent output might be distorted.</P>


<P><B>Figure 15-2.</B> <I>The PaletteDemo application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="458"><H3>PaletteDemo.h</H3></A>
<PRE>class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CFrameWnd
{
protected:
    CPalette m_palette;
    void DoGradientFill (CDC* pDC, LPRECT pRect);
    void DoDrawText (CDC* pDC, LPRECT pRect);

public:
    CMainWindow ();

protected:
    afx_msg int OnCreate (LPCREATESTRUCT lpcs);
    afx_msg BOOL OnEraseBkgnd (CDC* pDC);
    afx_msg void OnPaint ();
    afx_msg BOOL OnQueryNewPalette ();
    afx_msg void OnPaletteChanged (CWnd* pFocusWnd);
    DECLARE_MESSAGE_MAP ()
};
</PRE>
</td></tr></table></P>


<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="459"><H3>PaletteDemo.cpp</H3></A>
<PRE>
#include &lt;afxwin.h&gt;
#include &quot;PaletteDemo.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CFrameWnd)
    ON_WM_CREATE ()
    ON_WM_ERASEBKGND ()
    ON_WM_PAINT ()
    ON_WM_QUERYNEWPALETTE ()
    ON_WM_PALETTECHANGED ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    Create (NULL, _T (&quot;Palette Demo&quot;));
}

int CMainWindow::OnCreate (LPCREATESTRUCT lpcs)
{
    if (CFrameWnd::OnCreate (lpcs) == -1)
        return -1;

    //
    // Create a logical palette if running on a palettized adapter.
    //
    CClientDC dc (this);
    if (dc.GetDeviceCaps (RASTERCAPS) &amp; RC_PALETTE) {
        struct {
            LOGPALETTE lp;
            PALETTEENTRY ape[63];
        } pal;

        LOGPALETTE* pLP = (LOGPALETTE*) &amp;pal;
        pLP-&gt;palVersion = 0x300;
        pLP-&gt;palNumEntries = 64;

        for (int i=0; i&lt;64; i++) {
            pLP-&gt;palPalEntry[i].peRed = 0;
            pLP-&gt;palPalEntry[i].peGreen = 0;
            pLP-&gt;palPalEntry[i].peBlue = 255 - (i * 4);
            pLP-&gt;palPalEntry[i].peFlags = 0;
        }
        m_palette.CreatePalette (pLP);
    }
    return 0;
}

BOOL CMainWindow::OnEraseBkgnd (CDC* pDC)
{
    CRect rect;
    GetClientRect (&amp;rect);

    CPalette* pOldPalette;
    if ((HPALETTE) m_palette != NULL) {
        pOldPalette = pDC-&gt;SelectPalette (&amp;m_palette, FALSE);
        pDC-&gt;RealizePalette ();
    }

    DoGradientFill (pDC, &amp;rect);

    if ((HPALETTE) m_palette != NULL)
        pDC-&gt;SelectPalette (pOldPalette, FALSE);
    return TRUE;
}

void CMainWindow::OnPaint ()
{
    CRect rect;
    GetClientRect (&amp;rect);
    CPaintDC dc (this);
    DoDrawText (&amp;dc, &amp;rect);
}

BOOL CMainWindow::OnQueryNewPalette ()
{    
    if ((HPALETTE) m_palette == NULL)   // Shouldn't happen, but
        return 0;                       // let's be sure.

    CClientDC dc (this);
    CPalette* pOldPalette = dc.SelectPalette (&amp;m_palette, FALSE);

    UINT nCount;
    if (nCount = dc.RealizePalette ())
        Invalidate ();

    dc.SelectPalette (pOldPalette, FALSE);
    return nCount;
}

void CMainWindow::OnPaletteChanged (CWnd* pFocusWnd)
{
    if ((HPALETTE) m_palette == NULL)   // Shouldn't happen, but
        return;                         // let's be sure.

    if (pFocusWnd != this) {
        CClientDC dc (this);
        CPalette* pOldPalette = dc.SelectPalette (&amp;m_palette, FALSE);
        if (dc.RealizePalette ())
            Invalidate ();
        dc.SelectPalette (pOldPalette, FALSE);
    }
}

void CMainWindow::DoGradientFill (CDC* pDC, LPRECT pRect)
{
    CBrush* pBrush[64];
    for (int i=0; i&lt;64; i++)
        pBrush[i] = new CBrush (PALETTERGB (0, 0, 255 - (i * 4)));

    int nWidth = pRect-&gt;right - pRect-&gt;left;
    int nHeight = pRect-&gt;bottom - pRect-&gt;top;
    CRect rect;

    for (i=0; i&lt;nHeight; i++) {
        rect.SetRect (0, i, nWidth, i + 1);
        pDC-&gt;FillRect (&amp;rect, pBrush[(i * 63) / nHeight]);
    }

    for (i=0; i&lt;64; i++)
        delete pBrush[i];
}

void CMainWindow::DoDrawText (CDC* pDC, LPRECT pRect)
{
    CFont font;
    font.CreatePointFont (720, _T (&quot;Comic Sans MS&quot;));

    pDC-&gt;SetBkMode (TRANSPARENT);
    pDC-&gt;SetTextColor (RGB (255, 255, 255));

    CFont* pOldFont = pDC-&gt;SelectObject (&amp;font);
    pDC-&gt;DrawText (_T (&quot;Hello, MFC&quot;), -1, pRect, DT_SINGLELINE &#166; 
        DT_CENTER &#166; DT_VCENTER);
    pDC-&gt;SelectObject (pOldFont);
}
</PRE>
</td></tr></table></P>

<A NAME="460"><H2>Palette Animation</H2></A>

<P>One of the more novel uses for a logical palette is for performing palette 
animation. Conventional computer animation is performed by repeatedly drawing, erasing, 
and redrawing images on the screen. Palette animation involves no drawing and 
erasing, but it can make images move just the same. A classic example of palette animation 
is a simulated lava flow that cycles shades of red, orange, and yellow to produce 
an image that resembles lava flowing down a hill. What's interesting is that the image 
is drawn only once. The illusion of motion is created by repeatedly reprogramming 
the system palette so that red becomes orange, orange becomes yellow, yellow 
becomes red, and so on. Palette animation is fast because it doesn't involve moving any 
pixels. A simple value written to a palette register on a video adapter can change 
the color of an entire screen full of pixels in the blink of an eye&#8212;to be precise, in 
the 1/60 of a second or so it takes for a monitor's electron guns to complete one 
screen refresh cycle.</P>

<p>What does it take to do palette animation in Windows? Just these three steps:</P>

<OL>
<P><LI>Call <I>GetDeviceCaps,</I> and check RC_PALETTE to verify that palettes are supported. Palette animation won't work if the RC_PALETTE bit isn't set.</LI></P>
<P><LI>Create a logical palette containing the colors you want to animate, and mark each palette entry with a PC_RESERVED flag. Only palette entries marked PC_RESERVED can be used for palette animation.</LI></P>
<P><LI>Draw an image using colors in the logical palette, and then call <I>CPalette::AnimatePalette</I> repeatedly to change the palette colors. Each time you change the palette with <I>AnimatePalette</I>, the colors in the image will change accordingly.</LI></P>
</OL>

<P>
<A HREF="javascript:fullSize('F15mg03x.htm')"> <img src="images/F15mg03.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-3.</B> <I>The LivePalette window.</I><!-- /CAPTION -->
</p>

<P>The LivePalette application in Figure 15-3 and Figure 15-4 demonstrates 
how palette animation works. The window background is painted with bands of color 
(eight different colors in all) from PC_RESERVED entries in a logical palette. Brush 
colors are specified with PALETTEINDEX values. PALETTERGB values would work, too, 
but ordinary RGB values wouldn't because pixels whose colors will be animated 
must be painted with colors marked PC_RESERVED in the logical palette, not static 
colors. LivePalette sets a timer to fire every 500 milliseconds, and 
<I>OnTimer</I> animates the palette as follows:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
PALETTEENTRY pe[8];
m_palette.GetPaletteEntries (7, 1, pe);
m_palette.GetPaletteEntries (0, 7, &amp;pe[1]);
m_palette.AnimatePalette (0, 8, pe);
</PRE>
</td></tr></table></P>

<P>The calls to <I>CPalette::GetPaletteEntries</I> initialize an array of PALETTEENTRY 
structures with values from the logical palette and simultaneously rotate every color 
up one position so that color 7 becomes color 0, color 0 becomes color 1, and so 
on. <I>AnimatePalette</I> then updates the colors on the screen by copying the values 
from the array directly to the corresponding entries in the system palette. It isn't 
necessary to call <I>RealizePalette</I> because the equivalent of a palette realization has 
already been performed.</P>

<p>The remainder of the program is very similar to the previous section's 
PaletteDemo program, with one notable exception: If RC_PALETTE is NULL, 
<I>InitInstance</I> displays a message box informing the user that palette animation isn't supported in the 
present environment and shuts down the application by returning FALSE. You'll see 
this message if you run LivePalette in anything other than a 256-color video mode.</P>

<P><B>Figure 15-4.</B> <I>The LivePalette application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="461"><H3>LivePalette.h</H3></A>
<PRE>
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CFrameWnd
{
protected:
    CPalette m_palette;
    void DoBkgndFill (CDC* pDC, LPRECT pRect);
    void DoDrawText (CDC* pDC, LPRECT pRect);

public:
    CMainWindow ();

protected:
    afx_msg int OnCreate (LPCREATESTRUCT lpcs);
    afx_msg BOOL OnEraseBkgnd (CDC* pDC);
    afx_msg void OnPaint ();
    afx_msg void OnTimer (UINT nTimerID);
    afx_msg BOOL OnQueryNewPalette ();
    afx_msg void OnPaletteChanged (CWnd* pFocusWnd);
    afx_msg void OnDestroy ();
    DECLARE_MESSAGE_MAP ()
};
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="462"><H3>LivePalette.cpp</H3></A>
<PRE>
#include &lt;afxwin.h&gt;
#include &quot;LivePalette.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    //
    // Verify that the host system is running in a palettized video mode.
    //
    CClientDC dc (NULL);
    if ((dc.GetDeviceCaps (RASTERCAPS) &amp; RC_PALETTE) == 0) {
        AfxMessageBox (_T (&quot;Palette animation is not supported on this &quot; \
            &quot;device. Set the color depth to 256 colors and try again.&quot;),
            MB_ICONSTOP &#166; MB_OK);
        return FALSE;
    }

    //
    // Initialize the application as normal.
    //
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CFrameWnd)
    ON_WM_CREATE ()
    ON_WM_ERASEBKGND ()
    ON_WM_PAINT ()
    ON_WM_TIMER ()
    ON_WM_QUERYNEWPALETTE ()
    ON_WM_PALETTECHANGED ()
    ON_WM_DESTROY ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    Create (NULL, _T (&quot;Palette Animation Demo&quot;));
}

int CMainWindow::OnCreate (LPCREATESTRUCT lpcs)
{
    static BYTE bColorVals[8][3] = {
        128, 128, 128,  // Dark Gray
        0,     0, 255,  // Blue
        0,   255,   0,  // Green
        0,   255, 255,  // Cyan
        255,   0,   0,  // Red
        255,   0, 255,  // Magenta
        255, 255,   0,  // Yellow
        192, 192, 192   // Light gray
    };
    if (CFrameWnd::OnCreate (lpcs) == -1)
        return -1;

    //
    // Create a palette to support palette animation.
    //
    struct {
        LOGPALETTE lp;
        PALETTEENTRY ape[7];
    } pal;

    LOGPALETTE* pLP = (LOGPALETTE*) &amp;pal;
    pLP-&gt;palVersion = 0x300;
    pLP-&gt;palNumEntries = 8;

    for (int i=0; i&lt;8; i++) {
        pLP-&gt;palPalEntry[i].peRed = bColorVals[i][0];
        pLP-&gt;palPalEntry[i].peGreen = bColorVals[i][1];
        pLP-&gt;palPalEntry[i].peBlue = bColorVals[i][2];
        pLP-&gt;palPalEntry[i].peFlags = PC_RESERVED;
    }

    m_palette.CreatePalette (pLP);

    //
    // Program a timer to fire every half-second.
    //
    SetTimer (1, 500, NULL);
    return 0;
}

void CMainWindow::OnTimer (UINT nTimerID)
{
    PALETTEENTRY pe[8];
    m_palette.GetPaletteEntries (7, 1, pe);
    m_palette.GetPaletteEntries (0, 7, &amp;pe[1]);
    m_palette.AnimatePalette (0, 8, pe);
}

BOOL CMainWindow::OnEraseBkgnd (CDC* pDC)
{
    CRect rect;
    GetClientRect (&amp;rect);

    CPalette* pOldPalette;
    pOldPalette = pDC-&gt;SelectPalette (&amp;m_palette, FALSE);
    pDC-&gt;RealizePalette ();
    DoBkgndFill (pDC, &amp;rect);

    pDC-&gt;SelectPalette (pOldPalette, FALSE);
    return TRUE;
}

void CMainWindow::OnPaint ()
{
    CRect rect;
    GetClientRect (&amp;rect);
    CPaintDC dc (this);
    DoDrawText (&amp;dc, &amp;rect);
}

BOOL CMainWindow::OnQueryNewPalette ()
{
    CClientDC dc (this);
    dc.SelectPalette (&amp;m_palette, FALSE);

    UINT nCount;
    if (nCount = dc.RealizePalette ())
        Invalidate ();

    return nCount;
}

void CMainWindow::OnPaletteChanged (CWnd* pFocusWnd)
{
    if (pFocusWnd != this) {
        CClientDC dc (this);
        dc.SelectPalette (&amp;m_palette, FALSE);
        if (dc.RealizePalette ())
            Invalidate ();
    }
}

void CMainWindow::OnDestroy ()
{
    KillTimer (1);
}

void CMainWindow::DoBkgndFill (CDC* pDC, LPRECT pRect)
{
    CBrush* pBrush[8];
    for (int i=0; i&lt;8; i++)
        pBrush[i] = new CBrush (PALETTEINDEX (i));

    int nWidth = pRect-&gt;right - pRect-&gt;left;
    int nHeight = (pRect-&gt;bottom - pRect-&gt;top) / 8;

    CRect rect;
    int y1, y2;

    for (i=0; i&lt;8; i++) {
        y1 = i * nHeight;
        y2 = (i == 7) ? pRect-&gt;bottom - pRect-&gt;top : y1 + nHeight;
        rect.SetRect (0, y1, nWidth, y2);
        pDC-&gt;FillRect (&amp;rect, pBrush[i]);
    }

    for (i=0; i&lt;8; i++)
        delete pBrush[i];
}

void CMainWindow::DoDrawText (CDC* pDC, LPRECT pRect)
{
    CFont font;
    font.CreatePointFont (720, _T (&quot;Comic Sans MS&quot;));

    pDC-&gt;SetBkMode (TRANSPARENT);
    pDC-&gt;SetTextColor (RGB (255, 255, 255));

    CFont* pOldFont = pDC-&gt;SelectObject (&amp;font);
    pDC-&gt;DrawText (_T (&quot;Hello, MFC&quot;), -1, pRect, DT_SINGLELINE &#166; 
        DT_CENTER &#166; DT_VCENTER);
    pDC-&gt;SelectObject (pOldFont);
}
</PRE>
</td></tr></table></P>

<A NAME="463"><H2>The <I>::SetSystemPaletteUse</I> Function</H2></A>
<P>A final word on palette usage: if your application absolutely, unequivocally has 
to have access to the entire system palette and not just the unused color entries that 
remain after the static colors are added, it can call 
<I>::SetSystemPaletteUse</I> with a device context handle and a SYSPAL_NOSTATIC parameter to reduce the number of static 
colors from 20 to 2&#8212;black and white. On a 256-color video adapter, this means that 
254 instead of just 236 colors can be copied from a logical palette to the system 
palette. The Win32 API documentation makes it pretty clear how 
<I>::SetSystemPaletteUse</I> and its companion function 
<I>::GetSystemPaletteUse</I> are used, so I'll say no more about 
them here. However, realize that replacing the static colors with colors of your own is 
an extremely unfriendly thing to do because it could corrupt the colors of title bars, 
push buttons, and other window elements throughout the entire system. Don't do it 
unless you have to.</P>

</BODY>
</HTML>




