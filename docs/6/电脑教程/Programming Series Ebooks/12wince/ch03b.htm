<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Keyboard</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="73"><H1>The Keyboard</H1></A>

<P>While keyboards play a lesser role in Windows CE, they're still the best means of entering large volumes of information. Even on systems without a physical keyboard such as the Palm-size PC, <I>soft</I> keyboards&#8212;controls that simulate keyboards on a touch screen&#8212;will most likely be available to the user. Given this, proper handling of keyboard input is critical to all but the most specialized of Windows CE applications. While I'll talk at length about soft keyboards later in the book, one point should be made here. To the application, input from a soft keyboard is no different from input from a traditional &quot;hard&quot; keyboard.

<A NAME="74"><H2>Input Focus</H2></A>

<P>Under Windows operating systems, only one window at a time has the input focus. The focus window receives all keyboard input until it loses focus to another window. The system assigns the keyboard focus using a number of rules but most often the focus window is the current active window. The active window, you'll recall, is the top-level window, the one with which the user is currently interacting. With rare exceptions, the active window also sits at the top of the Z-order; that is, it's drawn on top of all other windows in the system. The user can change the active window by pressing Alt-Esc to switch between programs or by tapping on another top-level window's button on the task bar. The focus window is either the active window or one of its child windows.

<P>Under Windows, a program can determine which window has the input focus by calling

<p><pre>
HWND GetFocus (void);
</pre>

<P>The focus can be changed to another window by calling

<p><pre>
HWND SetFocus (HWND hWnd);
</pre>

<P>Under Windows CE, the target window of <I>SetFocus</I> is limited. The window being given the focus by <I>SetFocus</I> must have been created by the thread calling <I>SetFocus</I>. An exception to this rule occurs if the window losing focus is related to the window gaining focus by a parent/child or sibling relationship; in this case, the focus can be changed even if the windows were created by different threads.

<P>When a window loses focus, Windows sends a WM_KILLFOCUS message to that window informing it of its new state. The <I>wParam</I> parametercontains the handle of the window that will be gaining the focus. The window gaining focus receives a WM_SETFOCUS message. The <I>wParam</I> parameter of the WM_SETFOCUS message contains the handle of the window losing focus.

<P>Now for a bit of motherhood. Programs shouldn't change the focus window without some input from the user. Otherwise, the user can easily become confused. A proper use of <I>SetFocus</I> is to set the input focus to a child window (more than likely a control) contained in the active window. In this case, a window would respond to the WM_SETFOCUS message by calling <I>SetFocus</I> with the handle of a child window contained in the window to which the program wants to direct keyboard messages.

<A NAME="75"><H2>Keyboard Messages</H2></A>

<P>Windows CE practices the same keyboard message processing as its larger desktop relations with a few small exceptions, which I cover shortly. When a key is pressed, Windows sends a series of messages to the focus window, typically beginning with a WM_KEYDOWN message. If the key pressed represents a character such as letter or number, Windows follows the WM_KEYDOWN with a WM_CHAR message. (Some keys, such as function keys and cursor keys don't represent characters, so WM_CHAR messages aren't sent in response to those keys. For those keys, a program must interpret the WM_KEYDOWN message to know when the keys are pressed.) When the key is released, Windows sends a WM_KEYUP message. If a key is held down long enough for the auto-repeat feature to kick in, multiple WM_KEYDOWN and WM_CHAR messages are sent for each auto-repeat until the key is released when the final WM_KEYUP message is sent. I used the word <I>typically</I> to qualify this process because if the Alt key is being held when another key is pressed, the messages I've just described are replaced by WM_SYSKEYDOWN, WM_SYSCHAR, and WM_SYSKEYUP messages.

<P>For all of these messages, the generic parameters <I>wParam</I> and <I>lParam</I> are used in mostly the same manner. For WM_KEY<I>xx</I> and WM_SYSKEY<I>xx </I>messages, the <I>wParam</I> value contains the virtual key value, indicating the key being pressed. All versions of Windows provide a level of indirection between the keyboard hardware and applications by translating the scan codes returned by the keyboard into virtual key values. You see a list of the VK_<I>xx</I> values and their associated keys in Figure 3-1. While the table of virtual keys is extensive, not all keys listed in the table are present on Windows CE devices. For example, function keys, a mainstay on PC keyboards and listed in the virtual key table, aren't present on most Windows CE keyboards. In fact, a number of keys on a PC keyboard are left off the space-constrained Windows CE keyboards. A short list of the keys not typically used on Windows CE devices is presented in Figure 3-2. This list is meant to inform you that these keys might not exist, not to indicate that the keys <I>never</I> exist on Windows CE keyboards.

<P><B>Figure 3-1.</B> <I>Virtual key values in relation to the keys on the keyboard. Not all keys will be on all keyboards.</I>

<P><b>Virtual-Key Codes</b>
<P>
<TABLE cellpadding=5 width="95%">

<TR><td valign="top"><b><i>Constant</i></b></td>
<td valign="top"><b><i>Value</i></b></td>
<td valign="top"><b><i>Keyboard Equivalent</i></b></td></TR>

<TR><td valign="top">VK_LBUTTON</TD>
<td valign="top">01</TD>
<td valign="top">Stylus tap</TD></TR>

<TR><td valign="top">VK_RBUTTON</TD>
<td valign="top">02</TD>
<td valign="top">Mouse right button<SUP>&#167;</SUP></TD></TR>

<TR><td valign="top">VK_CANCEL</TD>
<td valign="top">03</TD>
<td valign="top">Control-break processing</TD></TR>

<TR><td valign="top">VK_RBUTTON</TD>
<td valign="top">04</TD>
<td valign="top">Mouse middle button<SUP>&#167;</SUP></TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">05_07</TD>
<td valign="top">Undefined</TD></TR>

<TR><td valign="top">VK_BACK</TD>
<td valign="top">08</TD>
<td valign="top">Backspace key</TD></TR>

<TR><td valign="top">VK_TAB</TD>
<td valign="top">09</TD>
<td valign="top">Tab key</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">0A_0B</TD>
<td valign="top">Undefined</TD></TR>

<TR><td valign="top">VK_CLEAR</TD>
<td valign="top">0C</TD>
<td valign="top">Clear key</TD></TR>

<TR><td valign="top">VK_RETURN</TD>
<td valign="top">0D</TD>
<td valign="top">Enter key</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">0E_0F</TD>
<td valign="top">Undefined</TD></TR>

<TR><td valign="top">VK_SHIFT</TD>
<td valign="top">10</TD>
<td valign="top">Shift key</TD></TR>

<TR><td valign="top">VK_CONTROL</TD>
<td valign="top">11</TD>
<td valign="top">Ctrl key</TD></TR>

<TR><td valign="top">VK_MENU</TD>
<td valign="top">12</TD>
<td valign="top">Alt key</TD></TR>

<TR><td valign="top">VK_CAPITAL</TD>
<td valign="top">14</TD>
<td valign="top">Caps Lock key</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">15_19</TD>
<td valign="top">Reserved for Kanji systems</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">1A</TD>
<td valign="top">Undefined</TD></TR>

<TR><td valign="top">VK_ESCAPE</TD>
<td valign="top">1B</TD>
<td valign="top">Escape key</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">1C_1F</TD>
<td valign="top">Reserved for Kanji systems</TD></TR>

<TR><td valign="top">VK_SPACE</TD>
<td valign="top">20</TD>
<td valign="top">Spacebar</TD></TR>

<TR><td valign="top">VK_PRIOR</TD>
<td valign="top">21</TD>
<td valign="top">Page Up key</TD></TR>

<TR><td valign="top">VK_NEXT</TD>
<td valign="top">22</TD>
<td valign="top">Page Down key</TD></TR>

<TR><td valign="top">VK_END</TD>
<td valign="top">23</TD>
<td valign="top">End key</TD></TR>

<TR><td valign="top">VK_HOME</TD>
<td valign="top">24</TD>
<td valign="top">Home key</TD></TR>

<TR><td valign="top">VK_LEFT</TD>
<td valign="top">25</TD>
<td valign="top">Left Arrow key</TD></TR>

<TR><td valign="top">VK_UP</TD>
<td valign="top">26</TD>
<td valign="top">Up Arrow key</TD></TR>

<TR><td valign="top">VK_RIGHT</TD>
<td valign="top">27</TD>
<td valign="top">Right Arrow key</TD></TR>

<TR><td valign="top">VK_DOWN</TD>
<td valign="top">28</TD>
<td valign="top">Down Arrow key</TD></TR>

<TR><td valign="top">VK_SELECT</TD>
<td valign="top">29</TD>
<td valign="top">Select key</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">2A</TD>
<td valign="top">Original equipment manufacturer (OEM)_specific</TD></TR>

<TR><td valign="top">VK_EXECUTE</TD>
<td valign="top">2B</TD>
<td valign="top">Execute key</TD></TR>

<TR><td valign="top">VK_SNAPSHOT</TD>
<td valign="top">2C</TD>
<td valign="top">Print Screen key for Windows 3.0 and later</TD></TR>

<TR><td valign="top">VK_INSERT</TD>
<td valign="top">2D</TD>
<td valign="top">Insert *</TD></TR>

<TR><td valign="top">VK_DELETE</TD>
<td valign="top">2E</TD>
<td valign="top">Delete<SUP>&#8224;</SUP></TD></TR>

<TR><td valign="top">VK_HELP</TD>
<td valign="top">2F</TD>
<td valign="top">Help key</TD></TR>

<TR><td valign="top">VK_0 - VK_9</TD>
<td valign="top">30_39</TD>
<td valign="top">09 keys</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">3A_40</TD>
<td valign="top">Undefined</TD></TR>

<TR><td valign="top">VK_A - VK_Z</TD>
<td valign="top">41_5A</TD>
<td valign="top">A through Z keys</TD></TR>

<TR><td valign="top">VK_LWIN</TD>
<td valign="top">5B</TD>
<td valign="top">Windows key</TD></TR>

<TR><td valign="top">VK_RWIN</TD>
<td valign="top">5C</TD>
<td valign="top">Windows key *</TD></TR>

<TR><td valign="top">VK_APPS</TD>
<td valign="top">5D</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">5E_5F</TD>
<td valign="top">Undefined</TD></TR>

<TR><td valign="top">VK_NUMPAD0 - 9</TD>
<td valign="top">60_69</TD>
<td valign="top">Numeric keypad 0_9 keys</TD></TR>

<TR><td valign="top">VK_MULTIPLY</TD>
<td valign="top">6A</TD>
<td valign="top">Numeric keypad Asterisk (*) key</TD></TR>

<TR><td valign="top">VK_ADD</TD>
<td valign="top">6B</TD>
<td valign="top">Numeric keypad Plus sign (+) key</TD></TR>

<TR><td valign="top">VK_SEPARATOR</TD>
<td valign="top">6C</TD>
<td valign="top">Separator key</TD></TR>

<TR><td valign="top">VK_SUBTRACT</TD>
<td valign="top">6D</TD>
<td valign="top">Numeric keypad Minus sign (-) key</TD></TR>

<TR><td valign="top">VK_DECIMAL</TD>
<td valign="top">6E</TD>
<td valign="top">Numeric keypad Period (.) key</TD></TR>

<TR><td valign="top">VK_DIVIDE</TD>
<td valign="top">6F</TD>
<td valign="top">Numeric keypad Slash mark (/) key</TD></TR>

<TR><td valign="top">VK_F1 - VK_F24</TD>
<td valign="top">70_87</TD>
<td valign="top"> F1 _ F24 *</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">88_8F</TD>
<td valign="top">Unassigned</TD></TR>

<TR><td valign="top">VK_NUMLOCK</TD>
<td valign="top">90</TD>
<td valign="top">Num Lock *</TD></TR>

<TR><td valign="top">VK_SCROLL</TD>
<td valign="top">91</TD>
<td valign="top">Scroll Lock *</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">92_9F</TD>
<td valign="top">Unassigned</TD></TR>

<TR><td valign="top">VK_LSHIFT</TD>
<td valign="top">A0</TD>
<td valign="top">Left Shift<SUP>&#8225;</SUP></TD></TR>

<TR><td valign="top">VK_RSHIFT</TD>
<td valign="top">A1</TD>
<td valign="top">Right Shift<SUP>&#8225;</SUP></TD></TR>

<TR><td valign="top">VK_LCONTROL</TD>
<td valign="top">A2</TD>
<td valign="top">Left Control<SUP>&#8225;</SUP></TD></TR>

<TR><td valign="top">VK_RCONTROL</TD>
<td valign="top">A3</TD>
<td valign="top">Right Control<SUP>&#8225;</SUP></TD></TR>

<TR><td valign="top">VK_LMENU</TD>
<td valign="top">A4</TD>
<td valign="top">Left Alt<SUP>&#8225;</SUP></TD></TR>

<TR><td valign="top">VK_RMENU</TD>
<td valign="top">A5</TD>
<td valign="top">Right Alt<SUP>&#8225;</SUP></TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">A6_B9</TD>
<td valign="top"> Unassigned</TD></TR>

<TR><td valign="top">VK_SEMICOLON</TD>
<td valign="top">BA</TD>
<td valign="top">; key</TD></TR>

<TR><td valign="top">VK_EQUAL</TD>
<td valign="top">BB</TD>
<td valign="top">= key</TD></TR>

<TR><td valign="top">VK_COMMA</TD>
<td valign="top">BC</TD>
<td valign="top">, key</TD></TR>

<TR><td valign="top">VK_HYPHEN</TD>
<td valign="top">BD</TD>
<td valign="top">- key</TD></TR>

<TR><td valign="top">VK_PERIOD</TD>
<td valign="top">BE</TD>
<td valign="top">. key</TD></TR>

<TR><td valign="top">VK_SLASH</TD>
<td valign="top">BF</TD>
<td valign="top">/ key</TD></TR>

<TR><td valign="top">VK_BACKQUOTE</TD>
<td valign="top">C0</TD>
<td valign="top">` key</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">C1-DA</TD>
<td valign="top">Unassigned</TD></TR>

<TR><td valign="top">VK_LBRACKET</TD>
<td valign="top">DB</TD>
<td valign="top">[ key</TD></TR>

<TR><td valign="top">VK_BACKSLASH</TD>
<td valign="top">DC</TD>
<td valign="top">\ key</TD></TR>

<TR><td valign="top">VK_RBRACKET</TD>
<td valign="top">DD</TD>
<td valign="top">] key</TD></TR>

<TR><td valign="top">VK_APOSTROPHE</TD>
<td valign="top">DE</TD>
<td valign="top">` key</TD></TR>

<TR><td valign="top">VK_OFF</TD>
<td valign="top">DF</TD>
<td valign="top">Power button</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">E5</TD>
<td valign="top">Unassigned</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">E6</TD>
<td valign="top">OEM-specific</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">E7_E8</TD>
<td valign="top">Unassigned</TD></TR>

<TR><td valign="top">--</TD>
<td valign="top">E9_F5</TD>
<td valign="top">OEM-specific</TD></TR>

<TR><td valign="top">VK_ATTN</TD>
<td valign="top">F6</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_CRSEL</TD>
<td valign="top">F7</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_EXSEL</TD>
<td valign="top">F8</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_EREOF</TD>
<td valign="top">F9</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_PLAY</TD>
<td valign="top">FA</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_ZOOM</TD>
<td valign="top">FB</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_NONAME</TD>
<td valign="top">FC</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_PA1</TD>
<td valign="top">FD</TD>
<td valign="top"></TD></TR>

<TR><td valign="top">VK_OEM_CLEAR</TD>
<td valign="top">FE</TD>
<td valign="top"></TD></TR>
</table>

<P>*     Many Windows CE Systems don't have this key.

<P>&#8224;     On some Windows CE systems, Delete is simulated with Shift-Backspace

<P>&#8225;     These constants can be used only with <I>GetKeyState</I> and <I>GetAsyncKeyState.</I>

<P>&#167;     Mouse right and middle buttons are defined but are relevant only on a Windows CE system equipped with a mouse.


<P>For the WM_CHAR and WM_SYSCHAR messages, the <I>wParam</I> value contains the Unicode character represented by the key. Most often an application can simply look for WM_CHAR messages and ignore WM_KEYDOWN and WM_KEYUP. The WM_CHAR message allows for a second level of abstraction so that the application doesn't have to worry about the up or down state of the keys and can concentrate on the characters being entered by means of the keyboard.

<P>The <I>lParam</I> value of any of these keyboard messages contains further information about the pressed key. The format of the <I>lParam</I> parameter is shown in Figure 3-3.

<P><B>Figure 3-2.</B> <I>Keys on a PC keyboard that are rarely on a Windows CE keyboard.</I>

<P><PRE>
InsertDelete (Many Windows CE keyboards use Shift-Backspace for this function.)
Num LockPause
Print Screen
Scroll Lock
Function Keys
Windows Context Menu key

</PRE>

<P> The low word, bits 0 through 15, contains the repeat count of the key. Often, keys on a Windows CE device can be pressed faster than Windows CE can send messages to the focus application. In these cases, the repeat count contains the number of times the key has been pressed. Bit 29 contains the context flag. If the Alt key was being held down when the key was pressed, this bit will be set. Bit 30 contains the previous key state. If the key was previously down, this bit is set; otherwise it's 0. Bit 30 can be used to determine whether the key message is the result of an auto-repeat sequence. Bit 31 indicates the transition state. If the key is in transition from down to up, Bit 31 is set. The Reserved field, bits 16 through 28, is used in the desktop versions of Windows to indicate the key scan code. In almost all cases, Windows CE doesn't support this field. However, on some of the newer Windows CE platforms where scan codes are necessary, this field does contain the scan code. You shouldn't plan on the scan code field being available unless you know it's supported on your specific platform.

<P><A HREF="javascript:fullSize('f03rg03x.htm')"> <img src="f03rg03.jpg" width=404 height=107 border="0" ALT="Click to view at full size."></a>
<P><!-- caption --><B>Figure 3-3.</B> <I>The layout of the </I>lParam<I> value for key messages.</I><!-- /caption -->

<P>One additional keyboard message, WM_DEADCHAR, can sometimes come into play. You send it when the pressed key represents a dead character, such as an umlaut, that you want to combine with a character to create a different character. In this case the WM_DEADCHAR message can be used to prevent the text entry point (the caret) from advancing to the next space until the second key is pressed so that you can complete the combined character.

<P>The WM_DEADCHAR message has always been present under Windows, but under Windows CE it takes on a somewhat larger role. With the internationalization of small consumer devices that run Windows CE, programmers should plan for, and if necessary use, the WM_DEADCHAR message that is so often necessary in foreign language systems.

<A NAME="76"><H2>Keyboard Functions</H2></A>

<P>You will find useful a few other keyboard-state-determining functions for Windows applications. Among the keyboard functions, two are closely related but often confused: <I>GetKeyState</I> and <I>GetAsyncKeyState</I>.

<P><I>GetKeyState,</I> prototyped as

<p><pre>
SHORT GetKeyState (int nVirtKey);
</pre>

<P>returns the up/down state of the shift keys, Ctrl, Alt, and Shift, and indicates whether any of these keys is in a toggled state. If the keyboard has two keys with the same function&#8212;for example, two Shift keys, one on each side of the keyboard&#8212;this function can also be used to differentiate which of them is being pressed. (Most keyboards have left and right Shift keys, and some include left and right Ctrl and Alt keys.)

<P>You pass to the function the virtual key code for the key being queried. If the high bit of the return value is set, the key is down. If the least significant bit of the return value is set, the key is in a toggled state; that is, it has been pressed an odd number of times since the system was started. The state returned is the state at the time the most recent message was read from the message queue, which isn't necessarily the real-time state of the key. An interesting aside: notice that the virtual key label for the Alt key is VK_MENU, which relates to the windows convention that the Alt-shift key combination works in concert with other keys to access various menus from the keyboard.

<P>Note that the <I>GetKeyState</I> function is limited under Windows CE to querying the state of the shift keys. Under other versions of Windows, <I>GetKeyState</I> can determine the state of every key on the keyboard.

<P>To determine the real-time state of a key, use

<p><pre>
SHORT GetAsyncKeyState (int vKey);
</pre>

<P>As with <I>GetKeyState</I>, you pass to this function the virtual key code for the key being queried. The <I>GetAsyncKeyState</I> function returns a value subtly different from the one returned by <I>GetKeyState</I>. As with the <I>GetKeyState </I>function, the high bit of the return value is set while the key is being pressed. However, the least significant bit is then set if the key was pressed after a previous call to <I>GetAsyncKeyState</I>. Like <I>GetKeyState</I>, the <I>GetAsyncKeyState</I> function can distinguish the left and right Shift, Ctrl, and Alt keys. In addition, by passing the VK_LBUTTON virtual key value, <I>GetAsyncKeyState</I> determines whether the stylus is currently touching the screen.

<P>An application can simulate a keystroke using the <I>keybd_event</I> function:

<p><pre>
VOID keybd_event (BYTE bVk, BYTE bScan, DWORD dwFlags,
                  DWORD dwExtraInfo);
</pre>

<P>The first parameter is the virtual key code of the key to simulate. The <I>bScan </I>code should be set to NULL under Windows CE. The <I>dwFlags</I> parameter can have two possible flags: KEYEVENTF_KEYUP indicates that the call is to emulate a key up event while KEYEVENTF_SILENT indicates that the simulated key press won't cause the standard keyboard click that you normally hear when you press a key. So, to fully simulate a key press, <I>keybd_event</I> should be called twice, once without KEYEVENTF_KEYUP to simulate a key down, then once again, this time <I>with </I>KEYEVENTF_KEYUP to simulate the key release.

<P>One final keyboard function, <I>MapVirtualKey</I>, translates virtual key codes to characters. <I>MapVirtualKey</I> in Windows CE doesn't translate keyboard scan codes to and from virtual key codes, although it does so in other versions of Windows. The prototype of the function is the following:

<p><pre>
<P>UINT MapVirtualKey (UINT uCode, UINT uMapType);
</pre>

<P>Under Windows CE, the first parameter is the virtual key code to be translated while the second parameter, <I>uMapType</I>, must be set to 2.

<A NAME="77"><H3>Testing for the keyboard</H3></A>

<P>To determine whether a keyboard is even present in the system, first call <I>GetVersionEx</I> to find out which version of Windows CE is running. All systems that run Windows CE 1.0 have a keyboard. When running under Windows CE 2.0 or later, call

<p><pre>
<P>DWORD GetKeyboardStatus (VOID);
</pre>

<P>This function returns the KBDI_KEYBOARD_PRESENT flag if a hardware keyboard is present in the system. This function also returns a KBDI_KEYBOARD_ENABLED flag if the keyboard is enabled. To disable the keyboard, a call can be made to

<p><pre>
<P>BOOL EnableHardwareKeyboard (BOOL bEnable);
</pre>

<P>with the <I>bEnable</I> flag set to FALSE. You might want to disable the keyboard in a system for which the keyboard folds around behind the screen; in such a system, a user could accidentally hit keys while using the stylus. This function is also new to Windows CE 2.0.

<P>If you build an application to run under Windows CE 1.0, you'll need to explicitly load both <I>GetKeyboardStatus</I> and <I>EnableHardwareKeyboard</I> using <I>LoadLibrary</I> and <I>GetProcAddress</I> to determine the address of these 2.0-specific functions. If a call is made directly to a 2.0 function from an application, that application is incompatible with Windows CE 1.0 and won't load.

<A NAME="78"><H2>The KeyTrac Example Program</H2></A>

<P>The following example program, KeyTrac, displays the sequence of keyboard messages. Programmatically, KeyTrac isn't much of a departure from the earlier programs in the book. The difference is that the keyboard messages I've been describing are all trapped and recorded in an array that's then displayed during the WM_PAINT message. For each keyboard message, the message name is recorded along with the <I>wParam</I> and <I>lParam</I> values and a set of flags indicating the state of the shift keys. The key messages are recorded in an array because these messages can occur faster than the redraw can occur. Figure 3-4 shows the KeyTrac window after a few keys have been pressed.

<P><A HREF="javascript:fullSize('f03rg04x.htm')"> <img src="f03rg04.jpg" width=404 height=203 border="0" ALT="Click to view at full size."></a>
<P><!-- caption --><B>Figure 3-4.</B> <I>The KeyTrac window after a Shift-A key combination followed by a lowercase </I>a <I>key press.</I><!-- /caption -->

<P>The best way to learn about the sequence of the keyboard messages is to run KeyTrac, press a few keys, and watch the messages scroll down the screen. Pressing a character key such as the <I>a</I> results in three messages: WM_KEYDOWN, WM_CHAR, and WM_KEYUP. Holding down the Shift key while pressing the <I>a</I> and then releasing the Shift key produces a key-down message for the Shift key followed by the three messages for the <I>a</I> key followed by a key-up message for the Shift key. Because the Shift key itself isn't a character key, no WM_CHAR message is sent in response to it. However, the WM_CHAR message for the <I>a</I> key now contains a <I>0x41</I> in the <I>wParam</I> value, indicating that an uppercase <I>A</I> was entered instead of a lowercase <I>a</I>.

<P>Figure 3-5 shows the source code for the KeyTrac program.

<P><B>Figure 3-5.</B> <I>The KeyTrac program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="79"><H3>KeyTrac.h</H3></A>
<p><pre>
//======================================================================
// Header file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//

struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR 1                           // Command bar ID

//----------------------------------------------------------------------
// Program-specific defines and structures
//
#define FLAG_LMENU       0x0001
#define FLAG_RMENU       0x0002
#define FLAG_LCONTROL    0x0004
#define FLAG_RCONTROL    0x0008
#define FLAG_LSHIFT      0x0010
#define FLAG_RSHIFT      0x0020

typedef struct {
    UINT wKeyMsg;
    INT wParam;
    INT lParam;
    UINT wFlags;
    TCHAR szMsgTxt[64];
} KEYARRAY, *PKEYARRAY;

//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoKeysMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="80"><H3>KeyTrac.c</H3></A>
<p><pre>
//======================================================================
// KeyTrac - displays keyboard messages

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;keytrac.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;KeyTrac&quot;);
HINSTANCE hInst;                     // Program instance handle

// Program-specific global data
KEYARRAY ka[16];
UINT wKeyMsg = 0;
INT nKeyCnt = 0, nFontHeight;
TCHAR szMsgTxt[64];

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_PAINT, DoPaintMain,
    WM_KEYUP, DoKeysMain,
    WM_KEYDOWN, DoKeysMain,
    WM_CHAR, DoKeysMain,
    WM_DEADCHAR, DoKeysMain,
    WM_SYSCHAR, DoKeysMain,
    WM_SYSDEADCHAR, DoKeysMain,
    WM_SYSKEYDOWN, DoKeysMain,
    WM_SYSKEYUP, DoKeysMain,
    WM_DESTROY, DoDestroyMain,
};

//======================================================================
//
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndMain;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;
    
    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass(&amp;wc) == 0) return 1;

    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow) {
                   HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,           // Window class
                         TEXT (&quot;KeyTrac&quot;),    // Window title
                         WS_VISIBLE,          // Style flags
                         CW_USEDEFAULT,       // x position
                         CW_USEDEFAULT,       // y position
                         CW_USEDEFAULT,       // Initial Width
                         CW_USEDEFAULT,       // Initial Height
                         NULL,                // Parent 
                         NULL,                // Menu, must be null
                         hInstance,           // App instance
                         NULL);               // Pointer to create
                                              // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//

//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam, 
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam) {
    HWND hwndCB;
    HDC hdc;
    TEXTMETRIC tm;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);

    // Get the height of the default font.
    hdc = GetDC (hWnd);
    GetTextMetrics (hdc, &amp;tm);
    nFontHeight = tm.tmHeight + tm.tmExternalLeading;
    ReleaseDC (hWnd, hdc);

    return 0;
}
//----------------------------------------------------------------------
// DoPaintMain - Process WM_PAINT message for window.
//
LRESULT DoPaintMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                     LPARAM lParam) {
    PAINTSTRUCT ps;
    RECT rect, rectOut;
    TCHAR szOut[256];
    HDC hdc;
    INT i;

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    // Create a drawing rectangle for the bottom line of the window.
    rectOut = rect;
    rectOut.top = rectOut.bottom - nFontHeight;

    hdc = BeginPaint (hWnd, &amp;ps); 

    if (nKeyCnt) {
        for (i = 0; i &lt; nKeyCnt; i++) {
            // Scroll window up by one line.
            ScrollDC (hdc, 0, -nFontHeight, &amp;rect, &amp;rect, NULL, NULL);
            // Write key name, use opaque mode to erase background.
            ExtTextOut (hdc, 5, rect.bottom - nFontHeight, ETO_OPAQUE,
                        &amp;rectOut, ka[i].szMsgTxt, 
                        lstrlen (ka[i].szMsgTxt), NULL);
            // Write key variables.
            wsprintf (szOut, TEXT (&quot;wParam:%08x    lParam:%08x    shift: &quot;), 
                      ka[i].wParam, ka[i].lParam);

            if (ka[i].wFlags &amp; FLAG_LMENU)
                lstrcat (szOut, TEXT (&quot;lA &quot;));
            if (ka[i].wFlags &amp; FLAG_RMENU)
                lstrcat (szOut, TEXT (&quot;rA &quot;));

            if (ka[i].wFlags &amp; FLAG_LCONTROL)
                lstrcat (szOut, TEXT (&quot;lC &quot;));
            if (ka[i].wFlags &amp; FLAG_RCONTROL)
                lstrcat (szOut, TEXT (&quot;rC &quot;));

            if (ka[i].wFlags &amp; FLAG_LSHIFT)
                lstrcat (szOut, TEXT (&quot;lS &quot;));
            if (ka[i].wFlags &amp; FLAG_RSHIFT)
                lstrcat (szOut, TEXT (&quot;rS &quot;));

            ExtTextOut (hdc, 125, rect.bottom - nFontHeight, 0, NULL,
                        szOut, lstrlen (szOut), NULL);
        }
        nKeyCnt = 0;
    }
    EndPaint (hWnd, &amp;ps); 
    return 0;
}
//----------------------------------------------------------------------
// DoKeysMain - Process all keyboard messages for window.
//
LRESULT DoKeysMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                    LPARAM lParam) {

    if (nKeyCnt &gt;= 16)
        return 0;

    switch (wMsg) {
        case WM_KEYUP:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_KEYUP&quot;));
            break;

        case WM_KEYDOWN:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_KEYDOWN&quot;));
            break;

        case WM_CHAR:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_CHAR&quot;));
            break;

        case WM_DEADCHAR:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_DEADCHAR&quot;));
            break;

        case WM_SYSCHAR:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_SYSCHAR&quot;));
            break;

        case WM_SYSDEADCHAR:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_SYSDEADCHAR&quot;));
            break;

        case WM_SYSKEYDOWN:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_SYSKEYDOWN&quot;));
            break;

        case WM_SYSKEYUP:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;WM_SYSKEYUP&quot;));
            break;

        default:
            lstrcpy (ka[nKeyCnt].szMsgTxt, TEXT (&quot;unknown&quot;));
            break;
    }
    ka[nKeyCnt].wKeyMsg = wMsg;
    ka[nKeyCnt].wParam = wParam;
    ka[nKeyCnt].lParam = lParam;

    // Capture the state of the shift flags.
    ka[nKeyCnt].wFlags = 0;
    if (GetKeyState (VK_LMENU))
        ka[nKeyCnt].wFlags |= FLAG_LMENU;
    if (GetKeyState (VK_RMENU))
        ka[nKeyCnt].wFlags |= FLAG_RMENU;

    if (GetKeyState (VK_LCONTROL))
        ka[nKeyCnt].wFlags |= FLAG_LCONTROL;
    if (GetKeyState (VK_RCONTROL))
        ka[nKeyCnt].wFlags |= FLAG_RCONTROL;

    if (GetKeyState (VK_LSHIFT))
        ka[nKeyCnt].wFlags |= FLAG_LSHIFT;
    if (GetKeyState (VK_RSHIFT))
        ka[nKeyCnt].wFlags |= FLAG_RSHIFT;

    nKeyCnt++;
    InvalidateRect (hWnd, NULL, FALSE);
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
</pre>
</td></tr></table>

<P>Here are a few more characteristics of KeyTrac to notice. After each keyboard message is recorded, an <I>InvalidateRect</I> function is called to force a redraw of the window and therefore also a WM_PAINT message. As I mentioned in <A HREF="ch02a.htm">Chapter 2</a>, a program should never attempt to send or post a WM_PAINT message to a window because Windows needs to perform some setup before it calls a window with a WM_PAINT message.

<P>Another device context function used in KeyTrac is

<P><pre>
BOOL ScrollDC (HDC hDC, int dx, int dy, const RECT *lprcScroll,
              const RECT *lprcClip, HRGN hrgnUpdate,
              LPRECT lprcUpdate);
</pre>

<P>which scrolls an area of the device context either horizontally or vertically, but under Windows CE, not both directions at the same time. The three rectangle parameters define the area to be scrolled, the area within the scrolling area to be clipped, and the area to be painted after the scrolling ends. Alternatively, a handle to a region can be passed to <I>ScrollDC</I>. That region is defined by <I>ScrollDC</I> to encompass the region that needs painting after the scroll.

<P>Finally, if the KeyTrac window is covered up for any reason and then reexposed, the message information on the display is lost. This is because a device context doesn't store the bit information of the display. The application is responsible for saving any information necessary to completely restore the client area of the screen. Since Keytrac doesn't save this information, it's lost when the window is covered up.

</BODY>
</HTML>




