<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Basic Serial Communication</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="346"><H1>Basic Serial Communication</H1></A>

<P>The interface for a serial device is a combination of generic driver I/O calls and specific communication-related functions. The serial device is treated as a generic, installable, stream device for opening, closing, reading, and writing the serial port. For configuring the port, the Win32 API supports a set of Comm functions. Windows CE supports most of the Comm functions supported by Windows NT and Windows 98.

<P>A word of warning: programming a serial port under Windows CE isn't like programming one under MS-DOS. You can't simply find the base address of the serial port and program the registers directly. While there are ways for a program to gain access to the physical memory space, every Windows CE device has a different physical memory map. Even if you solved the access problem by knowing exactly where the serial hardware resided in the memory map, there's no guarantee the serial hardware is going to be compatible with the 8250 (or, these days, a 16550) serial interface we've all come to know and love in the PC world. In fact, the implementation of the serial port on some Windows CE devices looks nothing like an 8250.

<P>But even if you know where to go in the memory map and the implementation of the serial hardware, you still don't need to &quot;hack down to the hardware.&quot; The serial port drivers in Windows CE are efficient, interrupt-driven designs and are written to support its specific serial hardware. If you have any special needs not provided by the base serial driver, you can purchase the Embedded Toolkit and write a serial driver yourself. Aside from that extreme case, there's just no reason not to use the published Win32 serial interface under Windows CE.

<A NAME="347"><H2>Opening and Closing a Serial Port</H2></A>

<P>As with all stream device drivers, a serial port device is opened using <I>CreateFile</I>. The name used needs to follow the standards I described previously, with the three letters COM followed by the number of the COM port to open and then a colon. The colon is required under Windows CE and is a departure from the naming convention used for device driver names used in Windows NT and Windows 98. The following line opens COM port 1 for reading and writing:

<p><pre>
hSer = CreateFile (TEXT (&quot;COM1:&quot;), GENERIC_READ | GENERIC_WRITE,
                   0, NULL, OPEN_EXISTING, 0, NULL);
</PRE>

<P>You must pass a 0 in the sharing parameter as well as in the security attributes and the template file parameters of <I>CreateFile</I>. Windows CE doesn't support overlapped I/O for devices, so you can't pass the FILE_FLAG_OVERLAPPED flag in the <I>dwFlagsAndAttributes</I> parameter. The handle returned is either the handle to the opened serial port or INVALID_HANDLE_VALUE. Remember that, unlike many of the Windows functions, <I>CreateFile</I> doesn't return a 0 for a failed open.

<P>You close a serial port by calling <I>CloseHandle</I>, as in the following:

<p><pre>
CloseHandle (hSer);
</PRE>

<P>You don't do anything differently when using <I>CloseHandle</I> to close a serial device than when you use it to close a file handle.

<A NAME="348"><H2>Reading and Writing to a Serial Port</H2></A>


<P>Just as you use the <I>CreateFile</I> function to open a serial port, you use the functions <I>ReadFile</I> and <I>WriteFile</I> to write to that serial port. Reading data from a serial port is as simple as making this call to <I>ReadFile</I>:

<p><pre>
INT rc;
DWORD cBytes;
BYTE ch;


rc = ReadFile(hSer, &amp;ch, 1, &amp;cBytes, NULL);
</PRE>

<P>This call assumes the serial port has been successfully opened with a call to <I>CreateFile</I>. If the call is successful, one byte is read into the variable <I>ch</I>, and <I>cBytes</I> is set to the number of bytes read.

<P>Writing to a serial port is just as simple. The call would look something like the following:

<p><pre>
INT rc;
DWORD cBytes;

BYTE ch;

ch = TEXT (`a');
rc = WriteFile(hSer, &amp;ch, 1, &amp;cBytes, NULL);
</PRE>

<P>This code writes the character <I>a</I> to the serial port previously opened. As you may remember from <A HREF="ch07a.htm">Chapter 7</a>, both <I>ReadFile</I> and <I>WriteFile</I> return TRUE if successful.

<P>Since overlapped I/O isn't supported under Windows CE, you should be careful not to attempt to read or write a large amount of serial data from your primary thread or from any thread that has created a window. Because those threads are also responsible for handling the message queues for their windows, they can't be blocked waiting on a relatively slow serial read or write. Instead, you should use separate threads for reading and writing the serial port.

<P>You can also transmit a single character using this function:

<p><pre>
BOOL TransmitCommChar (HANDLE hFile, char cChar);
</PRE>

<P>The difference between <I>TransmitCommChar</I> and <I>WriteFile</I> is that <I>TransmitCommChar</I> puts the character to be transmitted at the front of the transmit queue. When you call <I>WriteFile</I>, the characters are queued up after any characters that haven't yet been transmitted by the serial driver. <I>TransmitCommChar</I> allows you to insert control characters quickly in the stream without having to wait for the queue to empty.

<A NAME="349"><H2>Asynchronous Serial I/O</H2></A>

<P>While Windows CE doesn't support overlapped I/O, there's no reason why you can't use multiple threads to implement the same type of overlapped operation. All that's required is that you launch separate threads to handle the synchronous I/O operations while your primary thread goes about its business. In addition to using separate threads for reading and writing, Windows CE supports the Win32 <I>WaitCommEvent</I> function that blocks a thread until one of a group of preselected serial events occurs. I'll demonstrate how to use separate threads for reading and writing a serial port in the CeChat example program later in this chapter.

<P>You can make a thread wait on serial driver events by means of the following three functions:


<p><pre>
BOOL SetCommMask (HANDLE hFile, DWORD dwEvtMask);
BOOL GetCommMask (HANDLE hFile, LPDWORD lpEvtMask);
</PRE>

<P>and

<p><pre>
BOOL WaitCommEvent (HANDLE hFile, LPDWORD lpEvtMask,
                     LPOVERLAPPED lpOverlapped);
</PRE>

<P>To wait on an event, you first set the event mask using <I>SetCommMask</I>. The parameters for this function are the handle to the serial device and a combination of the following event flags:

<UL>
<P><LI><I>EV_BREAK</I> A break was detected.
<P><LI><I>EV_CTS</I> The Clear to Send (CTS) signal changed state.
<P><LI><I>EV_DSR</I> The Data Set Ready (DSR) signal changed state.
<P><LI><I>EV_ERR</I> An error was detected by the serial driver.
<P><LI><I>EV_RLSD</I> The Receive Line Signal Detect (RLSD) line changed state.
<P><LI><I>EV_RXCHAR</I> A character was received.
<P><LI><I>EV_RXFLAG</I> An event character was received.
<P><LI><I>EV_TXEMPTY</I> The transmit buffer is empty.
</UL>

<P>You can set any or all of the flags in this list at the same time using <I>SetCommMask</I>. You can query the current event mask using <I>GetCommMask</I>.

<P>To wait on the events specified by <I>SetCommMask</I>, you call <I>WaitCommEvent</I>. The parameters for this call are the handle to the device, a pointer to a DWORD that will receive the reason the call returned, and <I>lpOverlapped</I>, which under Windows CE must be set to NULL. The code fragment that follows waits on a character being received or an error. The code assumes that the serial port has already been opened and the handle is contained in <I>hComPort</I>.

<p><pre>
DWORD dwMask;
// Set mask and wait.
SetCommMask (hComPort, EV_RXCHAR | EV_ERR);
if (WaitCommEvent (hComPort, &amp;dwMask, 0) {

    // Use the flags returned in dwMask to determine the reason
    // for returning.
    Switch (dwMask) {
    case EV_RXCHAR:
         //Read character.
         break;
    case EV_ERR:
         // Process error.
         break;
    }
}
</PRE>

<A NAME="350"><H2>Configuring the Serial Port</H2></A>

<P>Reading and writing to a serial port is fairly straightforward, but you also must configure the port for the proper baud rate, character size, and so forth. The masochist could configure the serial driver through device I/O control (IOCTL) calls but the <I>IoCtl</I> codes necessary for this are exposed only in the Embedded Toolkit, not the Software Development Kit. Besides, here's a simpler method.

<P>You can go a long way in configuring the serial port using two functions, <I>GetCommState</I> and <I>SetCommState,</I> prototyped here:

<p><pre>
BOOL SetCommState (HANDLE hFile, LPDCB lpDCB);
BOOL GetCommState (HANDLE hFile, LPDCB lpDCB);
</PRE>

<P>Both these functions take two parameters, the handle to the opened serial port and a pointer to a DCB structure. The extensive DCB structure is defined as follows:

<p><pre>
typedef struct _DCB {
   DWORD DCBlength;
   DWORD BaudRate;
   DWORD fBinary: 1;
   DWORD fParity: 1;
   DWORD fOutxCtsFlow:1;
   DWORD fOutxDsrFlow:1;
   DWORD fDtrControl:2;
   DWORD fDsrSensitivity:1;
   DWORD fTXContinueOnXoff:1;
   DWORD fOutX: 1;
   DWORD fInX: 1;
   DWORD fErrorChar: 1;
   DWORD fNull: 1;
   DWORD fRtsControl:2;
   DWORD fAbortOnError:1;
   DWORD fDummy2:17;
   WORD wReserved;
   WORD XonLim;
   WORD XoffLim;
   BYTE ByteSize;
   BYTE Parity;
   BYTE StopBits;
   char XonChar;
   char XoffChar;
   char ErrorChar;
   char EofChar;
   char EvtChar;
   WORD wReserved1;
} DCB;
</PRE>

<P>As you can see from the structure, the <I>SetCommState</I> can set a fair number of states. Instead of attempting to fill out the entire structure from scratch, you should use the best method of modifying a serial port, which is to call <I>GetCommState</I> to fill in a DCB structure, modify the fields necessary, and then call <I>SetCommState</I> to configure the serial port.

<P>The first field in the DCB structure, <I>DCBlength,</I> should be set to the size of the structure. The <I>BaudRate</I> field should be set to one of the baud rate constants defined in WINBASE.H. The baud rate constants range from CBR_110 for 110 bits per second to CBR_256000 for 256 kilobits per second (Kbps). Just because constants are defined for speeds up to 256 Kbps doesn't mean that all serial ports support that speed. To determine what baud rates a serial port supports, you can call <I>GetCommProperties</I>,<I> </I>which I'll describe shortly. Windows CE devices generally support speeds up to 115 Kbps, although some support faster speeds. The <I>fBinary</I> field must be set to TRUE because no Win32 operating system currently supports a nonbinary serial transmit mode familiar to MS-DOS programmers. The <I>fParity</I> field can be set to TRUE to enable parity checking.

<P>The <I>fOutxCtsFlow</I> field should be set to TRUE if the output of the serial port should be controlled by the port CTS line. The <I>fOutxDsrFlow</I> field should be set to TRUE if the output of the serial port should be controlled by the DSR line of the serial port. The <I>fDtrControl</I> field can be set to one of three values: DTR_CONTROL_DISABLE, which disables the DTR (Data Terminal Ready) line and leaves it disabled; DTR_CONTROL_ENABLE, which enables the DTR line; or DTR_CONTROL_HANDSHAKE, which tells the serial driver to toggle the DTR line in response to how much data is in the receive buffer.

<P>The <I>fDsrSensitivity</I> field is set to TRUE, and the serial port ignores any incoming bytes unless the port DSR line is enabled. Setting the <I>fTXContinueOnXoff</I> field to TRUE tells the driver to stop transmitting characters if its receive buffer has reached its limit and the driver has transmitted an XOFF character. Setting the <I>fOutX</I> field to TRUE specifies that the XON/XOFF control is used to control the serial output. Setting the <I>fInX</I> field to TRUE specifies that the XON/XOFF control is used for the input serial stream.

<P>The <I>fErrorChar</I> and <I>ErrorChar</I> fields are ignored by the default implementation of the Windows CE serial driver although some drivers might support these fields. Likewise, the <I>fAbortOnError</I> fields is also ignored. Setting the <I>fNull</I> field to TRUE tells the serial driver to discard null bytes received.

<P>The <I>fRtsControl</I> field specifies the operation of the RTS (Request to Send) line. The field can be set to one of the following: RTS_CONTROL_DISABLE, indicating that the RTS line is set to the disabled state while the port is open; RTS_CONTROL_ENABLE, indicating that the RTS line is set to the enabled state while the port is open; or RTS_CONTROL_HANDSHAKE, indicating that the RTS line is controlled by the driver. In this mode, if the serial input buffer is less than half full, the RTS line is enabled and disabled otherwise. Finally, RTS_CONTROL_TOGGLE indicates the driver enables the RTS line if there are bytes in the output buffer ready to be transmitted and disables the line otherwise.

<P>The <I>XonLim</I> field specifies the minimum number of bytes in the input buffer before an XON character is automatically sent. The <I>XoffLim</I> field specifies the maximum number of bytes in the input buffer before the XOFF character is sent. This limit value is computed by taking the size of the input buffer and subtracting the value in <I>XoffLim</I>. In the sample Windows CE implementation of the serial driver provided in the ETK, the <I>XonLim</I> field is ignored and XON and XOFF characters are sent based on the value in <I>XoffLim</I>. However, this behavior might differ in some systems.

<P>The next three fields, <I>ByteSize</I>, <I>Parity</I>, and <I>StopBits</I>, define the format of the serial data word transmitted. The <I>ByteSize</I> field specifies the number of bits per byte, usually a value of 7 or 8, but in some older modes the number of bits per byte can be as small as 5. The parity field can be set to the self-explanatory constants EVENPARITY, MARKPARITY, NOPARITY, ODDPARITY, or SPACEPARITY. The <I>StopBits</I> field should be set to ONESTOPBIT, ONE5STOPBITS, or TWOSTOPBITS depending on whether you want one, one and a half, or two stop bits per byte.

<P>The next two fields, <I>XonChar</I> and <I>XoffChar</I>, let you specify the XON and XOFF characters. Likewise, the <I>EvtChar</I> field lets you specify the character used to signal an event. If an event character is received, an EV_RXFLAG event is signaled by the driver. This &quot;event&quot; is what triggers the <I>WaitCommEvent</I> function to return if the EV_RXFLAG bit is set in the event mask.

<A NAME="351"><H2>Setting the Port Timeout Values</H2></A>

<P>As you can see, <I>SetCommState</I> can fine-tune, to almost the smallest detail, the operation of the serial driver. However, one more step is necessary&#8212;setting the timeout values for the port. The timeout is the length of time Windows CE waits on a read or write operation before <I>ReadFile</I> or <I>WriteFile</I> automatically returns. The functions that control the serial timeouts are the following:

<p><pre>
BOOL GetCommTimeouts (HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
</PRE>


<P>and

<p><pre>
BOOL SetCommTimeouts (HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
</PRE>

<P>Both functions take the handle to the open serial device and a pointer to a COMMTIMEOUTS structure, defined as the following:

<p><pre>
typedef struct _COMMTIMEOUTS {
   DWORD ReadIntervalTimeout;
   DWORD ReadTotalTimeoutMultiplier;
   DWORD ReadTotalTimeoutConstant;
   DWORD WriteTotalTimeoutMultiplier;
   DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS;
</PRE>

<P>The COMMTIMEOUTS structure provides for a set of timeout parameters that time both the interval between characters and the total time to read and write a block of characters. Timeouts are computed in two ways. First <I>ReadIntervalTimeout</I> specifies the maximum interval between characters received. If this time is exceeded, the <I>ReadFile</I> call returns immediately. The other timeout is based on the number of characters you're waiting to receive. The value in <I>ReadTotalTimeoutMultiplier</I> is multiplied by the number of characters requested in the call to <I>ReadFile</I>, and is added to <I>ReadTotalTimeoutConstant</I> to compute a total timeout for a call to <I>ReadFile</I>.

<P>The write timeout can be specified only for the total time spent during the <I>WriteFile</I> call. This timeout is computed the same way as the total read timeout, by specifying a multiplier value, the time in <I>WriteTotalTimeoutMultiplier</I>, and a constant value in <I>WriteTotalTimeoutConstant</I>. All of the times in this structure are specified in milliseconds.

<P>In addition to the basic timeouts that I just described, you can set values in the COMMTIMEOUTS structure to control whether and exactly how timeouts are used in calls to <I>ReadFile</I> and <I>WriteFile</I>. You can configure the timeouts in the following ways:


<UL>
<P><LI>Timeouts for reading and writing as well as an interval timeout. Set the fields in the COMMTIMEOUTS structure for the appropriate timeout values.
<P><LI>Timeouts for reading and writing with no interval timeout. Set <I>ReadIntervalTimeout</I> to 0. Set the other fields for the appropriate timeout values.


<P><LI><I>ReadFile</I> returns immediately regardless of whether there is data to be read. Set <I>ReadIntervalTimeout</I> to MAXDWORD. Set <I>ReadTotalTimeoutMultiplier</I> and <I>ReadTotalTimeoutConstant</I> to 0.
<P><LI><I>ReadFile</I> doesn't have a timeout. The function doesn't return until the proper number of bytes is returned or an error occurs. Set <I>ReadIntervalTimeout</I>, <I>ReadTotalTimeoutMultiplier</I>, and <I>ReadTotalTimeoutConstant</I> to 0.
<P><LI>WriteFile doesn't have a timeout. Set <I>WriteTotalTimeoutMultiplier</I> and <I>WriteTotalTimeoutConstant</I> to 0.
</UL>


<P>The timeout values are important because the worst thing you can do is to spin in a loop waiting on characters from the serial port. While the calls to <I>ReadFile</I> and <I>WriteFile</I> are waiting on the serial port, the calling threads are efficiently blocked on an event object internal to the driver. This saves precious CPU and battery power during the serial transmit and receive operations. Of course, to block on the <I>ReadFile</I> and <I>WriteFile</I>, you'll have to create secondary threads because you can't have your primary thread blocked waiting on the serial port.

<P>Another call isn't quite as useful&#8212;<I>SetupComm,</I> prototyped this way:


<p><pre>
BOOL SetupComm (HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);
</PRE>

<P>This function lets you specify the size of the input and output buffers for the driver. However, the sizes passed in <I>SetupComm</I> are only recommendations, not requirements to the serial driver. For example, the example implementation of the serial driver in the ETK ignores these recommended buffer sizes.

<A NAME="352"><H2>Querying the Capabilities of the Serial Driver</H2></A>

<P>The configuration functions enable you to configure the serial driver, but with varied implementations of serial ports you need to know just what features a serial port supports before you configure it. The function <I>GetCommProperties</I> provides just this service. The function is prototyped this way:

<p><pre>
BOOL GetCommProperties (HANDLE hFile, LPCOMMPROP lpCommProp);
</PRE>

<P><I>GetCommProperties</I> takes two parameters: the handle to the opened serial driver, and a pointer to a COMMPROP structure defined as

<p><pre>
typedef struct _COMMPROP {
   WORD wPacketLength;
   WORD wPacketVersion;
   DWORD dwServiceMask;
   DWORD dwReserved1;
   DWORD dwMaxTxQueue;
   DWORD dwMaxRxQueue;
   DWORD dwMaxBaud;
   DWORD dwProvSubType;
   DWORD dwProvCapabilities;
   DWORD dwSettableParams;
   DWORD dwSettableBaud;
   WORD wSettableData;
   WORD wSettableStopParity;
   DWORD dwCurrentTxQueue;
   DWORD dwCurrentRxQueue;
   DWORD dwProvSpec1;
   DWORD dwProvSpec2;
   WCHAR wcProvChar[1];
} COMMPROP;
</PRE>

<P>As you can see from the fields of the COMMPROP structure, <I>GetCommProperties</I> returns generally enough information to determine the capabilities of the device. Of immediate interest to speed demons is the <I>dwMaxBaud</I> field that indicates the maximum baud rate of the serial port. The <I>dwSettableBaud</I> field contains bit flags that indicate the allowable baud rates for the port. Both these fields use bit flags that are defined in WINBASE.H. These constants are expressed as BAUD_<I>xxxx</I>, as in BAUD_19200, which indicates the port is capable of a speed of 19.2 kbps. Note that these constants are <I>not</I> the constants used to set the speed of the serial port in the DCB structure. Those constants are numbers, not bit flags. To set the speed of a COM port in the DCB structure to 19.2 kbps, you would use the constant CBR_19200 in the <I>BaudRate</I> field of the DCB structure.

<P>Starting back at the top of the structure are the <I>wPacketLength</I> and <I>wPacketVersion</I> fields. These fields allow you to request more information from the driver than is supported by the generic call. The <I>dwServiceMask</I> field indicates what services the port supports. The only service currently supported is SP_SERIALCOMM, indicating that the port is a serial communication port.

<P>The <I>dwMaxTxQueue</I> and <I>dwMaxRxQueue</I> fields indicate the maximum size of the output and input buffers internal to the driver. A value of 0 in these fields indicates that you'll encounter no limit in the size of the internal queues. The <I>dwCurrentTxQueue</I> and <I>dwCurrentRxQueue</I> fields indicate the current size for the queues. These fields are 0 if the queue size can't be determined.

<P>The <I>dwProvSubType</I> field contains flags that indicate the type of serial port supported by the driver. Values here include PST_RS232, PST_RS422, and PST_RS423, indicating the physical layer protocol of the port. PST_MODEM indicates a modem device, and PST_FAX tells you the port is a fax device. This field reports what the driver thinks the port is, not what device is attached to the port. For example, if an external modem is attached to a standard, RS-232 serial port, the driver returns the PST_RS232 flag, not the PST_MODEM flag.

<P>The <I>dwProvCapabilities</I> field contains flags indicating the handshaking the port supports, such as XON/XOFF, RTS/CTS, and DTR/DSR. This field also shows you whether the port supports setting the characters used for XON/XOFF, parity checking, and so forth. The <I>dwSettableParams</I>, <I>dwSettableData</I>, and <I>dwSettableStopParity</I> fields give you information about how the serial data stream can be configured. Finally, the fields <I>dwProvSpec1</I>, <I>dwProvSpec2</I>, and <I>wcProvChar</I> are used by the driver to return driver-specific data.

<A NAME="353"><H2>Controlling the Serial Port</H2></A>

<P>You can stop and start a serial stream using the following functions:

<p><pre>
BOOL SetCommBreak (HANDLE hFile);
</PRE>

<P>and

<p><pre>
BOOL ClearCommBreak (HANDLE hFile);
</PRE>

<P>The only parameter for both these functions is the handle to the opened COM port. When <I>SetCommBreak</I> is called, the COM port stops transmitting characters and places the port in a break state. Communication is resumed with the <I>ClearCommBreak</I> function.

<P>You can clear out any characters in either the transmit or receive queues internal to the serial driver using this function:

<p><pre>
BOOL PurgeComm (HANDLE hFile, DWORD dwFlags);
</PRE>

<P>The <I>dwFlags</I> parameter can be a combination of the flags PURGE_TXCLEAR and PURGE_RXCLEAR. These flags terminate any pending writes and reads and reset the queues. In the case of PURGE_RXCLEAR, the driver also clears any receive holds due to any flow control states, transmitting an XON character if necessary, and setting RTS and DTR if those flow control methods are enabled. Since Windows CE doesn't support overlapped I/O, the flags PURGE_TXABORT and PURGE_RXABORT, used under Windows NT and Windows 98, are ignored.

<P>The <I>EscapeCommFunction</I> provides a more general method of controlling the serial driver. It allows you to set and clear the state of specific signals on the port. On Windows CE devices, it's also used to control serial hardware that's shared between the serial port and the IrDA port. (I'll talk more about infrared data transmission and the Infrared Data Association (IrDA) standard later in this chapter.) The function is prototyped as

<p><pre>
BOOL EscapeCommFunction (HANDLE hFile, DWORD dwFunc);
</PRE>

<P>The function takes two parameters, the handle to the device and a set of flags in <I>dwFunc</I>. The flags can be one of the following values:

<UL>
<P><LI><I>SETDTR</I> Sets the DTR signal.
<P><LI><I>CLRDTR</I> Clears the DTR signal.
<P><LI><I>SETRTS</I> Sets the RTS signal
<P><LI><I>CLRRTS</I> Clears the RTS) ignal.
<P><LI><I>SETXOFF</I> Tells the driver to act as if an XOFF character has been received.
<P><LI><I>SETXON</I> Tells the driver to act as if an XON character has been received.
<P><LI><I>SETBREAK</I> Suspends serial transmission and sets the port in a break state.
<P><LI><I>CLRBREAK</I> Resumes serial transmission from a break state.
<P><LI><I>SETIR</I> Tells the serial port to transmit and receive through the infrared transceiver.
<P><LI><I>CLRIR</I> Tells the serial port to transmit and receive through the standard serial transceiver.
</UL>

<P>The SETBREAK and CLRBREAK commands act identically to <I>SetCommBreak</I> and <I>ClearCommBreak</I> and can be used interchangeably. For example, you can use <I>EscapeCommFunction</I> to put the port in a break state and <I>ClearCommBreak</I> to restore communication.

<A NAME="354"><H2>Clearing Errors and Querying Status</H2></A>

<P>The function

<p><pre>
BOOL ClearCommError (HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat);
</PRE>

<P>performs two functions. As you might expect from the name, it clears any error states within the driver so that I/O can continue. The serial device driver is responsible for reporting the errors. The default serial driver returns the following flags in the variable pointed to by <I>lpErrors</I>: CE_OVERRUN, CE_RXPARITY, CE_FRAME, and CE_TXFULL. <I>ClearCommError</I> also returns the status of the port. The third parameter of <I>ClearCommError</I> is a pointer to a COMSTAT structure defined as

<p><pre>
typedef struct _COMSTAT {
   DWORD fCtsHold : 1;
   DWORD fDsrHold : 1;
   DWORD fRlsdHold : 1;
   DWORD fXoffHold : 1;
   DWORD fXoffSent : 1;
   DWORD fEof : 1;
   DWORD fTxim : 1;
   DWORD fReserved : 25;
   DWORD cbInQue;
   DWORD cbOutQue;
} COMSTAT;
</PRE>

<P>The first five fields indicate that serial transmission is waiting for one of the following reasons. It's waiting for a CTS signal, waiting for a DSR signal, waiting for a Receive Line Signal Detect (also known as a Carrier Detect), waiting for an XON character, or it's waiting because an XOFF character was sent by the driver. The <I>fEor</I> field indicates that an end-of-file character has been received. The <I>fTxim</I> field is TRUE if a character placed in the queue by the <I>TransmitCommChar</I> function instead of a call to <I>WriteFile </I>is queued for transmission. The final two fields, <I>cbInQue</I> and <I>cbOutQue,</I> return the number of characters in the input and output queues of the serial driver.

<P>The function

<p><pre>
BOOL GetCommModemStatus (HANDLE hFile, LPDWORD lpModemStat);
</PRE>

<P>returns the status of the modem control signals in the variable pointed to by <I>lpModemStat</I>. The flags returned can be any of the following:

<UL>
<P><LI><I>MS_CTS_ON</I> Clear to Send (CTS) is active.
<P><LI><I>MS_DSR_ON</I> Data Set Ready (DSR) is active.
<P><LI><I>MS_RING_ON</I> Ring Indicate (RI) is active.
<P><LI><I>MS_RLSD_ON</I> Receive Line Signal Detect (RLSD) is active.
</UL>

<A NAME="355"><H2>Stay'n Alive</H2></A>

<P>One of the issues with serial communication is preventing the system from powering down while a serial link is active. A Windows CE system determines activity by the number of key presses and screen taps. It doesn't take into account such tasks as a serial port transmitting data. To prevent a Windows CE device from powering off, you can simulate a keystroke using either of the following functions:

<p><pre>
VOID keybd_event (BYTE bVk, BYTE bScan, DWORD dwFlags,
                     DWORD dwExtraInfo);
</PRE>

<P>or


<p><pre>
UINT SendInput (UINT nInputs, LPINPUT pInputs, int cbSize);
</PRE>

<P>These functions can be used to simulate a keystroke that resets the activity timer used by Windows CE to determine when the system should automatically power down. Windows CE supports an additional constant for both these functions&#8212;KEYEVENTF_SILENT, which prevents the default keyboard click sound from being played.

</BODY>

</HTML>




