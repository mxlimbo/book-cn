<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Windows CE File System</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="247"><H1>The Windows CE File System</H1></A>

<P>The default file system, supported on all Windows CE platforms, is the object store. The object store is equivalent to the hard disk on a Windows CE device. It's a subtly complex file storage system incorporating compressed RAM storage for read/write files and seamless integration with ROM-based files. A user sees no difference between a file in RAM in the object store and those files based in ROM. Files in RAM and ROM can reside in the same directory, and document files in ROM can be opened (although not modified) by the user. In short, the object store integrates the default files provided in ROM with the user-generated files stored in RAM.

<P>In addition to the object store, Windows CE supports multiple, installable file systems that can support up to 256 different storage devices or partitions on storage devices. (The limit is 10 storage devices for Windows CE 2.0 and earlier.) The interface to these devices is the installable file system (IFS) API. Most Windows CE platforms include an IFS driver for the FAT file system for files stored on ATA flash cards or hard disks. In addition, under Windows CE 2.1 and later, third party manufacturers can write an IFS driver to support other file systems.

<P>Windows CE doesn't use drive letters as is the practice on PCs. Instead, every storage device is simply a directory off the root directory. Under Windows CE 1.0, an application can count on the name of the directory of the external drive being <I>PC Card</I>. If more than one PC Card was inserted, the additional ones are numbered, as in <I>PC Card 1</I> and <I>PC Card 2</I>, up to <I>PC Card 99</I> for the 100th card.<SUP>1</SUP> Under Windows CE 2.0, the default name was changed from <I>PC Card</I> to <I>Storage Card</I>, but the numbering concept stayed the same. For Windows CE 2.1, Windows CE doesn't assume a name. Instead it asks the driver what it wants to call the directory.<SUP>2</SUP> Later in this chapter, I'll demonstrate a method for determining which directories in the root are directories and which are actually storage devices.

<P>As should be expected for a Win32-compatible operating system, the filename format for Windows CE is the same as its larger counterparts. Windows CE supports long filenames. Filenames and their complete path can be up to MAX_PATH in length, which is currently defined at 260 bytes. Filenames have the same <I>name.ext</I> format as they do in other Windows operating systems. The extension is the three characters following the last period in the filename and defines the type of file. The file type is used by the shell when determining the difference between executable files and different documents. Allowable characters in filenames are the same as for Windows NT and Windows 98.

<P>Windows CE files support most of the same attribute flags as Windows 98 with a few additions. Attribute flags include the standard read-only, system, hidden, compressed, and archive flags. A few additional flags have been included to support the special RAM/ROM mix of files in the object store.

<A NAME="248"><H2>The Object Store vs. Other Storage Media</H2></A>

<P>To the programmer, the difference between files in the RAM part of the object store and the files based in ROM are subtle. The files in ROM can be detected by a special, in-ROM file attribute flag. However, files in the RAM part of the object store that are always compressed don't have the compressed file attribute as might be expected. The reason is that the compressed attribute is used to indicate when a file or directory is in a compressed state relative to the other files on the drive. In the object store, all files are compressed, which makes the compressed attribute redundant.

<P>The object store in Windows CE has some basic limitations. First, the size of the object store is limited to 16 MB of RAM. Given the compression features of the object store, this means that the amount of data that the object store can contain is somewhere around 32 MB. Individual files in the object store are limited to 4 MB under Windows CE 2.0 and earlier. Files under Windows CE 2.1 and later are limited only by the size of the object store's 16-MB limit. These file size limits don't apply to files on secondary storage such as hard disks, PC Cards, or Compact Flash Cards.

<A NAME="249"><H2>Standard File I/O</H2></A>

<P>Windows CE supports the most of the same file I/O functions found on Windows NT and Windows 98. The same Win32 API calls, such as <I>CreateFile</I>, <I>ReadFile</I>, <I>WriteFile</I> and <I>CloseFile</I>, are all supported. A Windows CE programmer must be aware of a few differences, however. First of all, the standard C file I/O functions, such as <I>fopen</I>, <I>fread</I>, and <I>fprintf</I>,<I> </I>aren't supported under Windows CE. Likewise, the old Win16 standards, <I>_lread</I>, <I>_lwrite</I>, and <I>_llseek</I>, aren't supported. This isn't really a huge problem because all of these functions can easily be implemented by wrapping the Windows CE file functions with a small amount of code. Windows CE 2.1 does support basic console library functions such as <I>printf</I> for console applications.

<P>Windows CE doesn't support the overlapped I/O that's supported under Windows NT. Files or devices can't be opened with the FILE_FLAG_OVERLAPPED flag nor can reads or writes use the overlapped mode of asynchronous calls and returns.

<P>File operations in Windows CE follow the traditional handle-based methodology used since the days of MS-DOS. Files are opened by means of a function that returns a handle. Read and write functions are passed the handle to indicate the file to act on. Data is read from or written to the offset in the file indicated by a system-maintained file pointer. Finally, when the reading and writing have been completed, the application indicates this by closing the file handle. Now on to the specifics.

<A NAME="250"><H2>Creating and Opening Files</H2></A>

<P>Creating a file or opening an existing file or device is accomplished by means of the standard Win32 function:

<p><pre>
HANDLE CreateFile (LPCTSTR lpFileName, DWORD dwDesiredAccess, 
                   DWORD dwShareMode, 
                   LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
                   DWORD dwCreationDistribution, 
                   DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
</pre>

<P>The first parameter is the filename of the file to be opened or created. The name of the file should have a fully specified path. Filenames with no path information are assumed to be in the root directory of the object store.

<P>The <I>dwDesiredAccess</I> parameter indicate the requested access rights. The allowable flags are GENERIC_READ to request read access to the file and GENERIC_WRITE for write access. Both flags must be passed to get read/write access. You can open a file with neither read nor write permissions. This is handy if you just want to get the attributes of a device. The <I>dwShareMode</I> parameter specifies the access rights that can be granted to other processes. This parameter can be FILE_SHARE_READ and/or FILE_SHARE_WRITE. The <I>lpSecurityAttributes</I> parameter is ignored by Windows CE and should be set to NULL.

<P>The <I>dwCreationDistribution</I> parameter tells <I>CreateFile</I> how to open or create the file. The following flags are allowed:

<UL>
<P><LI><I>CREATE_NEW</I> Creates a new file. If the file already exists, the function fails.
<P><LI><I>CREATE_ALWAYS</I> Creates a new file or truncates an existing file.
<P><LI><I>OPEN_EXISTING</I> Opens a file only if it already exists.
<P><LI><I>OPEN_ALWAYS</I> Opens a file or creates a file if it doesn't exist. This differs from CREATE_ALWAYS because it doesn't truncate the file to 0 bytes if the file exists.
<P><LI><I>TRUNCATE_EXISTING</I> Opens a file and truncates it to 0 bytes. The function fails if the file doesn't already exist.
</UL>

<P>The <I>dwFlagsAndAttributes</I> parameter defines the attribute flags for the file if it's being created in addition to flags in order to tailor the operations on the file. The following flags are allowed under Windows CE:

<UL>
<P><LI><I>FILE_ATTRIBUTE_NORMAL</I> This is the default attribute. It's overridden by any of the other file attribute flags.
<P><LI><I>FILE_ATTRIBUTE_READONLY</I> Sets the read-only attribute bit for the file. Subsequent attempts to open the file with write access will fail.
<P><LI><I>FILE_ATTRIBUTE_ARCHIVE</I> Sets the archive bit for the file.
<P><LI><I>FILE_ATTRIBUTE_SYSTEM</I> Sets the system bit for the file indicating that the file is critical to the operation of the system.
<P><LI><I>FILE_ATTRIBUTE_HIDDEN</I> Sets the hidden bit. The file will be visible only to users who have the View All Files option set in the Explorer.
<P><LI><I>FILE_FLAG_WRITE_THROUGH</I> Write operations to the file won't be lazily cached in memory.
<P><LI><I>FILE_FLAG_RANDOM_ACCESS</I> Indicates to the system that the file will be randomly accessed instead of sequentially accessed. This flag can help the system determine the proper caching strategy for the file.
</UL>

<P>Windows CE doesn't support a number of file attributes and file flags that are supported under Windows 98 and Windows NT. The unsupported flags include but aren't limited to the following: FILE_ATTRIBUTE_OFFLINE, FILE_FLAG_OVERLAPPED, FILE_FLAG_NO_BUFFERING, FILE_FLAG_SEQUENTIAL_SCAN, FILE_FLAG_DELETE_ON_CLOSE, FILE_FLAG_BACKUP_SEMANTICS, and FILE_FLAG_POSIX_SEMANTICS. Under Windows NT and Windows 98, the flag FILE_ATTRIBUTE_TEMPORARY is used to indicate a temporary file, but as we'll see below, it's used by Windows CE to indicate a directory that is in reality a separate drive or network share.

<P>The final parameter in <I>CreateFile</I>, <I>hTemplate</I>, is ignored by Windows CE and should be set to 0. <I>CreateFile</I> returns a handle to the opened file if the function was successful. If the function fails, it returns INVALID_HANDLE_VALUE. To determine why the function failed, call <I>GetLastError</I>. If the <I>dwCreationDistribution</I> flags included CREATE_ALWAYS or OPEN_ALWAYS, you can determine whether the file previously existed by calling <I>GetLastError</I> to see if it returns ERROR_ALREADY_EXISTS. <I>CreateFile</I> will set this error code even though the function succeeded.

<A NAME="251"><H2>Reading and Writing</H2></A>

<P>Windows CE supports the standard Win32 functions <I>ReadFile</I> and <I>WriteFile</I>. Reading a file is as simple as calling the following:

<p><pre>
BOOL ReadFile (HANDLE hFile, LPVOID lpBuffer,
               DWORD nNumberOfBytesToRead,
               LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
</pre>

<P>The parameters are fairly self-explanatory. The first parameter is the handle of the opened file to read followed by a pointer to the buffer that will receive the data and the number of bytes to read. The fourth parameter is a pointer to a DWORD that will receive the number of bytes that was actually read. Finally, the <I>lpOverlapped</I> parameter must be set to NULL because Windows CE doesn't support overlapped file operations. As an aside, Windows CE does support multiple reads and writes pending on a device; it just doesn't support the ability to return from the function before the operation completes.

<P>Data is read from the file starting at the file offset indicated by the file pointer. After the read has completed, the file pointer is adjusted by the number of bytes read.

<P><I>ReadFile</I> won't read beyond the end of a file. If a call to <I>ReadFile</I> asks for more bytes than remains in the file, the read will succeed, but only the number of bytes remaining in the file will be returned. This is why you must check the variable pointed to by <I>lpNumberOfBytesRead</I> after a read completes to learn how many bytes were actually read. A call to <I>ReadFile</I> with the file pointer pointing to the end of the file results in the read being successful, but the number of read bytes is set to 0.

<P>Writing to a file is accomplished with this:

<p><pre>
BOOL WriteFile (HANDLE hFile, LPCVOID lpBuffer,
                DWORD nNumberOfBytesToWrite,
                LPDWORD lpNumberOfBytesWritten,
                LPOVERLAPPED lpOverlapped);
</pre>

<P>The parameters are similar to <I>ReadFile</I> with the obvious exception that <I>lpBuffer</I> now points to the data that will be written to the file. As in <I>ReadFile</I>, the <I>lpOverlapped</I> parameter must be NULL. The data is written to the file offset indicated by the file pointer, which is updated after the write so that it points to the byte immediately beyond the data written.

<A NAME="252"><H3>Moving the file pointer</H3></A>

<P>The file pointer can be adjusted manually with a call to the following:

<p><pre>
DWORD SetFilePointer (HANDLE hFile, LONG lDistanceToMove, 
                      PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
</pre>

<P>The parameters for <I>SetFilePointer</I> are the handle of the file; a signed offset distance to move the file pointer; a second, upper 32-bit offset parameter; and <I>dwMoveMethod</I>, a parameter indicating how to interpret the offset. While <I>lDistanceToMove</I> is a signed 32-bit value, <I>lpDistanceToMoveHigh</I> is a <I>pointer</I> to a signed 32-bit value. For file pointer moves of greater than 4 GB, <I>lpDistanceToMoveHigh</I> should point to a LONG that contains the upper 32-bit offset of the move. This variable will receive the high 32 bits of the resulting file pointer. For moves of less than 4 GB, simply set <I>lpDistanceToMoveHigh</I> to NULL. Clearly, under Windows CE, the <I>lpDistanceToMoveHigh</I> parameter is a bit excessive, but having the function the same format as its Windows NT counterpart aids in portability across platforms.

<P>The offset value is interpreted as being from the start of the file if <I>dwMoveMethod</I> contains the flag FILE_BEGIN. To base the offset on the current position of the file pointer, use FILE_CURRENT. To base the offset from the end of the file, use FILE_END in <I>dwMoveMethod</I>.

<P><I>SetFilePointer</I> returns the file pointer at its new position after the move has been accomplished. To query the current file position without changing the file pointer, simply call <I>SetFilePointer</I> with a zero offset and relative to the current position in the file, as shown here:

<p><pre>
nCurrFilePtr = SetFilePointer (hFile, 0, NULL, FILE_CURRENT);
</pre>

<A NAME="253"><H3>Closing a file</H3></A>

<P>Closing a file handle is a simple as calling

<p><pre>
BOOL CloseHandle (HANDLE hObject);
</pre>

<P>This generic call, used to close a number of handles, is also used to close file handles. The function returns TRUE if it succeeds. If the function fails, a call to <I>GetLastError</I> will return the reason for the failure.

<A NAME="254"><H3>Truncating a file</H3></A>

<P>When you have finished writing the data to a file, you can close it with a call to C<I>loseHandle</I> and you're done. Sometimes, however, you must truncate a file to make it smaller than it currently is. In the days of MS-DOS, the way to set the end of a file was to make a call to write zero bytes to a file. The file was then truncated at the current file pointer. This won't work in Windows CE. To set the end of a file, move the file pointer to the location in the file where you want the file to end and call:

<p><pre>
BOOL SetEndOfFile (HANDLE hFile);
</pre>

<P>Of course, for this call to succeed, you need write access to the file. The function returns TRUE if it succeeds.

<P>To insure that all the data has been written to a storage device and isn't just sitting around in a cache, you can call this function:

<p><pre>
WINBASEAPI BOOL WINAPI FlushFileBuffers (HANDLE hFile);
</pre>

<P>The only parameter is the handle to the file you want to flush to the disk, or more likely in Windows CE a PC Card.

<A NAME="255"><H3>Getting file information</H3></A>

<P>A number of calls allow you to query information about a file or directory. To quickly get the attributes knowing only the file or directory name, you can use this function:

<p><pre>
DWORD GetFileAttributes (LPCTSTR lpFileName);
</pre>

<P>In general, the attributes returned by this function are the same ones that I covered for <I>CreateFile</I>, with the addition of the attributes listed below:

<UL>
<P><LI><I>FILE_ATTRIBUTE_COMPRESSED</I> The file is compressed.
<P><LI><I>FILE_ATTRIBUTE_INROM</I> The file is in ROM.
<P><LI><I>FILE_ATTRIBUTE_ROMMODULE</I> The file is an executable module in ROM formatted for execute-in-place loading. These files can't be opened with <I>CreateFile</I>.
<P><LI><I>FILE_ATTRIBUTE_DIRECTORY</I> The name specifies a directory, not a file.
<P><LI><I>FILE_ATTRIBUTE_TEMPORARY</I> When this flag is set in combination with FILE_ATTRIBUTE_DIRECTORY, the directory is the root of a secondary storage device, such as a PC Card or a hard disk.
</UL>

<P>The attribute FILE_ATTRIBUTE_COMPRESSED is somewhat misleading on a Windows CE device. Files in the RAM-based object store are always compressed, but this flag isn't set for those files. On the other hand, the flag does accurately reflect whether a file in ROM is compressed. Compressed ROM files have the advantage of taking up less space but the disadvantage of not being execute-in-place files.

<P>An application can change the basic file attributes, such as read only, hidden, system, and attribute by calling this function:

<p><pre>
BOOL SetFileAttributes (LPCTSTR lpFileName, DWORD dwFileAttributes);
</pre>

<P>This function simply takes the name of the file and the new attributes. Note that you can't compress a file by attempting to set its compressed attribute. Under other Windows systems that do support selective compression of files, the way to compress a file is to make a call directly to the file system driver.

<P>A number of other informational functions are supported by Windows CE. All of these functions, however, require a file handle instead of a filename, so the file must have been previously opened by means of a call to <I>CreateFile</I>.

<A NAME="256"><H3>File times</H3></A>

<P>The standard Win32 API supports three file times: the time the file was created, the time the file was last accessed (that is, the time it was last read, written, or executed), and the last time the file was written to. That being said, the Windows CE object store keeps track of only one time, the time the file was last written to. One of the ways to query the file times for a file is to call this function:

<p><pre>
BOOL GetFileTime (HANDLE hFile, LPFILETIME lpCreationTime, 
                  LPFILETIME lpLastAccessTime,
                  LPFILETIME lpLastWriteTime);
</pre>

<P>The function takes a handle to the file being queried and pointers to three FILETIME values that will receive the file times. If you're interested in only one of the three values, the other pointers can be set to NULL.

<P>When the file times are queried for a file in the object store, Windows CE copies the last write time into all FILETIME structures. This goes against Win32 documentation, which states that any unsupported time fields should be set to 0. For the FAT file system used on storage cards, two times are maintained: the file creation time and the last write time. When <I>GetFileTime</I> is called on a file on a storage card, the file creation and last write times are returned and the last access time is set to 0.

<P>The FILETIME structures returned by <I>GetFileTime</I> and other functions can be converted to something readable by calling

<p><pre>
BOOL FileTimeToSystemTime (const FILETIME *lpFileTime, 
                           LPSYSTEMTIME lpSystemTime);
</pre>

<P>This function translates the FILETIME structure into a SYSTEMTIME structure that has documented day, date, and time fields that can be used. One large caveat is that file times are stored in coordinated universal time format (UTC), also known as Greenwich Mean Time. This doesn't make much difference as long as you're using unreadable FILETIME structures but when you're translating a file time into something readable, a call to

<p><pre>
BOOL FileTimeToLocalFileTime (const FILETIME *lpFileTime,
                              LPFILETIME lpLocalFileTime);
</pre>

<P>before translating the file time into system time provides the proper time zone translation to the user.

<P>You can manually set the file times of a file by calling

<p><pre>
BOOL SetFileTime (HANDLE hFile, const FILETIME *lpCreationTime,
                  const FILETIME *lpLastAccessTime, 
                  const FILETIME *lpLastWriteTime);
</pre>

<P>The function takes a handle to a file and three times each in FILETIME format. If you want to set only one or two of the times, the remaining parameters can be set to NULL. Remember that file times must be in UTC time, not local time.

<P>For files in the Windows CE object store, setting any one of the time fields results in all three being updated to that time. If you set multiple fields to different times and attempt to set the times for an object store file, the <I>lpLastWriteTime</I> takes precedence. Files on storage cards maintain separate creation and last-write times. You must open the file with write access for <I>SetFileTime</I> to work.

<A NAME="257"><H3>File size and other information</H3></A>

<P>You can query a file's size by calling

<p><pre>
DWORD GetFileSize (HANDLE hFile, LPDWORD lpFileSizeHigh);
</pre>

<P>The function takes the handle to the file and an optional pointer to a DWORD that's set to the high 32 bits of the file size. This second parameter can be set to NULL if you don't expect to be dealing with files over 4 GB. <I>GetFileSize</I> returns the low 32 bits of the file size.

<P>I've been talking about these last few functions separately, but an additional function, <I>GetFileInformationByHandle</I>, returns all this information and more. The function prototyped as

<p><pre>
BOOL GetFileInformationByHandle (HANDLE hFile, 
                       LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
</pre>

<P>takes the handle of an opened file and a pointer to a BY_HANDLE_FILE_INFORMATION structure. The function returns TRUE if it was successful.

<P>The BY_HANDLE_FILE_INFORMATION structure is defined this way:

<p><pre>
typedef struct _BY_HANDLE_FILE_INFORMATION { 
    DWORD dwFileAttributes; 
    FILETIME ftCreationTime; 
    FILETIME ftLastAccessTime; 
    FILETIME ftLastWriteTime; 
    DWORD dwVolumeSerialNumber; 
    DWORD nFileSizeHigh; 
    DWORD nFileSizeLow; 
    DWORD nNumberOfLinks; 
    DWORD nFileIndexHigh; 
    DWORD nFileIndexLow; 
    DWORD dwOID; 
} BY_HANDLE_FILE_INFORMATION;
</pre>

<P>As you can see, the structure returns data in a number of fields that separate functions return. I'll talk about only the new fields here.

<P>The <I>dwVolumeSerialNumber</I> field is filled with the serial number of the volume in which the file resides. The <I>volume</I> is what's considered a disk or partition under Windows 98 or Windows NT. Under Windows CE, the volume refers to the object store, a storage card, or a disk on a local area network. For files in the object store, the volume serial number is 0.

<P>The <I>nNumberOfLinks</I> field is used by Windows NT's NTFS file system and can be ignored under Windows CE. The <I>nFileIndexHigh</I> and <I>nFileIndexLow</I> fields contain a systemwide unique identifier number for the file. This number can be checked to see whether two different file handles point to the same file. The File Index value is used under Windows NT and Windows 98, but Windows CE has a more useful value, the <I>object ID</I> of the file, which is returned in the <I>dwOID</I> field. I'll explain the object ID later in the chapter; for now I'll just mention that it's a universal identifier that can be used to reference directories, files, databases, and individual database records. Handy stuff.

<A NAME="258"><H2>The FileView Sample Program</H2></A>

<P>FileView is an example program that displays the contents of a file in a window. It displays the data in hexadecimal format instead of text, which makes it different from simply opening the file in Microsoft Pocket Word or another editor. FileView is simply a file <I>viewer</I>; it doesn't allow you to modify the file. The code for FileView is shown in Figure 7-1.

<P><!-- caption --><B>Figure 7-1.</B> <I>The Viewer program.</I><!-- /caption -->

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="259"><H3>FileView.rc</H3></A>
<p><pre>
//================================================================
// Resource file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &quot;windows.h&quot;
#include &quot;FileView.h&quot;                    // Program-specific stuff

//----------------------------------------------------------------------
// Icons and bitmaps
ID_ICON ICON   &quot;fileview.ico&quot;            // Program icon

//----------------------------------------------------------------------
// Menu
ID_MENU MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;Open...&quot;,                    IDM_OPEN
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_EXIT
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About...&quot;,                   IDM_ABOUT
    END
END
//----------------------------------------------------------------------
// About box dialog template
aboutbox DIALOG discardable 10, 10, 160, 40
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_CENTER | 
       DS_MODALFRAME 
CAPTION &quot;About&quot;
BEGIN
    ICON  ID_ICON,                    -1,   5,   5,  10,  10
    LTEXT &quot;FileView - Written for the book Programming Windows \
           CE Copyright 1998 Douglas Boling&quot;
                                      -1,  40,   5, 110,  30
END
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="260"><H3>FileView.h</H3></A>
<p><pre>
//======================================================================
// Header file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements.
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages 
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  ID_ICON             1                  // Application icon
                                                // Resource ID
#define  IDC_CMDBAR          2                  // Command band ID
#define  ID_MENU             3                  // Main menu resource ID
#define  ID_VIEWER           4                  // View control ID

// Menu item IDs
#define  IDM_OPEN            101                // File menu
#define  IDM_EXIT            102
#define  IDM_ABOUT           120                // Help menu

//----------------------------------------------------------------------
// Function prototypes
//
INT MyGetFileName (HWND hWnd, LPTSTR szFileName, INT nMax);

int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoSizeMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);
// Command functions
LPARAM DoMainCommandOpen (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAbout (HWND, WORD, HWND, WORD);

// Dialog procedures
BOOL CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>



<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="261"><H3>FileView.c</H3></A>
<p><pre>
//======================================================================

// FileView - A Windows CE file viewer
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &lt;commdlg.h&gt;                 // Common dialog includes

#include &quot;FileView.h&quot;                // Program-specific stuff
#include &quot;Viewer.h&quot;                  // Program-specific stuff
//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;FileView&quot;);
extern TCHAR szViewerCls[];
HINSTANCE hInst;                     // Program instance handle

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_SIZE, DoSizeMain,
    WM_COMMAND, DoCommandMain,
    WM_DESTROY, DoDestroyMain,
};

// Command message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDM_OPEN, DoMainCommandOpen,
    IDM_EXIT, DoMainCommandExit,
    IDM_ABOUT, DoMainCommandAbout,
};

=================================================================
//
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    HWND hwndMain;
    MSG msg;
    int rc = 0;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;
    INITCOMMONCONTROLSEX icex;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    RegisterCtl (hInstance);                  // Register viewer window.

    // Load the command bar common control class.
    icex.dwSize = sizeof (INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_BAR_CLASSES;
    InitCommonControlsEx (&amp;icex);
    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
// 
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow){
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;
    // Create main window.
    hWnd = CreateWindow (szAppName, TEXT (&quot;FileView&quot;),
                         WS_VISIBLE, CW_USEDEFAULT, CW_USEDEFAULT,
                         CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,         
                         hInstance, NULL);        
                                       
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {
    TermViewer (hInstance, nDefRC);
    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//----------------------------------------------------------------------
// MainWndProc - Callback function for application window.
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam, 
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call function.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam) {
    HWND hwndCB, hwndChild;
    INT nHeight, nCnt;
    RECT rect;
    LPCREATESTRUCT lpcs;

    // Convert lParam into pointer to create structure.
    lpcs = (LPCREATESTRUCT) lParam;

    // Create a minimal command bar that only has a menu and an 
    // exit button.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);
    // Insert the menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);
    // Add exit button to command bar. 
    CommandBar_AddAdornments (hwndCB, 0, 0);
    nHeight = CommandBar_Height (hwndCB);

    SetRect (&amp;rect, 0, nHeight, lpcs-&gt;cx, lpcs-&gt;cy - nHeight);
    hwndChild = CreateViewer (hWnd, &amp;rect, ID_VIEWER);

    // Destroy frame if window not created.
    if (!IsWindow (hwndChild)) {
        DestroyWindow (hWnd);
        return 0;
    }
    ListView_SetItemCount (hwndChild, nCnt);
    return 0;
}

//----------------------------------------------------------------
// DoSizeMain - Process WM_SIZE message for window.
// 
LRESULT DoSizeMain (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam){
    HWND hwndViewer;
    RECT rect;

    hwndViewer = GetDlgItem (hWnd, ID_VIEWER);

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    SetWindowPos (hwndViewer, NULL, rect.left, rect.top, 
                  (rect.right - rect.left), rect.bottom - rect.top,
                  SWP_NOZORDER);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window.
// 
LRESULT DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                       LPARAM lParam) {
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD (wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code)
            return (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl, 
                                              wNotifyCode);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
//======================================================================
// Command handler routines
//----------------------------------------------------------------------
// DoMainCommandOpen - Process File Open command.
//
LPARAM DoMainCommandOpen (HWND hWnd, WORD idItem, HWND hwndCtl, 
                          WORD wNotifyCode) {
    TCHAR szFileName[MAX_PATH], szText[64];
    HWND hwndViewer;
    INT rc;

    hwndViewer = GetDlgItem (hWnd, ID_VIEWER);

    if (MyGetFileName (hWnd, szFileName, dim(szFileName)) == 0)
        return 0;
    // Tell the viewer control to open the file.
    rc = SendMessage (hwndViewer, VM_OPEN, 0, (LPARAM)szFileName);

    if (rc) {
        wsprintf (szText, TEXT (&quot;File open failed.  rc: %d &quot;) ,rc);
        MessageBox (hWnd, szText, szAppName, MB_OK);
        return 0;
    }
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl, 
                          WORD wNotifyCode) {

    SendMessage (hWnd, WM_CLOSE, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandVText - Process the View Text command.
//
LPARAM DoMainCommandVText (HWND hWnd, WORD idItem, HWND hwndCtl, 
                           WORD wNotifyCode) {
    return 0;
}
//----------------------------------------------------------------
// DoMainCommandVHex - Process the View Hex command.
//
LPARAM DoMainCommandVHex (HWND hWnd, WORD idItem, HWND hwndCtl, 
                          WORD wNotifyCode) {
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAbout - Process the Help | About menu command.
//
LPARAM DoMainCommandAbout(HWND hWnd, WORD idItem, HWND hwndCtl, 
                          WORD wNotifyCode) {

    // Use DialogBox to create a modal dialog.
    DialogBox (hInst, TEXT (&quot;aboutbox&quot;), hWnd, AboutDlgProc);
    return 0;
}
//======================================================================
// About Dialog procedure
//
BOOL CALLBACK AboutDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, 
                            LPARAM lParam) {
    switch (wMsg) {
        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hWnd, 0);
                    return TRUE;
            }
        break;
    }
    return FALSE;
}

//----------------------------------------------------------------------
// MyGetFileName - Returns a filename using the common dialog.
//
INT MyGetFileName (HWND hWnd, LPTSTR szFileName, INT nMax) {
    OPENFILENAME of;
    const LPTSTR pszOpenFilter = TEXT (&quot;All Documents (*.*)\0*.*\0\0&quot;);

    szFileName[0] = `\0';                 // Initial filename
    memset (&amp;of, 0, sizeof (of));         // Initial file open structure
    of.lStructSize = sizeof (of);
    of.hwndOwner = hWnd;
    of.lpstrFile = szFileName;
    of.nMaxFile = nMax;
    of.lpstrFilter = pszOpenFilter;
    of.Flags = 0;

    if (GetOpenFileName (&amp;of))
        return lstrlen (szFileName);
    else
        return 0;
}
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="262"><H3>Viewer.h</H3></A>
<p><pre>

//======================================================================
// Header file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================

#define  VM_OPEN              (WM_USER+100)

//----------------------------------------------------------------------
// Function prototypes
//
int RegisterCtl (HINSTANCE hInstance);
HWND CreateViewer (HWND hParent, RECT *prect, int nID);
int TermViewer (HINSTANCE hInstance, int nDefRC);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="263"><H3>Viewer.c</H3></A>

<p><pre>
//======================================================================
// Viewer - A file view control
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff

#include &quot;fileview.h&quot;                // Program-specific stuff
#include &quot;viewer.h&quot;                  // Control-specific stuff
//----------------------------------------------------------------
// Internal function prototypes
LRESULT CALLBACK ViewerWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateViewer (HWND, UINT, WPARAM, LPARAM);
LRESULT DoSizeViewer (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintViewer (HWND, UINT, WPARAM, LPARAM);
LRESULT DoVScrollViewer (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyViewer (HWND, UINT, WPARAM, LPARAM);
LRESULT DoOpenViewer (HWND, UINT, WPARAM, LPARAM);

HFONT GetFixedEquiv (HWND hWnd, HFONT hFontIn);

#define BUFFSIZE   4096
//----------------------------------------------------------------------
// Global data
extern HINSTANCE hInst;              // Program instance handle
HANDLE g_hFile = 0;                  // Handle to the opened file
LONG g_lFileSize;                    // Size of the file
PBYTE g_pBuff = 0;                   // Pointer to file data buffer 
LONG g_lFilePtr = 0;                 // Pointer to current offset
                                     // into file
LONG g_lBuffBase = 0;                // Offset into file of buffer data
INT g_nBuffLen = 0;                  // Size of data in file buffer
HFONT g_hFont = 0;                   // Fixed pitch font used for text
INT g_nPageLen = 0;                  // Number of bytes displayed / page

const TCHAR szViewerCls[] = TEXT (&quot;Viewer&quot;);

// Message dispatch table for ViewerWindowProc
const struct decodeUINT ViewerMessages[] = {
    WM_CREATE, DoCreateViewer,
    WM_PAINT, DoPaintViewer,
    WM_SIZE, DoSizeViewer,
    WM_VSCROLL, DoVScrollViewer,
    WM_DESTROY, DoDestroyViewer,
    VM_OPEN, DoOpenViewer,
};

//----------------------------------------------------------------------
// RegisterCtl - Register the viewer control.
//
int RegisterCtl (HINSTANCE hInstance) {
    WNDCLASS     wc;
    // Register application viewer window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = ViewerWndProc;           // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szViewerCls;           // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//----------------------------------------------------------------------
// CreateViewer - Create a viewer control.
// 
HWND CreateViewer (HWND hParent, RECT *prect, int nID) {
    HWND hwndCtl;

    // Create viewer control.
    hwndCtl = CreateWindowEx (0, szViewerCls, TEXT (&quot;&quot;), 
                              WS_VISIBLE | WS_CHILD | WS_VSCROLL |
                              WS_BORDER, prect-&gt;left, prect-&gt;top,
                              prect-&gt;right - prect-&gt;left,
                              prect-&gt;bottom - prect-&gt;top,
                              hParent, (HMENU)nID, hInst, NULL);
    return hwndCtl;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermViewer (HINSTANCE hInstance, int nDefRC) {

    if (g_hFile)
        CloseHandle (g_hFile);                // Close the opened file.

    if (g_pBuff)
        LocalFree (g_pBuff);                  // Free buffer.
    if (g_hFont)
        DeleteObject (g_hFont);
    return nDefRC;
}
//================================================================
// Message handling procedures for ViewerWindow
//----------------------------------------------------------------------
// ViewerWndProc - Callback function for viewer window
//
LRESULT CALLBACK ViewerWndProc (HWND hWnd, UINT wMsg, WPARAM wParam, 
                                LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(ViewerMessages); i++) {
        if (wMsg == ViewerMessages[i].Code)
            return (*ViewerMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateViewer - Process WM_CREATE message for window.
//
LRESULT DoCreateViewer (HWND hWnd, UINT wMsg, WPARAM wParam, 
                        LPARAM lParam) {
    LPCREATESTRUCT lpcs;

    // Convert lParam into pointer to create struct.
    lpcs = (LPCREATESTRUCT) lParam;

    // Allocate a buffer.
    g_pBuff = LocalAlloc (LMEM_FIXED, BUFFSIZE);
    if (!g_pBuff) {
        MessageBox (NULL, TEXT (&quot;Not enough memory&quot;),
                    TEXT (&quot;Error&quot;), MB_OK);
        return 0;
    }
    // Create a fixed-pitch font.
    g_hFont = GetFixedEquiv (hWnd, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoSizeViewer - Process WM_SIZE message for window.
// 
LRESULT DoSizeViewer (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam){
    return 0;
}
//----------------------------------------------------------------
// ComposeLine - Converts hex buff to unicode string
//
int ComposeLine (INT nOffset, LPTSTR szOut) {
    INT i, nLen, nBuffOffset;
    TCHAR szTmp[16];
    LPBYTE pPtr;
    DWORD cBytes;

    szOut[0] = TEXT (`\0');
    if (g_hFile == 0)                // If no file open, no text
        return 0;
    // Make sure we have enough bytes in buffer for dump.
    if ((nOffset + 16 &gt; g_lBuffBase + g_nBuffLen) || 
        (nOffset &lt; g_lBuffBase)) {

        // Move file pointer to new place and read data.
        SetFilePointer (g_hFile, nOffset, NULL, FILE_BEGIN);
        if (!ReadFile (g_hFile, g_pBuff, BUFFSIZE, &amp;cBytes, NULL))
            return 0;
        g_lBuffBase = nOffset;
        g_nBuffLen = cBytes;
    }
    nBuffOffset = nOffset - g_lBuffBase;
    if (nBuffOffset &gt; g_nBuffLen)
        return 0;

    // Now create the text for the line.
    wsprintf (szOut, TEXT (&quot;%08X   &quot;), nOffset);

    pPtr = g_pBuff + nBuffOffset;
    nLen = g_nBuffLen - nBuffOffset;
    if (nLen &gt; 16)
        nLen = 16;
    for (i = 0; i &lt; nLen; i++) {
        wsprintf (szTmp, TEXT (&quot;%02X&quot;), *pPtr++);
        lstrcat (szOut, szTmp);
        if (i == 7)
            lstrcat (szOut, TEXT (&quot;-&quot;));
        else
            lstrcat (szOut, TEXT (&quot; &quot;));
    }
    return nLen;
}
//----------------------------------------------------------------
// DoPaintViewer - Process WM_PAINT message for window.
// 
LRESULT DoPaintViewer (HWND hWnd, UINT wMsg, WPARAM wParam, 
                       LPARAM lParam) {
    TCHAR szOut[128];
    INT nFontHeight;
    INT i, yCurrent;
    TEXTMETRIC tm;
    PAINTSTRUCT ps;
    HFONT hOldFont;
    RECT rect;
    HDC hdc;

    hdc = BeginPaint (hWnd, &amp;ps);
    GetClientRect (hWnd, &amp;rect);

    hOldFont = SelectObject (hdc, g_hFont);

    // Get the height of the default font.
    GetTextMetrics (hdc, &amp;tm);
    nFontHeight = tm.tmHeight + tm.tmExternalLeading;

    i = 0;
    yCurrent = rect.top;
    while (yCurrent &lt; rect.bottom) {
        i += ComposeLine (g_lFilePtr+i, szOut);
        ExtTextOut (hdc, 5, yCurrent, 0, NULL,
                    szOut, lstrlen (szOut),    NULL);

        // Update new draw point.
        yCurrent += nFontHeight;
    }
    SelectObject (hdc, hOldFont);
    EndPaint (hWnd, &amp;ps);
    g_nPageLen = i;
    return 0;
}
//----------------------------------------------------------------------
// DoVScrollViewer - Process WM_VSCROLL message for window.
//
LRESULT DoVScrollViewer (HWND hWnd, UINT wMsg, WPARAM wParam, 
                         LPARAM lParam) {
    RECT rect;
    SCROLLINFO si;
    INT sOldPos = g_lFilePtr;
    GetClientRect (hWnd, &amp;rect);

    switch (LOWORD (wParam)) {
    case SB_LINEUP:
        g_lFilePtr -= 16;
        break;

    case SB_LINEDOWN:
        g_lFilePtr += 16;
        break;

    case SB_PAGEUP:
        g_lFilePtr -= g_nPageLen;
        break;

    case SB_PAGEDOWN:
        g_lFilePtr += g_nPageLen;
        break;

    case SB_THUMBPOSITION:
        g_lFilePtr = HIWORD (wParam);
        break;
    }
    // Check range.
    if (g_lFilePtr &lt; 0)
        g_lFilePtr = 0;
    if (g_lFilePtr &gt; g_lFileSize-16)
        g_lFilePtr = (g_lFileSize - 16) &amp; 0xfffffff0;

    // If scroll position changed, update scrollbar and
    // force redraw of window.
    if (g_lFilePtr != sOldPos) {
        si.cbSize = sizeof (si);
        si.nPos = g_lFilePtr;
        si.fMask = SIF_POS;
        SetScrollInfo (hWnd, SB_VERT, &amp;si, TRUE);

        InvalidateRect (hWnd, NULL, TRUE);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyViewer - Process WM_DESTROY message for window.
//
LRESULT DoDestroyViewer (HWND hWnd, UINT wMsg, WPARAM wParam, 
                         LPARAM lParam) {
    if (g_hFile)
        CloseHandle (g_hFile);
    g_hFile = 0;
    return 0;
}
//----------------------------------------------------------------------
// DoOpenViewer - Process VM_OPEN message for window.
// 
LRESULT DoOpenViewer (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam){
    SCROLLINFO si;

    if (g_hFile)
        CloseHandle (g_hFile);

    // Open the file.
    g_hFile = CreateFile ((LPTSTR)lParam, GENERIC_READ | GENERIC_WRITE,
                          FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                          FILE_ATTRIBUTE_NORMAL, NULL);

    if (g_hFile == INVALID_HANDLE_VALUE) {
        g_hFile = 0;
        return GetLastError();
    }
    g_lFilePtr = wParam;
    g_lFileSize = GetFileSize (g_hFile, NULL);

    si.cbSize = sizeof (si);
    si.nMin = 0;
    si.nMax = g_lFileSize;
    si.nPos = g_lFilePtr;
    si.fMask = SIF_POS | SIF_RANGE;
    SetScrollInfo (hWnd, SB_VERT, &amp;si, TRUE);

    InvalidateRect (hWnd, NULL, TRUE);
    return 0;
}
//----------------------------------------------------------------------
HFONT GetFixedEquiv (HWND hWnd, HFONT hFontIn) {
    HDC hdc;
    TEXTMETRIC tm;
    LOGFONT lf;
    HFONT hOldFont;
    hdc = GetDC (hWnd);
    if (hFontIn == 0)
        hFontIn = GetStockObject (SYSTEM_FONT);
    hOldFont = SelectObject (hdc, hFontIn);
    GetTextMetrics (hdc, &amp;tm);
    SelectObject (hdc, hOldFont);
    ReleaseDC (hWnd, hdc);

    memset (&amp;lf, 0, sizeof (lf));

    lf.lfHeight = -(tm.tmHeight);
    lf.lfWeight    = tm.tmWeight; 
    lf.lfItalic    = tm.tmItalic;  
    lf.lfUnderline = tm.tmUnderlined;
    lf.lfStrikeOut = tm.tmStruckOut; 
    lf.lfCharSet   = tm.tmCharSet; 
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS; 
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; 
    lf.lfQuality = DEFAULT_QUALITY; 
    lf.lfPitchAndFamily = (tm.tmPitchAndFamily &amp; 0xf0) | TMPF_FIXED_PITCH; 
    lf.lfFaceName[0] = TEXT (`\0'); 

    // Create the font from the LOGFONT structure passed.
    return CreateFontIndirect (&amp;lf);
}
</pre>
</td></tr></table>

<P>The C source code is divided into two files, FileView.c and Viewer.c. FileView.c contains the standard windows functions and the menu command handlers. In Viewer.c, you find the source code for a child window that opens the file and displays its contents. The routines of interest are <I>DoOpenViewer</I>, where the file is opened, and <I>ComposeLine</I>, where the file data is read. Both of these routines are in Viewer.c. <I>DoOpenViewer</I> uses <I>CreateFile</I> to open the file with read only access. If the function succeeds, it calls <I>GetFileSize</I> to query the size of the file being viewed. This is used to initialize the range of the view window scrollbar. The window is then invalidated to force a WM_PAINT message to be sent.

<P>In the WM_PAINT handler, <I>OnPaintViewer</I>, a fixed pitch font is selected into the device context, and data from the file, starting at the current scroll location, is displayed in the window after the application calls the <I>ComposeLine</I> function. This routine is responsible for reading the file data into a 4096-byte buffer. The data is then read out of the buffer 16 bytes at a time as each line is displayed. If the data for the line isn't in the file buffer, <I>ComposeLine</I> refills the buffer with the proper data from the file by calling <I>SetFilePointer</I> and then <I>ReadFile</I>.

<A NAME="264"><H2>Memory-Mapped Files and Objects</H2></A>

<P>Memory-mapped files give you a completely different method for reading and writing files. With the standard file I/O functions, files are read as streams of data. To access bytes in different parts of a file, the file pointer must be moved to the first byte, the data read, the file pointer moved to the other byte, and then the file read again.

<P>With memory-mapped files, the file is mapped to a region of memory. Then, instead of using <I>FileRead</I> and <I>FileWrite</I>, you simply read and write the region of memory that's mapped to the file. Updates of the memory are automatically reflected back to the file itself. Setting up a memory-mapped file is a somewhat more complex process than making a simple call to <I>CreateFile</I>, but once a file is mapped, reading and writing the file is trivial.

<A NAME="265"><H3>Memory-mapped files</H3></A>

<P>Windows CE uses a slightly different procedure from Windows NT or Windows 98 to access a memory-mapped file. To open a file for memory-mapped access, a new function, unique to Windows CE, is used; it's named <I>CreateFileForMapping</I>. The prototype for this function is the following:

<p><pre>
HANDLE CreateFileForMapping (LPCTSTR lpFileName, DWORD dwDesiredAccess,
                             DWORD dwShareMode,
                             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                             DWORD dwCreationDisposition,
                             DWORD dwFlagsAndAttributes, 
                             HANDLE hTemplateFile);
</pre>

<P>The parameters for this function are similar to those for <I>CreateFile</I>. The filename is the name of the file to read. The <I>dwDesiredAccess</I> parameter, specifying the access rights to the file, must be a combination of GENERIC_READ and GENERIC_WRITE, or it must be 0. The security attributes must be NULL, while the <I>hTemplateFile</I> parameter is ignored by Windows CE. Note that Windows CE 2.1 is the first version of Windows CE to support write access to memory-mapped files. If you try to use this function in versions earlier than 2.1, it will fail if the <I>dwDesiredAccess</I> parameter contains the GENERIC_WRITE flag.

<P>The handle returned by <I>CreateFileForMapping</I> can then be passed to

<p><pre>
HANDLE CreateFileMapping (HANDLE hFile, 
                          LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
                          DWORD flProtect, DWORD dwMaximumSizeHigh, 
                          DWORD dwMaximumSizeLow, LPCTSTR lpName);
</pre>

<P>This function creates a file mapping object and ties the opened file to it. The first parameter for this function is the handle to the opened file. The security attributes parameter must be set to NULL under Windows CE. The <I>flProtect</I> parameter should be loaded with the protection flags for the virtual pages that will contain the file data. The maximum size parameters should be set to the expected maximum size of the object, or they can be set to 0 if the object should be the same size as the file being mapped. The <I>lpName</I> parameter allows you to specify a name for the object. This is handy when you're using a memory-mapped file to share information across different processes. Calling <I>CreateFileMapping</I> with the name of an already-opened file-mapping object returns a handle to the object already opened instead of creating a new one.

<P>Once a mapping object has been created, a view into the object is created by calling

<p><pre>
LPVOID MapViewOfFile (HANDLE hFileMappingObject, DWORD dwDesiredAccess,
                      DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, 
                      DWORD dwNumberOfBytesToMap);
</pre>

<P><I>MapViewOfFile</I> returns a pointer to memory that's mapped to the file. The function takes as its parameters the handle of the mapping object just opened as well as the access rights, which can be FILE_MAP_READ, FILE_MAP_WRITE, or FILE_MAP_ALL_ACCESS. The offset parameters let you specify the starting point within the file that the view starts, while the <I>dwNumberOfBytesToMap</I> parameter specifies the size of the view window.

<P>These last three parameters are useful when you're mapping large objects. Instead of attempting to map the file as one large object, you can specify a smaller view that starts at the point of interest in the file. This reduces the memory required because only the view of the object, not the object itself, is backed up by physical RAM.

<P>When you're finished with the memory-mapped file, a little cleanup is required. First a call to

<p><pre>
BOOL UnmapViewOfFile (LPCVOID lpBaseAddress);
</pre>

<P>unmaps the view to the object. The only parameter is the pointer to the base address of the view.

<P>Next, a call should be made to close the mapping object and the file itself. Both these actions are accomplished by means of calls to <I>CloseHandle</I>. The first call should be to close the memory-mapped object, and then <I>CloseHandle</I> should be called to close the file.

<P>The code fragment that follows shows the entire process of opening a file for memory mapping, creating the file-mapping object, mapping the view, then cleaning up. The routine is written to open the file in read-only mode. This allows the code to run under all versions of Windows CE.

<p><pre>
HANDLE hFile, hFileMap;
PBYTE pFileMem;
TCHAR szFileName[MAX_PATH];
// Get the filename.

hFile = CreateFileForMapping (szFileName, GENERIC_READ, 
                              FILE_SHARE_READ, NULL, 
                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                              FILE_FLAG_RANDOM_ACCESS,0); 
    
if (hFile != INVALID_HANDLE_VALUE) {

    hFileMap = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, 0);
    if (hFileMap) {
        pFileMem = MapViewOfFile (hFileMap, FILE_MAP_READ, 0, 0, 0);
        if (pFileMem) {
            //
            // Use the data in the file.
            //

            // Start cleanup by unmapping view.
            UnmapViewOfFile (pFileMem);
        }
        CloseHandle (hFileMap);
    } 
    CloseHandle (hFile);
}
</pre>

<A NAME="266"><H3>Memory-mapped objects</H3></A>

<P>One of the more popular uses for memory-mapped objects is for interprocess communication. For this purpose, you don't need to have an actual file; it's the shared memory that's important. Windows CE supports entities referred to as <I>unnamed memory-mapped objects</I>. These objects are memory-mapped objects that, under Windows NT and Windows 98, are backed up by the paging file but under Windows CE are simply areas of virtual memory with only program RAM to back up the object. Without the paging file, these objects can't be as big as they would be under Windows NT or Windows 98 but Windows CE does have a way of minimizing the RAM required to back up the memory-mapped object.


<P>You create such a memory-mapped object by eliminating the call to <I>CreateFileForMapping</I> and passing a -1 in the handle field of <I>CreateFileMapping</I>. Since no file is specified, you must specify the size of the memory-mapped region in the maximum size fields of <I>CreateFileMapping</I>. The following routine creates a 16-MB region using a memory-mapped file:

<p><pre>
// Create a 16-MB memory mapped object.
hNFileMap = CreateFileMapping ((HANDLE)-1, NULL, PAGE_READWRITE,
                                0, 0x1000000, NULL);
if (hNFileMap) 
    // Map in the object.
    pNFileMem = MapViewOfFile (hNFileMap, 
                               FILE_MAP_WRITE, 0, 0, 0);
</pre>

<P>The memory object created by the code above doesn't actually commit 16 MB of RAM. Instead, only the address space is reserved. Pages are autocommitted as they're accessed. This process allows an application to create a huge, sparse array of pages that takes up only as much physical RAM as is needed to hold the data. At some point, however, if you start reading or writing to a greater number of pages, you'll run out of memory. When this happens, the system generates an exception. I'll talk about how to deal with exceptions in the next chapter. The important thing to remember is that if you really need RAM to be committed to a memory-mapped object, you need to read each of the pages so that the system will commit physical RAM to that object. Of course, don't be too greedy with RAM; commit only the pages you absolutely require.

<h4>Naming a memory-mapped object</h4>

<P>A memory-mapped object can be named by passing a string to <I>CreateFileMapping</I>. This isn't the name of a file being mapped. Instead the name identifies the mapping object being created. In the previous example, the region was unnamed. The following code creates a named memory-mapped object named <I>Bob</I>. This name is global so that if another process opens a mapping object with the same name, the two processes will share the same memory-mapped object.

<p><pre>
// Create a 16-MB memory mapped object.
hNFileMap = CreateFileMapping ((HANDLE)-1, NULL, PAGE_READWRITE,
                                0, 0x1000000, TEXT (&quot;Bob&quot;));
if (hNFileMap) 
    // Map in the object.
    pNFileMem = MapViewOfFile (hNFileMap, 
                               FILE_MAP_WRITE, 0, 0, 0);
</pre>

<P>The difference between named and unnamed file mapping objects is that a named object is allocated only once in the system. Subsequent calls to <I>CreateFileMapping</I> that attempt to create a region with the same name will succeed, but the function will return a handle to the original mapping object instead of creating a new one. For unnamed objects, the system creates a new object each time <I>CreateFileMapping</I> is called.

<P>When using a memory-mapped object for interprocess communication, processes should create a named object and pass the name of the region to the second process, not a pointer. While the first process can simply pass a pointer to the mapping region to the other process, this isn't advisable. If the first process frees the memory-mapped file region while the second process is still accessing the file, an exception will occur. Instead, the second process should create a memory-mapped object with the same name as the initial process. Windows knows to pass a pointer to the same region that was opened by the first process. The system also increments a use count to track the number of opens. A named memory-mapped object won't be destroyed until all processes have closed the object. This assures a process that the object will remain at least until it closes the object itself. The XTALK example in <A HREF="ch08a.htm">Chapter 8</a> provides an example of how to use a named memory mapped object for interprocess communication.

<A NAME="267"><H2>Navigating the File System</H2></A>

<P>Now that we've seen how files are read and written, let's take a look at how the files themselves are managed in the file system. Windows CE supports most of the convenient file and directory management APIs, such as <I>CopyFile</I>, <I>MoveFile</I>, and <I>CreateDirectory</I>.

<A NAME="268"><H3>File and directory management</H3></A>

<P>Windows CE supports a number of functions useful in file and directory management. You can move files using <I>MoveFile</I>, copy them using <I>CopyFile</I>, and delete them using <I>DeleteFile</I>. You can create directories using <I>CreateDirectory</I> and delete them using <I>RemoveDirectory</I>. While most of these functions are straightforward, I should cover a few intricacies here.

<P>To copy a file, call

<p><pre>
BOOL CopyFile (LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName,  
               BOOL bFailIfExists);
</pre>

<P>The parameters are the name of the file to copy and the name of the destination directory. The third parameter indicates whether the function should overwrite the destination file if one already exists before the copy is made.

<P>Files and directories can be moved and renamed using

<p><pre>
BOOL MoveFile (LPCTSTR lpExistingFileName, LPCTSTR lpNewFileNam);
</pre>

<P>To move a file, simply indicate the source and destination names for the file. The destination file must not already exist. File moves can be made within the object store, from the object store to an external drive, or from an external drive to the object store. <I>MoveFile</I> can also be used to rename a file. In this case, the source and target directories remain the same; only the name of the file changes.

<P><I>MoveFile</I> can also be used in the same manner to move or rename directories. The only exception is that <I>MoveFile</I> can't move a directory from one volume to another. Under Windows CE, <I>MoveFile</I> moves a directory and all its subdirectories and files to a different location within the object store or different locations within another volume.

<P>Deleting a file is as simple as calling

<p><pre>
BOOL DeleteFile (LPCTSTR lpFileName);
</pre>

<P>You pass the name of the file to delete. For the delete to be successful, the file must not be currently open.

<P>You can create and destroy directories using the following two functions:

<p><pre>
BOOL CreateDirectory (LPCTSTR lpPathName, 
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes);
</pre>

<P>and

<p><pre>
BOOL RemoveDirectory (LPCTSTR lpPathName);
</pre>

<P><I>CreateDirectory</I> takes the name of the directory to create and a security parameter that should be NULL under Windows CE. <I>RemoveDirectory</I> deletes a directory. The directory must be empty for the function to be successful.

<A NAME="269"><H3>Finding files</H3></A>

<P>Windows CE supports the basic <I>FindFirstFile</I>, <I>FindNextFile</I>, <I>FindClose</I> procedure for enumerating files as is supported under Windows NT or Windows 98. Searching is accomplished on a per-directory basis using template filenames with wild card characters in the template.

<P>Searching a directory involves first passing a filename template to <I>FindFirstFile</I>, which is prototyped in this way:

<p><pre>
HANDLE FindFirstFile (LPCTSTR lpFileName,
                      LPWIN32_FIND_DATA lpFindFileData);
</pre>

<P>The first parameter is the template filename used in the search. This filename can contain a fully specified path if you want to search a directory other than the root. Windows CE has no concept of <I>Current Directory</I> built into it; if no path is specified in the search string, the root directory of the object store is searched.

<P>As would be expected, the wildcards for the filename template are ? and *. The question mark (?) indicates that any single character can replace the question mark. The asterisk (*) indicates that any number of characters can replace the asterisk. For example, the search string <I>\windows\alarm?.wav</I> would return the files \windows\alarm1.wav, \windows\alarm2.wav, and \windows\alarm3.wav. On the other hand, a search string of <I>\windows\*.wav</I> would return all files in the windows directory that have a wav extension.

<P>The second parameter of <I>FindFirstFile</I> is a pointer to a WIN32_FIND_DATA 
structure as defined below.

<p><pre>
typedef struct _WIN32_FIND_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwOID;
    WCHAR cFileName[ MAX_PATH ];
} WIN32_FIND_DATA;
</pre>

<P>This structure is filled with the file data for the first file found in the search. The fields shown are similar to what we've seen.

<P>If <I>FindFirstFile</I> finds no files or directories that match the template filename, it returns INVALID_HANDLE_VALUE. If at least one file is found, <I>FindFirstFile</I> fills in the WIN32_FIND_DATA structure with the specific data for the found file and returns a handle value that you use to track the current search.

<P>To find the next file in the search, call this function:

<p><pre>
BOOL FindNextFile (HANDLE hFindFile,
                   LPWIN32_FIND_DATA lpFindFileData);
</pre>

<P>The two parameters are the handle returned by <I>FindFirstFile</I> and a pointer to a find data structure. <I>FindNextFile</I> returns TRUE if a file matching the template passed to <I>FindFirstFile </I>is found and fills in the appropriate file data in the WIN32_FIND_DATA structure. If no file is found, <I>FindNextFile</I> returns FALSE.

<P>When you've finished searching either because <I>FindNextFile</I> returned FALSE or because you simply don't want to continue searching, you must call this function:

<P>BOOL FindClose (HANDLE hFindFile);

<P>This function accepts the handle returned by <I>FindFirstFile</I>. If <I>FindFirstFile</I> returned INVALID_ HANDLE_VALUE, you shouldn't call <I>FindClose</I>.

<P>The following short code fragment encompasses the entire file search process. This code computes the total size of all files in the Windows directory.

<p><pre>
WIN32_FIND_DATA fd;
HANDLE hFind;
INT nTotalSize = 0;

// Start search for all files in the windows directory.
hFind = FindFirstFile (TEXT (&quot;\\windows\\*.*&quot;), &amp;fd);

// If a file was found, hFind will be valid.
if (hFind != INVALID_HANDLE_VALUE) {

    // Loop through found files.  Be sure to process file
    // found with FindFirstFile before calling FindNextFile.
    do {
        // If found file is not a directory, add its size to
        // the total.  (Assume that the total size of all files 
        // is less than 2 GB.)
        if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)) 
            nTotalSize += fd.nFileSizeLow;

    // See if another file exists.
    } while (FindNextFile (hFind, &amp;fd));

    // Clean up by closing file search handle.
    FindClose (hFind);
}
</pre>

<P>In this example, the windows directory is searched for all files. If the found &quot;file&quot; isn't a directory, that is, if it's a true file, its size is added to the total. Notice that the return handle from <I>FindFirstFile</I> must be checked, not only so that you know whether a file was found but also to prevent <I>FindClose</I> from being called if the handle is invalid.

<A NAME="270"><H3>Determining drives from directories</H3></A>

<P>As I mentioned at the beginning of this chapter, Windows CE doesn't support the concept of drive letters so familiar to MS-DOS and Windows users. Instead, file storage devices such as PC Cards or even hard disks are shown as directories in the root directory. That leads to the question, &quot;How can you tell a directory from a drive?&quot; The newer versions of Windows CE, starting with version 2.1, don't have a predefined name for these other storage devices. Using a predefined name is shaky at best, anyway, given that the name was originally <I>PC Card</I> and then changed to <I>Storage Card</I>. Instead, you need to look at the file attributes for the directory. Directories that are actually secondary storage devices&#8212;that is, they store files in a place other than the object store&#8212;have the file attribute flag FILE_ATTRIBUTE_TEMPORARY set. So, finding storage devices on any version of Windows CE is fairly easy as is shown in the following code fragment:

<p><pre>
    WIN32_FIND_DATA fd;
    HANDLE hFind;
    TCHAR szPath[MAX_PATH];
    ULARGE_INTEGER lnTotal, lnFree;

    lstrcpy (szPath, TEXT (&quot;\\*.*&quot;));
    hFind = FindFirstFile (szPath, &amp;fd);

    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if ((fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &amp;&amp;
                (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_TEMPORARY)) {

                // Get the disk space statistics for drive.
                GetDiskFreeSpaceEx (fd.cFileName, NULL, &amp;lnTotal,
                                    &amp;lnFree);
            }
        } while (FindNextFile (hFind, &amp;fd));
        FindClose (hFind);
    }
</pre>

<P>This code uses the find first/find next functions to search the root directory for all directories with the FILE_ATTRIBUTE_TEMPORARY attribute set.

<P>Notice in the code I just showed you, the call to this function:

<p><pre>
BOOL GetDiskFreeSpaceEx (LPCWSTR lpDirectoryName, 
                         PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                         PULARGE_INTEGER lpTotalNumberOfBytes,
                         PULARGE_INTEGER lpTotalNumberOfFreeBytes);
</pre>

<P>This function provides information about the total size of the drive, and amount of free space it contains. The first parameter is the name of any directory on the drive in question. This doesn't have to be the root directory of the drive. <I>GetDiskFreeSpaceEx</I> returns three values: the free bytes available to the caller, the total size of the drive, and the total free space on the drive. These values are returned in three ULARGE_INTEGER structures. These structures contain two DWORD fields named <I>LowPart</I> and <I>HighPart</I>. This allows <I>GetDiskFreeSpaceEx</I> to return 64-bit values. Those 64-bit values can come in handy on Windows NT and Windows 98, where the drives can be large. If you aren't interested in one or more of the fields, you can pass a NULL in place of the pointer for that parameter. You can also use <I>GetDiskFreeSpaceEx</I> to determine the size of the object store.

<P>Another function that can be used to determine the size of the object store is

<p><pre>
BOOL GetStoreInformation (LPSTORE_INFORMATION lpsi);
</pre>

<P><I>GetStoreInformation</I> takes one parameter a pointer to a STORE_INFORMATION structure defined as

<p><pre>
typedef struct STORE_INFORMATION {
    DWORD dwStoreSize;
    DWORD dwFreeSize;
} STORE_INFORMATION, *LPSTORE_INFORMATION;
</pre>

<P>As you can see, this structure simply returns the total size and amount of free space in the object store. Why would you use <I>GetStoreInformation</I> when <I>GetDiskFreeSpaceEx</I> is available and more general? Because <I>GetDiskFreeSpaceEx</I> wasn't available under Windows CE 1.0 but <I>GetStoreInformation</I> was.

<P>That covers the Windows CE file API. As you can see, very little Windows CE_unique code is necessary when you're working with the object store. Now let's look at an entirely new set of functions, the database API.

<P><div class="sidebar"><blockquote><ol>
<P><LI>This limit is 10 cards for Windows CE 2.0 and earlier.

<P><LI>The Handheld PC Pro uses Storage Card as its default name.
</ol></blockquote></div>

</BODY>
</HTML>




