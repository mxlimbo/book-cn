<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Notifications</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="457"><H1>Notifications</H1></A>

<P>One area in which Windows CE exceeds the Windows 98 and Windows NT API is the notification interface. Windows CE applications can register to be launched at a predetermined time or when any of a set of system events occur. Applications can also register a <I>user</I> <I>notification</I>. In a user notification, the system notifies the user at a specific time without the application itself being launched at that time.

<P>In Windows CE 2.1, the notification interface was moved from the shell to the base system. The advantage of this change is that this interface is now available for embedded systems.

<A NAME="458"><H2>User Notifications</H2></A>

<P>A Windows CE application can schedule the user to be notified at a given time using the <I>CeSetUserNotification</I> function. When the time of the notification occurs, the system alerts the user by displaying a dialog box, playing a wave file, or flashing an external LED. Windows CE also displays the icon of the application that set the notification on the taskbar. The user has the option of acknowledging the notification either by clicking OK on the notification dialog box, pressing the Notify button on the system case, if one is present, or tapping on the application's taskbar annunciator icon, which launches the application that registered the notification. After a user notification has been set, you can modify it by making another call to <I>CeSetUserNotification</I>.

<A NAME="459"><H3>Setting a user notification</H3></A>

<P><I>CeSetUserNotification</I> is prototyped as

<p><pre>
HANDLE CeSetUserNotification (HANDLE hNotification,
                TCHAR *pwszAppName, SYSTEMTIME *lpTime, 
                PCE_USER_NOTIFICATION lpUserNotification);
</PRE>

<P>The <I>hNotification</I> parameter is set to 0 to create a new notification. To modify a notification already registered, you should set <I>hNotification</I> to the handle of the user notification that you want to modify. The <I>pswzAppName</I> parameter specifies the name of the owning application. If this application has a small icon (16-by-16-pixel) image in its primary icon, that icon will be displayed as the taskbar annunciator icon when the notification occurs. The <I>lpTime</I> parameter is a pointer to a SYSTEMTIME structure that specifies the time for the notification to occur. The <I>lpUserNotification </I>parameter points to a CE_USER_NOTIFICATION structure that describes how the user is to be notified. This structure is defined as

<p><pre>
typedef struct UserNotificationType {
   DWORD ActionFlags;
   TCHAR *pwszDialogTitle;
   TCHAR *pwszDialogText;
   TCHAR *pwszSound;
   DWORD nMaxSound;
   DWORD dwReserved;
} CE_USER_NOTIFICATION;
</PRE>

<P>The <I>ActionFlags</I> field of this structure contains a set of flags that define how the user is notified. The flags can be any combination of the following:

<UL>
<P><LI><I>PUN_LED</I> Flash the external LED.
<P><LI><I>PUN_VIBRATE</I> Vibrate the device.
<P><LI><I>PUN_DIALOG</I> Display a dialog box.
<P><LI><I>PUN_SOUND</I> Play a wave file.
<P><LI><I>PUN_REPEAT</I> Repeat the wave file for 10 to 15 seconds.
</UL>

<P>The fact that these flags are defined doesn't mean that all systems implement all these actions. Most Windows CE devices can't vibrate and a few don't even have an external LED. There isn't a defined method for determining the notification capabilities of a device, but as I'll presently show you, the system provides a dialog box that's customized by the OEM for the capabilities of each device.

<P>The remainder of the fields in the structure depend on the flags set in the <I>ActionFlags</I> field. If the PUN_DIALOG flag is set, the <I>pwszDialogTitle</I> and <I>pwszDialogText</I> specify the title and text of the dialog that's displayed. The <I>pwszSound</I> field is loaded with the filename of a wave file to play if the PUN_SOUND flag is set. The <I>nMaxSound</I> field defines the size of the <I>pwsSound</I> field.

<A NAME="460"><H3>Configuring a user notification</H3></A>

<P>To give you a consistent user interface for choosing the method of notification, Windows CE provides a dialog box to query the user how he wants to be notified. To display the user configuration dialog box, you call this function:

<p><pre>
BOOL CeGetUserNotificationPreferences (HWND hWndParent,
                      PCE_USER_NOTIFICATION lpNotification);
</PRE>

<P>This function takes two parameters&#8212;the window handle of the parent window for the dialog box and a pointer to a CE_USER_NOTIFICATION structure. You can initialize the CE_USER_NOTIFICATION structure with default settings for the dialog before <I>CeGetUserNotificationPreferences</I> is called. When the function returns, this structure is filled with the changes the user made. <I>CeGetUserNotificationPreferences</I> returns TRUE if the user clicked on the OK button to accept the changes and FALSE if an error occurred or the user canceled the dialog box.

<P>This function gives you a convenient method for configuring user notifications. The dialog box lets you have check boxes for playing a sound, displaying another dialog box, and flashing the LED. It also contains a combo box that lists the available wave files that the user can choose from if he wants sound. The dialog box doesn't have fields to allow the user to specify the text or title of the dialog box if one is to be displayed. That text must be provided by the application.

<A NAME="461"><H3>Acknowledging a user notification</H3></A>

<P>A user notification can be cleared by the application before it times out by calling

<p><pre>
BOOL CeClearUserNotification (HANDLE hNotification); 
</PRE>

<P>Once a user notification has occurred, it must be acknowledged by the user. The user can tap the OK button on the notification dialog box or press the notification button on the H/PC or Palm-size PC case. A third alternative is for the user to tap on the taskbar icon of the program that registered the notification. This icon is displayed by the system when the notification is made. In this case, Windows CE launches the application.

<P>If the user taps on the taskbar icon, the notification isn't automatically acknowledged. Instead, an application should programmatically acknowledge the notification by calling this function:

<p><pre>
BOOL CeHandleAppNotifications (TCHAR *pwszAppName);
</PRE>

<P>The one parameter is the name of the application that was launched due to the taskbar icon tap. Calling this function removes the dialog box, stops the sound, turns off the flashing LED, and removes the application's annunciator icon from the taskbar.

<P>When the system starts an application due to a notification, it passes a command line argument to indicate why the application was started. For a user notification, this argument is the command line string <I>AppRunToHandleNotification</I> followed by a space, and the handle of the notification. Instead of using the literal string for comparison, notify.h, which is the include file that contains the notification API, includes defines for the command line strings. The constant for <I>AppRunToHandleNotification</I> is APP_RUN_TO_HANDLE_NOTIFICATION.

<P>As a general rule, an application started by a notification should first check to see whether another instance of the application is running. If so, the application should communicate to the first instance that the notification occurred and terminate. This saves memory because only one instance of the application is running. The code fragment below shows how this can be easily accomplished.

<p><pre>
INT i;
HWND hWnd;
HANDLE hNotify;
TCHAR szText[128];

if (*lpCmdLine) {

    pPtr = lpCmdLine;
    // Parse the first word of the command line.
    for (i = 0; i &lt; dim(szText) &amp;&amp; *lpCmdLine &gt; TEXT (` `); i++)
        szText[i] = *pPtr++;
    szText[i] = TEXT (`\0');

    // Check to see if app started due to notification.
   if (lstrcmp (szText, APP_RUN_TO_HANDLE_NOTIFICATION) == 0) {
        // Acknowledge the notification
        GetModuleFileName (hInst, szText, sizeof (szText));
        CeHandleAppNotifications (szText);

        // Get handle off the command line.
        hNotify = (HANDLE)_wtol (pPtr);

        // Look to see if another instance of the app is running.
       hWnd = FindWindow (NULL, szAppName);
        if (hWnd) {
         SendMessage (hWnd, MYMSG_TELLNOTIFY, 0, (LPARAM)hNotify);
           // This app should terminate here.
            // return 0;
        }
    } 
}
</PRE>

<P>This code first looks to see whether a command line parameter exists and if so, whether the first word is the keyword indicating that the application was launched by the system in response to a user notification. If so, the notification is acknowledged and the application looks for an instance of the application already running, using <I>FindWindow</I>. If found, the routine sends an application-defined message to the main window of the first instance and terminates. Otherwise, the application can take actions necessary to respond to the user's tap of the program icon on the taskbar.

<A NAME="462"><H2>Timer Event Notifications</H2></A>

<P>To run an application at a given time without user intervention, use a <I>timer event</I> <I>notification</I>. The function that creates a timer event notification is this one:

<p><pre>
BOOL CeRunAppAtTime (TCHAR *pwszAppName, SYSTEMTIME *lpTime); 
</PRE>

<P>The two parameters are the name of the application to launch and a pointer to a SYSTEMTIME structure to set the time to launch the application. Only one timer event notification can be set for any one application. Calling <I>CeRunAppAtTime</I> a second time with a new time simply replaces the first notification with the second. A timer notification can be cleared by passing a NULL pointer in the <I>lpTime</I> parameter.

<P>When the timer notification is activated, the system powers on, if currently off, and launches the application with a command line parameter of APP_RUN_AT_TIME. As with the user notification, the application should check to see whether another instance of the application is running and pass the notification on if one is running. Also, an application should be careful about creating a window and taking control of the machine during a timer event. The user might object to having his game of solitaire interrupted by another application popping up because of a timer notification.

<A NAME="463"><H2>System Event Notifications</H2></A>

<P>Other times, you might want an application to be automatically started. Windows CE supports a third type of notification, known as a <I>system event notification</I>. This notification starts an application when one of a set of system events occurs, such as after the system has completed synchronizing with its companion PC. To set a system event notification use this function:

<p><pre>
BOOL CeRunAppAtEvent (TCHAR *pwszAppName, LONG lWhichEvent);
</PRE>

<P>As with the timer event notification, the first parameter is the name of the application to launch. The second parameter is a constant indicating which event to monitor. The flags are the following:

<UL>
<P><LI><I>NOTIFICATION_EVENT_NONE</I> Clear event notifications.
<P><LI><I>NOTIFICATION_EVENT_SYNC_END</I> Notify when sync complete.
<P><LI><I>NOTIFICATION_EVENT_DEVICE_CHANGE</I> Notify when a PCMCIA device is added or removed.
<P><LI><I>NOTIFICATION_EVENT_RS232_DETECTED</I> Notify when an RS232 connection is detected.
<P><LI><I>NOTIFICATION_EVENT_TIME_CHANGE</I> Notify when the system time is changed.
<P><LI><I>NOTIFICATION_EVENT_RESTORE_END</I> Notify when a device restore is complete.
</UL>

<P>For each of these events, the application is launched with a specific command line parameter indicating why the application was launched. In the case of a device change notification, the NOTIFICATION_EVENT_DEVICE_CHANGE command line string is followed by either <I>/ADD</I> or <I>/REMOVE</I> and the name of the device being added or removed. For example, if the user inserts a modem card, the command line for the notification would look like this:

<p><pre>
AppRunDeviceChange /ADD COM3:
</PRE>

<P>A number of additional system events are defined in notify.h but at this point, none are currently supported.

<P>Once an application has registered for a system event notification, Windows CE will start the application again if the event that caused the notification is repeated. To stop being notified, an application must call <I>CeRunAppAtEvent</I> and pass its name and NOTIFICATION_EVENT_NONE in the <I>lWhichEvent</I> parameter.


<A NAME="464"><H2>The MyNotify Example Program</H2></A>

<P>The following program, MyNotify, demonstrates each of the notification functions that allow you to set user notifications, system notifications, and timer notifications. The program presents a simple dialog box that has four buttons. The first two buttons allow you to configure and set a user notification. The second two buttons let you set system and timer notifications. The gap above the buttons is filled with the command line, if any, that was passed when the application started. It's also used to display a message when another instance of MyNotify is started due to a user notification. Figure 12-4 shows two MyNotify windows. The one in the foreground was launched because of a user notification while the one in the background displays a message, indicating it was sent a message from the other instance of the application.

<P><A HREF="javascript:fullSize('f12rg04x.htm')"> <img src="f12rg04.jpg" width=404 height=303 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 12-4.</B> <I>The MyNotify window.</I><!-- /caption -->

<P>The source code for MyNotify is shown in Figure 12-5. The notification code is confined to the button handler routines. The code is fairly simple: for each type of notification, the appropriate Windows CE function is called. When asked to configure a user notification, the application calls <I>CeGetUserNotificationPreferences</I>. The program gives you one additional dialog box with which to configure the system notifications.

<P><B>Figure 12-5.</B> <I>The MyNotify program.</I>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="465"><H3>MyNotify.rc</H3></A>

<p><pre>
//======================================================================
// Resource file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &quot;windows.h&quot;
#include &quot;MyNotify.h&quot;                      // Program-specific stuff

//----------------------------------------------------------------------
// Icons and bitmaps
//
ID_ICON ICON   &quot;MyNotify.ico&quot;              // Program icon
//----------------------------------------------------------------------
// Main window dialog template
//
MyNotify DIALOG discardable  25, 5, 120,  85
STYLE  WS_OVERLAPPED | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | 
       DS_CENTER | DS_MODALFRAME 
CAPTION &quot;MyNotify&quot;
BEGIN
    LTEXT &quot;&quot;,            IDD_OUTPUT,   2,   2, 115,  21
    PUSHBUTTON &quot;&amp;Set User Notification&quot;,
                         IDD_ADDUSERNOT,   2,  25, 115,  12, WS_TABSTOP
    PUSHBUTTON &quot;&amp;Configure User Notification&quot;,
                         IDD_CFGUSERNOT,   2,  38, 115,  12, WS_TABSTOP

    PUSHBUTTON &quot;&amp;Set System Notification&quot;,
                         IDD_ADDSYSNOT,   2,  56, 115,  12, WS_TABSTOP
    PUSHBUTTON &quot;&amp;Set Timer Notification&quot;,
                         IDD_ADDTIMENOT,   2,  69, 115,  12, WS_TABSTOP
END
//----------------------------------------------------------------------
// Set system event notification dialog box dialog template.
//
SysNotifyConfig DIALOG DISCARDABLE  0, 0, 139, 87
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_CAPTIONOKBTN
CAPTION &quot;Notify On...&quot;
BEGIN
    AUTOCHECKBOX &quot;Sync End&quot;,          IDC_SYNC_END,   7,   7, 121,  10, 
                                           WS_TABSTOP
    AUTOCHECKBOX &quot;Device Change&quot;,IDC_DEVICE_CHANGE,   7,  22, 121,  10, 
                                           WS_TABSTOP
    AUTOCHECKBOX &quot;Serial Connection Detected&quot;,
                                 IDC_SERIAL_DETECT,   7,  37, 121,  10, 
                                           WS_TABSTOP
    AUTOCHECKBOX &quot;System Time Change&quot;,
                                   IDC_TIME_CHANGE,   7,  52, 121,  10, 
                                           WS_TABSTOP
    AUTOCHECKBOX &quot;Restore End&quot;,    IDC_RESTORE_END,   7,  67, 121,  10, 
                                           WS_TABSTOP
END
</pre>
</td></tr></table>

<p><table cellspacing=5 width="95%"><tr><td>
<A NAME="466"><H3>MyNotify.h</H3></A>

<P><pre>
//======================================================================
// Header file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0])) 

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                            // Structure associates
    UINT Code;                                 // messages 
                                               // with a function. 
    BOOL (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                             // Structure associates
    UINT Code;                                 // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);    // function.
};

// Define function not supported under Windows CE.
#ifndef IsDlgButtonChecked
#define IsDlgButtonChecked(a, b)\
                           SendDlgItemMessage (a, b, BM_GETCHECK, 0, 0)
#endif
//----------------------------------------------------------------------
// Generic defines used by application

#define  ID_ICON             1   

#define  IDD_ADDUSERNOT      10                // Control IDs
#define  IDD_CFGUSERNOT      11
#define  IDD_ADDSYSNOT       12
#define  IDD_ADDTIMENOT      13
#define  IDD_OUTPUT          14

#define  IDC_SYNC_END        20
#define  IDC_DEVICE_CHANGE   21
#define  IDC_SERIAL_DETECT   22
#define  IDC_TIME_CHANGE     23
#define  IDC_RESTORE_END     24

#define MYMSG_TELLNOTIFY     (WM_USER + 100)

//----------------------------------------------------------------------
// Function prototypes
//
void Add2List (HWND hWnd, LPTSTR lpszFormat, ...);

// Window procedures
BOOL CALLBACK MainDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK SetEventNotifyDlgProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
BOOL DoInitDialogMain (HWND, UINT, WPARAM, LPARAM);
BOOL DoCommandMain (HWND, UINT, WPARAM, LPARAM);
BOOL DoTellNotifyMain (HWND, UINT, WPARAM, LPARAM);

// Command functions
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAddUserNotification (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandConfigUserNotification (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAddSysNotification (HWND, WORD, HWND, WORD); 
LPARAM DoMainCommandAddTimerNotification (HWND, WORD, HWND, WORD); 
</pre>
</td></tr></table>

<p><table cellspacing=5 width="95%"><tr><td>
<A NAME="467"><H3>MyNotify.c</H3></A>

<P><pre>
//======================================================================

// MyNotify - Demonstrates the Windows CE Notification API
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;notify.h&gt;                  // For notification defines
#include &quot;MyNotify.h&quot;                // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;MyNotify&quot;);
HINSTANCE hInst;                     // Program instance handle

CE_USER_NOTIFICATION g_ceun;         // User notification structure
TCHAR szDlgTitle[128] = TEXT (&quot;Notification Demo&quot;);
TCHAR szDlgText[128] = TEXT (&quot;Times Up!&quot;);
TCHAR szSound[MAX_PATH] = TEXT (&quot;alarm1.wav&quot;);

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_INITDIALOG, DoInitDialogMain,
    WM_COMMAND, DoCommandMain,
    MYMSG_TELLNOTIFY, DoTellNotifyMain,
};
// Command Message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDOK, DoMainCommandExit,
    IDCANCEL, DoMainCommandExit,
    IDD_ADDUSERNOT, DoMainCommandAddUserNotification,
    IDD_CFGUSERNOT, DoMainCommandConfigUserNotification,
    IDD_ADDSYSNOT, DoMainCommandAddSysNotification, 
    IDD_ADDTIMENOT, DoMainCommandAddTimerNotification, 
};
//======================================================================
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    INT i;
    TCHAR szText[MAX_PATH];
    WCHAR *pPtr;
    HANDLE hNotify;
    HWND hWnd;

    hInst = hInstance;

    if (*lpCmdLine) {
        pPtr = lpCmdLine;
        // Parse the first word of the command line.
        for (i = 0; (i &lt; dim(szText)-1) &amp;&amp; (*pPtr &gt; TEXT (` `)); i++)
            szText[i] = *pPtr++;
        szText[i] = TEXT (`\0');

        // Check to see if app started due to notification.
        if (lstrcmp (szText, APP_RUN_TO_HANDLE_NOTIFICATION) == 0) {
            // Ack the notification
            GetModuleFileName (hInst, szText, sizeof (szText));
            CeHandleAppNotifications (szText);

            // Get handle off the command line.
            hNotify = (HANDLE)_wtol (pPtr);

            // Look to see if another instance of the app is running.
            hWnd = FindWindow (NULL, szAppName);
            if (hWnd) {
                SendMessage (hWnd, MYMSG_TELLNOTIFY, 0, 
                             (LPARAM)hNotify);
                // I should terminate this app here, but I don't so you
                // can see what happens.
                // return 0;
            }
        } 
    }
    // Do a little initialization of CE_USER_NOTIFICATION.
    memset (&amp;g_ceun, 0, sizeof (g_ceun));
    g_ceun.ActionFlags = PUN_DIALOG;
    g_ceun.pwszDialogTitle = szDlgTitle;
    g_ceun.pwszDialogText = szDlgText;
    g_ceun.pwszSound = szSound;
    g_ceun.nMaxSound = sizeof (szSound);

    // Display dialog box as main window.
    DialogBoxParam (hInstance, szAppName, NULL, MainDlgProc, 
                    (LPARAM)lpCmdLine);
    return 0;

}
//======================================================================
// Message handling procedures for main window
//----------------------------------------------------------------------
// MainDlgProc - Callback function for application window
//
BOOL CALLBACK MainDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, 
                           LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return FALSE;
}
//----------------------------------------------------------------------
// DoInitDialogMain - Process WM_INITDIALOG message for window.
//
BOOL DoInitDialogMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {

    if (*(LPTSTR)lParam)
        Add2List (hWnd, (LPTSTR)lParam);
    return FALSE;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window.
//
BOOL DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam){
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT  i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD (wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code) {
            (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl, 
                                       wNotifyCode);
            return TRUE;
        }
    }
    return FALSE;
}
//----------------------------------------------------------------------
// DoTellNotifyMain - Process MYMSG_TELLNOTIFY message for window.
//
BOOL DoTellNotifyMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                       LPARAM lParam) {
    Add2List (hWnd, TEXT (&quot;Notification %d reported&quot;), lParam);
    return 0;
}
//======================================================================
// Command handler routines
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl, 
                          WORD wNotifyCode) {
    EndDialog (hWnd, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAddUserNotification - Process Add User Notify button.
//
LPARAM DoMainCommandAddUserNotification (HWND hWnd, WORD idItem, 
                                       HWND hwndCtl, WORD wNotifyCode) {
    SYSTEMTIME st;
    TCHAR szExeName[MAX_PATH], szText[128];
    HANDLE hNotify;

    // Initialize time structure with local time.
    GetLocalTime (&amp;st);
    // Do a trival amount of error checking.
    if (st.wMinute == 59) {
        st.wHour++;
        st.wMinute = 0;
    } else
        st.wMinute++;

    GetModuleFileName (hInst, szExeName, sizeof (szExeName));
    // Set the notification.
    hNotify = CeSetUserNotification (0, szExeName, &amp;st, &amp;g_ceun);
    if (hNotify) {
        wsprintf (szText, TEXT (&quot;User notification set for %d:%d&quot;),
                  st.wHour, st.wMinute);
        MessageBox (hWnd, szText, szAppName, MB_OK);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandConfigUserNotification - Process Config user
// notification button.
//
LPARAM DoMainCommandConfigUserNotification (HWND hWnd, WORD idItem, 
                                       HWND hwndCtl, WORD wNotifyCode) {
    CeGetUserNotificationPreferences (hWnd, &amp;g_ceun);
    return 0;
}
//----------------------------------------------------------------------
//  DoMainCommandAddSysNotification - Process Add Sys notify button.
//
LPARAM DoMainCommandAddSysNotification (HWND hWnd, WORD idItem, 
                                      HWND hwndCtl,  WORD wNotifyCode) {

    DialogBox (hInst, TEXT (&quot;SysNotifyConfig&quot;), hWnd, 
               SetEventNotifyDlgProc);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAddTimerNotification - Process add timer notify button.
//
LPARAM DoMainCommandAddTimerNotification (HWND hWnd, WORD idItem, 
                                      HWND hwndCtl,  WORD wNotifyCode) {
    SYSTEMTIME st;
    TCHAR szExeName[MAX_PATH], szText[128];

    // Initialize time structure with local time.
    GetLocalTime (&amp;st);
    // Do a trivial amount of error checking.
    if (st.wMinute == 59) {
        st.wHour++;
        st.wMinute = 0;
    } else
        st.wMinute++;

    GetModuleFileName (hInst, szExeName, sizeof (szExeName));
    // Set the notification.
    if (CeRunAppAtTime (szExeName, &amp;st)) { 
        wsprintf (szText, TEXT (&quot;Timer notification set for %d:%d&quot;),
                  st.wHour, st.wMinute);
        MessageBox (hWnd, szText, szAppName, MB_OK);
    }
    return 0;
}
//----------------------------------------------------------------------
// Add2List - Add string to the report list box.
//
void Add2List (HWND hWnd, LPTSTR lpszFormat, ...) {
    int i, nBuf;
    TCHAR szBuffer[512];

    va_list args;
    va_start(args, lpszFormat);

    nBuf = _vstprintf(szBuffer, lpszFormat, args);
    i = SendDlgItemMessage (hWnd, IDD_OUTPUT, WM_SETTEXT, 0, 
                            (LPARAM)(LPCTSTR)szBuffer);
    va_end(args);
}
//======================================================================
// SetEventNotifyDlgProc - Callback function for Event dialog box
//
BOOL CALLBACK SetEventNotifyDlgProc (HWND hWnd, UINT wMsg,
                                     WPARAM wParam,
                                     LPARAM lParam) {
    LONG lEvent;
    TCHAR szExeName[MAX_PATH];

    switch (wMsg) {
    case WM_COMMAND:
        {
            WORD idItem = LOWORD (wParam);
            switch (idItem) {
            case IDOK:
                lEvent = 0;

                // IsDlgButtonChecked isn't defined in Win CE, so 
                // a macro has been defined.
                if (IsDlgButtonChecked (hWnd, IDC_SYNC_END) == 1)
                    lEvent |= NOTIFICATION_EVENT_SYNC_END;

                if (IsDlgButtonChecked (hWnd, IDC_SERIAL_DETECT) == 1)
                    lEvent |= NOTIFICATION_EVENT_RS232_DETECTED;

                if (IsDlgButtonChecked (hWnd, IDC_DEVICE_CHANGE) == 1)
                    lEvent |= NOTIFICATION_EVENT_DEVICE_CHANGE;

                if (IsDlgButtonChecked (hWnd, IDC_TIME_CHANGE) == 1)
                    lEvent |= NOTIFICATION_EVENT_TIME_CHANGE;

                if (IsDlgButtonChecked (hWnd, IDC_RESTORE_END) == 1)
                    lEvent |= NOTIFICATION_EVENT_RESTORE_END;
 
                // Set the notification.
                GetModuleFileName (hInst, szExeName, 
                   sizeof (szExeName));
                CeRunAppAtEvent (szExeName, lEvent); 

                EndDialog (hWnd, 1); 
                return TRUE;

            case IDCANCEL:
                EndDialog (hWnd, 0); 
                return TRUE;
            }
        }
        break;
    }
    return FALSE;
}
</pre>
</td></tr></table>

<P>When MyNotify is started, it examines the command line to determine whether it was started by a user notification. If so, the program attempts to find another instance of the application already running. If the program finds one, a message is sent to the first instance, informing it of the user notification. Because this is an example program, the second instance doesn't terminate itself as it would were it a commercial application.

</BODY>
</HTML>




