<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Working with the Shell</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="445"><H1>Working with the Shell</H1></A>

<P>Because the H/PC and Palm-size PC shells are derived from the Windows 95 shell, I must cover some system definitions first introduced with Windows 95. In general, while the concepts remain the same, the implementation is completely different under the covers.

<A NAME="446"><H2>The Shell Namespace</H2></A>

<P>From Windows 95 on, the Windows shell has used the concept of a shell namespace. The Windows CE shell also uses the namespace concept to track the objects in the shell. Simply put, the shell namespace is the entire collection of the operating system's objects, files, directories, printers, control panel applets, and so forth. The idea is that by addressing files the same way as control panel applets, the shell makes it easy to deal with the diverse collection of objects.

<P>A <I>folder</I> is simply a collection of objects. A <I>directory</I> is a collection of files on a disk. A folder generalizes and extends the directory concept, in that a folder doesn't merely contain files, but can include other objects such as control panel objects, printers, or remote connection links. Each object in a folder is called an <I>item</I>. Items are identified by an <I>item ID</I>.

<P>The item ID is a data structure that uniquely identifies the item in the folder. Since folders also have identifiers, an individual item can be uniquely defined by means of a list of item IDs that identify the item, its folder, and the parent folders of the folder. Think of this list of item identifiers as a completely specified pathname of a file. A system might have many files named <I>foobar</I>, but only one in a specific directory. This list of item IDs is appropriately called an <I>ID list</I>. A pointer to such a list is a <i>pointer to an ID list</i>, frequently abbreviated as <I>pidl</I>, which is generally and rather unfortunately pronounced <I>piddle</I>. Shell functions usually reference items in the shells by their <I>pidls</I>. There is, of course, a translation function that converts a <I>pidl</I> to a filename.

<P>With the release of the Palm-size PC, the developers faced a problem. The <I>pidl</I> concept is powerful, but implementing and maintaining <I>pidls</I> didn't seem worth the trouble, given the limited need the Palm-size PC shell has for them. But because some of the shell functions use <I>pidls</I> to remain compatible with the H/PC, the Palm-size PC has to implement <I>pidls</I>. The solution is for the Palm-size PC shell to &quot;fake&quot; <I>pidl</I>s. The necessary APIs use a value typed as a <I>pidl</I> but the actual implementation is a constant, not a pointer to an item ID list. This strategy doesn't much affect you as you program the Palm-size PC, but you should be aware of it.

<A NAME="447"><H2>Special Folders</H2></A>

<P>The Windows CE shell, like the shells for Windows 95 and Windows NT 4.0, has a set of folders that are treated differently from normal directories in the file system. An example of this is the recycle bin, which is simply a hidden directory to which the shell moves files and directories when the user deletes them. Another example is the Programs folder, which contains a set of shortcuts that are then displayed on the Start menu.

<P>The list of special folders changes with each shell. The Windows 95, Windows 98, and Windows NT 4.0 shells have a different set of special folders from those of the Windows CE shells. The shells implemented on the Palm-size PC and H/PC each implement their own subset of special folders. Fortunately, the function to return the location of a specific special folder is the same on all these systems. That function, <I>ShSpecialFolderLocation</I>, is prototyped as

<p><pre>
HRESULT SHGetSpecialFolderLocation (HWND hwndOwner, int nFolder,
                               LPITEMIDLIST *ppidl);
</PRE>

<P>The first parameter is a handle to a window that owns any dialog box the shell needs to display during the processing of this function. The second parameter is a constant that specifies the directory you're requesting. The two main shells for Windows CE support different subsets of the constants defined by Windows. Below are the lists of constants supported by the H/PC and the Palm-size PC.

<P>On the Handheld PC

<UL>
<P><LI><I>CSIDL_BITBUCKET</I> The location of the recycle bin.
<P><LI><I>CSIDL_DESKTOP</I> The folder that stores the objects that appear on the desktop. Note that the use of this constant is different than under Windows 95.
<P><LI><I>CSIDL_FONTS</I> The folder that contains the system fonts.
<P><LI><I>CSIDL_DRIVES</I> The root of the file system.
<P><LI><I>CSIDL_PROGRAMS</I> The folder that contains the items shown in the Programs submenu of the Start menu.
<P><LI><I>CSIDL_PERSONAL</I> The default folder in which to save documents.
<P><LI><I>CSIDL_FAVORITES</I> The folder that contains shortcuts to favorite items.
<P><LI><I>CSIDL_STARTUP</I> The folder that contains programs or shortcuts to programs that will be launched when the system is restarted.
<P><LI><I>CSIDL_RECENT</I> The folder that contains the list of recently used documents.
</UL>

<P>On the Palm-size PC

<UL>
<P><LI><I>CSIDL_DRIVES</I> The root of the file system.
<P><LI><I>CSIDL_PROGRAMS</I> The folder that contains the items shown in the Programs submenu of the Start menu.
<P><LI><I>CSIDL_STARTUP</I> The folder that contains programs or shortcuts to programs that will be launched when the system is restarted.
<P><LI><I>CSIDL_FONTS</I> The folder that contains the system fonts.
<P><LI><I>CSIDL_FAVORITES</I> The folder that contains shortcuts to favorite items.
<P><LI><I>CSIDL_STARTMENU</I> The folder that contains the items shown in the Start menu.
<P><LI><I>CSIDL_PERSONAL</I> The default folder in which to save documents.
</UL>

<P>The final parameter in <I>SHGetSpecialFolderLocation</I>, <I>pidl</I>, is a pointer to an ITEMIDLIST pointer that receives a pointer to the folder's item ID list.

<P>The <I>pidl</I> that is returned by <I>SHGetSpecialFolderLocation</I> can be translated to a standard file path using this function:

<p><pre>
BOOL WINAPI SHGetPathFromIDList (LPCITEMIDLIST pidl,
                           LPTSTR pszPath);
</PRE>

<P>The two parameters for this function are a <I>pidl</I> and a pointer to a buffer that receives the path of the folder specified by the <I>pidl</I>. This buffer must be at least MAX_PATH characters in length.

<P>If you needed only to call <I>SHGetSpecialFolderLocation</I> and follow that by calling <I>SHGetPathFromIDList</I> to get the path, life would be simple. Unfortunately, the process isn't that simple. On systems other than the Palm-size PC, the <I>pidl </I>that's returned by <I>SHGetSpecialFolderLocation</I> points to a buffer that has been allocated by the shell. You need to call the shell back to free this buffer after you're finished with the ID list. You free this buffer using an <I>IMalloc</I> interface provided by the shell.

<P>The <I>IMalloc</I> interface contains methods that allow an application to allocate, free, and otherwise manipulate memory in the local heap of the <I>IMalloc</I> provider. In the case of the shell, a pointer to its <I>IMalloc</I> interface can be acquired with a call to <I>SHGetMalloc</I>. The function is prototyped as

<p><pre>
HRESULT SHGetMalloc (LPMALLOC *ppMalloc);
</PRE>

<P>Once you have a pointer to the interface, you can call the <I>Free </I>method to free any ID lists returned by <I>ShGetSpecialFolderLocation</I>. On systems other than the Palm-size PC, the process can be encapsulated in the following routine:

<p><pre>
INT MyGetSpecialDirectory (HWND hWnd, INT nFolderID,
                         LPTSTR lpDir) {
    int rc;
   LPITEMIDLIST pidl;
  LPMALLOC lpMalloc = NULL;

  // Get the Shell Malloc interface to be able to free the pidls.
  rc = SHGetMalloc (&amp;lpMalloc);
  if (rc != NOERROR) 
        return rc;

  // Ask the shell for the specified folder's pidl.
  rc = SHGetSpecialFolderLocation (hWnd, nFolderID, &amp;pidl);
  if (rc == NOERROR) {
       // Translate the pidl to a directory name.
       SHGetPathFromIDList (pidl, lpDir);
        // Free the idlist.
       IMalloc_Free(lpMalloc,pidl);
    } 

    // Free shell's IMalloc interface.
    IMalloc_Release(lpMalloc);
    return rc;
}
</PRE>

<P>This routine calls <I>SHGetMalloc</I> to receive a pointer to the shell's <I>IMalloc</I> interface. You then make calls to <I>SHGetSpecialFolderLocation</I> and <I>SHGetPathFromIDList</I> to get the folder and translate it into a directory name. Next you call the <I>Free</I> method of <I>IMalloc</I> using a macro defined for C-compiled programs. The methods of most COM interfaces have macros defined for C-compiled programs if your application isn't written in C++. Finally you call the <I>Release</I> method of <I>IMalloc</I> to free the interface.

<P>As I mentioned earlier, the Palm-size PC doesn't formally implement <I>pidls</I>. Instead, <I>SHGetSpecialFolderLocation</I> returns a constant, typed as a <I>pidl,</I> that can then be passed to <I>SHGetPathFromIDList </I>to get a directory name. Had the developers also implemented a dummy <I>IMalloc</I> interface for the shell, the process for getting the location of a special folder would be identical. Instead, the current version of the Palm-size PC shell doesn't implement an <I>IMalloc</I> interface. Although you could simply remove any references to the <I>IMalloc</I> interface, a better solution would be something like the following routine:

<p><pre>
INT MyGetSpecialDirectory (HWND hWnd, INT nFolderID,
                           LPTSTR lpDir) {
   int rc;
  LPITEMIDLIST pidl;
  BOOL fUseIMalloc = TRUE;
  LPMALLOC lpMalloc = NULL;

  // Attempt to get the Shell Malloc interface. 
  rc = SHGetMalloc (&amp;lpMalloc);
  if (rc == E_NOTIMPL)
      fUseIMalloc = FALSE;
  else if (rc != NOERROR) 
       return rc;

  rc = SHGetSpecialFolderLocation (hWnd, nFolderID, &amp;pidl);
  if (rc == NOERROR) {
       // Translate the idlist to a directory name.
       SHGetPathFromIDList (pidl, lpDir);
       // Free the idlist.
       if (fUseIMalloc)
          IMalloc_Free(lpMalloc,pidl);
   } 

   // Free shell's IMalloc interface.
   if (fUseIMalloc)
       IMalloc_Release(lpMalloc);
   return rc;
}
</PRE>

<A NAME="448"><H2>Shortcuts</H2></A>

<P>Shortcuts are small files that, when opened, launch an application or open a document in another folder. The idea behind shortcuts is that you could have an application located in one directory but you might want to be able to launch it from other directories. Since the shell uses the contents of special directories to define what is in the Start menu and on the desktop, placing a shortcut in one of those special directories allows an application to appear in the Start menu or on the desktop.

<P>While the concept of shortcuts was taken from Windows 95, the method of creating them was not. Instead of using a COM interface, as is done under Windows 95, you create a shortcut in Windows CE using the following function:

<p><pre>
BOOL SHCreateShortcut (LPTSTR szShortcut, LPTSTR szTarget);
</PRE>

<P>The first parameter specifies the name and location of the shortcut. This name should be a fully qualified filename with an extension of LNK. The second parameter is the fully qualified filename of the application you want to start or the file you want to open. The function returns TRUE if successful.

<P>You can determine the contents of a shortcut by calling this function:

<p><pre>
BOOL SHGetShortcutTarget (LPTSTR szShortcut, LPTSTR szTarget,
                          int cbMax);
</PRE>

<P>The first parameter is the filename of the shortcut. The remaining two parameters are the buffer that receives the target filename of the shortcut and the size of that buffer.

<A NAME="449"><H2>Configuring the Start Menu</H2></A>

<P>Shortcuts come into their own when you're customizing the Start menu. When the Start button is clicked, the taskbar looks in its special folder and creates a menu item for each item in the folder. Subfolders contained in the special folder become submenus on the Start menu.

<P>The Start menu of the H/PC is limited in that you can't customize the Start menu itself. You can, however, modify the Programs submenu and the submenus it contains. To add an item to the Programs submenu of the H/PC Start menu, you place a shortcut in the folder returned after you called <I>SHGetSpecialFolderLocation</I> with the folder constant CSIDL_PROGRAMS. For example, look at the short code fragment below; it lists the Calc program in the Programs submenu of the Start directory on an H/PC.

<p><pre>
INT rc;
TCHAR szDir[MAX_PATH];

rc = MyGetSpecialDirectory (hWnd, CSIDL_PROGRAMS, szDir);
if (rc == NOERROR) {
    lstrcat (szDir, TEXT (&quot;\\Calc.lnk&quot;));
    SHCreateShortcut (szDir, TEXT (&quot;\\windows\\calc.exe&quot;));
}
</PRE>

<P>This fragment uses the routine <I>MyGetSpecialDirectory</I>, which I listed earlier in the chapter, to return the folder used by the Programs submenu. Once that's found, all that is required is to append the necessary LNK extension to the name of the link and call <I>SHCreateShortcut</I> specifying the location of CALC.EXE.

<P>The Start menu of the Palm-size PC is more flexible than the H/PC's because you can add items directly to the Start menu itself. To accomplish this, add shortcuts to the folder returned with <I>SHGetSpecialFolderLocation </I>and the constant CSIDL_STARTMENU. From that folder, you can use the standard <I>FindFirstFile</I> and <I>FileNextFile</I> functions to determine the structure of the Start menu.

<A NAME="450"><H2>Recent Documents List</H2></A>

<P>A feature of the Start menu since it was introduced in Windows 95 is the Documents submenu. This menu lists the last 10 documents that were opened by applications in the system. This list is a convenient place in which users can reopen recently used files. The system doesn't keep track of the last-opened documents. Instead, an application must tell Windows that it has opened a document. Windows then prunes the least recently opened document on the menu and adds the new one.

<P>Under Windows CE, the function that an application calls to add a document to the recently used list is

<p><pre>
void SHAddToRecentDocs (UINT uFlags, LPCVOID pv);
</PRE>

<P>The first parameter can be set to one of two flags, SHARD_PATH or SHARD_PIDL. If <I>uFlags</I> is set to SHARD_PATH, the second parameter points to the fully qualified path of the document file. If SHARD_PIDL is specified in <I>uFlags</I>, the second parameter points to a pointer to an ID list. If the second parameter is 0, all items in the recently used document menu are deleted.

</BODY>

</HTML>




