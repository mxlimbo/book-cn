<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Boot Process</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="511"><H1>The Boot Process</H1></A>

<P>If you're a systems programmer, you might enjoy, as I do, seeing how a system boots up. When you think about it, booting up poses some interesting problems. How does the system load its first process when the process loader is part of that process you want to load? How do you deal with 30 different CPUs, each with its own method of initialization?

<P>In the case of Windows CE, we have a somewhat better view of this process. Because the hardware varies radically across the different platforms, Windows CE requires that OEMs write some of the initialization code. In each instance, this initialization code is incorporated in the HAL (hardware abstraction layer), under the kernel. When an OEM builds the system for a specific hardware platform, the HAL is statically linked with the Windows CE kernel code to produce NK.exe.

<P>Actually, the OEM writes far more than the HAL when porting Windows CE to a new platform. The OEM also writes a thin layer under the Graphics, Windowing, and Event Manager (GWE) to link in some of the more basic drivers used by GWE. In addition, the OEM must write a series of device drivers, from a display device driver to drivers for the keyboard, touch panel, serial, and audio devices. The actual collection of drivers is, of course, dependent on the hardware. This collection of the HAL layer plus the drivers is called the OEM Adaptation Layer, or OAL.

<P>In any case, let's get back to the boot process. This boot process is described through the documentation and code examples provided in the Embedded Tool Kit. Our journey starts, as with any CPU, at the occurrence of a reset.

<A NAME="512"><H2>Reset</H2></A>

<P>When the system is reset, the CPU jumps to the entry point of NK.exe, which is the kernel module for Windows CE.<SUP>1</SUP> The code at the entry point is actually written by the OEM, not Microsoft. This routine, written in assembler, is traditionally named <I>Startup</I> and is responsible for initializing the CPU into a known state for the kernel. Since most CPUs supported by Windows CE are embedded CPUs, they generally have a number of registers that must be set to configure the system for the speed and sometimes even the base address of memory. Startup is also responsible for initializing any caches and for ensuring that the system is in an uncached, flat addressing mode.

<A NAME="513"><H2>NK.exe</H2></A>

<P>When Startup has completed its tasks, it jumps to the entry point of the kernel, <I>KernelStart</I>. This is the entry point for the Microsoft written code for NK. <I>KernelStart</I> configures the virtual memory manager, initializes the interrupt vector table to a default handler, and calls down to the OEM layer to initialize the debug serial port.<SUP>2</SUP> <I>KernelStart</I> then initializes its local heap by copying the initialized heap data from ROM into system RAM, in a routine named <I>KernelRelocate</I>. Now that the local heap for NK.exe has been initialized, the code can start acting less like a loader and more like a program. The kernel then calls back down to the HAL to the <I>OEMInit</I> routine.

<P>The job of <I>OEMInit</I>, which is customarily written in C, is to initialize any OEM-specific hardware. This includes hooking interrupts, initializing timers, and testing memory.<SUP>3</SUP> Many systems perform some initial configuration of integrated peripherals, if only to place them in a quiescent state until the driver for that peripheral can be loaded. The <I>OEMInit</I> routine is generally responsible for drawing the splash screen on the display during a boot process.

<P>When <I>OEMInit</I> returns, the kernel calls back into the HAL to ask whether any additional RAM is available to the system. When an OEM creates a ROM image of the Windows CE files, it makes some preliminary estimates about the size and location of the RAM as well as defining the size and location of the ROM. This routine, <I>OEMGetExtensionDRAM</I>, allows the OEM to tell the kernel about additional RAM that can be used by the system. Once <I>OEMGetExtensionDRAM</I> returns, the kernel enables interrupts and calls the scheduler to schedule the first thread in the system.

<A NAME="514"><H3>FileSys.exe</H3></A>

<P>At this point, the kernel looks for the file FileSys.exe and launches that application. FileSys is the process that manages the file system, the database functions, and more important at this stage, the registry. When FileSys is loaded, it looks in the RAM to see whether it can find a file system already initialized. If one is found, FileSys uses the already initialized file system. This allows Windows CE devices to retain the data in their RAM-based file systems over a reboot of the system.

<P>If FilSys doesn't find a file system, it creates one that merges an empty RAM file system with the files on ROM. FileSys knows what files are in ROM by means of a table that's built into the ROM image by the ROM builder program, which merged all the disparate programs into one image. FileSys reads the default directory structure from a file stored on ROM, which is composed of entries suggested by Microsoft for the OEM. In addition to initializing the file system, FileSys creates default database images and a default registry. The initial images of the default databases and default registry are also defined in files in ROM written by the OEM and Microsoft. This file-driven initialization process allows OEMs to customize the initial images of the file system from the directory tree to the individual entries in the registry.

<P>One other feature of FileSys acts like a back door to the file system. During initialization, FileSys looks to see whether the system is connected to a debugging station, which is a PC running a program named CESH.<SUP>4</SUP> Traditionally, the connection between the PC and the Windows CE system was a parallel port link. However, starting with Windows CE 2.1, this link can be made over Ethernet or a dedicated serial link. If such a connection is found, FileSys takes the additional step of looking on the PC for files when the system asks it to load a file. In effect, this seamlessly extends the \windows directory on the Windows CE system to include any files in a specific directory on the debugging PC. This procedure allows the system to load files that aren't in the initial ROM image during the boot process. Later, when the system is running, files can be directly loaded from the PC without your first having to copy them into the object store of the Windows CE system.

<A NAME="515"><H3>Launching optional processes</H3></A>

<P>Once FileSys has initialized, the system initialization can proceed. The kernel needs to wait because, at this point, it needs data from the registry to continue the boot process. Specifically, the kernel looks in the registry for values under the key [HKEY_LOCAL_MACHINE]\Init. The values in this key provide the name, order, and dependencies of a set of processes that should be loaded as part of the boot process. The processes to be launched are specified by values named <I>Launchxx</I> where the <I>xx</I> is a number defining the order of the launch. An optional value, <I>Dependxx</I>, can be used to make the launch of a process dependent on another process specified earlier in the order. For example, the following set of values was take from the registry of a Casio Handheld PC.

<p><table width="95%" cellpadding=5>
<tr><td valign="top"><b>Value</b></td>
<td valign="top"><b>Data</b></td>
<td valign="top"><b>Comments</b></td></tr>

<tr><td valign="top">Launch10</td>
<td valign="top">SHELL.EXE</td>
<td valign="top"></td></tr>

<tr><td valign="top">Launch20</td>
<td valign="top">DEVICE.EXE</td>
<td valign="top"></td></tr>

<tr><td valign="top">Launch30<br>Depend30</td>
<td valign="top">GWES.EXE<br>0014</td>
<td valign="top"><br>Depends on Device (0x14 == 20)</td></tr>

<tr><td valign="top">Launch50<br>Depend50</td>
<td valign="top">EXPLORER.EXE<br>0014 001E</td>
<td valign="top"><br>Depends on Device and GWE</td></tr>
</table>

<P>While I've listed the values in their launch order for clarity, the values don't need to be in order in the registry. The numbers embedded in the names of the values define the launch order.

<P>The kernel loads each of the modules listed in their own process space. When a process completes its initialization successfully, it signals this event to the kernel by calling the function <I>SignalStarted</I> and passing the application's launch number. The kernel knows from these calls to <I>SignalStarted</I> that any dependent processes can now be launched.

<P>What's interesting here is that each of these components of the operating system functions as a standard user-level process. Just because a process appears in this list doesn't mean that it's part of the operating system. While this launch list is generally used only by OEMs, you can insert other processes in this list, as long as the functions needed by that application have been loaded earlier in the list. For example, you could write an application that's loaded after Device and before GWES.exe as long as that application didn't make any calls to the window manager or the graphics functions until GWE is initialized. On the other hand, launching an application with a standard user interface before Explorer loads can confuse Explorer. So unless you need to launch a process to support system services, you should use Explorer to launch your applications on startup. One additional point&#8212;you <I>can't</I> separately launch an application that depends on Explorer to launch successfully because Explorer.exe doesn't call <I>SignalStarted </I>during its initialization. Now let's follow this sequence and examine each of these launched processes.

<A NAME="516"><H3>Shell.exe</H3></A>

<P>Shell is an interesting process because it's not even in the ROM of most systems. Shell.exe is the Windows CE side of CESH, the command line-based monitor. Because Shell.exe isn't in the ROM, the only way to load it is by connecting the system to the PC debugging station so that the file can be automatically downloaded from the PC.

<P>CESH uses the FileSys link to the debugging PC to communicate with the programmer. Instead of opening a file on the PC, CESH opens a console session on the PC. The CESH debugger provides a number of useful functions to the Windows CE OEM. First it gives the OEM developer a command line shell, running on a PC that can be used to launch applications, query system status, and read and write memory on the system.

<P>CESH also lets the OEM developer manipulate a very handy feature of debug builds of Windows CE named <I>debug zones</I>. When you're developing software, it's often useful to insert debugging messages that print out information. On a Windows CE system, these debugging messages are sent via the debug serial port. The problem is that too many messages can hide a critical error behind a blizzard of irrelevant informational messages. On the other hand, Murphy says that the day after you strip all your debugging messages from a section of code, you'll need those messages to diagnose a newly reported bug. Debug zones allow the developer to interactively enable and disable sets of debug messages that are built into debug builds of Windows CE. All of the base processes bundled with Windows CE as well as all the device drivers have these debugging messages built into them. Every message is assigned to one of 16 defined debug zones for that process or DLL. So, a developer can use CESH to enable or disable each of the 16 zones for a module, which enables or disables the messages for that zone.

<P>Shell.exe uses a Windows CE version of toolhelp.dll, so when Shell loads, it loads ToolHelp. Shell doesn't bring any additional function to Windows CE; it's just one place where Microsoft has added built-in debugging features for the OEM.

<A NAME="517"><H3>Device.exe</H3></A>

<P>After Shell, the next module in the launch list is Device.exe. Notice that there's no <I>Depened20</I> line that makes the launch of Device.exe dependent on Shell.exe. That's important because Shell won't launch successfully unless the system has Shell.exe in the object store or is connected to a debug station. The job of Device.exe is to load and manage the installable device drivers in the system. This includes managing any PCMCIA Card drivers that must be dynamically loaded and freed as well.

<P>When Device.exe loads, it first loads the PCMCIA driver. It then looks in the registry under [HKEY_LOCAL_MACHINE\BuiltIn for the list of the other drivers it must load when it initializes. This list is contained in a series of keys. The names of the keys don't matter&#8212;it's the values contained in the keys that define which drivers to load and the order in which to load them. Figure 14-1 shows the contents of the WaveDev key. The Wave driver is the audio driver.

<P><A HREF="javascript:fullSize('F14RG01x.htm')"> <img src="F14RG01.JPG" width=404 height=342 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 14-1.</B> <I>The registry key for the Wave driver on an HP360.</I><!-- /caption -->

<P>The four values under this key are the basic four entries used by a device driver under Windows CE. The Prefix value defines the three-letter name of the driver. Applications that want to open this driver use the three-letter key with the number that Windows CE appends to create the device name. 

<P>The Index value is the number that will be appended to the device name. The Dll key specifies the name of the DLL that implements the driver. This is the DLL that Device.exe loads. 

<P>The Order value allows the OEM to recommend the order in which the drivers are loaded. Device.exe loads drivers with lower Order values before drivers with higher Order<I> </I>values in the registry. As Device.exe reads each of the registry keys, it loads the DLL specified, calls <I>RegisterDevice</I> to register the DLL as a device driver with the system, and then unloads the DLL. The DLL stays in memory because <I>RegisterDevice</I> increments the use count of the DLL.

<P>While this is the standard load procedure, you can use another method. If the driver key contains a value named Entry, Device loads the DLL, and then, instead of calling <I>RegisterDevice</I>, it calls the entry point in the driver named in Entry. The driver is then responsible for calling the <I>RegisterDevice</I> function on its own so that it will be registered as a driver with the system.

<P>The Entry value allows OEMs to fine-tune the loading process for a driver, if necessary. If the Entry key is present, another key, Keep, can also be specified. Specifying the Keep key tells Device.exe not to attempt to unload the driver after it calls the driver's entry point. This allows the driver DLL to avoid calling <I>RegisterDevice</I> and therefore avoid being a driver at all. Instead, the DLL is simply loaded into the process space of Device.exe.

<P>One of the subtle points about having Device.exe load the installable drivers is that all these drivers will execute in the same 32-MB process space of Device.exe. This coincidence allows related drivers to actually directly call entry points in each other, although the preferred method would be to formally make an IOCTL call into the other driver. You can't count on this common process arrangement in future versions of Windows CE.

<A NAME="518"><H3>GWES.exe</H3></A>

<P>Referring again to the list in the registry, we see that the next module to be loaded is GWES.EXE. GWES.exe contains the GWE subsystem. As I mentioned earlier in the book, GWE stands for Graphics Windowing and Event Subsystem. Essentially, GWES is the graphical user interface over the top of the base operating system composed of NK, FileSys, and Device.

<P>Because the GWE forms the user interface of a graphical version of Windows CE, it's not too surprising that the drivers that directly access the user interface hardware, the keyboard, the touch panel, and the display are loaded by GWES.exe instead of Device.exe. A &quot;pure&quot; operating system design would isolate these drivers with the others, down in the kernel. Given the lightweight nature of Windows CE, however, having these drivers loaded by GWE makes a faster and simpler interface for the operating system. These drivers also don't support the standard stream interface required of drivers loaded by Device.exe. Instead, each driver has a custom set of entry points called by GWES.exe.

<P>Unlike device.exe, GWES.exe doesn't load just any set of drivers. Instead, GWE simply loads three predefined drivers: the keyboard driver, the touch panel driver, and the display driver. GWES.exe looks in the registry in the following keys to find these drivers all under the root registry key of [HKEY_LOCAL_MACHINE]:

<P><table cellpadding=5 width="95%">
  <tr>
    <td valign="top"><b>Driver</b></td>
    <td valign="top"><b>Registry Key Name</b></td>
    <td valign="top"><b>Value Name</b></td>
  </tr>

  <tr>
    <td valign="top">Keyboard</td>
    <td valign="top">\HARDWAREDEVICEMAP\KEYBD</td>
    <td valign="top">DriverName</td>
  </tr>
  <tr>
    <td valign="top">Touch Panel</td>
    <td valign="top">\HARDWARE\DEVICEMAP\TOUCH</td>
    <td valign="top">DriverName</td>
  </tr>
  <tr>
    <td valign="top">Display</td>
    <td valign="top">\SYSTEM\GDI\DRIVERS</td>
    <td valign="top">Display</td>
  </tr>
</table>

<P>If the registry entries aren't found for a particular driver, GWES.exe uses default names for that driver. These drivers are written by the OEM and are called <I>native drivers</I> to differentiate them from the installable form of a driver loaded by Device.

<P>In addition to the drivers loaded by GWE, the OEM also is charged with writing a small amount of system adaptation code to support GWE. This code deals with providing information about the state of the battery and an interface to the notification LED, if one is present. Although this code can be statically linked to GWE when the system is built, many OEMs isolate this code into one or more DLLs and statically link only a small amount of code that loads these DLLs.

<A NAME="519"><H3>Custom processes</H3></A>

<P>At this point in the boot process, Windows CE, as an operating system, is up and running. All that's left is to launch the shell. Some OEMs, however, launch processes at this point that manage some OEM-specific tasks. Although you <I>can</I> launch other applications before you launch the Explorer, you should be careful about that, as I mentioned before. The Explorer isn't written to handle visible top-level windows that are created before the Explorer. You can see this by inserting the following lines in the init key that launches Calc before the Explorer:

<p><pre>
Launch45        calc.exe
Depend45        0014 001E 
</PRE>

<P>After you insert the lines, reset your Windows CE device. Tap the desktop button on the right end of the taskbar a couple of times and you'll see the Calc window. Pressing on the Pop-Up button reduces the size of the Calc window so you can again see the Explorer underneath. Notice that the taskbar doesn't have a button for the Calc window. Nor, if you press Alt-Tab, is Calc listed in the Active Tasks list. Figure 142 shows this unusual arrangement of Calc and the Explorer on an H/PC.


<P><A HREF="javascript:fullSize('F14RG02x.htm')"> <img src="F14RG02.JPG" width=404 height=152 border=0 ALT="Click to view at full size."> </A>
<P><!-- caption --><B>Figure 14-2.</B> <I>The unusual arrangement of Calc and the Explorer.</I><!-- /caption -->

<P>Because of the limitations of this arrangement, you shouldn't launch applications with a user interface before the Explorer is launched. On the other hand, if you have an application that doesn't have a user interface but you need to launch before the shell, this is the time to do it.

<A NAME="520"><H3>Explorer.exe</H3></A>

<P>Finally the list is terminated by the launch of the Explorer, or Shell32.exe, if the system is a Palm-size PC. The Explorer is, of course, the shell. Although the latest versions of the Explorer add some functions to the API, the trend is to move as many functions as possible from the shell to the operating system. This allows developers of embedded systems to use those functions even if the system doesn't include the Explorer.

<P>At this point, the location of the list of files launched during startup changes from the registry to the file system. After the Explorer initializes the desktop and the taskbar window, it looks in the \windows\startup directory and launches any executables or shortcuts contained in that directory. This is the standard, user-accessible method for launching applications when the system starts. This auto launching is part of the Explorer, so if you're building an embedded system without the Explorer, you'll have to perform this last task yourself.

<A NAME="521"><H2>Powering Up Doesn't Boot the System</H2></A>

<P>One thing to always remember in Windows CE is that for most configurations, including all battery-powered systems, pressing the Power button doesn't reset the device. As I explained in <A HREF="ch06a.htm">Chapter 6</a>, when the system is powered down it doesn't really turn off. Instead, the system enters an extremely low power state in which all the peripherals and the CPU power down but the state of the RAM is maintained. When a user presses the power switch, the system restores power and simply returns to the thread that was executing when the power button was originally pressed.

<P>Battery-powered Windows CE systems are reset only when power is initially applied to the system&#8212;that is, when the first set of batteries is put in the device. Other than that, resets occur only when the user presses the reset button that's generally exposed through a pinhole somewhere on the case of the device. Memory isn't erased when a user presses the reset switch, which allows FileSys to use the Object Store that was already in RAM before the reset.

<P><div class="sidebar"><blockquote><ol>
<P><LI>The program that builds the ROM image inserts the proper jump instructions, or vector, at the reset location, which causes the CPU to start executing code at the entry point of NK.
<P><LI>All Windows CE systems, including all H/PCs and Palm-size PCs, have a way to access a dedicated serial port used for debugging.  For consumer platforms, where controlling hardware cost is critical, this debug serial port is typically on a separate &quot;debug board&quot; that can be plugged into a system.  
<P><LI>It's the OEM's decision whether to run a RAM test when the system boots.  Microsoft requires only that the system boot process is complete within 5 or so seconds.
<P><LI>CESH is a PC-based debugging tool provided by Microsoft in the ETK. It was called PPSH, for parallel port shell, before the release of Windows CE 2.1.
</ol></blockquote></div>




</BODY>
</HTML>




