<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Supplementary Input Panel</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="472"><H1>The Supplementary Input Panel</H1></A>

<P>The SIP gives the user access to a keyboard's capacities on devices that don't have a keyboard or at times when the keyboard of a device isn't available to the user. Having a SIP on a Windows CE system affects the application in a couple of ways. First the screen real estate used by the SIP isn't available to the application. Second since the SIP can be displayed and hidden interactively by the user, the amount of the screen that's available to the application can change while the application is running. What doesn't change is the way an application deals with keyboard input. Characters entered by means of a SIP appear to an application in the same message-based way that keys appear if they're pressed on a hardware keyboard. That is, the same series of WM_KEYDOWN, WM_CHAR, and WM_KEYUP messages are generated by the system in response to a key being entered through a SIP.

<P>A SIP can use a number of different <I>input methods</I> or IMs. These input methods are installable components and provide the user interface to the SIP. Two such input methods are the keyboard IM and the Jot Character recognizer IM, which are provided on the Palm-size PC.

<A NAME="473"><H2>Working with a SIP</H2></A>

<P>The functions available to Windows CE applications for interaction with the SIP have changed since they were introduced with the Palm-size PC. So while Windows CE 2.1 adds a newer and more general set of functions, I'm going to present the Palm-size PC functions first, because most applications dealing with the SIP run, at this point, on the Palm-size PC. At the end of this section, I'll describe the different functions provided by Windows CE 2.1 for use with the SIP.

<P>The primary function an application uses when dealing with the SIP on a Palm-size PC is <I>SHSipInfo</I>. This omnibus function allows an application to receive information about the current SIP settings (such as its location), set those settings, query the current default SIP, and even change the default SIP. The function is prototyped as

<p><pre>
BOOL SHSipInfo (UINT uiAction, UINT uiParam, PVOID pvParam,
                UINT fWinIni);
</PRE>

<P>The first parameter to <I>SHSipInfo</I>, <I>uiAction</I>, should be set with a flag that specifies the action you want to perform with the function. The allowable flags are these:

<UL>
<P><LI><I>SPI_SETSIPINFO</I> Sets the SIP configuration including its location and its visibility
<P><LI><I>SPI_GETSIPINFO</I> Queries the SIP configuration
<P><LI><I>SPI_SETCURRENTIM</I> Sets the current default input method
<P><LI><I>SPI_GETCURRENTIM</I> Queries the current default input method
</UL>

<P>Because the behavior of <I>SHSipInfo</I> is completely different for each of the flags, I'll describe the function as if it were four different function calls. For each of the flags though, the second and fourth parameters, <I>uiParam</I> and <I>fWinIni</I>, must be set to 0.

<A NAME="474"><H3>Querying the state of the SIP</H3></A>

<P>To query the current state of the SIP, you would call <I>SHSipInfo</I> with the SPI_GETSIPINFO flag in the <I>uiAction</I> parameter. In this case, the function looks like this:

<p><pre>
BOOL SHSipInfo (SPI_GETSIPINFO, 0, SIPINFO *psi, 0);
</PRE>

<P>The third parameter must point to a SIPINFO structure, which is defined as

<p><pre>
typedef struct {
    DWORD cbSize;
    DWORD fdwFlags;
    RECT rcVisibleDesktop;
    RECT rcSipRect;
    DWORD dwImDataSize;
    VOID *pvImData;
} SIPINFO;
</PRE>

<P>The structure's first field, <I>cbSize</I>, must be set to the size of the SIPINFO structure before a call is made to <I>SHSipInfo</I>. The second field in SIPINFO, <I>fdwFlags</I>, can contain a combination of the following flags:

<UL>
<P><LI><I>SIPF_ON</I> When set, the SIP is visible.<P>
<P><LI><I>SIPF_DOCKED</I> When set, the SIP is docked to its default location on the screen.
<P><LI><I>SIPF_LOCKED</I> When set, the visibility state of the SIP can't be changed by the user.
</UL>

<P>The next two fields of SIPINFO provide information on the location of the SIP. The field <I>rcVisibleDesktop</I> is filled with the screen dimensions of the visible area of the desktop. If the SIP is docked, this area is the rectangle above the SIP. If the SIP is undocked, this rectangle contains the full desktop area minus the taskbar, if it's showing. This field is ignored when you set the SIP configuration. Some SIPs might have a docked state that doesn't run from edge to edge of the screen. In this case, the rectangle describes the largest rectangular area of the screen that isn't obscured by the SIP.

<P>The <I>rcSipRect</I> field contains the location and size of the SIP. If the SIP is docked, the rectangle is usually the area of the screen not included by <I>rcVisibleDesktop</I>. But if the SIP is undocked, <I>rcSipRect</I> contains the size and position of the SIP while <I>rcVisibleDesktop</I> contains the entire desktop not obscured by the taskbar, including the area under the SIP. Figure 13-1 shows the relationship between <I>rcVisibleDesktop</I> and <I>rcSipRect</I>.

<P><A HREF="javascript:fullSize('f13rg01x.htm')"> <img src="f13rg01.JPG" width=404 height=308 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 13-1.</B> <I>The relationship between </I>rcVisibleDesktop<I> and </I>rcSipRect<I> in the SIPINFO structure.</I><!-- /caption -->

<P>The final two fields of SIPINFO allow you to query information specific to the current input method. The format of this information is defined by the input method. To query this information, the <I>pvImData</I> field should be set to point to a buffer to receive the information and <I>dwImDataSize</I> should be set to the size of the buffer. It is up to the application to know which input methods provide what specific data. For most input methods, these two fields should be set to 0 to indicate that no IM-specific data is being queried.

<A NAME="475"><H3>Setting the SIP configuration</H3></A>

<P>To set the configuration of the current SIP, you call <I>SHSipInfo</I> with the SPI_SETSIPINFO flag, as in

<p><pre>
BOOL SHSipInfo (SPI_SETSIPINFO, 0, SIPINFO *psi, 0);
</PRE>

<P>The parameters are the same as when you call to query the SIP configuration with the third parameter pointing to a SIPINFO structure. As a general rule, you shouldn't fill in the SIPINFO fields from scratch. Instead, you should call <I>SHSipInfo</I> to fill in the SIPINFO structure, modify the fields necessary to make your change, and then call <I>SHSipInfo</I> again to make the changes. That said, you really can't change much with the present version of the Palm-size PC shell. Currently, an application can't undock a SIP, move the SIP, or even dock an undocked SIP. The only state that an application can change is to show or hide the SIP by toggling the SIPF_ON flag in the <I>fdwFlags</I> field of the SIPINFO structure.

<A NAME="476"><H3>Changing the default input method</H3></A>

<P>You can use <I>SHSipInfo</I> to query and to change the current SIP. To query the current SIP, you call <I>SHSipInfo</I> with the SPI_GETCURRENTIM flag in the <I>uiAction</I> parameter as in

<p><pre>
BOOL SHSipInfo (SPI_SETSIPINFO, 0, CLSID *pclsid, 0);
</PRE>

<P>In this case, the third parameter points to a CLSID variable that receives the CLSID of the current input method.

<P>To set the current input method, call <I>SHSipInfo</I> with the <I>uiAction</I> parameter set to SPI_SETCURRENTIM, as in

<p><pre>
BOOL SHSipInfo (SPI_SETSIPINFO, 0, CLSID *pclsid, 0);
</PRE>

<P>Here again, the third parameter of <I>SHSipInfo</I> is a pointer to a CLSID value. In this case, the value must contain a CLSID of a valid input method.

<A NAME="477"><H3>Enumerating the installed input methods</H3></A>

<P>The Palm-size PC has no function that enumerates the input methods that are installed on a system. So applications must iterate through the registry to find the input method DLLs. Fortunately, this isn't an onerous task because input methods are COM objects, and an input method is required to have a special key named <I>IsSIPInputMethod</I> with a default value of 1 in its COM registration key. So, to enumerate the installed input methods, all you have to do is enumerate the CLSID keys under [HKEY_CLASSES_ROOT]\CLSID. In each key that you open, look for the subkey <I>IsSIPInputMethod</I>. If you find it, the entry is the CLSID of an input method and the default value of the CLSID key is the name of the input method.

<P>The routine that follows enumerates the installed input methods. The routine fills a buffer with a list of strings. For each input method found, the routine returns two strings, the CLSID of the input method and the input method's friendly name. The list is terminated with a null character.

<P><pre>
//----------------------------------------------------------------------
// EnumerateInputMethods - Produces a list of installed input methods 
// and their CLSIDs  
//
int EnumerateInputMethods (LPTSTR pOut, int sMax) {
    INT i = 0, rc, nCnt = 0;
    HKEY hKey, hSubKey, hKey2;
    DWORD dwType, dwSize;

    // Open CLSID key.
    if (RegOpenKeyEx (HKEY_CLASSES_ROOT, TEXT (&quot;CLSID&quot;), 0,
                      0, &amp;hKey) != ERROR_SUCCESS) 
        return 0;
    sMax -= 2;                 // Make room for terminating zero.
    while (sMax &gt; 0) {
        // Enumerate active driver list.
        dwSize = sMax;
        if (RegEnumKeyEx (hKey, i++, pOut, &amp;dwSize, NULL, NULL, 
                          NULL, NULL) != ERROR_SUCCESS) 
            break;

        // Open object ID key for object.
        rc = RegOpenKeyEx (hKey, pOut, 0, 0, &amp;hSubKey);
        if (rc != ERROR_SUCCESS) 
            continue;

        // See if IsSIPMethod key present indicating an IM object.
        rc = RegOpenKeyEx (hSubKey, TEXT (&quot;IsSIPInputMethod&quot;), 0, 0,
                           &amp;hKey2);

        if (rc == ERROR_SUCCESS) {
            RegCloseKey (hKey2);
            // Move output pointer beyond CLSID.
            sMax -= (lstrlen (pOut) + 1) * sizeof (TCHAR);
            if (sMax &gt; 0)
                pOut += lstrlen (pOut) + 1;
            else
                break;
            // Get name of IM.
            dwSize = sMax;
            rc = RegQueryValueEx (hSubKey, 0, 0, &amp;dwType, 
                                  (PBYTE)pOut, &amp;dwSize);
            RegCloseKey (hSubKey);
            if (rc != ERROR_SUCCESS) {
                *pOut = TEXT (`\0');
                RegCloseKey (hSubKey);
                RegCloseKey (hKey);
                return -1;
            }
            // Move output pointer beyond current name.
            sMax -= (int)dwSize;
            if (sMax &gt; 0)
                pOut += lstrlen (pOut) + 1;
            nCnt++;
        }
        RegCloseKey (hSubKey);
    }
    RegCloseKey (hKey);
    // Add terminating zero.
    if (!rc)
        *pOut = TEXT (`\0');
    return nCnt;
}
</pre>

<A NAME="478"><H2>Reacting to SIP Changes</H2></A>

<P>When the user or an application displays or hides the SIP, the Palm-size PC shell sends a WM_SETTINGCHANGE message to all top-level windows. To indicate that the message was sent in response to the state of the SIP changing, the <I>wParam</I> value is set to the constant SPI_SETSIPINFO. You can then call <I>SHSipInfo</I> to determine the new state of the SIP. Note that while this message is sent to all top-level windows, only the foreground window should make any changes to the SIP. A window not in the foreground can save the indication that the SIP state has changed and respond when that window is brought to the foreground.

<P>When the user changes the input method of the SIP, a WM_SETTINGCHANGE message is sent to all top-level windows. In this case, the <I>wParam</I> value is set to the constant SPI_SETCURRENTIM.

<P>When a foreground application detects that the SIP has been displayed, it should ensure that the SIP doesn't obscure the location of the input caret or, in the case of a dialog box, the control that currently has focus. In most cases, this means scrolling the window or reconfiguring the dialog box so that the user can see the control even with the SIP displayed. Another option is to always have controls laid out on the top two thirds of the Palm-size PC screen because docked SIPs won't obscure this area.

<A NAME="479"><H2>Input Panels on Windows CE 2.1 Devices</H2></A>

<P>One of the goals of Windows CE 2.1 was to take some of the more interesting and useful functional units of the different H/PC and Palm-size PC shells and move them into the base operating system. This would allow developers of embedded systems, who don't currently have access to those complex shells, to use those functional blocks. One of the functional blocks moved is the notification API that I talked about in <A HREF="ch12a.htm">Chapter 12</a>. Another functional block is the SIP architecture. When the SIP was moved to the operating system from the shell, the API for the SIP was redesigned to be a more general API. Because of this, SIP-aware applications written for Windows CE 2.1 need to use a different set of functions than used by their Palm-size PC cousins.

<P>Note that the SIP API isn't the same IME API that's also supported on Windows CE 2.1. The IME API is a much more general and complex API than the relatively simple SIP needs.

<P>The first four functions of the Windows CE 2.1 SIP API correspond directly to the four different modes of the Palm-size PC's <I>SHSipInfo</I> functions. Their prototypes are

<p><pre>
BOOL SipGetInfo (SIPINFO *pSIPInfo); 
BOOL SipSetInfo (SIPINFO *pSIPInfo); 
BOOL SipGetCurrentIM (CLSID *pClsid); 
BOOL SipSetCurrentIM (CLSID *pClsid); 
</PRE>

<P>Both <I>SipGetInfo</I> and <I>SipSetInfo</I> use the same SIPINFO structure that I described earlier in connection to the <I>SHSipInfo </I>function. Likewise, the <I>SipGetCurrentIM</I> and <I>SipSetCurrentIM</I> functions use pointers to CLSID values to identify the input methods.

<P>A new function has been added to simplify the process of showing and hiding the SIP. Instead of using <I>SipGetInfo</I> and <I>SipSetInfo</I> to fill in a SIPINFO structure and modify the SIPF_ON flag to show or hide the SIP, you can use the <I>SipShowIM</I> function. It's prototyped as

<p><pre>
BOOL SipShowIM (DWORD dwFlags); 
</PRE>

<P>The only flags that can be specified are SPIF_ON and SPIF_OFF.

<P>Instead of your having to manually enumerate the input methods by looking through the registry, you can use a new function, <I>SipEnumIM</I>. This function is prototyped as

<p><pre>
int SipEnumIM (IMENUMPROC pEnumIMProc); 
</PRE>

<P>The only parameter is a pointer to an enumeration function in your application. If you pass NULL in the <I>pEnumIMProc</I> parameter, <I>SipEnumIM</I> returns the number of input methods installed on the system. The callback function should be prototyped as

<p><pre>
int SipEnumIMProc (IMENUMINFO * pIMInfo); 
</PRE>

<P>Windows CE will call the enumeration function once for each input method installed on the system. The function will be called with the parameter pointing to an IMENUMINFO structure, which is defined as

<p><pre>
struct _IMENUMINFO {
    TCHAR szName[MAX_PATH];
    CLSID Clsid;
} IMENUMINFO;
</PRE>

<P>Here again, the fields are fairly self-explanatory. The <I>szName</I> is the friendly name of the IM, while the <I>Clsid</I> field contains the CLSID value for the IM.

<P>Another function is <I>SipStatus</I>. This function tells the caller whether the SIP component of Windows CE is installed on a system. The function is prototyped as

<p><pre>
DWORD SipStatus(void); 
</PRE>

<P>The function returns SIP_STATUS_AVAILABLE if the SIP functions are available or SIP_STATUS_UNAVAILABLE if the SIP component isn't installed.

<P>The last two functions are provided for SIP maintenance. The Palm-size PC doesn't need these functions because its shell maintains the SIP. For systems whose shells don't have knowledge of a SIP, you'll have to write an application that maintains the SIP through these functions. A better alternative would be to have your custom shell provide the SIP maintenance through these functions.

<P>On the Palm-size PC, the taskbar maintains the button that displays and hides the SIP window. The taskbar maintains a button that displays a bitmap, which represents the current input method so that the user knows which input method is the default. On other systems, this function must be performed by another application or more likely, by a custom shell. To provide this function, the custom shell needs to know what bitmap the SIP wants displayed, while also maintaining the default rectangle for the SIP. Windows CE 2.1 gives you two functions for this purpose.

<P>The <I>SipRegisterNotification</I> function can be called by the application that maintains the SIP. This application will then be notified when the input method changes the bitmaps that are used to represent the input method. Only one application, the application that manages the SIP, can call <I>SipRegisterNotification</I> to ask to be notified when the SIP changes state. That application will then be notified about input method changes until the system is rebooted. The function is prototyped as

<p><pre>
BOOL SipRegisterNotification (HWND hWnd); 
</PRE>

<P>The only parameter is the window that will receive the notifications. That window will receive WM_IM_INFO messages when an input method initially sets or later changes its bitmaps. The <I>wParam</I> for this message contains one of the following flags, indicating what's being changed by the input method. These flags are

<UL>
<P><LI><I>IM_POSITION</I> The size or position of the input method has changed.
<P><LI><I>IM_WIDEIMAGE</I> The input method has selected a new wide image.
<P><LI><I>IM_NARROWIMAGE</I> The input method has selected a new narrow image.
</UL>

<P>The <I>lParam</I> parameter contains different data, depending on the flag. For IM_POSITION, <I>lParam</I> isn't used. For IM_WIDEIMAGE and IM_NARROWIMAGE, <I>lParam</I> contains the handle to the new bitmap to be used.

<P>The final function is also used by the custom shell or the application maintaining the SIP. It is

<p><pre>
BOOL SipSetDefaultRect (RECT * pRect); 
</PRE>

<P>This function is called to set the default docked rectangle for the SIP. This allows a custom shell to define where the docked position of the SIP is to be on the screen. The only parameter is the rectangle that defines the default location. This new location won't be used until a new input method is selected either by the user or by the program.

<P>You might want to have your SIP-aware applications that need to be cross-compatible with the Palm-size PC shell manually load the function pointers to the different SIP functions. This procedure would allow an application to run both on the Palm-size PC as well as on any embedded Windows CE 2.1 or later system. I describe how to do this in <A HREF="ch14a.htm">Chapter 14</a>.

</BODY>
</HTML>




