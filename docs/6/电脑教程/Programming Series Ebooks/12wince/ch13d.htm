<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Hardware Keys</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="504"><H1>Hardware Keys</H1></A>

<P>The SIP isn't the only way for the user to enter keystrokes to an application. All Palm-size PCs and some Handheld PCs have additional buttons that can be assigned to launch an application or to send unique virtual key codes to applications. The Palm-size PC has an additional set of buttons known as <I>navigation buttons</I> that mimic common navigation keys such as Line Up and Line Down. These navigation keys give the user shortcuts, which allow scrolling up and down as well as access to the services of the often-used keys, Enter and Escape. Because the scrolling buttons simply send Page Up, Page Down, Line Up, and Line Down key messages, your application doesn't have to take any special action to use these keys.

<P>The application launch buttons are another matter. When pressed, these keys cause the shell to launch the application registered for that key. Although a system is usually configured with default associations, you can override these settings by modifying the registry so that pressing a hardware control button launches your application. An application can also override the application launch ability of a specific key by having the key mapped directly to a window. In addition, you can use the hot key features of GWE to override the hardware key assignment and send a hot key message to a window.

<A NAME="505"><H2>Virtual Codes for Hardware Keys </H2></A>

<P>Since the hardware control buttons are treated as keyboard keys, pressing a hardware control key results in WM_KEYDOWN and WM_KEYUP messages as well as a WM_CHAR message if the virtual key matches a Unicode character. The system mapping of these keys employs two strategies. For the navigation keys, the resulting virtual key codes are codes known and used by Windows applications so that those applications can &quot;use&quot; the keys without even knowing that's what they're doing. The application-launching keys, on the other hand, need virtual key codes that are completely different from previously known keys so that they won't conflict with standard key events.

<A NAME="506"><H3>Navigation key codes</H3></A>

<P>As I mentioned above, the navigation keys are mapped to common navigation keys. The actual virtual key code mapping for navigation keys is shown below.

<p><table cellpadding=5 width="95%">
  <tr>
    <td valign="top"><b>Key</b></td>
    <td valign="top"><b>Action</b></td>
    <td valign="top"><b>Key Message</b></td>
    <td valign="top"><b>Key Code</b></td>
  </tr>
  <tr>
    <td valign="top">Action</td>
    <td valign="top">Press</td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top">Action</td>
    <td valign="top">Release</td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">VK_RETURN</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_CHAR</td>
    <td valign="top">VK_RETURN</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">VK_RETURN</td>
  </tr>
  <tr>
    <td valign="top">Exit</td>
    <td valign="top">Press</td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">VK_ESCAPE</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">VK_ESCAPE</td>
  </tr>
  <tr>
    <td valign="top">Rock Up</td>
    <td valign="top">Press</td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top">Release</td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">VK_UP</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">VK_UP</td>
  </tr>
  <tr>
    <td valign="top">Rock Down</td>
    <td valign="top">Press</td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top">Release</td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">OEM dependent*</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYDOWN</td>
    <td valign="top">VK_DOWN</td>
  </tr>
  <tr>
    <td valign="top"></td>
    <td valign="top"></td>
    <td valign="top">WM_KEYUP</td>
    <td valign="top">VK_DOWN</td>
  </tr>
</table>


<P><div class="sidebar"><blockquote>
<P>*     OEM-dependent key codes differ from system to system. Some OEMs might not send these messages while others may send the messages with a virtual key code of 0.</blockquote></div>

<P>Unfortunately, there's no reliable way of determining whether a VK_RETURN key event came from the SIP or from a hardware button. Each OEM has a different method of assigning virtual key codes to the hardware navigation buttons.

<A NAME="507"><H3>Application launch key codes</H3></A>

<P>The shell manages the application launch keys named App1 through a possible App16. These keys produce a combination of virtual key codes that are interpreted by the shell. The codes produced are a combination of the left Windows key (VK_LWIN) and a virtual code starting with 0xC1 and continuing up, depending on the application key pressed. For example, App1 key produces the virtual key sequence VK_LWIN followed by 0xC1 while App2 key produces the sequence VK_LWIN followed by 0xC2.

<A NAME="508"><H2>Using the Application Launch Keys</H2></A>

<P>Applications are bound to a specific application launch key through entries in the registry. Specifically, each key has an entry under [HKEY_LOCAL_MACHINE]\Software\Microsoft\Shell\Keys. The entry is the virtual key combination for that key, so for the App1 key, the entry is

<p><pre>
[HKEY_LOCAL_MACHINE]\Software\Microsoft\Shell\Keys\40C1
</PRE>

<P>The 40C1 comes from the code 0x40, which indicates the Windows key has been pressed and concatenated with the virtual key code of the application key, 0xC1. The default value assigned to this key is the fully specified path name of the application assigned to the key. A few other values are also stored under this key. The <I>ResetCmd</I> value is the path name of the application that is assigned to this key if the Restore Defaults button is pressed in the Palm-size PC's Button control panel applet. The <I>Name</I> value contains the friendly name of the key, such as Button 1 or Side Button.

<P>The only way to change the application assigned to a key is to manually change the registry entry to point to your application. Of course, you shouldn't do this without consulting your users, since they may have already configured the application keys to their liking. The routine that follows assigns an application to a specific button and returns the name of the application previously assigned to that button. The <I>vkAppKey</I> parameter should be set to an application key virtual key code, 0xC1 through 0xCF. The <I>pszNewApp</I> parameter should point to the fully specified path name of the application you want to assign to the key.


<p><pre>
//----------------------------------------------------------------------
// SetAppLaunchKey - Assigns an application launch key to an 
// application
//
int SetAppLaunchKey (LPTSTR pszNewApp, BYTE vkAppKey, LPTSTR pszOldApp, 
                     INT nOldAppSize) {

    TCHAR szKeyName[256];
    DWORD dwType, dwDisp;
    HKEY hKey;
    INT rc;

    // Construct the key name.
    wsprintf (szKeyName, 
        TEXT (&quot;Software\\Microsoft\\Shell\\Keys\\40%02x&quot;), vkAppKey);

    // Open the key.
    rc = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0, TEXT (&quot;&quot;),
                         0, 0, NULL, &amp;hKey, &amp;dwDisp);
    if (rc != ERROR_SUCCESS)
        return -1;

    // Read the old application name.
    rc = RegQueryValueEx (hKey, TEXT (&quot;&quot;), 0, &amp;dwType, 
                          (PBYTE)pszOldApp, &amp;nOldAppSize);
    if (rc != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        return -2;
    }
    // Set the new application name.
    rc = RegSetValueEx (hKey, TEXT (&quot;&quot;), 0, REG_SZ, (PBYTE)pszNewApp,
                        (lstrlen (pszNewApp)+1) * sizeof (TCHAR));
    RegCloseKey (hKey);
    if (rc != ERROR_SUCCESS) 
        return -3;

    return 0;
}
</PRE>

<P>When an application button is pressed, the system doesn't check to see whether another copy of the application is already running&#8212;it simply launches a new copy. You should design your application, especially on the Palm-size PC, to check to see whether another copy of your application is already running and if so, to activate the first copy of the application and quietly terminate the newly launched copy.

<P>You can determine whether an application is assigned to a key by calling the Palm-size PC-specific function <I>SHGetAppKeyAssoc</I>, which is prototyped as

<p><pre>
Byte SHGetAppKeyAssoc (LPCTSTR ptszApp);
</PRE>

<P>The only parameter is the fully qualified name of your application. If a key is associated with your application, the function returns the virtual key code for that key. If no key is associated with your application, the function returns 0. This function is useful because most applications, when launched by an application key, override the default action of the key so that another copy of the application won't launch if the key is pressed again.



<A NAME="509"><H2>Dynamically Overriding Application Launch Keys</H2></A>

<P>A running application can override a launch key in two ways. The first method is to use the Palm-size PC-specific function <I>SHSetAppKeyWndAssoc</I>, prototyped as

<p><pre>
BOOL SHSetAppKeyWndAssoc (BYTE bVk, HWND hwnd);
</PRE>

<P>The first parameter is the virtual key code of the hardware button. The second parameter is the handle of the window that's to receive the notices of button presses. For example, a program might redirect the App1 key to its main window with the following line of code:



<p><pre>
SHSetAppKeyWndAssoc (0xC1, hwndMain);
</PRE>

<P>The window that has redirected an application might receive key messages but the virtual key codes received and the type of key messages are OEM-specific. The chief reason for using <I>SHSetAppKeyWndAssoc</I> is to prevent the button from launching an application. When you no longer want to redirect the application launch key, you can call <I>SHSetAppKeyWndAssoc</I> specifying the virtual code of the key and NULL for the window handle.

<P>The second method of overriding an application launch key is to use the <I>RegisterHotKey</I> function. The advantage of using the <I>RegisterHotKey</I> function is that your window will receive known messages, albeit WM_HOTKEY instead of WM_KEY<I>xxx</I> messages when the key is pressed, no matter what application currently has the keyboard focus. A second, even more important reason to use <I>RegisterHotKey </I>is that this function is supported on Handheld PCs as well as on Palm-size PCs. This function is prototyped as


<p><pre>
BOOL RegisterHotKey (HWND hWnd, int id, UINT fsModifiers, UINT vk);
</PRE>

<P>The first parameter is the handle of the window that receives the WM_HOTKEY messages. The second parameter is an application-defined identifier that's included with the WM_HOTKEY message to indicate which key caused the message. The <I>fsModifiers </I>parameter should be set with flags, indicating the shift keys that must also be pressed before the WM_HOTKEY message can be sent. These self-explanatory flags are MOD_ALT, MOD_CONTROL, MOD_SHIFT, and MOD_WIN. An additional flag, MOD_KEYUP, indicates that the window will receive WM_HOTKEY messages when the key is pressed and when the key is released. When using <I>RegisterHotKey</I> on application keys, you should always specify the MOD_WIN flag because application keys always are combined with the Windows shift-modifier key. The final parameter, <I>vk</I>, is the virtual key code for the key you want as your hot key. This key doesn't have to be a hardware key code; you can actually use almost any other virtual key code supported by Windows, although assigning Shift-F to your custom fax application might make Pocket Word users a bit irate when they tried to enter a capital <I>F</I>.

<P>When the key registered with <I>RegisterHotKey</I> is pressed, the system sends a WM_HOTKEY message to the window. The <I>wParam</I> parameter contains the ID code you specified when you called <I>RegisterHotKey</I>. The low word of <I>lParam</I> parameter contains the shift-key modifiers, MOD_<I>xxx</I>,<I> </I>that were set when the key was pressed, while the high word of <I>lParam</I> contains the virtual key code for the key.


<P>The disadvantage of using <I>RegisterHotKey</I> is that if another application has already registered the hot key, the function will fail. This can be problematic on the Palm-size PC, where applications stay running until the system purges them to gain extra memory space. One strategy to employ when you want to use a hardware key temporarily&#8212;for example, in a game&#8212;would be to use <I>SHGetAppKeyAssoc</I> to determine what application is currently assigned to that key. It's a good bet that if <I>RegisterHotKey</I> failed due to some other program using it, the application assigned the application key is also the one currently running and has redirected the hot key to its window. You can then send a WM_CLOSE message to that application's main window to see whether it will close and free up the hardware key.

<P>When you no longer need the hot key, you can unregister the hot key with this function:

<p><pre>
BOOL UnregisterHotKey (HWND hWnd, int id);
</PRE>

<P>The two parameters are the window handle of the window that had registered the hot key and the ID value for that hot key you assigned with <I>RegisterHotKey</I>.

<P>As you can see, the Palm-size PC presents new problems and new opportunities for developers. The SIP technology, originally developed for the Palm-size PC, is already starting to migrate to other Windows CE platforms. The application launch buttons are another area of cross platform cooperation. You use the same techniques for managing these buttons on H/PCs as on Palm-size PC devices.


<P>In the final chapter of the book, I step back from application programming and look at system programming issues. <A HREF="ch14a.htm">Chapter 14</a> explains how the different components of Windows CE work together while presenting a unified Win32-compatible API.

</BODY>
</HTML>




