<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Dialog Boxes</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="138"><H1>Dialog Boxes</H1></A>

<P>The CtlView example program demonstrates a complex use of controls. While CtlView creates these controls for demonstration purposes, controls are generally used to query user input. As CtlView demonstrates, a fair amount of code is necessary for creating and placing the controls in the windows. Fortunately, you don't need this code because Windows provides a service for exactly this purpose: dialog boxes. Dialog boxes query data from the user or present data to the user, hence the term <I>dialog</I> box.

<P>Dialog boxes are windows created by Windows using a template provided by an application. The template describes the type and placement of the controls in the window. The Dialog Manager&#8212;the part of Windows that creates and manages dialog boxes&#8212;also provides default functionality for switching focus between the controls using the Tab key as well as default actions for the Enter and Escape keys. In addition, Windows provides a default dialog box window class, freeing applications from the necessity of registering a window class for each of the dialog boxes it might create.

<P>Dialog boxes come in two types: <I>modal</I> and <I>modeless</I>. A modal dialog prevents the user from using the application until the dialog box has been dismissed. For example, the File Open and the Print dialog boxes are modal. A modeless dialog box can be used interactively with the remainder of the application. The Find dialog box in Microsoft Pocket Word is modeless; the user doesn't need to dismiss it before typing in the main window.

<P>Like other windows, dialog boxes have a window procedure, although the dialog box window procedure is constructed somewhat differently from standard windows procedures. Instead of passing unprocessed messages to <I>DefWindowProc</I> for default processing, a dialog box procedure returns TRUE if it processed the message and FALSE if it didn't process the message. Windows supplies a default procedure, <I>DefDialogProc</I>, for use in specific cases&#8212;that is, for specialized modeless dialog boxes that have their own window classes.

<A NAME="139"><H2>Dialog Box Resource Templates</H2></A>

<P>Most of the time, the description for the size and placement of the dialog box and for the controls is provided via a resource called a <I>dialog template</I>. You can create a dialog template in memory, but unless a program has an overriding need to format the size and shape of the dialog box on the fly, loading a dialog template directly from a resource is a much better choice. As is the case for other resources such as menus, dialog templates are contained in the resource (RC) file. The template is referenced by the application using either its name or its resource ID. Here is a dialog template for a simple dialog box:

<p><pre>
GetVal DIALOG discardable 10, 10, 75, 60
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_CENTER
EXSTYLE WS_EX_CAPTIONOKBTN
CAPTION &quot;Enter line number&quot;
BEGIN
    LTEXT &quot;Enter &amp;value:&quot;  IDD_VALLABEL,   5,  10,  40,  12
    EDITTEXT                  IDD_VALUE,  50,  10,  20,  12, WS_TABSTOP
    AUTORADIOBUTTON &quot;&amp;Decimal&quot;, IDD_DEC,   5,  25,  60,  12,
                    WS_TABSTOP | WS_GROUP
    AUTORADIOBUTTON &quot;&amp;Hex&quot;,     IDD_HEX,   5,  40,  60,  12
END
</pre>

<P>The syntax for a dialog template follows a simple pattern similar to that for a menu resource. First is the name or ID of the resource followed by the keyword <I>DIALOG</I> identifying that what follows is a dialog template. The optional <I>discardable</I> keyword is followed by the position and size of the dialog box. The position specified is, by default, relative to the owner window of the dialog box.

<P>The units of measurement in a dialog box aren't pixels but <I>dialog units</I>. A dialog unit is defined as one quarter of the average width of the characters in the system font for horizontal units and one eighth of the height of one character from the same font for vertical units. The goal is to create a unit of measurement independent of the display technology; in practice, dialog boxes still need to be tested in all display resolutions in which the box might be displayed. You can compute a pixel vs. dialog unit conversion using the <I>GetDialogBaseUnits</I> function but you'll rarely find it necessary. The visual tools that come with most compilers these days isolate a programmer from terms like <I>dialog units</I> but it's still a good idea to know just how dialog boxes are described in an RC file.

<P>The <I>STYLE</I> line of code specifies the style flags for the dialog box. The styles include the standard window (WS_<I>xx</I>) style flags used for windows as well as a series of dialog (DS_<I>xx</I>) style flags specific to dialog boxes. Windows CE supports the following dialog box styles:

<UL>
<p><LI><I>DS_ABSALIGN</I> Places the dialog box relative to the upper left corner of the screen instead of basing the position on the owner window.
<p><LI><I>DS_CENTER</I> Centers the dialog box vertically and horizontally on the screen.
<p><LI><I>DS_MODALFRAME</I> Creates a dialog box with a modal dialog box frame that can be combined with a title bar and System menu by specifying the WS_CAPTION and WS_SYSMENU styles.
<p><LI><I>DS_SETFONT</I> Tells Windows to use a nondefault font that is specified in the dialog template.
<p><LI><I>DS_SETFOREGROUND</I> Brings the dialog box to the foreground after it's created. If an application not in the foreground displays a dialog box, this style forces the dialog box to the top of the Z-order so that the user will see it.
</UL>

<P>Most dialog boxes are created with at least some combination of the WS_POPUP, WS_CAPTION, and WS_SYSMENU style flags. The WS_POPUP flag indicates the dialog box is a top-level window. The WS_CAPTION style gives the dialog box a title bar. A title bar allows the user to drag the dialog box around as well as serving as a site for title text for the dialog box. The WS_SYSMENU style causes the dialog box to have a Close button on the right end of the title bar, thus eliminating the need for a command bar control to provide the Close button. Note that Windows CE uses this flag differently from other versions of Windows, in which the flag indicates that a system menu is to be placed on the end of the title bar.

<P>The <I>EXSTYLE</I> line of code specifies the extended style flags for the dialog box. For Windows CE, these flags are particularly important. The WS_EX_CAPTIONOKBTN flag tells the dialog manager to place an OK button on the title bar to the immediate left of the Close button. Having both OK and Close (or Cancel) buttons on the title bar saves precious space in dialog boxes that are displayed on the small screens typical of Windows CE devices. The WS_EX_CONTEXTHELP extended style places a Help button on the title bar to the immediate left of the OK button. Clicking on this button results in a WM_HELP message being sent to the dialog box procedure.

<P>The <I>CAPTION</I> line of code specifies the title bar text of the dialog, providing that the WS_CAPTION style was specified so that the dialog box will have a title bar.

<P>The lines describing the type and placement of the controls in the dialog box are enclosed in <I>BEGIN</I> and <I>END</I> keywords. Each control is specified either by a particular keyword, in the case of commonly used controls, or by the keyword <I>CONTROL,</I> which is a generic placeholder that can specify any window class to be placed in the dialog box. The <I>LTEXT</I> line of code below specifies a static left-justified text control. The keyword is followed by the default text for the control in quotes. The next parameter is the ID of the control, which must be unique for the dialog box. In this template, the ID is a constant defined in an include file that is included by both the resource script and the C or C++ file containing the dialog box procedure.

<P>The next four values are the location and size of the control, in dialog units, relative to the upper left corner of the dialog box. Following that, any explicit style flags can be specified for the control. In the case of the <I>LTEXT</I> line, no style flags are necessary, but as you can see the <I>EDITTEXT</I> and first <I>AUTORADIOBUTTON</I> entries each have style flags specified. Each of the control keywords have subtly different syntax. For example, the <I>EDITTEXT</I> line doesn't have a field for default text. The style flags for the individual controls deserve notice. The edit control and the first of the two radio buttons have a WS_TABSTOP style. The dialog manager looks for controls with the WS_TABSTOP style to determine which control gets focus when the user presses the Tab. In this example, pressing the Tab key results in focus being switched between the edit control and the first radio button.

<P>The WS_GROUP style on the first radio button starts a new group of controls. All the controls following the radio button are grouped together, up to the next control that has the WS_GROUP style. Grouping auto radio buttons allow only one radio button at a time to be selected.

<P>Another benefit of grouping is that focus can be changed among the controls within a group by exploiting the cursor keys as well as the Tab key. The first member of a group should have a WS_TABSTOP style; this allows the user to tab to the group of controls and then use the cursor keys to switch the focus among the controls in the group.

<P>The CONTROL statement isn't used in this example, but it's important and merits some explanation. It's a generic statement that allows inclusion of any window class in a dialog box. It has the following syntax:

<p><pre>
CONTROL &quot;text&quot;, id, class, style, x, y, width, height
    [, extended-style]
</pre>

<P>For this entry, the default text and control ID are similar to the other statements but the next field, <I>class</I>, is new. It specifies the window class of the control you want to place in the dialog box. The <I>class </I>field is followed by the <I>style</I> flags, then the location and size of your control<I>.</I> Finally, the CONTROL statement has a field for extended style flags. If you use Microsoft Developer Studio to create a dialog box and look at the resulting RC file using a text editor, you'll see that Developer Studio uses CONTROL statements instead of the more readable LTEXT, EDITTEXT, and BUTTON statements. There's no functional difference between an edit control created with a CONTROL statement and one created with an EDITTEXT statement. The CONTROL statement is a generic version of the more specific keywords. The CONTROL statement also allows inclusion of controls that don't have a special keyword associated with them.

<A NAME="140"><H2>Creating a Dialog Box</H2></A>

<P>Creating and displaying a dialog box is simple; just use one of the many dialog box creation functions. The first two are these:

<p><pre>
int DialogBox (HANDLE hInstance, LPCTSTR lpTemplate, HWND hWndOwner,
               DLGPROC lpDialogFunc);

int DialogBoxParam (HINSTANCE hInstance, LPCTSTR lpTemplate,
                    HWND hWndOwner, DLGPROC lpDialogFunc,
                    LPARAM dwInitParam);
</pre>

<P>These two functions differ only in <I>DialogBoxParam</I>'s additional <I>LPARAM</I> parameter, so I'll talk about them at the same time. The first parameter to these functions is the instance handle of the program. The second parameter specifies the name or ID of the resource containing the dialog template. As with other resources, to specify a resource ID instead of a name requires the use of the MAKEINTRESOURCE macro.

<P>The third parameter is the handle of the window that will own the dialog box. The owning window isn't the parent of the dialog box because, were that true, the dialog box would be clipped to fit inside the parent. Ownership means instead that the dialog box will be hidden when the owner window is minimized and will always appear above the owner window in the Z-order.

<P>The fourth parameter is a pointer to the dialog box procedure for the dialog box. I'll describe the dialog box procedure shortly. The <I>DialogBoxParam</I> function has a fifth parameter, which is a user-defined value that's passed to the dialog box procedure when the dialog box is to be initialized. This helpful value can be used to pass a pointer to a structure of data that can be referenced when your application is initializing the dialog box controls.

<P>Two other dialog box creation functions create modal dialogs. They are the following:

<p><pre>
int DialogBoxIndirect (HANDLE hInstance, LPDLGTEMPLATE lpTemplate,
                       HWND hWndParent, DLGPROC lpDialogFunc);

int DialogBoxIndirectParam (HINSTANCE hInstance,
                            LPCDLGTEMPLATE DialogTemplate, HWND hWndParent,
                            DLGPROC lpDialogFunc, LPARAM dwInitParam);
</pre>

<P>The difference between these two functions and the two previously described is that these two use a dialog box template in memory to define the dialog box rather than using a resource. This allows a program to dynamically create a dialog box template on the fly. The second parameter to these functions points to a DLGTEMPLATE structure, which describes the overall dialog box window, followed by an array of DLGITEMTEMPLATE structures defining the individual controls.

<P>When any of these four functions are called, the dialog manager creates a modal dialog box using the template passed. The window that owns the dialog is disabled and the dialog manager then enters its own internal <I>GetMessage</I>/<I>DispatchMessage</I> message processing loop; this loop doesn't exit until the dialog box is destroyed. Because of this, these functions don't return to the caller until the dialog box has been destroyed. The WM_ENTERIDLE message that's sent to owner windows in other versions of Windows while the dialog box is displayed isn't supported under Windows CE.

<P>If an application wanted to create a modal dialog box with the template shown above and pass a value to the dialog box procedure it might call this:

<p><pre>
DialogBoxParam (hInstance, TEXT (&quot;GetVal&quot;), hWnd, GetValDlgProc,
               0x1234);
</pre>

<P>The <I>hInstance</I> and <I>hWnd</I> parameters would be the instance handle of the application and the handle of the owner window. The <I>GetVal</I> string is the name of the dialog box template while <I>GetValDlgProc</I> is the name of the dialog box procedure. Finally, <I>0x1234</I> is an application-defined value. In this case, it might be used to provide a default value in the dialog box.

<A NAME="141"><H2>Dialog Box Procedures</H2></A>

<P>The final component necessary for a dialog box is the dialog box procedure. As in the case of a window procedure, the purpose of the dialog box procedure is to field messages sent to the window&#8212;in this case, a dialog box window&#8212;and perform the appropriate processing. In fact, a dialog box procedure is simply a special case of a window procedure, although we should pay attention to a few differences between the two.

<P>The first difference, as mentioned in the previous section, is that a dialog box procedure doesn't pass unprocessed messages to <I>DefWindowProc</I>. Instead, the procedure returns TRUE for messages it processes and FALSE for messages that it doesn't process. The dialog manager uses this return value to determine whether the message needs to be passed to the default dialog box procedure.

<P>The second difference from standard window procedures is the addition of a new message, WM_INITDIALOG. Dialog box procedures perform any initialization of the controls during the processing of this message. Also, if the dialog box was created with <I>DialogBoxParam</I> or <I>DialogBoxIndirectParam</I>, the <I>lParam</I> value is the generic parameter passed during the call that created the dialog box. While it might seem that the controls could be initialized during the WM_CREATE message, that doesn't work. The problem is that during the WM_CREATE message, the controls on the dialog box haven't yet been created, so they can't be initialized. The WM_INITDIALOG message is sent after the controls have been created and before the dialog box is made visible, which is the perfect time to initialize the controls.

<P>Here are a few other minor differences between a window procedure and a dialog box procedure. Most dialog box procedures don't need to process the WM_PAINT message because any necessary painting is done by the controls or, in the case of owner-draw controls, in response to control requests. Most of the code in a dialog box procedure is responding to WM_COMMAND messages from the controls. As with menus, the WM_COMMAND messages are parsed by the control ID values. Two special predefined ID values that a dialog box has to deal with are IDOK and IDCANCEL. IDOK is assigned to the OK button on the title bar of the dialog box while IDCANCEL is assigned to the Close button. In response to a click of either button, a dialog box procedure should call

<p><pre>
BOOL EndDialog (HWND hDlg, int nResult);
</pre>

<P><I>EndDialog</I> closes the dialog box and returns control to the caller of whatever function created the dialog box. The <I>hDlg</I> parameter is the handle of the dialog box while the <I>nResult</I> parameter is the value that's passed back as the return value of the function that created the dialog box.

<P>The difference, of course, between handling the IDOK and IDCANCEL buttons is that if the OK button is clicked, the dialog box procedure should collect any relevant data from the dialog box controls to return to the calling procedure before it calls <I>EndDialog.</I>

<P>A dialog box procedure to handle the GetVal template previously described is shown here:

<p><pre>
//======================================================================
// GetVal Dialog procedure
//
BOOL CALLBACK GetValDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                             LPARAM lParam) {
    TCHAR szText[64];
    INT nVal, nBase;

    switch (wMsg) {
        case WM_INITDIALOG:
            SetDlgItemInt (hWnd, IDD_VALUE, 0, TRUE);
            SendDlgItemMessage (hWnd, IDD_VALUE, EM_LIMITTEXT,
                                sizeof (szText)-1, 0);
            CheckRadioButton (hWnd, IDD_DEC, IDD_HEX, IDD_DEC);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {

                case IDD_HEX:
                    // See if Hex already checked.
                    if (SendDlgItemMessage (hWnd, IDD_HEX,
                            BM_GETSTATE, 0, 0) == BST_CHECKED)
                        return TRUE;

                    // Get text from edit control.
                    GetDlgItemText (hWnd, IDD_VALUE, szText,
                                    sizeof (szText));
                    // Convert value from decimal, then set as hex.
                    if (ConvertValue (szText, 10, &amp;nVal)) {
                        // If conversion successful, set new value.
                        wsprintf (szText, TEXT (&quot;%X&quot;), nVal);
                        SetDlgItemText (hWnd, IDD_VALUE, szText);
                        // Set radio button.
                        CheckRadioButton (hWnd, IDD_DEC, IDD_HEX,
                                          IDD_HEX);
                    } else {
                        MessageBox (hWnd,
                                    TEXT (&quot;Value not valid&quot;),
                                    TEXT (&quot;Error&quot;), MB_OK);
                    }
                    return TRUE;

                case IDD_DEC:
                    // See if Dec already checked.
                    if (SendDlgItemMessage (hWnd, IDD_DEC,
                            BM_GETSTATE, 0, 0) == BST_CHECKED)
                        return TRUE;

                    // Get text from edit control.
                    GetDlgItemText (hWnd, IDD_VALUE, szText,
                                    sizeof (szText));
                    // Convert value from hex, then set as decimal.
                    if (ConvertValue (szText, 16, &amp;nVal)) {
                        // If conversion successful, set new value.
                        wsprintf (szText, TEXT (&quot;%d&quot;), nVal);
                        SetDlgItemText (hWnd, IDD_VALUE, szText);
                        // Set radio button.
                        CheckRadioButton (hWnd, IDD_DEC, IDD_HEX,
                                          IDD_DEC);
                    } else {
                        // If bad conversion, tell user.
                        MessageBox (hWnd,
                                    TEXT (&quot;Value not valid&quot;),
                                    TEXT (&quot;Error&quot;), MB_OK);
                    }
                    return TRUE;

                case IDOK:
                    // Get the current text.
                    GetDlgItemText (hWnd, IDD_VALUE, szText,
                                    sizeof (szText));
                    // See which radio button checked.
                    if (SendDlgItemMessage (hWnd, IDD_DEC,
                            BM_GETSTATE, 0, 0) == BST_CHECKED)
                        nBase = 10;
                    else
                        nBase = 16;
                    // Convert the string to a number.
                    if (ConvertValue (szText, nBase, &amp;nVal))
                        EndDialog (hWnd, nVal);
                    else
                        MessageBox (hWnd,
                                    TEXT (&quot;Value not valid&quot;),
                                    TEXT (&quot;Error&quot;), MB_OK);
                    break;

                case IDCANCEL:
                    EndDialog (hWnd, 0);
                    return TRUE;
            }
        break;
    }
    return FALSE;
}
</pre>

<P>This is a typical example of a dialog box procedure for a simple dialog box. The only messages that are processed are the WM_INITDIALOG and WM_COMMAND messages. The WM_INITDIALOG message is used to initialize the edit control using a number passed, via <I>DialogBoxParam</I>, through to the <I>lParam</I> value. The radio button controls aren't auto radio buttons because the dialog box procedure needs to prevent the buttons from changing if the value in the entry field is invalid. The WM_COMMAND message is parsed by the control ID where the appropriate processing takes place. The IDOK and IDCANCEL buttons aren't in the dialog box template; as mentioned earlier, those buttons are placed by the dialog manager in the title bar of the dialog box.

<A NAME="142"><H2>Modeless Dialog Boxes</H2></A>

<P>I've talked so far about modal dialog boxes that prevent the user from using other parts of the application before the dialog box is dismissed. Modeless dialog boxes, on the other hand, allow the user to work with other parts of the application while the dialog box is still open. Creating and using modeless dialog boxes requires a bit more work. For example, you create modeless dialog boxes using different functions than those for modal dialog boxes:

<p><pre>
HWND CreateDialog (HINSTANCE hInstance, LPCTSTR lpTemplate,
                   HWND hWndOwner, DLGPROC lpDialogFunc);

HWND CreateDialogIndirect (HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate,
                           HWND hWndOwner, DLGPROC lpDialogFunc);

HWND CreateDialogIndirect (HINSTANCE hInstance,
                           LPCDLGTEMPLATE lpTemplate, HWND hWndOwner,
                           DLGPROC lpDialogFunc);
</pre>

<P>or

<p><pre>
HWND CreateDialogIndirectParam (HINSTANCE hInstance,
                                LPCDLGTEMPLATE lpTemplate, HWND hWndOwner,
                                DLGPROC lpDialogFunc, LPARAM lParamInit);
</pre>

<P>The parameters in these functions mirror the creation functions for the modal dialog boxes with similar parameters. The difference is that these functions return immediately after creating the dialog boxes. Each function returns 0 if the create failed or returns the handle to the dialog box window if the create succeeded.

<P>The handle returned after a successful creation is important because applications that use modeless dialog boxes must modify their message loop code to accommodate the dialog box. The new message loop should look similar to the following:

<p><pre>
while (GetMessage (&amp;msg, NULL, 0, 0)) {
    if ((hMlDlg == 0) || (!IsDialogMessage (hMlDlg, &amp;msg))) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
}
</pre>

<P>The difference from a modal dialog box message loop is that if the modeless dialog box is being displayed, messages should be checked to see whether they're dialog messages. If they're not dialog messages, your application forwards them to <I>TranslateMessage</I> and <I>DispatchMessage</I>. The code shown above simply checks to see whether the dialog box exists by checking a global variable containing the handle to the modeless dialog box and, if it's not 0, calls <I>IsDialogMessage</I>. If <I>IsDialogMessage</I> doesn't translate and dispatch the message itself, the message is sent to the standard <I>TranslateMessage</I>/<I>DispatchMessage</I> body of the message loop. Of course, this code assumes that the handle returned by <I>CreateDialog</I> (or whatever function creates the dialog box) is saved in <I>hMlDlg</I> and that <I>hMlDlg</I> is set to 0 when the dialog box is closed.

<P>Another difference between modal and modeless dialog boxes is in the dialog box procedure. Instead of using <I>EndDialog</I> to close the dialog box, you must call <I>DestroyWindow</I> instead. This is because <I>EndDialog</I> is designed to work only with the internal message loop processing that's performed with a modal dialog box. Finally, an application usually won't want more than one instance of a modeless dialog box displayed at a time. An easy way to prevent this is to check the global copy of the window handle to see whether it's nonzero before calling <I>CreateDialog</I>. To do this, the dialog box procedure must set the global handle to 0 after it calls <I>DestroyWindow</I>.

<A NAME="143"><H2>Property Sheets</H2></A>

<P>To the user, a property sheet is a dialog box with one or more tabs across the top that allow the user to switch among different &quot;pages&quot; of the dialog box. To the programmer, a property sheet is a series of stacked dialog boxes. Only the top dialog box is visible; the dialog manager is responsible for displaying the dialog box associated with the tab on which the user clicks. However you approach property sheets, they're invaluable given the limited screen size of Windows CE devices.

<P>Each page of the property sheet, named appropriately enough a <I>property page</I>, is a dialog box template, either loaded from a resource or created dynamically in memory. Each property page has its own dialog box procedure. The frame around the property sheets is maintained by the dialog manager, so the advantages of property sheets come with little overhead to the programmer. Unlike the property sheets supported in other versions of Windows, the property sheets in Windows CE don't support the Apply button. Also, the OK and Cancel buttons for the property sheet are contained in the title bar, not positioned below the pages.

<A NAME="144"><H3>Creating a property sheet</H3></A>

<P>Instead of using the dialog box creation functions to create a property sheet, a new function is used:

<p><pre>
int PropertySheet (LPCPROPSHEETHEADER lppsph);
</pre>

<P>The <I>PropertySheet</I> function creates the property sheet according to the information contained in the PROPSHEETHEADER structure which is defined as the following:

<p><pre>
typedef struct _PROPSHEETHEADER {
    DWORD dwSize;
    DWORD dwFlags;
    HWND hwndOwner;
    HINSTANCE hInstance;
    union {
        HICON hIcon;
        LPCWSTR pszIcon;
    };
    LPCWSTR pszCaption;
    UINT nPages;
    union {
        UINT nStartPage;
        LPCWSTR pStartPage;
    };
    union {
        LPCPROPSHEETPAGE ppsp;
        HPROPSHEETPAGE FAR *phpage;
    };
    PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADER;
</pre>

<P>Filling in this convoluted structure isn't as imposing a task as it might look. The <I>dwSize </I>field is the standard size field that must be initialized with the size of the structure. The <I>dwFlags</I> field contains the creation flags that define how the property sheet is created, which fields of the structure are valid, and how the property sheet behaves. Some of the flags indicate which fields in the structure are used. (I'll talk about those flags when I describe the other fields.) Two other flags set the behavior of the property sheet. The PSH_PROPTITLE flag appends the string &quot;Properties&quot; to the end of the caption specified in the <I>pszCaption</I> field. The PSH_MODELESS flag causes the <I>PropertySheet</I> function to create a modeless property sheet and immediately return. A modeless property sheet is like a modeless dialog box; it allows the user to switch back to the original window while the property sheet is still being displayed.

<P>The next two fields are the handle of the owner window and the instance handle of the application. Neither the <I>hIcon</I> or <I>pszIcon</I> fields are used in Windows CE so they should be set to 0. The <I>pszCaption</I> field should point to the title bar text for the property sheet. The <I>nStartPage</I>/<I>pStartPage</I> union should be set to indicate the page that should be initially displayed. This can be selected either by number or by title if the PSH_USEPSTARTPAGE flag is set in the <I>dwFlags</I> field.

<P>The <I>ppsp</I>/<I>phpage</I> union points to either an array of PROPSHEETPAGE structures describing each of the property pages or handles to previously created property pages. For either of these, the <I>nPages</I> field must be set to the number of entries of the array of structures or page handles. To indicate that the pointer points to an array of PROPSHEETPAGE structures, set the PSH_PROPSHEETPAGE flag in the <I>dwFlags</I> field. I'll describe both the structure and how to create individual pages shortly.

<P>The <I>pfnCallBack</I> field is an optional pointer to a procedure that's called twice&#8212;when the property sheet is about to be created and again when it's about to be initialized. The callback function allows applications to fine-tune the appearance of the property sheet for the rare times when it's necessary. This field is ignored unless the PSP_USECALLBACK flag is set in the <I>dwFlags</I> field.

<A NAME="145"><H3>Creating a property page</H3></A>

<P>As I mentioned earlier, individual property pages can be specified by an array of PROPSHEETPAGE structures or an array of handles to existing property pages. Creating a property page is accomplished with a call to the following:

<p><pre>
HPROPSHEETPAGE CreatePropertySheetPage (LPCPROPSHEETPAGE lppsp);
</pre>

<P>This function is passed a pointer to the same PROPSHEETPAGE structure and returns a handle to a property page. PROPSHEETPAGE is defined as this:

<p><pre>
typedef struct _PROPSHEETPAGE {
    DWORD dwSize;
    DWORD dwFlags;
    HINSTANCE hInstance;
    union {
        LPCSTR pszTemplate;
        LPCDLGTEMPLATE pResource;
    };
    union {
        HICON hIcon;
        LPCSTR pszIcon;
    };
    LPCSTR pszTitle;
    DLGPROC pfnDlgProc;
    LPARAM lParam;
    LPFNPSPCALLBACK pfnCallback;
    UINT FAR * pcRefParent;
} PROPSHEETPAGE;
</pre>

<P>The structure looks similar to the PROPSHEETHEADER structure, leading with a <I>dwSize</I> and <I>dwFlags</I> field followed by an <I>hInstance</I> field. In this structure, <I>hInstance</I> is the handle of the module from which the resources will be loaded. The <I>dwFlags</I> field again specifies which fields of the structure are used and how they're used, as well as a few flags specifying the characteristics of the page itself.

<P>The <I>pszTemplate</I>/<I>pResource</I> union specifies the dialog box template used to define the page. If the PSP_DLGINDIRECT flag is set in the <I>dwFlags</I> field, the union points to a dialog box template in memory. Otherwise, the field specifies the name of a dialog box resource. The <I>hIcon</I>/<I>pszIcon</I> union isn't used in Windows CE and should be set to 0. If the <I>dwFlags</I> field contains a PSP_USETITLE flag, the <I>pszTitle</I> field points to the text used on the tab for the page. Otherwise, the tab text is taken from the caption field in the dialog box template. The <I>pfnDlgProc</I> field points to the dialog box procedure for this specific page and the <I>lParam</I> field is an application-defined parameter that can be used to pass data to the dialog box procedure. The <I>pfnCallback</I> field can point to a callback procedure that's called twice&#8212; when the page is about to be created and when it's about to be destroyed. Again, like the callback for the property sheet, the property page callback allows applications to fine-tune the page characteristics. This field is ignored unless the <I>dwFlags</I> field contains the PSP_USECALLBACK flag. Finally, the <I>pcRefCount</I> field can contain a pointer to an integer that will store a reference count for the page. This field is ignored unless the flags field contains the PSP_USEREFPARENT flag.

<P>Windows CE supports a new flag for property pages, PSP_PREMATURE. This flag causes a property page to be created when the property sheet that owns it is created. Normally, a property page isn't created until the first time it's shown. This has an impact on property pages that communicate and cooperate with each other. Without the PSP_PREMATURE flag, the only property page that's automatically created when the property sheet is created is the page that is displayed first. So, at that moment, that first page has no sibling pages to communicate with. Using the PSP_PREMATURE flag, you can ensure that a page is created when the property sheet is created even though it isn't the first page in the sheet. While it's easy to get overwhelmed with all these structures, simply using the default values and not using the optional fields results in a powerful and easily maintainable property sheet that's also as easy to construct as a set of individual dialog boxes.

<P>Once a property sheet has been created, the application can add and delete pages. The application adds a page by sending a PSM_ADDPAGE message to the property sheet window. The message must contain the handle of a previously created property page in <I>lParam</I>; <I>wParam</I> isn't used. Likewise, the application can remove a page by sending a PSM_REMOVEPAGE message to the property sheet window. The application specifies a page for deletion either by setting <I>wParam</I> to the zero-based index of the page selected for removal or by passing the handle to that page in <I>lParam</I>.

<P>The code below creates a simple property sheet with three pages. Each of the pages references a dialog box template resource. As you can see, most of the initialization of the structures can be performed in a fairly mechanical fashion.

<p><pre>
PROPSHEETHEADER psh;
PROPSHEETPAGE psp[3];
INT i;

// Init page structures with generic information.
memset (&amp;psp, 0, sizeof (psp));      // Zero out all unused values.
for (i = 0; i &lt; dim(psp); i++) {
    psp[i].dwSize = sizeof (PROPSHEETPAGE);
    psp[i].dwFlags = PSP_DEFAULT;     // No special processing needed
    psp[i].hInstance = hInst;         // Instance handle where the
}                                     // dialog templates are located
// Now do the page specific stuff.
psp[0].pszTemplate = TEXT (&quot;Page1&quot;); // Name of dialog resource for page 1
psp[0].pfnDlgProc = Page1DlgProc;    // Pointer to dialog proc for page 1

psp[1].pszTemplate = TEXT (&quot;Page2&quot;); // Name of dialog resource for page 2
psp[1].pfnDlgProc = Page2DlgProc;    // Pointer to dialog proc for page 2

psp[2].pszTemplate = TEXT (&quot;Page3&quot;); // Name of dialog resource for page 3
psp[2].pfnDlgProc = Page3DlgProc;    // Pointer to dialog proc for page 3

// Init property sheet header structure.
psh.dwSize = sizeof (PROPSHEETHEADER);
psh.dwFlags = PSH_PROPSHEETPAGE;    // We are using templates not handles.
psh.hwndParent = hWnd;              // Handle of the owner window
psh.hInstance = hInst;              // Instance handle of the application
psh.pszCaption = TEXT (&quot;Property sheet title&quot;);
psh.nPages = dim(psp);              // Number of pages
psh.nStartPage = 0;                 // Index of page to be shown first
psh.ppsp = psp;                     // Pointer to page structures
psh.pfnCallback = 0;                // We don't need a callback procedure.

// Create property sheet.  This returns when the user dismisses the sheet
// by tapping OK or the Close button.
i = PropertySheet (&amp;psh);
</pre>

<P>While this fragment has a fair amount of structure filling, it's boilerplate code. Everything not defined, such as the page dialog box resource templates and the page dialog box procedures, are required for dialog boxes as well as property sheets. So, aside from the boilerplate stuff, property sheets require little, if any, work beyond simple dialog boxes.

<A NAME="146"><H3>Property page procedures</H3></A>

<P>The procedures that back up each of the property pages have only a few differences from standard dialog box procedures. First, as I mentioned previously, unless the PSP_PREMATURE flag is used, pages aren't created immediately when the property sheet is created. Instead, each page is created and WM_INITDIALOG messages are sent only when the page is initially shown. Also, the <I>lParam</I> parameter doesn't point to a user-defined parameter; instead, it points to the PROPSHEETPAGE structure that defined the page. Of course, that structure contains a user-definable value that can be used to pass data to the dialog box procedure.

<P>Also, a property sheet procedure doesn't field the IDOK and IDCANCEL control IDs for the OK and Close buttons on a standard dialog box. These buttons instead are handled by the system-provided property sheet procedure that coordinates the display and management of each page. When the OK or Close button is tapped, the property sheet sends a WM_NOTIFY message to each sheet notifying them that one of the two buttons has been tapped and that they should acknowledge that it's okay to close the property sheet.

<A NAME="147"><H3>WM_NOTIFY</H3></A>

<P>While this is the first time I've mentioned the WM_NOTIFY message, it has become a mainstay of the new common controls added to Windows over the last few years. The WM_NOTIFY message is essentially a redefined WM_COMMAND message, which instead of encoding the reason for the message in one of the parameters passes a pointer to an extensible structure instead. This has allowed the WM_NOTIFY message to be extended and adapted for each of the controls that use it. In the case of property sheets, the WM_NOTIFY message is sent under a number of conditions; when the user taps the OK button, when the user taps the Close button, when the page gains or loses focus from or to another page, or when the user requests help.

<P>At a minimum, the WM_NOTIFY message is sent with <I>lParam</I> pointing to an NMHDR structure defined as the following:

<p><pre>
typedef struct tagNMHDR {
    HWND hwndFrom;
    UINT idFrom;
    UINT code;
} NMHDR;
</pre>

<P>The <I>hwndFrom</I> field contains the handle of the window that sent the notify message. For property sheets, this is the property sheet window. The <I>idFrom</I> field contains the ID of the control if a control is sending the notification. Finally, the <I>code</I> field contains the notification code. While this basic structure doesn't contain any more information than the WM_COMMAND message, often this structure is extended with additional fields appended to the structure. The notification code then indicates what, if any, additional fields are appended to the notification structure.

<A NAME="148"><H3>Switching pages</H3></A>

<P>When a user switches from one page to the next, the Dialog Manager sends a WM_NOTIFY message with the code PSN_KILLACTIVE to the page currently being displayed. The dialog box procedure should then validate the data on the page. If it's permissible for the user to change the page, the dialog box procedure should then set the return value of the window structure of the page to PSNRET_NOERROR and return TRUE. You set the PSNRET_NOERROR return field by calling <I>SetWindowLong</I> with DWL_MSGRESULT as in the following line of code:

<p><pre>
SetWindowLong (hwndPage, DWL_MSGRESULT, PSNRET_NOERROR);
</pre>

<P>where <I>hwndPage</I> is the handle of the property sheet page. A page can keep focus by returning PSNRET_INVALID_NOCHANGEPAGE in the return field. Assuming a page has indicated that it's okay to lose focus, the page being switched to receives a PSN_SETACTIVE notification via a WM_NOTIFY message. The page can then accept the focus or specify another page that should receive the focus.

<A NAME="149"><H3>Closing a property sheet</H3></A>

<P>When the user taps on the OK button, the property sheet procedure sends a WM_NOTIFY with the notification code PSN_KILLACTIVE to the page currently being displayed followed by a WM_NOTIFY with the notification code PSN_APPLY to each of the pages that has been created. Each page procedure should save any data from the page controls when it receives the PSN_APPLY notification code.

<P>When the user clicks the Close button, a PSN_QUERYCANCEL notification is sent to the page procedure of the page currently being displayed. All this notification requires is that the page procedure return TRUE to prevent the close or FALSE to allow the close. A further notification, PSN_RESET, is then sent to all the pages that have been created, indicating that the property sheet is about to be destroyed.

<A NAME="150"><H2>Common Dialogs</H2></A>

<P>In the early days of Windows, it was a rite of passage for a Windows developer to write his or her own File Open dialog box. A File Open dialog box is complex&#8212;it must display a list of the possible files from a specific directory, allow file navigation, and return a fully justified filename back to the application. While it was great for programmers to swap stories about how they struggled with their unique implementation of a File Open dialog, it was hard on the users. Users had to learn a different file open interface for every Windows application.

<P>Windows now provides a set of common dialog boxes that perform typical functions, such as selecting a filename to open or save or picking a color. These standard dialog boxes (called <I>common dialogs</I>) serve two purposes. First, common dialogs lift from developers the burden of having to create these dialog boxes from scratch. Second, and just as important, common dialogs provide a common interface to the user across different applications. (These days, Windows programmers swap horror stories about learning COM.)

<P>Windows CE 2.0 provides four common dialogs: File Open, Save As, Print, and Choose Color. Common dialogs, such as Find, Choose Font, and Page Setup, that are available under other versions of Windows aren't supported under Windows CE. Applications developed for Windows CE 1.0 or for the first release of the Palm-size PC must also do without the Print and Color common dialogs, but this isn't much of a sacrifice because neither color screens nor printing is supported on those systems.

<P>The other advantage of the common dialogs is that they have a customized look for each platform while retaining the same programming interface. This makes it easy to use, say, the File Open dialog on both the H/PC and the Palm-size PC because the dialog box has the same interface on both systems even though the look of the dialog box is vastly different on the two platforms. Figure 4-7 shows the File Open dialog on the H/PC; Figure 4-8 shows the File Open dialog box on the Palm-size PC.

<P><A HREF="javascript:fullSize('f04rg07x.htm')"> <img src="f04rg07.jpg" width=404 height=152 border="0" ALT="Click to view at full size."></a>
<!-- caption --><P><B>Figure 4-7.</B> <I>The File Open dialog on a Handheld PC.</I><!-- /caption -->

<P><img src="f04rg08.gif" width=242 height=322 border="0">
<!-- caption --><P><B>Figure 4-8.</B> <I>The File Open dialog on a Palm-size PC.</I><!-- /caption -->

<P>Instead of showing you how to use the common dialogs here, I'll let the next example program, DlgDemo, show you. That program demonstrates all four supported common dialog boxes.

<A NAME="151"><H2>The DlgDemo Example Program</H2></A>

<P>The DlgDemo program demonstrates basic dialog boxes, modeless dialog boxes, property sheets, and common dialogs. When you start DlgDemo, it displays a window that shows the WM_COMMAND and WM_NOTIFY messages sent by the various controls in the dialogs, similar to the right side of the CtlView window. The different dialogs can be opened using the various menu items. Figure 4-9 shows the Dialog Demo window with the property sheet dialog displayed.

<P><A HREF="javascript:fullSize('f04rg09x.htm')"> <img src="f04rg09.jpg" width=404 height=303 border="0" ALT="Click to view at full size."></a>
<!-- caption --><P><B>Figure 4-9.</B> <I>The DlgDemo window.</I><!-- /caption -->

<P>The basic dialog box is a simple &quot;about box&quot; launched by selecting the Help About menu. The property sheet is launched by selecting the File Property Sheet menu. The property sheet dialog contains five pages corresponding to the different windows in the CtlView example. The common dialog boxes are launched from the File Open, File Save, File Color, and File Print menu items. These last two menu items are disabled when the program is run on a Palm-size PC since those common dialog boxes aren't supported on that platform. The DlgDemo source code is shown in Figure 4-10.

<P><B>Figure 4-10.</B> <I>The DlgDemo program.</I>

<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="152"><H3>DlgDemo.rc</H3></A>
<p><pre>
//======================================================================
// Resource file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================

#include &quot;windows.h&quot;                 //
#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Icons and bitmaps
//
ID_ICON      ICON   &quot;DlgDemo.ico&quot;    // Program icon
IDI_BTNICON  ICON   &quot;btnicon.ico&quot;    // Bitmap used in owner-draw button
statbmp      BITMAP &quot;statbmp.bmp&quot;    // Bitmap used in static window

//----------------------------------------------------------------------
// Menu
//
ID_MENU MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;Open...&quot;,                     IDM_OPEN
        MENUITEM &quot;Save...&quot;,                     IDM_SAVE
        MENUITEM SEPARATOR
        MENUITEM &quot;Color...&quot;,                    IDM_COLOR
        MENUITEM &quot;Print...&quot;,                    IDM_PRINT
        MENUITEM SEPARATOR
        MENUITEM &quot;Property Sheet&quot;,              IDM_SHOWPROPSHEET
        MENUITEM &quot;Modeless Dialog&quot;,             IDM_SHOWMODELESS
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_EXIT
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About...&quot;,                   IDM_ABOUT
    END
END

//----------------------------------------------------------------------
// Property page templates
//

ID_BTNPAGE DIALOG discardable 0, 0, 125,  90
CAPTION &quot;Buttons&quot;
BEGIN
    PUSHBUTTON &quot;Button 1&quot;,             IDC_PUSHBTN,   5,   5,  80,  12,
                                           WS_TABSTOP | BS_NOTIFY
    CHECKBOX &quot;Check Box&quot;,              IDC_CHKBOX,   5,  20,  80,  12,
                                           WS_TABSTOP | BS_NOTIFY
    AUTOCHECKBOX &quot;Auto check box&quot;      IDC_ACHKBOX,   5,  35,  80,  12,
                                           WS_TABSTOP
    AUTO3STATE &quot;Auto 3-state box&quot;,     IDC_A3STBOX,   5,  50,  80,  12,
                                           WS_TABSTOP
    AUTORADIOBUTTON &quot;Auto radio button 1&quot;,
                                       IDC_RADIO1,    5,  65,  80,  12,
                                           WS_TABSTOP | WS_GROUP
    AUTORADIOBUTTON &quot;Auto radio button 2&quot;,
                                       IDC_RADIO2,    5,  75,  80,  12
    PUSHBUTTON &quot;&quot;,                     IDC_OWNRDRAW, 95,   5,  30,  30,
                                           BS_OWNERDRAW
END

ID_EDITPAGE DIALOG discardable 0, 0,  80,  80
CAPTION &quot;Edit&quot;
BEGIN
    EDITTEXT                        IDC_SINGLELINE,   5,   5,  70,  12,
                                           WS_TABSTOP
    EDITTEXT                        IDC_MULTILINE,    5,  20,  70,  40,
                                           WS_TABSTOP | ES_MULTILINE
    EDITTEXT                        IDC_PASSBOX,      5,  65,  70,  12,
                                           WS_TABSTOP | ES_PASSWORD
END

ID_LISTPAGE DIALOG discardable 0, 0,  125,  80
CAPTION &quot;List&quot;
BEGIN
    COMBOBOX                  IDC_COMBOBOX,     5,   5,  70,  60,
                                           WS_TABSTOP | CBS_DROPDOWN
    LISTBOX                   IDC_SNGLELIST,   5,  20,  50,  60,
                                           WS_TABSTOP
    LISTBOX                   IDC_MULTILIST,   60,  20,  50,  60,
                                           WS_TABSTOP | LBS_EXTENDEDSEL
END

ID_STATPAGE DIALOG discardable 0, 0, 130,  80
CAPTION &quot;Static&quot;
BEGIN
    LTEXT &quot;Left text&quot;,              IDC_LEFTTEXT,    5,   5,  70,  20
    RTEXT &quot;Right text&quot;,             IDC_RIGHTTEXT,   5,  30,  70,  20
    CTEXT &quot;Center text&quot;,            IDC_CENTERTEXT,  5,  55,  70,  20,
                                           WS_BORDER
    ICON IDI_BTNICON                IDC_ICONCTL,    95,   5,  32,  32
    CONTROL &quot;statbmp&quot;,              IDC_BITMAPCTL,  &quot;static&quot;, SS_BITMAP,
                                                    95,  40,  32,  32
END

ID_SCROLLPAGE DIALOG discardable 0, 0,  60,  80
CAPTION &quot;Scroll&quot;
BEGIN
    SCROLLBAR                       IDC_LRSCROLL,   5,   5,  70,  12,
                                           WS_TABSTOP
    SCROLLBAR                       IDC_UDSCROLL,  80,   5,  12,  70,
                                           WS_TABSTOP | SBS_VERT
END
//----------------------------------------------------------------------
// Clear list modeless dialog box template.
//
Clearbox DIALOG discardable 60, 10,  70, 30
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_MODALFRAME
CAPTION &quot;Clear&quot;
BEGIN
    DEFPUSHBUTTON &quot;Clear Listbox&quot;
                      IDD_CLEAR,   5,   5,  60,   20
END
//----------------------------------------------------------------------
// About box dialog box template
//
aboutbox DIALOG discardable 10, 10, 132, 40
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_CENTER |
       DS_MODALFRAME
CAPTION &quot;About&quot;
BEGIN
    ICON    ID_ICON                  -1,   5,   5,   0,   0

    LTEXT &quot;DlgDemo - Written for the book Programming Windows \
           CE Copyright 1998 Douglas Boling&quot;
                                     -1,  28,   5, 100,  30
END
</pre>
</td></tr></table>





<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="153"><H3>DlgDemo.h</H3></A>
<p><pre>
//======================================================================
// Header file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
};
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR   1                         // Command bar ID
#define  IDC_RPTLIST  2                         // ID for report list box

#define  ID_ICON             10                 // Icon resource ID
#define  ID_MENU             11                 // Main menu resource ID

// Menu item IDs
#define  IDM_OPEN            100
#define  IDM_SAVE            101
#define  IDM_COLOR           102
#define  IDM_PRINT           103
#define  IDM_SHOWPROPSHEET   104
#define  IDM_SHOWMODELESS    105
#define  IDM_EXIT            106

#define  IDM_ABOUT           110

#define  IDI_BTNICON         120

// Identifiers for the property page resources
#define  ID_BTNPAGE          50
#define  ID_EDITPAGE         51
#define  ID_LISTPAGE         52
#define  ID_STATPAGE         53
#define  ID_SCROLLPAGE       54

// Button window defines
#define  IDC_PUSHBTN         200
#define  IDC_CHKBOX          201
#define  IDC_ACHKBOX         202
#define  IDC_A3STBOX         203
#define  IDC_RADIO1          204
#define  IDC_RADIO2          205
#define  IDC_OWNRDRAW        206

// Edit window defines
#define  IDC_SINGLELINE      210
#define  IDC_MULTILINE       211
#define  IDC_PASSBOX         212

// List box window defines
#define  IDC_COMBOBOX        220
#define  IDC_SNGLELIST       221
#define  IDC_MULTILIST       222

// Static control window defines
#define  IDC_LEFTTEXT        230
#define  IDC_RIGHTTEXT       231
#define  IDC_CENTERTEXT      232
#define  IDC_ICONCTL         233
#define  IDC_BITMAPCTL       234

// Scroll bar window defines
#define  IDC_LRSCROLL        240
#define  IDC_UDSCROLL        241

// Control IDs for modeless dialog box
#define  IDD_CLEAR           500

// User-defined message to add a line to the window
#define MYMSG_ADDLINE   (WM_USER + 10)

//----------------------------------------------------------------------
// Program-specific structures
//
typedef struct {
    TCHAR *pszLabel;
    DWORD wNotification;
} NOTELABELS, *PNOTELABELS;
//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoAddLineMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);

// Command functions
LPARAM DoMainCommandOpen (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandSave (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandColor (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandPrint (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandShowProp (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandModeless (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAbout (HWND, WORD, HWND, WORD);

// Dialog box procedures
BOOL CALLBACK BtnDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK EditDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ListDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK StaticDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ScrollDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK ModelessDlgProc (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>


<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="154"><H3>DlgDemo.c</H3></A>
<p><pre>
//======================================================================

// DlgDemo - Dialog box demonstration
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &lt;commdlg.h&gt;                 // Common dialog box includes
#include &lt;prsht.h&gt;                   // Property sheet includes

#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;DlgDemo&quot;);
HINSTANCE hInst;                     // Program instance handle
HWND g_hwndMlDlg = 0;                // Handle to modeless dialog box

HINSTANCE hLib = 0;                  // Handle to CommDlg lib
FARPROC lpfnChooseColor = 0;         // Ptr to color common dialog fn
FARPROC lpfnPrintDlg = 0;            // Ptr to print common dialog fn

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_COMMAND, DoCommandMain,
    MYMSG_ADDLINE, DoAddLineMain,
    WM_DESTROY, DoDestroyMain,
};

// Command message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDM_OPEN, DoMainCommandOpen,
    IDM_SAVE, DoMainCommandSave,
    IDM_SHOWPROPSHEET, DoMainCommandShowProp,
    IDM_SHOWMODELESS, DoMainCommandModeless,
    IDM_COLOR, DoMainCommandColor,
    IDM_PRINT, DoMainCommandPrint,
    IDM_EXIT, DoMainCommandExit,
    IDM_ABOUT, DoMainCommandAbout,
};
//
// Labels for WM_NOTIFY notifications
//
NOTELABELS nlPropPage[] = {{TEXT (&quot;PSN_SETACTIVE  &quot;), (PSN_FIRST-0)},
                           {TEXT (&quot;PSN_KILLACTIVE &quot;), (PSN_FIRST-1)},
                           {TEXT (&quot;PSN_APPLY      &quot;), (PSN_FIRST-2)},
                           {TEXT (&quot;PSN_RESET      &quot;), (PSN_FIRST-3)},
                           {TEXT (&quot;PSN_HASHELP    &quot;), (PSN_FIRST-4)},
                           {TEXT (&quot;PSN_HELP       &quot;), (PSN_FIRST-5)},
                           {TEXT (&quot;PSN_WIZBACK    &quot;), (PSN_FIRST-6)},
                           {TEXT (&quot;PSN_WIZNEXT    &quot;), (PSN_FIRST-7)},
                           {TEXT (&quot;PSN_WIZFINISH  &quot;), (PSN_FIRST-8)},
                           {TEXT (&quot;PSN_QUERYCANCEL&quot;), (PSN_FIRST-9)},
};
int nPropPageSize = dim(nlPropPage);

// Labels for the property pages
TCHAR *szPages[] = {TEXT (&quot;Button&quot;),
                    TEXT (&quot;Edit  &quot;),
                    TEXT (&quot;List  &quot;),
                    TEXT (&quot;Static&quot;),
                    TEXT (&quot;Scroll&quot;),
};
//======================================================================
// Program entry point
//
HWND hwndMain;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        // If modeless dialog box is created, let it have
        // the first crack at the message.
        if ((g_hwndMlDlg == 0) ||
            (!IsDialogMessage (g_hwndMlDlg, &amp;msg))) {
            TranslateMessage (&amp;msg);
            DispatchMessage (&amp;msg);
        }
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    // Get the Color and print dialog function pointers.
    hLib = LoadLibrary (TEXT (&quot;COMMDLG.DLL&quot;));
    if (hLib) {
        lpfnChooseColor = GetProcAddress (hLib, TEXT (&quot;ChooseColor&quot;));
        lpfnPrintDlg = GetProcAddress (hLib, TEXT (&quot;PrintDlg&quot;));
    }
    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine,
                   int nCmdShow) {
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,            // Window class
                         TEXT (&quot;Dialog Demo&quot;), // Window title
                         WS_VISIBLE,           // Style flags
                         CW_USEDEFAULT,        // x position
                         CW_USEDEFAULT,        // y position
                         CW_USEDEFAULT,        // Initial width
                         CW_USEDEFAULT,        // Initial height
                         NULL,                 // Parent
                         NULL,                 // Menu, must be null
                         hInstance,            // Application instance
                         NULL);                // Pointer to create
                                               // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {
    if (hLib)
        FreeLibrary (hLib);
    return nDefRC;
}
//======================================================================
// Message-handling procedures for MainWindow
//
//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    HWND hwndCB, hwndChild;
    INT i, nHeight;
    LPCREATESTRUCT lpcs;
    HMENU hMenu;

    // Convert lParam into pointer to create structure.
    lpcs = (LPCREATESTRUCT) lParam;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);
    // Add the menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);
    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);

    // See color and print functions not found, disable menus.
    hMenu = CommandBar_GetMenu (hwndCB, 0);
    if (!lpfnChooseColor)
        EnableMenuItem (hMenu, IDM_COLOR, MF_BYCOMMAND | MF_GRAYED);
    if (!lpfnPrintDlg)
        EnableMenuItem (hMenu, IDM_PRINT, MF_BYCOMMAND | MF_GRAYED);

    nHeight = CommandBar_Height (hwndCB);
    //
    // Create report window.  Size it so that it fits under
    // the command bar and fills the remaining client area.
    //
    hwndChild = CreateWindowEx (0, TEXT (&quot;listbox&quot;),
                         TEXT (&quot;&quot;), WS_VISIBLE | WS_CHILD | WS_VSCROLL |
                         LBS_USETABSTOPS | LBS_NOINTEGRALHEIGHT, 0,
                         nHeight, lpcs-&gt;cx, lpcs-&gt;cy - nHeight,
                         hWnd, (HMENU)IDC_RPTLIST,
                         lpcs-&gt;hInstance, NULL);

    // Destroy frame if window not created.
    if (!IsWindow (hwndChild)) {
        DestroyWindow (hWnd);
        return 0;
    }
    // Initialize tab stops for display list box.
    i = 40;
    SendMessage (hwndChild, LB_SETTABSTOPS, 1, (LPARAM)&amp;i);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window.
//
LRESULT DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT  i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD (wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code)
            return (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl,
                        wNotifyCode);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoAddLineMain - Process MYMSG_ADDLINE message for window.
//
LRESULT DoAddLineMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    TCHAR szOut[128];
    INT i;

    // If nothing in wParam, just fill in spaces.
    if (wParam == -1) {
        // Print message only.
        lstrcpy (szOut, (LPTSTR)lParam);
    } else {
        // If no ID val, ignore that field.
        if (LOWORD (wParam) == 0xffff)
            // Print prop page and message.
            wsprintf (szOut, TEXT (&quot;%s \t       \t %s&quot;),
                      szPages[HIWORD (wParam) - ID_BTNPAGE],
                      (LPTSTR)lParam);
        else
            // Print property page, control ID, and message.
            wsprintf (szOut, TEXT (&quot;%s \t id:%x \t %s&quot;),
                      szPages[HIWORD (wParam) - ID_BTNPAGE],
                      LOWORD (wParam), (LPTSTR)lParam);
    }
    i = SendDlgItemMessage (hWnd, IDC_RPTLIST, LB_ADDSTRING, 0,
                            (LPARAM)(LPCTSTR)szOut);

    if (i != LB_ERR)
        SendDlgItemMessage (hWnd, IDC_RPTLIST, LB_SETTOPINDEX, i,
                            (LPARAM)(LPCTSTR)szOut);
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
//======================================================================
// Command handler routines
//----------------------------------------------------------------------
// DoMainCommandOpen - Process File Open command
//
LPARAM DoMainCommandOpen (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {
    OPENFILENAME of;
    TCHAR szFileName [MAX_PATH] = {0};
    const LPTSTR pszOpenFilter = TEXT (&quot;All Documents (*.*)\0*.*\0\0&quot;);
    TCHAR szOut[128];
    INT rc;

    // Initialize filename.
    szFileName[0] = `\0';

    // Initialize File Open structure.
    memset (&amp;of, 0, sizeof (of));

    of.lStructSize = sizeof (of);
    of.hwndOwner = hWnd;
    of.lpstrFile = szFileName;
    of.nMaxFile = dim(szFileName);
    of.lpstrFilter = pszOpenFilter;
    of.Flags = 0;

    rc = GetOpenFileName (&amp;of);
    wsprintf (szOut,
              TEXT (&quot;GetOpenFileName returned: %x, filename: %s&quot;),
              rc, szFileName);
    SendMessage (hWnd, MYMSG_ADDLINE, -1, (LPARAM)szOut);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandSave - Process File Save command.
//
LPARAM DoMainCommandSave (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {
    OPENFILENAME of;
    TCHAR szFileName [MAX_PATH] = {0};
    const LPTSTR pszOpenFilter = TEXT (&quot;All Documents (*.*)\0*.*\0\0&quot;);
    TCHAR szOut[128];
    INT rc;

    // Initialize filename.
    szFileName[0] = `\0';

    // Initialize File Open structure.
    memset (&amp;of, 0, sizeof (of));

    of.lStructSize = sizeof (of);
    of.hwndOwner = hWnd;
    of.lpstrFile = szFileName;
    of.nMaxFile = dim(szFileName);
    of.lpstrFilter = pszOpenFilter;
    of.Flags = 0;

    rc = GetSaveFileName (&amp;of);

    wsprintf (szOut,
              TEXT (&quot;GetSaveFileName returned: %x, filename: %s&quot;),
              rc, szFileName);
    SendMessage (hWnd, MYMSG_ADDLINE, -1, (LPARAM)szOut);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandColor - Process File Color command.
//
LPARAM DoMainCommandColor (HWND hWnd, WORD idItem, HWND hwndCtl,
                           WORD wNotifyCode) {
    CHOOSECOLOR cc;
    static COLORREF cr[16];
    TCHAR szOut[128];
    INT rc;

    // Initialize color structure.
    memset (&amp;cc, 0, sizeof (cc));
    memset (&amp;cr, 0, sizeof (cr));

    cc.lStructSize = sizeof (cc);
    cc.hwndOwner = hWnd;
    cc.hInstance = hInst;
    cc.rgbResult = RGB (0, 0, 0);
    cc.lpCustColors = cr;
    cc.Flags = CC_ANYCOLOR;

    rc = (lpfnChooseColor) (&amp;cc);

    wsprintf (szOut, TEXT (&quot;Choose Color returned: %x, color: %x&quot;),
              rc, cc.rgbResult);
    SendMessage (hWnd, MYMSG_ADDLINE, -1, (LPARAM)szOut);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandPrint - Process File Print command.
//
LPARAM DoMainCommandPrint (HWND hWnd, WORD idItem, HWND hwndCtl,
                           WORD wNotifyCode) {
    PRINTDLG pd;
    INT rc;

    // Initialize print structure.
    memset (&amp;pd, 0, sizeof (pd));

    pd.cbStruct = sizeof (pd);
    pd.hwndOwner = hWnd;
    pd.dwFlags = PD_SELECTALLPAGES;

    rc = (lpfnPrintDlg) (&amp;pd);

    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandShowProp - Process show property sheet command.
//
LPARAM DoMainCommandShowProp(HWND hWnd, WORD idItem, HWND hwndCtl,
                             WORD wNotifyCode) {

    PROPSHEETPAGE psp[5];
    PROPSHEETHEADER psh;
    INT i;

    // Zero all the property page structures.
    memset (&amp;psp, 0, sizeof (psp));
    // Fill in default values in property page structures.
    for (i = 0; i &lt; dim(psp); i++) {
        psp[i].dwSize = sizeof (PROPSHEETPAGE);
        psp[i].dwFlags = PSP_DEFAULT;
        psp[i].hInstance = hInst;
        psp[i].lParam = (LPARAM)hWnd;
    }
    // Set the dialog box templates for each page.
    psp[0].pszTemplate = MAKEINTRESOURCE (ID_BTNPAGE);
    psp[1].pszTemplate = MAKEINTRESOURCE (ID_EDITPAGE);
    psp[2].pszTemplate = MAKEINTRESOURCE (ID_LISTPAGE);
    psp[3].pszTemplate = MAKEINTRESOURCE (ID_STATPAGE);
    psp[4].pszTemplate = MAKEINTRESOURCE (ID_SCROLLPAGE);

    // Set the dialog box procedures for each page.
    psp[0].pfnDlgProc = BtnDlgProc;
    psp[1].pfnDlgProc = EditDlgProc;
    psp[2].pfnDlgProc = ListDlgProc;
    psp[3].pfnDlgProc = StaticDlgProc;
    psp[4].pfnDlgProc = ScrollDlgProc;

    // Initialize property sheet structure.
    psh.dwSize = sizeof (PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE;
    psh.hwndParent = hWnd;
    psh.hInstance = hInst;
    psh.pszCaption = TEXT (&quot;Property Sheet Demo&quot;);
    psh.nPages = dim(psp);
    psh.nStartPage = 0;
    psh.ppsp = psp;
    psh.pfnCallback = 0;

    // Create and display property sheet.
    i = PropertySheet (&amp;psh);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandModelessDlg - Process the File Modeless menu command.
//
LPARAM DoMainCommandModeless(HWND hWnd, WORD idItem, HWND hwndCtl,
                             WORD wNotifyCode) {

    // Only create dialog box if not already created.
    if (g_hwndMlDlg == 0)
        // Use CreateDialog to create modeless dialog box.
        g_hwndMlDlg = CreateDialog (hInst, TEXT (&quot;Clearbox&quot;), hWnd,
                                    ModelessDlgProc);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    SendMessage (hWnd, WM_CLOSE, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAbout - Process the Help About menu command.
//
LPARAM DoMainCommandAbout(HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    // Use DialogBox to create modal dialog box.
    DialogBox (hInst, TEXT (&quot;aboutbox&quot;), hWnd, AboutDlgProc);
    return 0;
}
//======================================================================
// Modeless ClearList dialog box procedure.
//
BOOL CALLBACK ModelessDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                               LPARAM lParam) {

    switch (wMsg) {
        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                case IDD_CLEAR:
                    // Send message to list box to clear it.
                    SendDlgItemMessage (GetWindow (hWnd, GW_OWNER),
                                        IDC_RPTLIST,
                                        LB_RESETCONTENT, 0, 0);
                    return TRUE;

                case IDOK:
                case IDCANCEL:
                    // Modeless dialog boxes can't use EndDialog.
                    DestroyWindow (hWnd);

                    // Set hwnd value to zero to indicate that
                    // the dialog box is destroyed.
                    g_hwndMlDlg = 0;
                    return TRUE;
            }
        break;
    }
    return FALSE;
}
//======================================================================
// About dialog box procedure
//
BOOL CALLBACK AboutDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                            LPARAM lParam) {

    switch (wMsg) {
        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hWnd, 0);
                    return TRUE;
            }
        break;
    }
    return FALSE;
}
</pre>
</td></tr></table>



<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="155"><H3>BtnDlg.c</H3></A>
<p><pre>

//======================================================================
// BtnDlg - Button dialog box window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;prsht.h&gt;                   // Property sheet includes
#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;

LRESULT DrawButton (HWND hWnd, LPDRAWITEMSTRUCT pdi);
//----------------------------------------------------------------------
// Global data
//
// Identification strings for various WM_COMMAND notifications
NOTELABELS nlBtn[] = {{TEXT (&quot;BN_CLICKED &quot;),      0},
                      {TEXT (&quot;BN_PAINT   &quot;),      1},
                      {TEXT (&quot;BN_HILITE  &quot;),      2},
                      {TEXT (&quot;BN_UNHILITE&quot;),      3},
                      {TEXT (&quot;BN_DISABLE &quot;),      4},
                      {TEXT (&quot;BN_DOUBLECLICKED&quot;), 5},
                      {TEXT (&quot;BN_SETFOCUS &quot;),     6},
                      {TEXT (&quot;BN_KILLFOCUS&quot;),     7}
};
extern NOTELABELS nlPropPage[];
extern int nPropPageSize;

// Handle for icon used in owner-draw icon
HICON hIcon = 0;
//======================================================================
// BtnDlgProc - Button page dialog box procedure
//
BOOL CALLBACK BtnDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {
    TCHAR szOut[128];
    HWND hwndMain;
    INT i;

    switch (wMsg) {

        case WM_INITDIALOG:
            // The generic parameter contains the
            // top-level window handle.
            hwndMain = (HWND)((LPPROPSHEETPAGE)lParam)-&gt;lParam;
            // Save the window handle in the window structure.
            SetWindowLong (hWnd, DWL_USER, (LONG)hwndMain);

            // Load icon for owner-draw window.
            hIcon = LoadIcon (hInst, MAKEINTRESOURCE (IDI_BTNICON));

            // We need to set the initial state of the radio buttons.
            CheckRadioButton (hWnd, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
            return TRUE;
        //
        // Reflect WM_COMMAND messages to main window.
        //
        case WM_COMMAND:
            // Since the check box is not an auto check box, the button
            // has to be set manually.

            if ((LOWORD (wParam) == IDC_CHKBOX) &amp;&amp;
                (HIWORD (wParam) == BN_CLICKED)) {
                // Get the current state, complement, and set.
                i = SendDlgItemMessage (hWnd, IDC_CHKBOX, BM_GETCHECK,
                                        0, 0);
                if (i)
                    SendDlgItemMessage (hWnd, IDC_CHKBOX, BM_SETCHECK,
                                        0, 0);
                else
                    SendDlgItemMessage (hWnd, IDC_CHKBOX, BM_SETCHECK,
                                        1, 0);
            }


            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up button notification.
            lstrcpy (szOut, TEXT (&quot;WM_COMMAND: &quot;));
            for (i = 0; i &lt; dim(nlBtn); i++) {
                if (HIWORD (wParam) == nlBtn[i].wNotification) {
                    lstrcat (szOut, nlBtn[i].pszLabel);
                    break;
                }
            }
            if (i == dim(nlBtn))
                wsprintf (szOut, TEXT (&quot;WM_COMMAND notification: %x&quot;),
                          HIWORD (wParam));

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (LOWORD (wParam),ID_BTNPAGE),
                         (LPARAM)szOut);
            return TRUE;

        //
        // Reflect notify message.
        //
        case WM_NOTIFY:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up notify message.
            for (i = 0; i &lt; nPropPageSize; i++) {
                if (((NMHDR *)lParam)-&gt;code ==
                                       nlPropPage[i].wNotification) {
                    lstrcpy (szOut, nlPropPage[i].pszLabel);
                    break;
                }
            }
            if (i == nPropPageSize)
                wsprintf (szOut, TEXT (&quot;Notify code:%d&quot;),
                          ((NMHDR *)lParam)-&gt;code);

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (-1,ID_BTNPAGE), (LPARAM)szOut);

            return FALSE;  // Return false to force default processing.

        case WM_DRAWITEM:
            DrawButton (hWnd, (LPDRAWITEMSTRUCT)lParam);
            return TRUE;
    }
    return FALSE;
}

//---------------------------------------------------------------------
// DrawButton - Draws an owner-draw button.
//
LRESULT DrawButton (HWND hWnd, LPDRAWITEMSTRUCT pdi) {

    HPEN hPenShadow, hPenLight, hPenDkShadow, hOldPen;
    POINT ptOut[3], ptIn[3];
    HBRUSH hBr, hOldBr;
    TCHAR szOut[128];
    HWND hwndMain;
    LOGPEN lpen;

    // Get the handle of the main window from the user word.
    hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

    // Reflect the messages to the report window.
    wsprintf (szOut, TEXT (&quot;WM_DRAWITEM  Action:%x  State:%x&quot;),
              pdi-&gt;itemAction, pdi-&gt;itemState);

    SendMessage (hwndMain, MYMSG_ADDLINE,
                 MAKEWPARAM (pdi-&gt;CtlID, ID_BTNPAGE),
                 (LPARAM)szOut);

    // Create pens for drawing.
    lpen.lopnStyle = PS_SOLID;
    lpen.lopnWidth.x = 3;
    lpen.lopnWidth.y = 3;
    lpen.lopnColor = GetSysColor (COLOR_3DSHADOW);
    hPenShadow = CreatePenIndirect (&amp;lpen);

    lpen.lopnWidth.x = 1;
    lpen.lopnWidth.y = 1;
    lpen.lopnColor = GetSysColor (COLOR_3DLIGHT);
    hPenLight = CreatePenIndirect (&amp;lpen);

    lpen.lopnColor = GetSysColor (COLOR_3DDKSHADOW);
    hPenDkShadow = CreatePenIndirect (&amp;lpen);

    // Create a brush for the face of the button.
    hBr = CreateSolidBrush (GetSysColor (COLOR_3DFACE));

    // Draw a rectangle with a thick outside border to start the
    // frame drawing.
    hOldPen = SelectObject (pdi-&gt;hDC, hPenShadow);
    hOldBr = SelectObject (pdi-&gt;hDC, hBr);
    Rectangle (pdi-&gt;hDC, pdi-&gt;rcItem.left, pdi-&gt;rcItem.top,
               pdi-&gt;rcItem.right, pdi-&gt;rcItem.bottom);

    // Draw the upper left inside line.
    ptIn[0].x = pdi-&gt;rcItem.left + 1;
    ptIn[0].y = pdi-&gt;rcItem.bottom - 3;
    ptIn[1].x = pdi-&gt;rcItem.left + 1;
    ptIn[1].y = pdi-&gt;rcItem.top + 1;
    ptIn[2].x = pdi-&gt;rcItem.right - 3;
    ptIn[2].y = pdi-&gt;rcItem.top+1;

    // Select a pen to draw shadow or light side of button.
    if (pdi-&gt;itemState &amp; ODS_SELECTED) {
        SelectObject (pdi-&gt;hDC, hPenDkShadow);
    } else {
        SelectObject (pdi-&gt;hDC, hPenLight);
    }
    Polyline (pdi-&gt;hDC, ptIn, 3);

    // If selected, also draw a bright line inside the lower
    // right corner.
    if (pdi-&gt;itemState &amp; ODS_SELECTED) {
        SelectObject (pdi-&gt;hDC, hPenLight);
        ptIn[1].x = pdi-&gt;rcItem.right- 3;
        ptIn[1].y = pdi-&gt;rcItem.bottom - 3;
        Polyline (pdi-&gt;hDC, ptIn, 3);
    }
    // Now draw the black outside line on either the upper left or lower
    // right corner.
    ptOut[0].x = pdi-&gt;rcItem.left;
    ptOut[0].y = pdi-&gt;rcItem.bottom-1;
    ptOut[2].x = pdi-&gt;rcItem.right-1;
    ptOut[2].y = pdi-&gt;rcItem.top;

    SelectObject (pdi-&gt;hDC, hPenDkShadow);
    if (pdi-&gt;itemState &amp; ODS_SELECTED) {
        ptOut[1].x = pdi-&gt;rcItem.left;
        ptOut[1].y = pdi-&gt;rcItem.top;
    } else {
        ptOut[1].x = pdi-&gt;rcItem.right-1;
        ptOut[1].y = pdi-&gt;rcItem.bottom-1;
    }
    Polyline (pdi-&gt;hDC, ptOut, 3);

    // Draw the icon.
    if (hIcon) {
        ptIn[0].x = (pdi-&gt;rcItem.right - pdi-&gt;rcItem.left)/2 -
                     GetSystemMetrics (SM_CXICON)/2 - 2;
        ptIn[0].y = (pdi-&gt;rcItem.bottom - pdi-&gt;rcItem.top)/2 -
                     GetSystemMetrics (SM_CYICON)/2 - 2;
        // If pressed, shift image down one pel to simulate the press.
        if (pdi-&gt;itemState &amp; ODS_SELECTED) {
            ptOut[1].x += 2;
            ptOut[1].y += 2;
        }
        DrawIcon (pdi-&gt;hDC, ptIn[0].x, ptIn[0].y, hIcon);
    }

    // If button has the focus, draw the dotted rect inside the button.
    if (pdi-&gt;itemState &amp; ODS_FOCUS) {
        pdi-&gt;rcItem.left += 3;
        pdi-&gt;rcItem.top += 3;
        pdi-&gt;rcItem.right -= 4;
        pdi-&gt;rcItem.bottom -= 4;
        DrawFocusRect (pdi-&gt;hDC, &amp;pdi-&gt;rcItem);
    }

    // Clean up. First select the original brush and pen into the DC.
    SelectObject (pdi-&gt;hDC, hOldBr);
    SelectObject (pdi-&gt;hDC, hOldPen);

    // Now delete the brushes and pens created.
    DeleteObject (hBr);
    DeleteObject (hPenShadow);
    DeleteObject (hPenDkShadow);
    DeleteObject (hPenLight);
    return 0;
}
</pre>
</td></tr></table>


<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="156"><H3>EditDlg.c</H3></A>

<p><pre>
//======================================================================
// EditDlg _ Edit dialog box window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;prsht.h&gt;                   // Property sheet includes
#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Identification strings for various WM_COMMAND notifications
NOTELABELS nlEdit[] = {{TEXT (&quot;EN_SETFOCUS &quot;), 0x0100},
                       {TEXT (&quot;EN_KILLFOCUS&quot;), 0x0200},
                       {TEXT (&quot;EN_CHANGE   &quot;), 0x0300},
                       {TEXT (&quot;EN_UPDATE   &quot;), 0x0400},
                       {TEXT (&quot;EN_ERRSPACE &quot;), 0x0500},
                       {TEXT (&quot;EN_MAXTEXT  &quot;), 0x0501},
                       {TEXT (&quot;EN_HSCROLL  &quot;), 0x0601},
                       {TEXT (&quot;EN_VSCROLL  &quot;), 0x0602},
};
extern NOTELABELS nlPropPage[];
extern int nPropPageSize;
//======================================================================
// EditDlgProc - Button page dialog box procedure
//
BOOL CALLBACK EditDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                           LPARAM lParam) {
    TCHAR szOut[128];
    HWND hwndMain;
    INT i;

    switch (wMsg) {

        case WM_INITDIALOG:
            // The generic parameter contains the
            // top-level window handle.
            hwndMain = (HWND)((LPPROPSHEETPAGE)lParam)-&gt;lParam;
            // Save the window handle in the window structure.
            SetWindowLong (hWnd, DWL_USER, (LONG)hwndMain);
            return TRUE;
        //
        // Reflect WM_COMMAND messages to main window.
        //
        case WM_COMMAND:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up button notification.
            lstrcpy (szOut, TEXT (&quot;WM_COMMAND: &quot;));
            for (i = 0; i &lt; dim(nlEdit); i++) {
                if (HIWORD (wParam) == nlEdit[i].wNotification) {
                    lstrcat (szOut, nlEdit[i].pszLabel);
                    break;
                }
            }
            if (i == dim(nlEdit))
                wsprintf (szOut, TEXT (&quot;WM_COMMAND notification: %x&quot;),
                          HIWORD (wParam));

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (LOWORD (wParam),ID_EDITPAGE),
                         (LPARAM)szOut);
            return TRUE;

        //
        // Reflect notify message.
        //
        case WM_NOTIFY:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up notify message.
            for (i = 0; i &lt; nPropPageSize; i++) {
                if (((NMHDR *)lParam)-&gt;code ==
                                        nlPropPage[i].wNotification) {
                    lstrcpy (szOut, nlPropPage[i].pszLabel);
                    break;
                }
            }
            if (i == nPropPageSize)
                wsprintf (szOut, TEXT (&quot;Notify code:%d&quot;),
                          ((NMHDR *)lParam)-&gt;code);

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (-1,ID_EDITPAGE), (LPARAM)szOut);

            return FALSE;  // Return false to force default processing.
    }
    return FALSE;
}
</pre>
</td></tr></table>

<TABLE cellpadding=5 width="95%"><TR><td>

<A NAME="157"><H3>ListDlg.c</H3></A>
<p><pre>
//======================================================================
// ListDlg _ List box dialog window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;prsht.h&gt;                   // Property sheet includes
#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
NOTELABELS nlList[] = {{TEXT (&quot;LBN_ERRSPACE &quot;), (-2)},
                       {TEXT (&quot;LBN_SELCHANGE&quot;), 1},
                       {TEXT (&quot;LBN_DBLCLK   &quot;), 2},
                       {TEXT (&quot;LBN_SELCANCEL&quot;), 3},
                       {TEXT (&quot;LBN_SETFOCUS &quot;), 4},
                       {TEXT (&quot;LBN_KILLFOCUS&quot;), 5},
};

NOTELABELS nlCombo[] = {{TEXT (&quot;CBN_ERRSPACE    &quot;), (-1)},
                        {TEXT (&quot;CBN_SELCHANGE   &quot;), 1},
                        {TEXT (&quot;CBN_DBLCLK      &quot;), 2},
                        {TEXT (&quot;CBN_SETFOCUS    &quot;), 3},
                        {TEXT (&quot;CBN_KILLFOCUS   &quot;), 4},
                        {TEXT (&quot;CBN_EDITCHANGE  &quot;), 5},
                        {TEXT (&quot;CBN_EDITUPDATE  &quot;), 6},
                        {TEXT (&quot;CBN_DROPDOWN    &quot;), 7},
                        {TEXT (&quot;CBN_CLOSEUP     &quot;), 8},
                        {TEXT (&quot;CBN_SELENDOK    &quot;), 9},
                        {TEXT (&quot;CBN_SELENDCANCEL&quot;), 10},
};

extern NOTELABELS nlPropPage[];
extern int nPropPageSize;
//======================================================================
// ListDlgProc - Button page dialog box procedure
//
BOOL CALLBACK ListDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                           LPARAM lParam) {
    TCHAR szOut[128];
    HWND hwndMain;
    INT i;

    switch (wMsg) {

        case WM_INITDIALOG:
            // The generic parameter contains the
            // top-level window handle.
            hwndMain = (HWND)((LPPROPSHEETPAGE)lParam)-&gt;lParam;
            // Save the window handle in the window structure.
            SetWindowLong (hWnd, DWL_USER, (LONG)hwndMain);

            // Fill the list and combo boxes.
            for (i = 0; i &lt; 20; i++) {
                wsprintf (szOut, TEXT (&quot;Item %d&quot;), i);
                SendDlgItemMessage (hWnd, IDC_SNGLELIST, LB_ADDSTRING,
                                    0, (LPARAM)szOut);

                SendDlgItemMessage (hWnd, IDC_MULTILIST, LB_ADDSTRING,
                                    0, (LPARAM)szOut);

                SendDlgItemMessage (hWnd, IDC_COMBOBOX, CB_ADDSTRING,
                                    0, (LPARAM)szOut);
            }
            // Provide default selection for the combo box.
            SendDlgItemMessage (hWnd, IDC_COMBOBOX, CB_SETCURSEL, 0, 0);
            return TRUE;
        //
        // Reflect WM_COMMAND messages to main window.
        //
        case WM_COMMAND:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Report the WM_COMMAND messages.
            lstrcpy (szOut, TEXT (&quot;WM_COMMAND: &quot;));
            if (LOWORD (wParam) == IDC_COMBOBOX) {
                for (i = 0; i &lt; dim(nlCombo); i++) {
                    if (HIWORD (wParam) == nlCombo[i].wNotification) {
                        lstrcat (szOut, nlCombo[i].pszLabel);
                        break;
                    }
                }
                if (i == dim(nlCombo))
                    wsprintf (szOut,
                              TEXT (&quot;WM_COMMAND notification: %x&quot;),
                              HIWORD (wParam));
            } else {
                for (i = 0; i &lt; dim(nlList); i++) {
                    if (HIWORD (wParam) == nlList[i].wNotification) {
                        lstrcat (szOut, nlList[i].pszLabel);
                        break;
                    }
                }
                if (i == dim(nlList))
                    wsprintf (szOut,
                              TEXT (&quot;WM_COMMAND notification: %x&quot;),
                              HIWORD (wParam));
            }
            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (LOWORD (wParam),ID_LISTPAGE),
                        (LPARAM)szOut);
            return TRUE;

        //
        // Reflect notify message.
        //
        case WM_NOTIFY:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up notify message.
            for (i = 0; i &lt; nPropPageSize; i++) {
                if (((NMHDR *)lParam)-&gt;code ==
                                        nlPropPage[i].wNotification) {
                    lstrcpy (szOut, nlPropPage[i].pszLabel);
                    break;
                }
            }
            if (i == nPropPageSize)
                wsprintf (szOut, TEXT (&quot;Notify code:%d&quot;),
                          ((NMHDR *)lParam)-&gt;code);

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (-1,ID_LISTPAGE),
                         (LPARAM)szOut);
            return FALSE;  // Return false to force default processing.
    }
    return FALSE;
}
</pre>
</td></tr></table>



<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="158"><H3>StaticDlg.c</H3></A>
<p><pre>
//======================================================================
// StaticDlg _ Static control dialog box window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;prsht.h&gt;                   // Property sheet includes

#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Identification strings for various WM_COMMAND notifications
NOTELABELS nlStatic[] = {{TEXT (&quot;STN_CLICKED&quot;), 0},
                         {TEXT (&quot;STN_ENABLE &quot;), 2},
                         {TEXT (&quot;STN_DISABLE&quot;), 3},
};
extern NOTELABELS nlPropPage[];
extern int nPropPageSize;
//======================================================================
// StaticDlgProc - Button page dialog box procedure
//
BOOL CALLBACK StaticDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                             LPARAM lParam) {
    TCHAR szOut[128];
    HWND hwndMain;
    INT i;

    switch (wMsg) {

        case WM_INITDIALOG:
            // The generic parameter contains the
            // top-level window handle.
            hwndMain = (HWND)((LPPROPSHEETPAGE)lParam)-&gt;lParam;
            // Save the window handle in the window structure.
            SetWindowLong (hWnd, DWL_USER, (LONG)hwndMain);
            return TRUE;
        //
        // Reflect WM_COMMAND messages to main window.
        //
        case WM_COMMAND:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up button notification.
            lstrcpy (szOut, TEXT (&quot;WM_COMMAND: &quot;));
            for (i = 0; i &lt; dim(nlStatic); i++) {
                if (HIWORD (wParam) == nlStatic[i].wNotification) {
                    lstrcat (szOut, nlStatic[i].pszLabel);
                    break;
                }
            }
            if (i == dim(nlStatic))
                wsprintf (szOut, TEXT (&quot;WM_COMMAND notification: %x&quot;),
                          HIWORD (wParam));

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (LOWORD (wParam),ID_STATPAGE),
                         (LPARAM)szOut);
            return TRUE;

        //
        // Reflect notify message.
        //
        case WM_NOTIFY:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up notify message.
<P>            for (i = 0; i &lt; nPropPageSize; i++) {
                if (((NMHDR *)lParam)-&gt;code ==
                    nlPropPage[i].wNotification) {
                        lstrcpy (szOut, nlPropPage[i].pszLabel);
                    break;
                }
            }
            if (i == nPropPageSize)
                wsprintf (szOut, TEXT (&quot;Notify code:%d&quot;),
                          ((NMHDR *)lParam)-&gt;code);

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (-1,ID_STATPAGE), (LPARAM)szOut);

            return FALSE;  // Return false to force default processing.
    }
    return FALSE;
}
</pre>
</td></tr></table>




<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="159"><H3>ScrollDlg.c</H3></A>
<p><pre>
//======================================================================
// ScrollDlg _ Scroll bar dialog box window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff

#include &lt;prsht.h&gt;                   // Property sheet includes
#include &quot;DlgDemo.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Identification strings for various WM_xSCROLL notifications
NOTELABELS nlVScroll[] = {{TEXT (&quot;SB_LINEUP       &quot;), 0},
                          {TEXT (&quot;SB_LINEDOWN     &quot;), 1},
                          {TEXT (&quot;SB_PAGEUP       &quot;), 2},
                          {TEXT (&quot;SB_PAGEDOWN     &quot;), 3},
                          {TEXT (&quot;SB_THUMBPOSITION&quot;), 4},
                          {TEXT (&quot;SB_THUMBTRACK   &quot;), 5},
                          {TEXT (&quot;SB_TOP          &quot;), 6},
                          {TEXT (&quot;SB_BOTTOM       &quot;), 7},
                          {TEXT (&quot;SB_ENDSCROLL    &quot;), 8},
};
NOTELABELS nlHScroll[] = {{TEXT (&quot;SB_LINELEFT     &quot;), 0},
                          {TEXT (&quot;SB_LINERIGHT    &quot;), 1},
                          {TEXT (&quot;SB_PAGELEFT     &quot;), 2},
                          {TEXT (&quot;SB_PAGERIGHT    &quot;), 3},
                          {TEXT (&quot;SB_THUMBPOSITION&quot;), 4},
                          {TEXT (&quot;SB_THUMBTRACK   &quot;), 5},
                          {TEXT (&quot;SB_LEFT         &quot;), 6},
                          {TEXT (&quot;SB_RIGHT        &quot;), 7},
                          {TEXT (&quot;SB_ENDSCROLL    &quot;), 8},
};
extern NOTELABELS nlPropPage[];
extern int nPropPageSize;
//======================================================================
// EditDlgProc - Button page dialog box procedure
//
BOOL CALLBACK ScrollDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                             LPARAM lParam) {
    TCHAR szOut[128];
    SCROLLINFO si;
    HWND hwndMain;
    INT i, sPos;

    switch (wMsg) {

        case WM_INITDIALOG:
            // The generic parameter contains
            // the top-level window handle.
            hwndMain = (HWND)((LPPROPSHEETPAGE)lParam)-&gt;lParam;
            // Save the window handle in the window structure.
            SetWindowLong (hWnd, DWL_USER, (LONG)hwndMain);
            return TRUE;
        //
        // Reflect WM_COMMAND messages to main window.
        //
        case WM_VSCROLL:
        case WM_HSCROLL:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Update the report window.
            // Determine whether from horizontal or vertical scroll bar.
            if (GetDlgItem (hWnd, 101) == (HWND)lParam) {
                for (i = 0; i &lt; dim(nlVScroll); i++) {
                    if (LOWORD (wParam) == nlVScroll[i].wNotification) {
                        lstrcpy (szOut, nlVScroll[i].pszLabel);
                        break;
                    }
                }
                if (i == dim(nlVScroll))
                    wsprintf (szOut, TEXT (&quot;notification: %x&quot;),
                              HIWORD (wParam));
            } else {
                for (i = 0; i &lt; dim(nlHScroll); i++) {
                    if (LOWORD (wParam) == nlHScroll[i].wNotification) {
                        lstrcpy (szOut, nlHScroll[i].pszLabel);
                        break;
                    }
                }
                if (i == dim(nlHScroll))
                    wsprintf (szOut, TEXT (&quot;notification: %x&quot;),
                              HIWORD (wParam));
            }
            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (-1, ID_SCROLLPAGE), (LPARAM)szOut);

            // Get scroll bar position.
            si.cbSize = sizeof (si);
            si.fMask = SIF_POS;
            GetScrollInfo ((HWND)lParam, SB_CTL, &amp;si);
            sPos = si.nPos;

            // Act on the scroll code.
            switch (LOWORD (wParam)) {
            case SB_LINEUP:      // Also SB_LINELEFT
                sPos -= 2;
                break;

            case SB_LINEDOWN:    // Also SB_LINERIGHT
                sPos += 2;
                break;

            case SB_PAGEUP:      // Also SB_PAGELEFT
                sPos -= 10;
                break;

            case SB_PAGEDOWN:    // Also SB_PAGERIGHT
                sPos += 10;
                break;

            case SB_THUMBPOSITION:
                sPos = HIWORD (wParam);
                break;
            }

            // Check range.
            if (sPos &lt; 0)
                sPos = 0;
            if (sPos &gt; 100)
                sPos = 100;

            // Update scrollbar position.
            si.cbSize = sizeof (si);
            si.nPos = sPos;
            si.fMask = SIF_POS;
            SetScrollInfo ((HWND)lParam, SB_CTL, &amp;si, TRUE);

            return TRUE;

        //
        // Reflect notify message.
        //
        case WM_NOTIFY:
            // Get the handle of the main window from the user word.
            hwndMain = (HWND) GetWindowLong (hWnd, DWL_USER);

            // Look up notify message.
            for (i = 0; i &lt; nPropPageSize; i++) {
                if (((NMHDR *)lParam)-&gt;code ==
                        nlPropPage[i].wNotification) {
                            lstrcpy (szOut, nlPropPage[i].pszLabel);
                            break;
                }
            }
            if (i == nPropPageSize)
                wsprintf (szOut, TEXT (&quot;Notify code:%d&quot;),
                          ((NMHDR *)lParam)-&gt;code);

            SendMessage (hwndMain, MYMSG_ADDLINE,
                         MAKEWPARAM (-1, ID_SCROLLPAGE), (LPARAM)szOut);

            return FALSE;  // Return false to force default processing.
    }
    return FALSE;
}
</pre>
</td></tr></table>

<P>The dialog box procedures for each of the property pages report all WM_COMMAND and WM_NOTIFY messages back to the main window where they're displayed in a list box contained in the main window. The property page dialog box procedures mirror the child window procedures of the CtlView example, the differences being that the page procedures don't have to create their controls, and they field the WM_INITDIALOG message to initialize the controls. The page procedures also use the technique of storing information in their window structures&#8212;in this case, the window handle of the main window of the example. This is necessary because the parent window of the pages is the property sheet, not the main window. The window handle is conveniently accessible during the WM_INITDIALOG message because it's loaded into the user-definable parameter in the PROPSHEETPAGE structure by the main window when the property sheet is created. Each page procedure copies the parameter from the PROPSHEETPAGE structure into the DWL_USER field of the window structure available to all dialog box procedures. When other messages are handled, the handle is then queried using <I>GetWindowLong</I>. The page procedures also field the WM_NOTIFY message so that they, too, can be reflected back to the main window.

<P>As with CtlView, the best way to learn from DlgDemo is to run the program and watch the different WM_COMMAND and WM_NOTIFY messages that are sent by the controls and the property sheet. Opening the property sheet and switching between the pages results in a flood of WM_NOTIFY messages informing the individual pages of what's happening. It's also interesting to note that when the OK button is pressed on the property sheet, the PSN_APPLY messages are sent only to property pages that have been displayed.

<P>The menu handlers that display the Print and Color common dialogs work with a bit of a twist. Since the Palm-size PC doesn't support these dialogs, DlgDemo can't call the functions directly. That would result in these two functions being implicitly linked at run time. Since the Palm-size PC doesn't have these common dialogs and therefore these functions, Windows CE wouldn't be able to resolve the implicit links to all the functions in the program and therefore the program wouldn't be able to load. So, instead of calling the functions directly, you explicitly link these functions in <I>InitApp</I> by loading the common dialog DLL using <I>LoadLibrary</I> and getting pointers to the functions using <I>GetProcAddress.</I> If DlgDemo is running on a Palm-size PC, the GetProcAddress function fails and returns 0 for the function pointer. In <I>OnCreateMain</I>, a check is made to see whether these function pointers are 0, and if so, the Print and Color menu items are disabled. In the menu handler functions <I>DoMainCommandColor</I> and <I>DoMainCommandPrint</I>, the function pointers returned by <I>GetProcAddress</I> are used to call the functions. This extra effort isn't necessary if you know your program will run only on a system that supports a specific set of functions, but every once in a while, this technique comes in handy.

</BODY>
</HTML>




