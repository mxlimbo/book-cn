<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Windows CE Remote API</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="398"><H1>The Windows CE Remote API</H1></A>

<P>The remote API (RAPI) allows applications on one machine to call functions on another machine. Windows CE supports essentially a one-way RAPI; applications on the PC can call functions on a connected Windows CE system. In the language of RAPI, the Windows CE device is the RAPI server while the PC is the RAPI client. The application runs on the client, the PC, which in turn calls functions that are executed on the server, the Windows CE device.

<A NAME="399"><H2>RAPI Overview</H2></A>

<P>RAPI under Windows CE is designed so that PC applications can manage the Windows CE device remotely. The exported functions deal with the file system, registry, and databases, as well as functions for querying the system configuration. While most RAPI functions are duplicates of functions in the Windows CE API, a few functions extend the API. You use these functions mainly for initializing the RAPI subsystem and enhancing performance of the communication link by compressing iterative operations into one RAPI call.

<P>The RAPI functions are listed in the Windows CE API reference but are called by PC applications&#8212;not by Windows CE applications. The RAPI functions are prefixed with a <I>Ce</I> in the function name to differentiate them from their Windows CE side counterparts; for example, the function <I>GetStoreInformation</I> in Windows CE is called <I>CeGetStoreInformation</I> in the RAPI version of the function. Unfortunately, some APIs in Windows CE, such as the database API, also have functions prefixed with <I>Ce</I>. In these cases, both the CE function (for example, <I>CeCreateDatabase</I>) and the RAPI function (again, <I>CeCreateDatabase</I>) have the same name. The linker isn't confused in this case because a Windows CE application won't be calling the RAPI function and a PC based program can't call the database function except through the RAPI interface.

<P>As I said, these Windows CE RAPI functions work for Windows 95/98 as well as Windows NT, but because they're Win32 functions applications developed for the Win16 API can't use the Windows CE RAPI functions. The RAPI functions can be called from either a Windows-based application or a Win32-console application. All you have to do to use the RAPI functions is to include the RAPI.h header file and link with the RAPI.lib library.

<P>Essentially, RAPI is a remote procedure call. It communicates a PC application's request to invoke a function and returns the results of that function. Because the RAPI layer is simple on the Windows CE side, all strings used in RAPI functions must be in Unicode regardless of whether the PC-based application calling the RAPI function uses the Unicode format.

<A NAME="400"><H3>Dealing with different versions of RAPI</H3></A>

<P>The problem of versioning has always been an issue with redistributable DLLs under Windows. RAPI.DLL, the DLL on the PC that handles the RAPI API, is distributed with the Mobile Devices software that comes with an H/PC, Palm-size PC, or other PC companion Windows CE devices. Trouble arises because the RAPI API has been extended over time as the Windows CE functions have expanded; you have to be aware that the RAPI DLL you load on a machine might not be the most up-to-date RAPI DLL. Older RAPI DLLs don't have all the exported functions that the newest RAPI DLL has.

<P>For example, any RAPI DLL distributed with a device running Windows CE 2.1 or later will export the newer database <I>Ex</I> functions so that you can manipulate databases that aren't in the object store of the remote device. However, if you assume that those functions are there and you run your RAPI application on a PC with an older RAPI DLL, the application won't load because the extended database functions aren't exported by the older DLL.

<P>On the other hand, just because <I>you're</I> using the latest RAPI DLL doesn't mean that the Windows CE system on the other end of the RAPI connection supports all the functions that the RAPI DLL supports. An H/PC running Windows CE 2.0 won't support the extended database API of Windows CE 2.1 no matter what RAPI DLL you're using on the PC.

<P>The best way to solve the problem of multiple versions of RAPI.DLL is to program defensively. Instead of loading the RAPI DLL implicitly by specifying an import library and directly calling the RAPI functions, you might want to load the RAPI DLL explicitly with a call to <I>LoadLibrary</I>. You can then access the exported functions by calling <I>GetProcAddress</I> for each function and then by calling the pointer to that function.

<P>The problem of different versions of Windows CE has a much easier solution. Just be sure to call <I>CeGetVersionEx </I>to query the version of Windows CE on the remote device. This gives you a good idea of what the device capabilities of that device are. If the remote device has a newer version of Windows CE than RAPI.DLL, you might want to inform the user of the version issue and suggest an upgrade of the synchronization software on the PC.

<A NAME="401"><H3>Initializing RAPI</H3></A>

<P>Before you can call any of the RAPI functions, you must first initialize the RAPI library with a call to either <I>CeRapiInit</I> or <I>CeRapiInitEx</I>. The difference between the two functions is that <I>CeRapiInit </I>blocks, waiting on a successful connection with a Windows CE device, while <I>CeRapiInitEx </I>doesn't block. Contrary to what you might expect, neither of these functions creates a connection between a PC and a device physically hooked up to one another but unconnected.

<P>The first initialization function is prototyped as

<p><pre>
HRESULT CeRapiInit (void);
</PRE>

<P>This function has no parameters. When the function is called, Windows looks for an established link to a Windows CE device. If one doesn't exist, the function blocks until one is established or another thread in your application calls <I>CeRapiUninit</I>, which is generally called to clean up after a RAPI session. The return value is either 0, indicating that a RAPI session has been established, or the constant E_FAIL, indicating an error. In this case, you can call <I>GetLastError</I> to diagnose the problem.

<P>Unfortunately <I>CeRapiInit</I> blocks, sometimes, for an extended period of time. To avoid this, you can use the other initialization function,

<p><pre>
HRESULT CeRapiInitEx (RAPIINIT* pRapiInit);
</PRE>

<P>The only parameter is a pointer to a RAPIINIT structure defined as

<p><pre>
typedef struct _RAPIINIT {
    DWORD cbSize;
    HANDLE heRapiInit;
    HANDLE hrRapiInit;
} RAPIINIT;
</PRE>

<P>The <I>cbSize</I> field must be filled in before the call is made to <I>CeRapiInitEx</I>. After the size field has been initialized, you call <I>CeRapiInitEx</I> and the function returns without blocking. It fills in the second of the two fields, <I>heRapiInit</I>, with the handle to an event object that will be signaled when the RAPI connection is initialized. You can use <I>WaitForSingleObject</I> to have a thread block on this event to determine when the connection is finally established. When the event is signaled, the final field in the structure, <I>hrRapiInit</I>, is filled with the return code from the initialization. This value can be 0 if the connection was successful or E_FAIL if the connection wasn't made for some reason.

<A NAME="402"><H3>Handling RAPI errors</H3></A>

<P>When you're dealing with the extra RAPI layer between the caller and the execution of the function, a problem arises when an error occurs: did the error occur because the function failed or because of an error in the RAPI connection? RAPI functions return error codes indicating success or failure of the function. If a function fails, you can use the following two functions to isolate the cause of the error:

<p><pre>
HRESULT CeRapiGetError (void);
</PRE>
<P>and
<p><pre>
DWORD CeGetLastError (void);
</PRE>


<P>The difference between these two functions is that <I>CeRapiGetError</I> returns an error code for failures due to the network or other RAPI-layer reasons. On the other hand, <I>CeGetLastError </I>is the RAPI counterpart to <I>GetLastError</I>; it returns the extended error for a failed function on the Windows CE device. So, if a function fails, call <I>CeRapiGetError </I>to determine whether an error occurred in the RAPI layer. If <I>CeRapiGetError</I> returns 0, the error occurred in the original function on the CE device. In this case, a call to <I>CeGetLastError</I> returns the extended error for the failure on the device.

<P>Here's one last general function, used to free buffers that are returned by some of the RAPI functions. This function is


<p><pre>
HRESULT CeRapiFreeBuffer (LPVOID Buffer);
</PRE>

<P>The only parameter is the pointer to the buffer you want to free. The function returns SOK when successful and E_FAIL if not. Throughout the explanation of RAPI functions, I'll mention those places where you need to use <I>CeRapiFreeBuffer</I>. In general, though, you use this function anywhere a RAPI function returns a buffer that it allocated for you.

<A NAME="403"><H3>Ending a RAPI session</H3></A>

<P>When you have finished making all the RAPI calls necessary, you should clean up by calling

<p><pre>
HRESULT CeRapiUninit (void);
</PRE>

<P>This function gracefully closes down the RAPI communication with the remote device. <I>CeRapiUninit</I> returns E_FAIL if a RAPI session hasn't been initialized.

<A NAME="404"><H2>Predefined RAPI Functions</H2></A>

<P>As I mentioned in the beginning of this chapter, the RAPI services include a number of predefined RAPI functions that duplicate Windows CE functions on the PC side of the connection. So, for example, just as <I>GetStoreInformation</I> returns the size and free space of the object store to a Windows CE program, <I>CeGetStoreInformation</I> returns that same information about a connected Windows CE device to a PC-based application. The functions are divided into a number of groups that I'll talk about in this chapter. Since the actions of the functions are identical to their Windows CE-based counterparts, I won't go into the details of each function. Instead, although I'll list every RAPI function, I'll explain at length only the functions that are unique to RAPI.

<A NAME="405"><H3>RAPI system information functions</H3></A>

<P>The RAPI database functions are shown in the following list. I've previously described most of the counterpart Windows CE functions shown, with the exception of <I>CeGetPassword </I>and <I>CeRapiInvoke</I>. The <I>CeGetPassword </I>function, as well as its Windows CE counterpart <I>GetPassword</I>, compares a string to the current system password. If the strings match, the function returns TRUE. The comparison is case specific. Another function you might not recognize is <I>CeGetDesktopDeviceCaps</I>. This is the RAPI equivalent of <I>GetDeviceCaps</I> on the Windows CE side.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><B>System information functions</B></td></tr>
<tr><td valign="top"><i>CeGetVersionEx</i></td></tr>
<tr><td valign="top"><i>CeGlobalMemoryStatus</i></td></tr>
<tr><td valign="top"><i>CeGetSystemPowerStatusEx</i></td></tr>
<tr><td valign="top"><i>CeGetStoreInformation</i></td></tr>
<tr><td valign="top"><i>CeGetSystemMetrics</i></td></tr>
<tr><td valign="top"><i>CeGetDesktopDeviceCaps</i></td></tr>
<tr><td valign="top"><i>CeGetSystemInfo</i></td></tr>
<tr><td valign="top"><i>CeCheckPassword</i></td></tr>
<tr><td valign="top"><i>CeCreateProcess</i></td></tr>
</table>

<A NAME="406"><H3>RAPI file and directory management functions</H3></A>

<P>The following list shows the RAPI file management functions, illustrating that almost any file function available to a Windows CE application is also available to a PC-based program.


<p><table cellpadding=5 width="95%">
<tr><td valign="top"><B>File and directory management functions</B></td></tr>
<tr><td valign="top"><i>CeFindAllFiles</i></td></tr>
<tr><td valign="top"><i>CeFindFirstFile</i></td></tr>
<tr><td valign="top"><i>CeFindNextFile</i></td></tr>
<tr><td valign="top"><i>CeFindClose</i></td></tr>
<tr><td valign="top"><i>CeGetFileAttributes</i></td></tr>
<tr><td valign="top"><i>CeSetFileAttributes</i></td></tr>
<tr><td valign="top"><i>CeCreateFile</i></td></tr>
<tr><td valign="top"><i>CeReadFile</i></td></tr>
<tr><td valign="top"><i>CeWriteFile</i></td></tr>
<tr><td valign="top"><i>CeCloseHandle</i></td></tr>
<tr><td valign="top"><i>CeSetFilePointer</i></td></tr>
<tr><td valign="top"><i>CeSetEndOfFile</i></td></tr>
<tr><td valign="top"><i>CeCreateDirectory</i></td></tr>
<tr><td valign="top"><i>CeRemoveDirectory</i></td></tr>
<tr><td valign="top"><i>CeMoveFile</i></td></tr>
<tr><td valign="top"><i>CeCopyFile</i></td></tr>
<tr><td valign="top"><i>CeDeleteFile</i></td></tr>
<tr><td valign="top"><i>CeGetFileSize</i></td></tr>
<tr><td valign="top"><i>CeGetFileTime</i></td></tr>
<tr><td valign="top"><i>CeSetFileTime</i></td></tr>
</table>

<P>Here's a new function, <I>CeFindAllFiles</I>, that's not even available to a Windows CE application. This function is prototyped as

<p><pre>
BOOL CeFindAllFiles (LPCWSTR szPath, DWORD dwFlags,
                     LPDWORD lpdwFoundCount,
                     LPLPCE_FIND_DATA ppFindDataArray);
</PRE>

<P><I>CeFindAllFiles</I> is designed to enhance performance by returning all the files of a given directory with one call rather than having to make repeated RAPI calls using <I>CeFindFirstFile</I> and <I>CeFindNextFile</I>. The first parameter is the search string. This string must be specified in Unicode, so if you're not creating a Unicode application, the TEXT macro won't work because the TEXT macro produces char strings for non-Unicode applications. In Microsoft Visual C++, prefixing the string with an <I>L</I> before the quoted string as in <I>L&quot;\\*.*&quot; </I>produces a proper Unicode for the function even in a non-Unicode application. For string conversion, you can use the <I>WideCharToMultiByte</I> and <I>MultiByteToWideChar</I> library functions to convert Unicode and ANSI strings into one another.

<P>The second parameter of the <I>CeFindAllFiles </I>function, <I>dwFlags</I>, defines the scope of the search and what data is returned. The first set of flags can be one or more of the following:

<UL>
<P><LI><I> FAF_ATTRIB_CHILDREN</I> Return only directories that have child items.
<P><LI><I> FAF_ATTRIB_NO_HIDDEN</I> Don't report hidden files or directories.
<P><LI><I> FAF_FOLDERS_ONLY</I> Return only folders in the directory.
<P><LI><I> FAF_NO_HIDDEN_SYS_ROMMODULES</I> Don't report ROM-based system files.
</UL>

<P>The second set of flags defines what data is returned by the <I>CeFindAllFiles </I>function. These flags can be one or more of the following:

<UL>
<P><LI><I> FAF_ATTRIBUTES</I> Return file attributes.
<P><LI><I> FAF_CREATION_TIME</I> Return file creation time.
<P><LI><I> FAF_LASTACCESS_TIME</I> Return file last access time.
<P><LI><I> FAF_LASTWRITE_TIME</I> Return file last write time.
<P><LI><I> FAF_SIZE_HIGH</I> Return upper 32 bits of file size.
<P><LI><I> FAF_SIZE_LOW</I> Return lower 32 bits of file size.
<P><LI><I> FAF_OID</I> Return the OID for the file.
<P><LI><I> FAF_NAME</I> Return the filename.
</UL>

<P>Just because the flags are listed above doesn't mean you can find a good use for them. For example, the FAF_SIZE_HIGH flag is overkill, considering that few files on a Windows CE device are going to be larger than 4 GB. The file time flags are also limited by the support of the underlying file system. For example, the Windows CE object store tracks only the last access time and reports it in all file time fields.

<P>There also appears to be a bug with the FAF_ATTRIB_CHILDREN flag. This valuable flag allows you to know when a directory contains subdirectories without your having to make an explicit call to that directory to find out. The flag seems to work only if the filename specification&#8212;the string to the right of the last directory separator backslash (\)&#8212;contains only one character. For example, the file specification

<p><pre>
\\windows\*
</PRE>

<P>works with FAF_ATTRIB_CHILDREN, while

<p><pre>

\\windows\*.*
</PRE>

<P>returns the same file list, but the flag FILE_ATTRIBUTE_HAS_CHILDREN isn't set for directories that have subdirectories.

<P>The third parameter of <I>CeFindAllFiles</I> should point to a DWORD value that will receive the number of files and directories found by the call. The final parameter, <I>ppFindDataArray</I>, should point to a variable of type LPCE_FIND_DATA, which is a pointer to an array of CE_FIND_DATA structures. When <I>CeFindAllFiles</I> returns, this variable will point to an array of CE_FIND_DATA structures that contain the requested data for each of the files found by the function. The CE_FIND_DATA structure is defined as


<p><pre>
typedef struct _CE_FIND_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwOID;
    WCHAR cFileName[MAX_PATH];
} CE_FIND_DATA;
</PRE>

<P>The fields of CE_FIND_DATA look familiar to us by now. The only interesting field is the <I>dwOID</I> field that allows a PC-based application to receive the OID of a Windows CE file. This can be used with <I>CeGetOidGetInfo</I> to query more information about the file or directory. The flags in the <I>dwFileAttributes</I> field relate to Windows CE file attributes even though your application is running on a PC. This means, for example, that the FILE_ATTRIBUTE_TEMPORARY flag indicates an external storage device like a PC Card. Also, attribute flags are defined for execute in place ROM files. The additional attribute flag, FILE_ATTRIBUTE_HAS_CHILDREN, is defined to indicate that the directory contains child directories.

<P>The buffer returned by <I>CeFindAllFiles</I> is originally allocated by the RAPI.DLL. Once you have finished with the buffer, you must call <I>CeRapiFreeBuffer </I>to free the buffer.

<A NAME="407"><H3>RAPI database functions</H3></A>

<P>The RAPI database functions are shown in the following list. As you can see, these functions mimic the extensive database API found in Windows CE. Here's a case in which explicitly loading the RAPI DLL can come in handy. The many RAPI functions that support the extended database API of Windows CE 2.1 aren't exported by older RAPI DLLs. If your application attempts implicitly to load one of these functions, it won't load if the PC has an older version of RAPI.DLL.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><B>Database management functions</B></td><td valign="top"><B>Support in</B></td></tr>
<tr><td valign="top"><i>CeCreateDatabase</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeCreateDatabaseEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeDeleteDatabase</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeDeleteDatabaseEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeDeleteRecord</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeFindFirstDatabase</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeFindFirstDatabaseEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeFindNextDatabase</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeFindNextDatabaseEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeOidGetInfo</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeOidGetInfoEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeOpenDatabase</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeOpenDatabaseEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeReadRecordProps</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeReadRecordPropsEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeSeekDatabase</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeSetDatabaseInfo</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeSetDatabaseInfoEx</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeWriteRecordProps</i></td><td valign="top"></td></tr>
<tr><td valign="top"><i>CeMountDBVol</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeUnmountDBVol</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeEnumDBVolumes</i></td><td valign="top">Windows CE 2.1 or later</td></tr>
<tr><td valign="top"><i>CeFindAllDatabases</i></td><td valign="top"></td></tr>
</table>

<P>All but one of the database functions has a Windows CE counterpart. The only new function is <I>CeFindAllDatabases</I>. Like <I>CeFindAllFiles</I>, this function is designed as a performance enhancement so that applications can query all the databases on the system without having to iterate using the <I>FindFirstDatabase</I> and <I>FindNextDatabase</I> functions. The function is prototyped as

<p><pre>
BOOL CeFindAllDatabases (DWORD dwDbaseType, WORD wFlags,
                         LPWORD cFindData,
                         LPLPCEDB_FIND_DATA ppFindData);
</PRE>

<P>The first parameter is the database type value, or 0, if you want to return all databases. The <I>wFlags</I> parameter can contain one or more of the following flags, which define what data is returned by the function.

<UL>
<P><LI><I> FAD_OID</I> Returns the database OID
<P><LI><I> FAD_FLAGS</I> Returns the <I>dwFlags</I> field of the DbInfo structure
<P><LI><I> FAD_NAME</I> Returns the name of the database
<P><LI><I> FAD_TYPE</I> Returns the type of the database
<P><LI><I> FAD_NUM_RECORDS</I> Returns the number of records in the database
<P><LI><I> FAD_NUM_SORT_ORDER</I> Returns the number of sort orders
<P><LI><I> FAD_SORT_SPECS</I> Returns the sort order specs for the database
</UL>

<P>The <I>cFindData</I> parameter should point to a WORD variable that receives the number of databases found. The last parameter should be the address of a pointer to an array of CEDB_FIND_DATA structures. As with the <I>CeFindAllFiles</I> function, <I>CeFindAllDatabases</I> returns the information about the databases found in an array and sets the <I>ppFindData</I> parameter to point to this array. The CEDB_FIND_DATA structure is defined as

<p><pre>
struct CEDB_FIND_DATA {
    CEOID OidDb;
    CEDBASEINFO DbInfo;
};
</PRE>

<P>The structure contains the OID for a database followed by a CEDBASEINFO structure. I described this structure in <A HREF="ch07a.htm">Chapter 7</a>, but I'll repeat it here so that you can see what information can be queried by <I>FindAllDatabases</I>.

<p><pre>
typedef struct _CEDBASEINFO {
    DWORD dwFlags;
    WCHAR szDbaseName[CEDB_MAXDBASENAMELEN];
    DWORD dwDbaseType;
    WORD wNumRecords;
    WORD wNumSortOrder;
    DWORD dwSize;
    FILETIME ftLastModified;
    SORTORDERSPEC rgSortSpecs[CEDB_MAXSORTORDER];
} CEDBASEINFO;
</PRE>

<P>As with <I>CeFindAllFiles</I>, you must free the buffer returned by <I>CeFindAllDatabases</I> with a call to <I>CeRapiFreeBuffer</I>.

<P>One other function in this section requires a call to <I>CeRapiFreeBuffer</I>. The function <I>CeReadRecordProps</I>, which returns properties for a database record, allocates the buffer where the data is returned. If you call the RAPI version function, you need to call <I>CeRapiFreeBuffer</I> to free the returned buffer.

<A NAME="408"><H3>RAPI registry management functions</H3></A>

<P>The RAPI functions for managing the registry are shown in the following list. The functions work identically to their Windows CE counterparts. But remember that all strings, whether they are specifying keys and values or strings returned by the functions, are in Unicode.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Registry management functions</b></td></tr>
<tr><td valign="top"><i>CeRegOpenKeyEx</i></td></tr>
<tr><td valign="top"><i>CeRegEnumKeyEx</i></td></tr>
<tr><td valign="top"><i>CeRegCreateKeyEx</i></td></tr>
<tr><td valign="top"><i>CeRegCloseKey</i></td></tr>
<tr><td valign="top"><i>CeRegDeleteKey</i></td></tr>
<tr><td valign="top"><i>CeRegEnumValue</i></td></tr>
<tr><td valign="top"><i>CeRegDeleteValue</i></td></tr>
<tr><td valign="top"><i>CeRegQueryInfoKey</i></td></tr>
<tr><td valign="top"><i>CeRegQueryValueEx</i></td></tr>
<tr><td valign="top"><i>CeRegSetValueEx</i></td></tr>
</table>

<A NAME="409"><H3>Shell management functions</H3></A>

<P>The RAPI shell management functions are shown in the first list below. While I'll cover the Windows CE-equivalent functions in the next chapter, you can see that the self-describing names of the functions pretty well document themselves. The <I>CeSHCreateShortcut</I> and <I>CeSHGetShortcutTarget</I> functions allow you to create and query shortcuts. The other two functions, <I>CeGetTempPath</I> and <I>CeGetSpecialFolderPath</I>, let you query the locations of some of the special-purpose directories on the Windows CE system, such as the programs directory and the recycle bin.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Shell management functions</b></td></tr>
<tr><td valign="top"><i>CeSHCreateShortcut</i></td></tr>
<tr><td valign="top"><i>CeSHGetShortcutTarget</i></td></tr>
<tr><td valign="top"><i>CeGetTempPath</i></td></tr>
<tr><td valign="top"><i>CeGetSpecialFolderPath</i></td></tr>
</table>

<A NAME="410"><H3>RAPI window management functions</H3></A>

<P>The final set of predefined RAPI functions allow a desktop application to manage the windows on the Windows CE desktop. These functions are shown in the following list. The functions work similarly to their Windows CE functions. The <I>CeGetWindow</I> function allows a PC-based program to query the windows and child windows on the desktop while the other functions allow you to query the values in the window structures.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Window management functions</b></td></tr>
<tr><td valign="top"><i>CeGetWindow</i></td></tr>
<tr><td valign="top"><i>CeGetWindowLong</i></td></tr>
<tr><td valign="top"><i>CeGetWindowText</i></td></tr>
<tr><td valign="top"><i>CeGetClassName</i></td></tr>
</table>

<A NAME="411"><H2>The RapiDir Example Program</H2></A>

<P>The RapiDir example is a PC-console application that displays the contents of a directory on an attached Windows CE device. The output of RapiDir, shown in Figure 11-1, resembles the output of the standard DIR command from a PC command line. RapiDir is passed one argument, the directory specification of the directory on the Windows CE machine. The directory specification can take wildcard arguments such as <I>*.exe</I> if you want, but the program isn't completely robust in parsing the directory specification. Perfect parsing of a directory string isn't the goal of RapiDir&#8212;demonstrating RAPI is.

<P><A HREF="javascript:fullSize('f11rg01x.htm')"> <img src="F11rg01.JPG" width=404 height=210 border="0" ALT="Click to view at full size."></a>

<P><!-- caption --><B>Figure 11-1.</B> <I>The output of RapiDir.</I><!-- /caption -->

<P>The source code for RapiDir is shown in Figure 11-2. The program is a command line application and therefore doesn't need the message loop or any of the other structure seen in a Windows-based application. Instead the <I>WinMain</I> function is replaced by our old C friend, <I>main</I>.

<P>Remember that RapiDir is a standard Win32 desktop application. It won't even compile for Windows CE. On the other hand, you have the freedom to use the copious amounts of RAM and disk space provided by the comparatively huge desktop PC. When you build RapiDir, you'll need to add <I>rapi.lib</I> to the libraries that the linker uses. Otherwise, you'll get unresolved external errors for all the RAPI functions you call in your application.


<P><!-- caption --><B>Figure 11-2.</B> <I>The RapiDir source code.</I><!-- /caption -->

<p><TABLE cellpadding=5 width="95%"><TR><td>
<P><pre>
//======================================================================

// RapiDir - Returns the contents of a directory on a Windows CE system
//
// Written for the book Programming Windows CE


// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;stdio.h&gt;
#include &lt;rapi.h&gt;                    // RAS includes

//======================================================================
// main - Program entry point
//
int main (int argc, char **argv) {
    RAPIINIT ri;
    char szSrch[MAX_PATH], *pPtr;
    WCHAR szwDir[MAX_PATH];
    CE_FIND_DATA *pfd;
    DWORD i, cItems, dwTotal = 0;
    FILETIME ft;
    SYSTEMTIME st;
    char ampm = `a';
    INT rc;

    // Call RapiInitEx to asynchronously start RAPI session.
    ri.cbSize = sizeof (ri);
    rc = CeRapiInitEx (&amp;ri);

    if (rc != NOERROR) {
        printf (TEXT (&quot;Rapi Initialization failed.\r\n&quot;));
        return 0;
    }
    // Wait 5 seconds for connect.
    rc = WaitForSingleObject (ri.heRapiInit, 5000);

    if (rc == WAIT_OBJECT_0) {
        if (ri.hrRapiInit != NOERROR) {
            printf (TEXT (&quot;Rapi Initialization failed.\r\n&quot;));
            return 0;
        }
    } else if (rc == WAIT_TIMEOUT) {
        printf (TEXT (&quot;Rapi Initialization timed out.\r\n&quot;));
        return 0;
    }
    // If no argument, assume root directory.
    if (argc &gt; 1)
        lstrcpy (szSrch, argv[1]);
    else
        lstrcpy (szSrch, &quot;\\&quot;);

    // Point to end of name.
    pPtr = szSrch + lstrlen (szSrch) - 1;

    // Strip any trailing backslash.
    if (*pPtr == `\\')
        *pPtr = `\0';

    // Look for wildcards in filename. pPtr points to string end.
    for (i = 0; (pPtr &gt;= szSrch) &amp;&amp; (*pPtr != `\\'); pPtr&#8212;) {
        if ((*pPtr == `*') || (*pPtr == `?'))
            i++;
    }
    // Display dir name first so that on long calls we show we're alive.
    if (pPtr &gt;= szSrch) {
        char ch;
        ch = *pPtr;
        *pPtr = `\0';
        printf (TEXT (&quot;\r\n Directory of %s\r\n\r\n&quot;), szSrch);
        *pPtr = ch;
    } else if (i)
        printf (TEXT (&quot;\r\n Directory of \\\r\n\r\n&quot;));
    else
        printf (TEXT (&quot;\r\n Directory of %s\r\n\r\n&quot;), szSrch);

    // No wildcards, append *.*
    if (i == 0)
        lstrcat (szSrch, &quot;\\*.*&quot;);

    // Convert ANSI string to Unicode.
    mbstowcs (szwDir, szSrch, lstrlen (szSrch));
    // RAPI call
    rc = CeFindAllFiles (szwDir, FAF_SIZE_LOW | FAF_NAME |
                         FAF_ATTRIBUTES | FAF_LASTACCESS_TIME,
                         &amp;cItems, &amp;pfd);

    // Display the results.
    if (cItems) {
        for (i = 0; i &lt; cItems; i++) {
            // Convert file time.
            FileTimeToLocalFileTime (&amp;pfd-&gt;ftLastAccessTime, &amp;ft);
            FileTimeToSystemTime (&amp;ft, &amp;st);
            // Adjust for AM/PM.
            if (st.wHour == 0)
                st.wHour = 12;
            else if (st.wHour &gt; 11) {
                ampm = `p';
                if (st.wHour &gt; 12)
                    st.wHour -= 12;
            }
            printf (TEXT (&quot;%02d/%02d/%02d  %02d:%02d%c\t&quot;),
                    st.wMonth, st.wDay, st.wYear,
                    st.wHour, st.wMinute, ampm);

            // Display dir marker or file size.
            if (pfd-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
                printf (TEXT (&quot;&lt;DIR&gt;\t\t &quot;));
            else {
                printf (TEXT (&quot;\t%8d &quot;), pfd-&gt;nFileSizeLow);
                dwTotal += pfd-&gt;nFileSizeLow;
            }

            // Display name, use Cap %S to indicate Unicode.
            printf (TEXT (&quot;%S\r\n&quot;), pfd-&gt;cFileName);
            pfd++;
        }
        printf (TEXT (&quot;\t%10d File(s)\t%9d bytes\r\n\r\n&quot;),
                cItems, dwTotal);
    } else
        printf (TEXT (&quot;File not Found\r\n\r\n&quot;));

    // Clean up by uninitializing RAPI.
    CeRapiUninit ();
    return 0;
}
</PRE>
</td></tr></table>

<P>This single procedure application first calls <I>CeRapiInitEx</I> to initialize the RAPI session. I used the <I>Ex</I> version of the initialization function so that RapiDir can time out and terminate if a connection isn't made within 5 seconds of starting the program. If I'd used <I>CeRapiInit</I> instead, the only way to terminate RapiDir if a remote CE device weren't connected would be a user-unfriendly Control-C key combination.

<P>Once the RAPI session is initialized, a minimal amount of work is done on the single command line argument that's the search string for the directory. Once that work is complete, the string is converted into Unicode and passed to <I>CeFindAllFiles</I>. This RAPI function then returns with an array of CE_FIND_DATA structures that contain the names and requested data of the files and directories found. The data from that array is then displayed using <I>printf </I>statements. Finally, the RAPI session is terminated with a call to <I>CeRapiUninit</I>.

<P>If you compare the output of RapiDir with the output of the standard DIR command, you notice that RapiDir doesn't display the total bytes free on the disk after the listing of files. While I could have displayed the total free space for the object store using <I>CeGetStorageInformation</I>, this wouldn't work if the user displayed a directory on a PCMCIA card or other external media. Windows CE supports the <I>GetDiskFreeSpaceEx</I> function, but the Windows CE RAPI DLL doesn't expose this function. To get this information, we'll use RAPI's ability to call user defined functions on a Windows CE system.

<A NAME="412"><H2>Custom RAPI Functions</H2></A>

<P>No matter how many functions the RAPI interface supports, you can always think of functions that an application needs but the RAPI interface doesn't give you. Because of this, RAPI provides a method for a PC application to call a user-defined function on the Windows CE device.

<P>You can invoke a user-defined RAPI function in one of two ways. The first way is called <I>block mode</I>. In block mode, you make a call to the RAPI remote invocation function, the function makes the call to a specified function in a specified DLL, the DLL function does its thing and returns, and the RAPI function then returns to the calling PC program with the output. The second method is called stream mode. In this mode, the RAPI call to the function returns immediately, but a connection is maintained between the calling PC application and the Windows CE DLL-based function. This method allows information to be fed back to the PC on an ongoing basis.

<A NAME="413"><H3>Using RAPI to call a custom function</H3></A>

<P>The RAPI function that lets you call a generic function on the Windows CE device is <I>CeRapiInvoke</I>, which is prototyped as

<p><pre>
HRESULT CeRapiInvoke (LPCWSTR pDllPath, LPCWSTR pFunctionName,
                      DWORD cbInput, BYTE *pInput, DWORD *pcbOutput,
                      BYTE **ppOutput, IRAPIStream **ppIRAPIStream,
                      DWORD dwReserved);
</PRE>

<P>The first parameter to <I>CeRapiInvoke</I> is the name of the DLL on the Windows CE device that contains the function you want to call. The name must be in Unicode but can include a path. If no path is specified, the DLL is assumed to be in the \windows directory on the device. The second parameter is the name of the function to be called. The function name must be in Unicode and is case specific.

<P>The next two parameters, <I>cbInput</I> and <I>pInput</I>, should be set to the buffer containing the data and the size of that data to be sent to the Windows CE-based function. The <I>pcbOutput</I> and <I>ppOutput</I> parameters are both pointers&#8212;the first a pointer to a DWORD that receives the size of the data returned and the second a pointer to a PBYTE variable that receives the pointer to the buffer containing the data returned by the Windows CE function. I'll describe the next-to-last parameter, <I>ppIRAPIStream</I>, later.

<P>To use <I>CeRapiInvoke</I> in block mode, all you do is specify the DLL containing the function you want to call, the name of the function, and the data and make the call. When <I>CeRapiInvoke</I> returns, the data from the CE-based function will be sitting in the buffer pointed to by your output pointer variable.

<A NAME="414"><H3>Writing a RAPI server function</H3></A>

<P>You can't just call any function in a Windows CE DLL. The structure of the Windows CE function must conform to the following function prototype:

<p><pre>
STDAPI INT FuncName (DWORD cbInput, BYTE *pInput, DWORD *pcbOutput,
                     BYTE **ppOutput, IRAPIStream *pIRAPIStream);
</PRE>

<P>As you can see, the parameters closely match those of <I>CeRapiInvoke</I>. As with <I>CeRapiInvoke</I>, I'll talk about the parameter <I>pIRAPIStream</I>, later.


<P>Figure 11-3 contains the source code for a very simple block-mode RAPI server. This is a DLL and therefore has a different structure from the application files previously used in the book. The primary difference is that the DLL contains a <I>LibMain</I> routine instead of <I>WinMain</I>. The <I>LibMain</I> routine is called by Windows whenever a DLL is loaded or freed by a process or thread. In our case, we don't need to take any action other that to return TRUE indicating all is well.

<P>You should be careful to make the name of your RAPI server DLL eight characters or less. Current implementations of the RAPI DLL will fail to find server DLLs with names not in the old 8.3 format.
<P><!-- caption --><B>Figure 11-3.</B> <I>RapiServ.c, a simple block-mode RAPI server DLL.</I><!-- /caption -->

<p><TABLE cellpadding=5 width="95%"><TR><td>
<P><pre>

//====================================================================
// RapiServ - A RAPI block mode server DLL
//


// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
// This ensures that the function will be exported by the DLL.
__declspec(dllexport) INT RAPIGetDiskSize (DWORD, BYTE *, DWORD *,
                                           BYTE **, PVOID);

//====================================================================
// DllMain - DLL initialization entry point
//
BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD dwReason,
                     LPVOID lpvReserved) {
    return TRUE;
}
//====================================================================
// RAPIGetDiskSize - Returns the disk size and free space.  Called from
// PC application using RAPI.
//
INT RAPIGetDiskSize (DWORD cbInput, BYTE *pInput, DWORD *pcbOutput,
                     BYTE **ppOutput, PVOID reserved) {
    PDWORD pdwLocal;
    LPTSTR pPtr;
    DWORD i;
    ULARGE_INTEGER lnFree, lnTotal;

    *pcbOutput = 0;            // Zero output bytes for now.

    // See if proper zero-terminated string.
    pPtr = (LPTSTR)pInput;
    for (i = 0; i &lt; cbInput / 2; i++)
        if (!*pPtr++)
            break;

    // If not zero terminated or if zero length, return error.
    if ((i &gt;= cbInput / 2) || (i == 0))
        return -2;

    // Call the function.
    if (GetDiskFreeSpaceEx ((LPTSTR)pInput, NULL, &amp;lnTotal, &amp;lnFree)) {

        // Allocate memory for the return buffer.
        pdwLocal = (PDWORD) LocalAlloc (LPTR, 2 * sizeof (DWORD));
        if (pdwLocal) {
            // Copy data from function to output buffer.
            pdwLocal[0] = lnTotal.LowPart;
            pdwLocal[1] = lnFree.LowPart;
            // Specify size and buffer.
            *pcbOutput = 2 * sizeof (DWORD);
            *ppOutput = (PBYTE)pdwLocal;
        } else
            return GetLastError();
    } else
        return GetLastError();
    return 0;
}
</pre>
</td></tr></table>

<P>The unusual prefix before the function prototype for <I>RAPIGetDiskSize</I>,

<p><pre>
__declspec (dllexport) INT RAPIGetDiskSize&#8230;
</PRE>

<P>tells the linker to export the function listed so that external modules can call the function directly. This declaration is a shortcut for the old way of defining exports in a separate function definition (DEF) file used in Win16 programming. While this shortcut is convenient, sometimes you still need to fall back on a DEF file.

<P>The function of RapiServ is to make available that <I>GetDiskFreeSpaceEx</I> function we needed in the RapiDir example application. The server function, <I>RAPIGetDiskSize</I>, has the same prototype I described earlier. The input buffer is used to pass a directory name to the DLL while the output buffer returns the total disk space and the free disk space for the directory passed. The format of the input and output buffers is totally up to you. However, the output buffer should be allocated using <I>LocalAlloc</I> so that the RAPI library can free it after it has been used. The value returned by <I>RAPIGetDiskSize</I> is the value that's returned by the <I>CeRapiInvoke</I> function to the PC-based application.


<P>On the PC side, a call to a block mode RAPI server function looks like the following.

<p><pre>
//-----------------------------------------------------------------------
// MyCeGetDiskFreeSpaceEx - Homegrown implementation of a RAPI
// GetDiskFreeSpace function
//
BOOL MyCeGetDiskFreeSpaceEx (LPWSTR pszDir, PDWORD pdwTotal,
                             PDWORD pdwFree) {
    HRESULT hr;
    DWORD dwIn, dwOut;
    LPBYTE pInput;
    LPWSTR pPtr;
    PDWORD pOut;

    // Get length of Unicode string.
    for (dwIn = 2, pPtr = pszDir; *pPtr++; dwIn+=2);

    // Allocate buffer for input.
    pInput = LocalAlloc (LPTR, dwIn);
    if (!pInput)
        return FALSE;
    // Copy directory name into input buffer.
    memcpy (pInput, pszDir, dwIn);

    // Call function on Windows CE device.
    hr = CeRapiInvoke (L&quot;\\RapiServ&quot;, L&quot;RAPIGetDiskSize&quot;, dwIn,
                       pInput, &amp;dwOut, (PBYTE *)&amp;pOut, NULL, 0);

    // If successful, return total and free values.
    if (hr == 0) {
        *pdwTotal = pOut[0];
        *pdwFree = pOut[1];
        CeRapiFreeBuffer (pOut);
        return TRUE;
    }
    return FALSE;
}
</PRE>

<P>This routine encapsulates the call to <I>CeRapiInvoke</I> so that the call looks just like another CE RAPI call. The code in this routine simply computes the length of the Unicode string that contains the directory specification, allocates a buffer and copies the string into it, and passes it to the <I>CeRapiInvoke</I> function. When the routine returns, the return code indicates success or failure of the call. <I>CeRapiInvoke</I> frees the input buffer passed to it. The data is then copied from the output buffer and that buffer is freed with a call to <I>CeRapiFreeBuffer</I>.

<P>Throughout this section, I've put off any explanation of the parameters referring to <I>IRAPIStream</I>. In fact, in the example code above, the prototype for the server call, <I>RAPIGetDiskSize</I>, simply typed the <I>pIRAPIStream</I> pointer as a PVOID and ignored it. In the client code, the <I>CeRapiInvoke</I> call passed a NULL to the <I>ppIRAPIStream</I> pointer. This treatment of the <I>IRAPIStream</I> interface is what differentiates a block-mode call from a stream-mode call. Now let's look at the <I>IRAPIStream</I> interface.

<A NAME="415"><H3>Stream mode</H3></A>

<P>Stream-mode RAPI calls are different from block mode in that the initial RAPI call creates a link between the PC application and the server routine on the Windows CE device. When you call <I>CeRapiInvoke</I> in stream mode, the call returns immediately. You communicate with the server DLL using an <I>IRAPIStream</I> interface. You access this interface using a pointer returned by the <I>CeRapiInvoke</I> call in the variable pointed to by <I>ppIRAPIStream</I>.

<P>The <I>IRAPIStream</I> interface is derived from the standard COM <I>IStream</I> interface. The only methods added to <I>IStream</I> to create <I>IRAPIStream</I> are <I>SetRapiStat</I> and <I>GetRapiStat</I>, which let you set a timeout value for the RAPI communication. Fortunately, we don't have to implement an <I>IRAPIStream</I> interface either on the client side or in the server DLL. This interface is provided for us by the RAPI services as a way to communicate.

<P>Following is a call to <I>CeRapiInvoke</I> that establishes a stream connection and then writes and reads back 10 bytes from the remote server DLL.

<p><pre>
DWORD dwIn, dwOut, cbBytes;
IRAPIStream *pIRAPIStream;
BYTE bBuff[BUFF_SIZE];
PBYTE pOut;
HRESULT hr;

// RAPI call
hr = CeRapiInvoke (L&quot;ServDLL&quot;, L&quot;RAPIRmtFunc&quot;, dwIn, bBuff,
                   &amp;dwOut, &amp;pOut, &amp;pIRAPIStream, 0);
if (hr == S_OK) {
    // Write 10 bytes.
    pIRAPIStream-&gt;Write (bBuff, 10, &amp;cbBytes);
    // Read data from server.
    pIRAPIStream-&gt;Read (bBuff, 10, &amp;cbBytes);
}
</PRE>

<P>When establishing a stream connection, you can still use the input buffer to pass initial data down to the remote server. From then on, you should use the <I>Read</I> and <I>Write </I>methods of <I>IRAPIStream</I> to communicate with the server.

<A NAME="416"><H2>The RapiFind Example Program</H2></A>

<P>The RapiFind example program searches the entire directory tree of a Windows CE device for files matching a search specification. The program is in two parts: a RAPI server DLL, FindSrv.DLL, and a console-based, Win32 application, RapiFind. The program works by passing a search string on the command line. RapiFind returns any files on the attached Windows CE device that match the search string. If the search specification includes a directory, only that directory and any of its subdirectories are searched for matching files. Figure 11-4 shows the output of RapiFind.

<P><A HREF="javascript:fullSize('f11rg04x.htm')"> <img src="F11rg04.JPG" width=404 height=349 border="0" ALIGN="BOTTOM" ALT="Click to view at full size."></a>

<P><!-- caption --><B>Figure 11-4.</B> <I>The output of RapiFind.</I><!-- /caption -->

<P>You'll notice that the following example is written in C++, and so are the rest of the examples in this chapter. Actually, almost all the code in both files is standard C, but the C++ extensions are used to reference the <I>IRAPIStream</I> interface. I could have written a C-equivalent structure to access the interface, but I could see little reason to avoid using C++ in this case. (As an aside, most COM interfaces defined in Win32 have C-interface equivalents for those of us who still like C.) First, let's look at the server DLL, FindSrv, shown in Figure 11-5.


<P><!-- caption --><B>Figure 11-5.</B> <I>FindSrv.cpp, a stream-mode RAPI server DLL.</I><!-- /caption -->


<p><TABLE cellpadding=5 width="95%"><TR><td>
<P><pre>
//====================================================================
// FindSrv - A RAPI stream server DLL
//


// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff

// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//-----------------------------------------------------------------------
// Not included in a server-side include file
typedef enum tagRAPISTREAMFLAG {
    STREAM_TIMEOUT_READ
} RAPISTREAMFLAG;

DECLARE_INTERFACE_ (IRAPIStream,  IStream)
{
    STDMETHOD(SetRapiStat)(THIS_ RAPISTREAMFLAG Flag,
                           DWORD dwValue) PURE;
    STDMETHOD(GetRapiStat)(THIS_ RAPISTREAMFLAG Flag,
                           DWORD *pdwValue) PURE;
};
//-----------------------------------------------------------------------
// Function prototypes declared as exports from the DLL.
// Bracket so that function name won't be mangled by C++.
extern &quot;C&quot; {
__declspec(dllexport) INT RAPIFindFile (DWORD cbInput, BYTE *pInput,
                              DWORD *pcbOutput, BYTE **ppOutput,
                              IRAPIStream *pIRAPIStream);
}

//====================================================================
// DllMain - DLL initialization entry point
//
BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD dwReason,
                     LPVOID lpvReserved) {
    return TRUE;
}
//-----------------------------------------------------------------------
// WriteToClient - Writes a command and optional string to the client
//
int WriteToClient (INT nCmd, INT nSize, LPTSTR pszStr,
                   IRAPIStream *pIRAPIStream) {
    INT nBuff;
    DWORD cbBytes;
    HRESULT hr;

    // Write command code.
    hr = pIRAPIStream-&gt;Write (&amp;nCmd, sizeof (nCmd), &amp;cbBytes);

    // Write size value.
    hr = pIRAPIStream-&gt;Write (&amp;nSize, sizeof (nSize), &amp;cbBytes);

    // Write length of string.
    nBuff = (lstrlen (pszStr) + 1) * sizeof (TCHAR);
    hr = pIRAPIStream-&gt;Write (&amp;nBuff, sizeof (nBuff), &amp;cbBytes);

    // Write string.
    hr = pIRAPIStream-&gt;Write (pszStr, nBuff, &amp;cbBytes);
    return 0;
}
int nFlag;
//-----------------------------------------------------------------------
// SrchDirectory - Recursive routine that searches a directory and all
// child dirs for matching files
//
int SrchDirectory (LPTSTR pszDir, IRAPIStream *pIRAPIStream) {
    WIN32_FIND_DATA fd;
    TCHAR szNew[MAX_PATH];
    INT i, rc, nErr = 0;
    HANDLE hFind;
    TCHAR *pPtr, *pSrcSpec;

    // Separate subdirectory from search specification.
    for (pSrcSpec = pszDir + lstrlen (pszDir); pSrcSpec &gt;= pszDir;
         pSrcSpec&#8212;)
        if (*pSrcSpec == TEXT (`\\'))
            break;

    // Copy the search specification up to the last directory sep char.
    if (pSrcSpec &lt;= pszDir)
        lstrcpy (szNew, TEXT (&quot;\\&quot;));
    else {
        for (i = 0; (i &lt; dim(szNew)-10) &amp;&amp;
                    ((pszDir+i) &lt;= pSrcSpec); i++)
            szNew[i] = *(pszDir+i);
        szNew[i] = TEXT (`\0');
    }
    pPtr = szNew + lstrlen (szNew);

    // Report directory we're searching.
    WriteToClient (2, 0, szNew, pIRAPIStream);

    // Find matching files.
    hFind = FindFirstFile (pszDir, &amp;fd);
    if (hFind != INVALID_HANDLE_VALUE) {

        do {
            // Report all matching files.
            if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))
                WriteToClient (1, fd.nFileSizeLow, fd.cFileName,
                               pIRAPIStream);
            rc = FindNextFile (hFind, &amp;fd);
        } while (rc);

        FindClose (hFind);
    } else {
        rc = GetLastError();
        if ((rc != ERROR_FILE_NOT_FOUND)  &amp;&amp;
            (rc != ERROR_NO_MORE_FILES)) {
            TCHAR szDbg[64];
            wsprintf (szDbg, TEXT (&quot;1Find Error:%d&quot;), rc);
            WriteToClient (99, 0, szDbg, pIRAPIStream);
            return -1;
        }
    }

    // Create generic search string for all directories.
    lstrcat (szNew, TEXT (&quot;*.*&quot;));

    hFind = FindFirstFile (szNew, &amp;fd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
                // Recurse to the lower directory.
                lstrcpy (pPtr, fd.cFileName);
                lstrcat (pPtr, pSrcSpec);
                nErr = SrchDirectory (szNew, pIRAPIStream);
                if (nErr) break;
                *pPtr = TEXT (`\0');
            }
            rc = FindNextFile (hFind, &amp;fd);
        } while (rc);

        FindClose (hFind);
    } else {
        rc = GetLastError();
        if ((rc != ERROR_FILE_NOT_FOUND) &amp;&amp;
            (rc != ERROR_NO_MORE_FILES)) {
            TCHAR szDbg[64];
            wsprintf (szDbg, TEXT (&quot;2Find Error:%d&quot;), rc);
            WriteToClient (99, 0, szDbg, pIRAPIStream);
            return -1;
        }
    }
    return nErr;
}

//======================================================================
// RAPIFindFile - Searches the device for matching files.  Called from
// PC application using RAPI.
//
INT RAPIFindFile (DWORD cbInput, BYTE *pInput, DWORD *pcbOutput,
                  BYTE **ppOutput, IRAPIStream *pIRAPIStream) {
    INT nBuff;
    DWORD i, cbBytes;
    TCHAR *pPtr;
    HRESULT hr;

    *pcbOutput = 0;
    // See if proper zero-terminated string.
    pPtr = (LPTSTR)pInput;
    for (i = 0; i &lt; cbInput / 2; i++)
        if (!*pPtr++)
            break;

    // If not zero terminated or if zero length, return error.
    if ((i &gt;= cbInput / 2) || (i == 0))
        return -2;
    nFlag = 0;
    // Search for files
    SrchDirectory ((LPTSTR) pInput, pIRAPIStream);

    // Write end code.  Cmd 0 -&gt; end of search
    nBuff = 0;
    hr = pIRAPIStream-&gt;Write (&amp;nBuff, sizeof (nBuff), &amp;cbBytes);
    return 0;
}
</PRE>
</td></tr></table>

<P>As with the earlier RAPI server DLL, FindSrv is short and to the point. The differences between this server and the block server can be seen early in the file. The <I>IRAPIStream</I> interface isn't defined in any of the include files used by Windows CE applications, so this interface is derived at the top of the file from <I>IStream</I>. Immediately following the interface declaration is the exported function prototype. Notice that the prototype is enclosed in an extern C bracket. This prevents the default mangling of the function name that the C++ precompiler would normally perform. We need the name of the function unmangled so that it's a known name to the client.

<P>The exported RAPI function is <I>RAPIFindFile</I>, which you can see at the end of the source code. This routine does little more than check to see that the search string is valid before it calls <I>SrchDirectory</I>, a function internal to the DLL. <I>SrchDirectory</I> is a recursive function that searches the directory defined in the search specification and all subdirectories underneath. When a file is found that matches the search specification, the name and size of the file is sent back to the client caller using the <I>Write</I> method of <I>IRAPIStream</I>. The format of the data transmitted between the client and server is up to the programmer. In this case, I send a command word, followed by the file size, the length of the name, and finally the filename itself. The command word gives you a minimal protocol for communication with the client. A command value of 1 indicates a found file, a value of 2 indicates the server is looking in a new directory, and a value of 0 indicates that the search is complete.

<P>The source code for the client application, RapiFind, is shown in Figure 11-6.

<P><!-- caption --><B>Figure 11-6.</B> <I>RapiFind.cpp, a stream-mode RAPI client application.</I><!-- /caption -->



<p><TABLE cellpadding=5 width="95%"><TR><td>
<P><pre>
//====================================================================
// RapiFind - Searches for a file or files on a Windows CE system


//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;stdio.h&gt;
#include &lt;rapi.h&gt;                    // RAS includes

//====================================================================
// main - Program entry point
//
int main (int argc, char **argv) {
    RAPIINIT ri;
    char szSrch[MAX_PATH], *pPtr;
    WCHAR szwDir[MAX_PATH];
    WCHAR szName[MAX_PATH];
    DWORD i, dwTotal = 0, dwFiles = 0, dwIn, dwOut, cbBytes;
    IRAPIStream *pIRAPIStream;
    PBYTE pInput, pOut;
    HRESULT hr;
    INT rc, nCmd, nSize;

    // If no argument, fail.
    if (argc &lt; 2) {
        printf (&quot;\r\nUSAGE: %s &lt;search spec&gt;\r\n\r\n&quot;, argv[0]);
        return -1;
    }
    lstrcpy (szSrch, argv[1]);

    // Call RapiInitEx to asynchronously start RAPI session.
    ri.cbSize = sizeof (ri);
    rc = CeRapiInitEx (&amp;ri);

    if (rc != NOERROR) {
        printf (TEXT (&quot;Rapi Initialization failed\r\n&quot;));
        return 0;
    }
    // Wait 5 seconds for connect.
    rc = WaitForSingleObject (ri.heRapiInit, 5000);
    if (rc == WAIT_OBJECT_0) {
        if (ri.hrRapiInit != NOERROR) {
            printf (TEXT (&quot;Rapi Initialization failed\r\n&quot;));
            return 0;
        }
    } else if (rc == WAIT_TIMEOUT) {
        printf (TEXT (&quot;Rapi Initialization timed out.\r\n&quot;));
        return 0;
    }
    // Point to end of name.
    pPtr = szSrch + lstrlen (szSrch) - 1;

    // Strip any trailing backslash.
    if (*pPtr == `\\')
        *pPtr = `\0';

    // Look for wildcards in filename. pPtr points to string end.
    for (i = 0; (pPtr &gt;= szSrch) &amp;&amp; (*pPtr != `\\'); pPtr&#8212;) {
        if ((*pPtr == `*') || (*pPtr == `?'))
            i++;
    }
    if (pPtr &lt;= szSrch) {
        lstrcpy (szSrch, TEXT (&quot;\\&quot;));
        lstrcat (szSrch, argv[1]);
    }

    if (i) {
        printf (TEXT (&quot;\r\n Searching for %s\r\n\r\n&quot;), pPtr+1);
    } else
        printf (TEXT (&quot;\r\n Searching in %s\r\n\r\n&quot;), szSrch);

    // No wildcards, append *.*
    if (i == 0)
        lstrcat (szSrch, &quot;\\*.*&quot;);

    // Convert ANSI string to Unicode.  At the same time, copy it
    // into a discardable buffer for CeRapiInvoke.
    dwIn = lstrlen (szSrch)+1;

    pInput = (PBYTE)LocalAlloc (LPTR, dwIn * sizeof (WCHAR));
    if (!pInput) {
        printf (TEXT (&quot;\r\nOut of memory\r\n&quot;));
        return -1;
    }
    mbstowcs ((LPWSTR)pInput, szSrch, dwIn);
    dwIn *= sizeof (WCHAR);

    // RAPI call
    hr = CeRapiInvoke (L&quot;\\FindSrv&quot;, L&quot;RAPIFindFile&quot;, dwIn,
                       pInput, &amp;dwOut, &amp;pOut, &amp;pIRAPIStream, 0);
    if (hr == S_OK) {
        // Read command.
        pIRAPIStream-&gt;Read (&amp;nCmd, sizeof (nCmd), &amp;cbBytes);
        while (nCmd) {
            switch (nCmd) {
            // Display found file.
            case 1:
                // Read length of file.
                pIRAPIStream-&gt;Read (&amp;i, sizeof (i), &amp;cbBytes);
                dwTotal += i;
                dwFiles++;

                // Read length of filename.
                pIRAPIStream-&gt;Read (&amp;nSize, sizeof (nSize), &amp;cbBytes);
                // Read name itself.
                pIRAPIStream-&gt;Read (szName, nSize, &amp;cbBytes);

                // Print directory and name.
                printf (TEXT (&quot;%9d\t%S%S\r\n&quot;), i, szwDir, szName);
                break;

            // Display name of directory we're currently searching.
            case 2:
                // Read and discard dummy length value.
                pIRAPIStream-&gt;Read (&amp;nSize, sizeof (nSize), &amp;cbBytes);
                // Read length of directory.
                pIRAPIStream-&gt;Read (&amp;nSize, sizeof (nSize), &amp;cbBytes);
                // Read directory name itself.
                pIRAPIStream-&gt;Read (szwDir, nSize, &amp;cbBytes);
                break;
            }
            // Read next command.
            pIRAPIStream-&gt;Read (&amp;nCmd, sizeof (nCmd), &amp;cbBytes);
        }
    } else if (hr == ERROR_FILE_NOT_FOUND)
        printf (TEXT (&quot;The RAPI server DLL FindSrv could not be found \
on the CE target device.\r\n&quot;));
    else
        printf (TEXT (&quot;CeRapiInvoke returned %d&quot;), hr);

    printf (TEXT (&quot;\r\nFound %d file(s). Total of %d bytes.\r\n\r\n&quot;),
            dwFiles, dwTotal);

    // Clean up by uninitializing RAPI.
    CeRapiUninit ();
    return 0;
}
</pre>
</td></tr></table>

<P>The call to <I>CeRapiInvoke</I> returns a pointer to an <I>IRAPIStream</I> interface that's then used to read data from the server. The client reads one integer value to determine whether the following data is a found file, a report of the current search directory, or a report that the search has ended. With each command, the appropriate data is read using the <I>Read</I> method. The result of the search is then reported using <I>printf</I> statements.

<P>While you could implement the same file find function of RapiFind using a block-mode connection, the stream format has a definite advantage in this case. By reporting back results as files are found, the program lets the user known that the program is executing correctly. If the program were designed to use a block-mode call, RapiFind would appear to go dead while the server DLL completed its entire search, which could take 10 or 20 seconds.

<P>As I mentioned in the explanation of <I>CeRapiInit</I>, a call to this function doesn't initiate a connection to a device. You can, however, be notified when a connection to a Windows CE device is established. There are ways, both on the PC and on the Windows CE device, to know when a connection is made between the two systems. After a brief look at CeUtil, which provides some handy helper functions for PC applications dealing with Windows CE devices, I'll talk about connection notifiers in the next section.

</BODY>
</HTML>




