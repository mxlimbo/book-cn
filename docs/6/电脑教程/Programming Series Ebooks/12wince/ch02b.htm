<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Painting Basics</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="36"><H1>Painting Basics</H1></A>

<P>Historically, Windows has been subdivided into three main components: the kernel, which handles the process and memory management; User, which handles the windowing interface and controls; and the Graphics Device Interface, or GDI, which performs the low-level drawing. In Windows CE, User and GDI are combined into the Graphics Windowing and Event handler, or GWE. At times, you might hear a Windows CE programmer talk about the GWE. The GWE is nothing really new&#8212;just a different packaging of standard Windows parts. In this book, I usually refer to the graphics portion of the GWE under its old name, GDI, to be consistent with standard Windows programming terminology.

<P>But whether you're programming for Windows CE or Windows 98 or Windows NT, there is more to drawing than simply handling the WM_PAINT message. It's helpful to understand just when and why a WM_PAINT message is sent to a window.

<A NAME="37"><H2>Valid and Invalid Regions</H2></A>

<P>When for some reason an area of a window is exposed to the user, that area, or <I>region</I>, as it's referred to in Windows, is marked invalid. When no other messages are waiting in an application's message queue and the application's window contains an invalid region, Windows sends a WM_PAINT message to the window. As mentioned in <A HREF="ch01a.htm">Chapter 1</a>, any drawing performed in response to a WM_PAINT message is couched in calls to <I>BeginPaint</I> and <I>EndPaint</I>. <I>BeginPaint</I> actually performs a number of actions. It marks the invalid region as valid, and it computes the <I>clipping</I> region. The clipping region is the area to which the painting action will be limited. <I>BeginPaint</I> then sends a WM_ERASEBACKGROUND message, if needed, to redraw the background, and it hides the caret&#8212;the text entry cursor&#8212;if it's displayed. Finally <I>BeginPaint</I> retrieves the handle to the display device context so that it can be used by the application. The <I>EndPaint</I> function releases the device context and redisplays the caret if necessary. If no other action is performed by a WM_PAINT procedure, you must at least call <I>BeginPaint</I> and <I>EndPaint</I> if only to mark the invalid region as valid.

<P>Alternatively, you can call to <I>ValidateRect</I> to blindly validate the region. But no drawing can take place in that case because an application must have a handle to the device context before it can draw anything in the window.

<P>Often an application needs to force a repaint of its window. An application should never post or send a WM_PAINT message to itself or to another window. Instead, you do the following:

<p><pre>
BOOL InvalidateRect (HWND hWnd, const RECT *lpRect, BOOL bErase);
</pre>

<P>Notice that <I>InvalidateRect</I> doesn't require a handle to the window's device context, only to the window handle itself. The <I>lpRect</I> parameter is the area of the window to be invalidated. This value can be NULL if the entire window is to be invalidated. The <I>bErase</I> parameter indicates whether the background of the window should be redrawn during the <I>BeginPaint</I> call as mentioned above. Note that unlike other versions of Windows, Windows CE requires that the <I>hWnd</I> parameter be a valid window handle.

<A NAME="38"><H2>Device Contexts</H2></A>

<P>A <I>device context,</I> often referred to simply as a DC, is a tool that Windows uses to manage access to the display and printer, although for the purposes of this chapter I'll be talking only about the display. Also, unless otherwise mentioned, the explanation that follows applies to Windows in general and isn't specific to Windows CE.

<P>Windows applications never write directly to the screen. Instead, they request a handle to a display device context for the appropriate window, and then using the handle, draw to the device context. Windows then arbitrates and manages getting the pixels from the DC to the screen.

<P><I>BeginPaint</I>, which should only be called in a WM_PAINT message, returns a handle to the display DC for the window. An application usually performs its drawing to the screen during the WM_PAINT messages. Windows treats painting as a low-priority task, which is appropriate since having painting at a higher priority would result in a flood of paint messages for every little change to the display. Allowing an application to complete all its pending business by processing all waiting messages results in all the invalid regions being painted efficiently at once. Users don't notice the minor delays caused by the low priority of the WM_PAINT messages.

<P>Of course, there are times when painting must be immediate. An example of such a time might be when a word processor needs to display a character immediately after its key is pressed. To draw outside a WM_PAINT message, the handle to the DC can be obtained using this:

<p><pre>
HDC GetDC (HWND hWnd);
</pre>

<P><I>GetDC</I> returns a handle to the DC for the client portion of the window. Drawing can then be performed anywhere within the client area of the window because this process isn't like processing inside a WM_PAINT message; there's no clipping to restrict you from drawing in an invalid region.

<P>Windows CE 2.1 supports another function that can be used to receive the DC. It is

<p><pre>
HDC GetDCEx (HWND hWnd, HRGN hrgnClip, DWORD flags);
</pre>

<P><I>GetDCEx</I> allows you to have more control over the device context returned. The new parameter, <I>hrgnClip</I> lets you define the clipping region, which limits drawing to that region of the DC. The <I>flags</I> parameter lets you specify how the DC acts as you draw on it. Windows CE doesn't support the following flags: DCX_PARENTCLIP, DCX_NORESETATTRS, DCX_LOCKWINDOWUPDATE, and DCX_VALIDATE.

<P>After the drawing has been completed, a call must be made to release the device context:

<p><pre>
int ReleaseDC (HWND hWnd, HDC hDC);
</pre>

<P>Device contexts are a shared resource, and therefore an application must not hold the DC for any longer than necessary.

<P>While <I>GetDC</I> is used to draw inside the client area, sometimes an application needs access to the nonclient areas of a window, such as the title bar. To retrieve a DC for the entire window, make the following call:

<p><pre>
HDC GetWindowDC (HWND hWnd);
</pre>

<P>As before, the matching call after drawing has been completed for <I>GetWindowDC</I> is <I>ReleaseDC.</I>

<P>The DC functions under Windows CE are identical to the device context functions under Windows 98 and Windows NT. This should be expected because DCs are the core of the Windows drawing philosophy. Changes to this area of the API would result in major incompatibilities between Windows CE applications and their desktop counterparts.

</BODY>
</HTML>




