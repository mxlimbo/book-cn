<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Stylus and the Touch Screen</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="81"><H1>The Stylus and the Touch Screen</H1></A>

<P>The stylus/touch screen combination is new to Windows platforms, but fortunately, its integration into Windows CE applications is relatively painless. The best way to deal with the stylus is to treat it as a single-button mouse. The stylus creates the same mouse messages that are provided by the mouse in other versions of Windows and by Windows CE systems that use a mouse. The differences that do appear between a mouse and a stylus are due to the different physical realities of the two input devices.

<P>Unlike a mouse, a stylus doesn't have a cursor to indicate the current position of the mouse. Therefore a stylus can't <I>hover</I> over a point on the screen in the way that the mouse cursor does. A cursor hovers when a user moves it over a window without pressing a mouse button. This concept can't be applied to programming for a stylus because the touch screen can't detect the position of the stylus when it isn't in contact with the screen.

<P>Another consequence of the difference between a stylus and a mouse is that without a mouse cursor, an application can't provide feedback to the user by means of changes in appearance of a hovering cursor. Windows CE does support setting the cursor for one classic Windows method of user feedback. The busy hourglass cursor, indicating that the user must wait for the system to complete processing, is supported under Windows CE so that applications can display the busy hourglass in the same manner as applications running under other versions of Windows, using the <I>SetCursor </I>function.

<A NAME="82"><H2>Stylus Messages</H2></A>

<P>When the user presses the stylus on the screen, the topmost window under that point receives the input focus if it didn't have it before and then receives a WM_LBUTTONDOWN message. When the user lifts the stylus, the window receives a WM_LBUTTONUP message. Moving the stylus within the same window while it's down causes WM_MOUSEMOVE messages to be sent to the window. For all of these messages, the <I>wParam</I> and <I>lParam</I> parameters are loaded with the same values. The <I>wParam</I> parameter contains a set of bit flags indicating whether the Ctrl or Shift keys on the keyboard are currently held down. As in other versions of Windows, the Alt key state isn't provided in these messages. To get the state of the Alt key when the message was sent, use the <I>GetKeyState</I> function.

<P>The <I>lParam</I> parameter contains two 16-bit values that indicate the position on the screen of the tap. The low-order 16 bits contains the <I>x</I> (horizontal) location relative to the upper left corner of the client area of the window while the high-order 16 bits contains the <I>y </I>(vertical) position.

<P>If the user <I>double-taps,</I> that is, taps twice on the screen at the same location and within a predefined time, Windows sends a WM_LBUTTONDBLCLK message to the double-tapped window, but only if that window's class was registered with the CS_DBLCLKS style. The class style is set when the window class is registered with <I>RegisterClass</I>.

<P>You can differentiate between a tap and a double-tap by comparing the messages sent to the window. When a double-tap occurs, a window first receives the WM_LBUTTONDOWN and WM_LBUTTONUP messages from the original tap. Then a WM_LBUTTONDBLCLK is sent followed by another WM_LBUTTONUP. The trick is to refrain from acting on a WM_LBUTTONDOWN message in any way that precludes action on a subsequent WM_LBUTTONDBLCLK. This is usually not a problem because taps usually select an object while double-tapping launches the default action for the object.

<A NAME="83"><H3>Inking</H3></A>

<P>A typical application for a handheld device is capturing the user's writing on the screen and storing the result as <I>ink</I>. This isn't handwriting recognition&#8212;simply ink storage. At first pass, the best way to accomplish this would be to store the stylus points passed in each WM_MOUSEMOVE message. The problem is that sometimes small CE-type devices can't send these messages fast enough to achieve a satisfactory resolution. Under Windows CE 2.0, a new function call has been added to assist programmers in tracking the stylus.

<P><pre>
BOOL GetMouseMovePoints (PPOINT pptBuf, UINT nBufPoints,
                         UINT *pnPointsRetrieved);
</pre>

<P><I>GetMouseMovePoints</I> returns a number of stylus points that didn't result in WM_MOUSEMOVE messages. The function is passed an array of points, the size of the array (in points), and a pointer to an integer that will receive the number of points passed back to the application. Once received, these additional points can be used to fill in the blanks between the last WM_MOUSEMOVE message and the current one.


<P><I>GetMouseMovePoints</I> does throw one curve at you. It returns points in the resolution of the touch panel, not the screen. This is generally set at four times the screen resolution, so you need to divide the coordinates returned by <I>GetMouseMovePoints </I>by four to convert them to screen coordinates. The extra resolution helps programs such as handwriting recognizers.

<P>A short example program, PenTrac, illustrates the difference that <I>GetMouseMovePoints</I> can make. Figure 3-6 shows the PenTrac window. Notice the two lines of dots across the window. The top line was drawn using points from WM_MOUSEMOVE only. The second line included points that were queried with <I>GetMouseMovePoints</I>. The black dots were queried from WM_MOUSEMOVE while the red (lighter) dots were locations queried with <I>GetMouseMovePoints</I>.

<P><A HREF="javascript:fullSize('f03rg06x.htm')"> <img src="f03rg06.jpg" width=404 height=203 border="0" ALT="Click to view at full size."></a>
<P><!-- caption --><B>Figure 3-6.</B> <I>The PenTrac window showing two lines drawn.</I><!-- /caption -->

<P>The source code for PenTrac is shown in Figure 3-7. The program places a dot on the screen for each WM_MOUSEMOVE or WM_LBUTTONDOWN message it receives. If the Shift key is held down during the mouse move messages, PenTrac also calls <I>GetMouseMovePoints</I> and marks those points in the window in red to distinguish them from the points returned by the mouse messages alone.

<P>PenTrac cheats a little to enhance the effect of <I>GetMouseMovePoints</I>. In the <I>DoMouseMain</I> routine called to handle WM_MOUSEMOVE and WM_LBUTTONDOWN messages, the routine calls the function <I>sleep</I> to kill a few milliseconds. This simulates a slow-responding application that might not have time to process every mouse move message in a timely manner.

<P><B>Figure 3-7.</B> <I>The PenTrac program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="84"><H3>PenTrac.h</H3></A>
<p><pre>
//======================================================================
// Header file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
// Returns number of elements.
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages 
                                                // with a function. 
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR 1                           // Command bar ID

//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoMouseMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="85"><H3>PenTrac.c</H3></A>
<p><pre>
//======================================================================
// PenTrac - Tracks stylus movement

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;pentrac.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;PenTrac&quot;);
HINSTANCE hInst;                     // Program instance handle

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_LBUTTONDOWN, DoMouseMain,
    WM_MOUSEMOVE, DoMouseMain,
    WM_DESTROY, DoDestroyMain,
};

//======================================================================
//
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndMain;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;
    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow) {
                   HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,           // Window class
                         TEXT (&quot;PenTrac&quot;),    // Window title
                         WS_VISIBLE,          // Style flags
                         CW_USEDEFAULT,       // x position
                         CW_USEDEFAULT,       // y position
                         CW_USEDEFAULT,       // Initial width
                         CW_USEDEFAULT,       // Initial height
                         NULL,                // Parent 
                         NULL,                // Menu, must be null
                         hInstance,           // App instance
                         NULL);               // Pointer to create
                                              // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//

//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    HWND hwndCB;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Add exit button to command bar. 
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMouseMain - Process WM_LBUTTONDOWN and WM_MOUSEMOVE messages
// for window.
//
LRESULT DoMouseMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                     LPARAM lParam) {
    POINT pt[64];
    POINT ptM;
    UINT i, uPoints = 0;
    HDC hdc;

    ptM.x = LOWORD (lParam);
    ptM.y = HIWORD (lParam);

    hdc = GetDC (hWnd);
    // If shift and mouse move, see if any lost points.
    if (wMsg == WM_MOUSEMOVE) {
        if (wParam &amp; MK_SHIFT) 
            GetMouseMovePoints (pt, 64, &amp;uPoints);

        for (i = 0; i &lt; uPoints; i++) {
            SetPixel (hdc, pt[i].x/4,   pt[i].y/4, RGB (255, 0, 0));
            SetPixel (hdc, pt[i].x/4+1, pt[i].y/4, RGB (255, 0, 0));
            SetPixel (hdc, pt[i].x/4,   pt[i].y/4+1, RGB (255, 0, 0));
            SetPixel (hdc, pt[i].x/4+1, pt[i].y/4+1, RGB (255, 0, 0));
        }
    }
    // The original point is drawn last in case one of the points 
    // returned by GetMouseMovePoints overlaps it.  
    SetPixel (hdc, ptM.x, ptM.y, RGB (0, 0, 0));
    SetPixel (hdc, ptM.x+1, ptM.y, RGB (0, 0, 0));
    SetPixel (hdc, ptM.x, ptM.y+1, RGB (0, 0, 0));
    SetPixel (hdc, ptM.x+1, ptM.y+1, RGB (0, 0, 0));
    ReleaseDC (hWnd, hdc);
    // Kill time to make believe we are busy.
    Sleep(25);
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
</pre>
</td></tr></table>

<A NAME="86"><H3>Input focus and mouse messages</H3></A>

<P>Here are some subtleties to note about circumstances that rule how and when mouse messages initiated by stylus input are sent to different windows. As I mentioned previously, the input focus of the system changes when the stylus is pressed against a window. However, dragging the stylus from one window to the next won't cause the new window to receive the input focus. The down tap sets the focus, not the process of dragging the stylus across a window. When the stylus is dragged outside the window, that window stops receiving WM_MOUSEMOVE messages but retains input focus. Because the tip of the stylus is still down, no other window will receive the WM_MOUSEMOVE messages. This is akin to using a mouse and dragging the mouse outside a window with a button held down.

<P>To continue to receive mouse messages even if the stylus moves off its window, an application can call

<p><pre>
HWND SetCapture (HWND hWnd);
</pre>

<P>passing the handle of the window to receive the mouse messages. The function returns the handle of the window that previously had captured the mouse or NULL if the mouse wasn't previously captured. To stop receiving the mouse messages initiated by stylus input, the window calls

<p><pre>
BOOL ReleaseCapture (void);
</pre>

<P>Only one window can capture the stylus input at any one time. To determine whether the stylus has been captured, an application can call

<p><pre>
HWND GetCapture (void);
</pre>

<P>which returns the handle of the window that has captured the stylus input or 0 if no window has captured the stylus input&#8212;although please note one caveat.<I> The window that has captured the stylus must be in the same thread context as the window calling the function.</I> This means that if the stylus has been captured by a window in another application, <I>GetCapture</I> still returns 0.

<P>If a window has captured the stylus input and another window calls <I>GetCapture</I>, the window that had originally captured the stylus receives a WM_CAPTURECHANGED message. The <I>lParam</I> parameter of the message contains the handle of the window that has gained the capture. You shouldn't attempt to take back the capture by calling <I>GetCapture</I> in response to this message. In general, since the stylus is a shared resource, applications should be wary of capturing the stylus for any length of time and they should be able to handle gracefully any loss of capture.

<P>Another interesting tidbit: Just because a window has captured the mouse, that doesn't prevent a tap on another window gaining the input focus for that window. You can use other methods for preventing the change of input focus, but in almost all cases, it's better to let the user, not the applications, decide what top-level window should have the input focus.

<A NAME="87"><H3>Right-button clicks</H3></A>

<P>When you click the right mouse button on an object in Windows systems, the action typically calls up a context menu, which is a stand-alone menu displaying a set of choices for what you can do with that particular object. On a system with a mouse, Windows sends WM_RBUTTONDOWN and WM_RBUTTONUP messages indicating a right-button click. When you use a stylus however, you don't have a right button. The Windows CE guidelines, however, allow you to simulate a right button click using a stylus. The guidelines specify that if a user holds down the Alt key while tapping the screen with the stylus, a program should act as if a right mouse button were being clicked and display any appropriate context menu. Because there's no MK_ALT flag in the <I>wParam </I>value of WM_LBUTTONDOWN, the best way to determine whether the Alt key is pressed is to use <I>GetKeyState</I> with VK_MENU as the parameter and test for the most significant bit of the return value to be set. <I>GetKeyState</I> is more appropriate in this case because the value returned will be the state of the key at the time the mouse message was pulled from the message queue.

<A NAME="88"><H2>The TicTac1 Example Program</H2></A>

<P>To demonstrate stylus programming, I have written a trivial tic-tac-toe game. The TicTac1 window is shown in Figure 3-8. The source code for the program is shown in Figure 3-9. This program doesn't allow you to play the game against the computer, nor does it determine the end of the game&#8212;it simply draws the board and keeps track of the Xs and Os. Nevertheless, it demonstrates basic stylus interaction.

<P><A HREF="javascript:fullSize('f03rg08x.htm')"> <img src="f03rg08.jpg" width=404 height=203 border="0" ALT="Click to view at full size."></a>
<P><!-- caption --><B>Figure 3-8.</B> <I>The TicTac1 window.</I><!-- /caption -->

<P><B>Figure 3-9.</B> <I>The TicTac1 program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="89"><H3>TicTac1.h</H3></A>
<p><pre>
//======================================================================

// Header file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages 
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR 1                           // Command bar ID
//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoSizeMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoLButtonDownMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoLButtonUpMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);

// Game function prototypes
void DrawXO (HDC hdc, HPEN hPen, RECT *prect, INT nCell, INT nType);
void DrawBoard (HDC hdc, RECT *prect);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="90"><H3>TicTac1.c</H3></A>
<p><pre>

//======================================================================
// TicTac1 - Simple tic-tac-toe game
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;tictac1.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;TicTac1&quot;);
HINSTANCE hInst;                     // Program instance handle

// State data for game
RECT rectBoard = {0, 0, 0, 0};       // Used to place game board.
RECT rectPrompt;                     // Used to place prompt.
BYTE bBoard[9];                      // Keeps track of Xs and Os.
BYTE bTurn = 0;                      // Keeps track of the turn.

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_SIZE, DoSizeMain,
    WM_PAINT, DoPaintMain,
    WM_LBUTTONUP, DoLButtonUpMain,
    WM_DESTROY, DoDestroyMain,
};

//======================================================================
//
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndMain;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow) {
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,           // Window class
                         TEXT (&quot;TicTac1&quot;),    // Window title
                         WS_VISIBLE,          // Style flags
                         CW_USEDEFAULT,       // x position
                         CW_USEDEFAULT,       // y position
                         CW_USEDEFAULT,       // Initial width
                         CW_USEDEFAULT,       // Initial height
                         NULL,                // Parent
                         NULL,                // Menu, must be null
                         hInstance,           // App instance
                         NULL);               // Pointer to create
                                              // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//

//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam) {
    HWND hwndCB;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Add exit button to command bar. 
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoSizeMain - Process WM_SIZE message for window.
//
LRESULT DoSizeMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                    LPARAM lParam) {
    RECT rect;
    INT i;
    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    // Init the board rectangle if not yet initialized.
    if (rectBoard.right == 0) {

        // Init the board.
        for (i = 0; i &lt; dim(bBoard); i++)
            bBoard[i] = 0;
    }
    // Define the playing board rect.
    rectBoard = rect;
    rectPrompt = rect;
    // Layout depends on portrait or landscape screen.
    if (rect.right - rect.left &gt; rect.bottom - rect.top) {
        rectBoard.left += 20;
        rectBoard.top += 10;
        rectBoard.bottom -= 10;
        rectBoard.right = rectBoard.bottom - rectBoard.top + 10; 

        rectPrompt.left = rectBoard.right + 10;

    } else {
        rectBoard.left += 20;
        rectBoard.right -= 20;
        rectBoard.top += 10;
        rectBoard.bottom = rectBoard.right - rectBoard.left + 10;

        rectPrompt.top = rectBoard.bottom + 10;
    }
    return 0;
}
//----------------------------------------------------------------------
// DoPaintMain - Process WM_PAINT message for window.
//
LRESULT DoPaintMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                    LPARAM lParam) {
    PAINTSTRUCT ps;
    RECT rect;
    HFONT hFont, hOldFont;
    HDC hdc;

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    hdc = BeginPaint (hWnd, &amp;ps); 

    // Draw the board.
    DrawBoard (hdc, &amp;rectBoard);

    // Write the prompt to the screen.
    hFont = GetStockObject (SYSTEM_FONT);
    hOldFont = SelectObject (hdc, hFont);
    if (bTurn == 0)
        DrawText (hdc, TEXT (&quot; X's turn&quot;), -1, &amp;rectPrompt,
                  DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    else
        DrawText (hdc, TEXT (&quot; O's turn&quot;), -1, &amp;rectPrompt, 
                  DT_CENTER | DT_VCENTER | DT_SINGLELINE);

    SelectObject (hdc, hOldFont);
    EndPaint (hWnd, &amp;ps);
    return 0;
}
//----------------------------------------------------------------------
// DoLButtonUpMain - Process WM_LBUTTONUP message for window.
//
LRESULT DoLButtonUpMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                         LPARAM lParam) {
    POINT pt;
    INT cx, cy, nCell = 0;

    pt.x = LOWORD (lParam);
    pt.y = HIWORD (lParam);

    // See if pen on board.  If so, determine which cell.
    if (PtInRect (&amp;rectBoard, pt)){
        // Normalize point to upper left corner of board.
        pt.x -= rectBoard.left;
        pt.y -= rectBoard.top;

        // Compute size of each cell.
        cx = (rectBoard.right - rectBoard.left)/3;
        cy = (rectBoard.bottom - rectBoard.top)/3;

        // Find column.
        nCell = (pt.x / cx); 
        // Find row.
        nCell += (pt.y / cy) * 3; 

        // If cell empty, fill it with mark.
        if (bBoard[nCell] == 0) {
            if (bTurn) {
                bBoard[nCell] = 2;
                bTurn = 0;
            } else {
                bBoard[nCell] = 1;
                bTurn = 1;
            }
            InvalidateRect (hWnd, NULL, FALSE);
        } else {
            // Inform the user of the filled cell.
            MessageBeep (0);
            return 0;
        }
    }
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
//======================================================================
// Game-specific routines
//
//----------------------------------------------------------------------
// DrawXO - Draw a single X or O in a square.
//
void DrawXO (HDC hdc, HPEN hPen, RECT *prect, INT nCell, INT nType) {
    POINT pt[2];
    INT cx, cy;
    RECT rect;

    cx = (prect-&gt;right - prect-&gt;left)/3;
    cy = (prect-&gt;bottom - prect-&gt;top)/3;

    // Compute the dimensions of the target cell.
    rect.left = (cx * (nCell % 3) + prect-&gt;left) + 10;
    rect.right = rect.right =  rect.left + cx - 20;
    rect.top = cy * (nCell / 3) + prect-&gt;top + 10;
    rect.bottom = rect.top + cy - 20;

    // Draw an X ?
    if (nType == 1) {
        pt[0].x = rect.left;
        pt[0].y = rect.top;
        pt[1].x = rect.right;
        pt[1].y = rect.bottom;
        Polyline (hdc, pt, 2);

        pt[0].x = rect.right;
        pt[1].x = rect.left;
        Polyline (hdc, pt, 2);
    // How about an O ?
    } else if (nType == 2) {
        Ellipse (hdc, rect.left, rect.top, rect.right, rect.bottom);
    }
    return;
}
//----------------------------------------------------------------------
// DrawBoard - Draw the tic-tac-toe board.
//  VK_MENU
void DrawBoard (HDC hdc, RECT *prect) {
    HPEN hPen, hOldPen;
    POINT pt[2];
    LOGPEN lp;
    INT i, cx, cy;

    // Create a nice thick pen.
    lp.lopnStyle = PS_SOLID;
    lp.lopnWidth.x = 5;
    lp.lopnWidth.y = 5;
    lp.lopnColor = RGB (0, 0, 0);
    hPen = CreatePenIndirect (&amp;lp);

    hOldPen = SelectObject (hdc, hPen);

    cx = (prect-&gt;right - prect-&gt;left)/3;
    cy = (prect-&gt;bottom - prect-&gt;top)/3;

    // Draw lines down.
    pt[0].x = cx + prect-&gt;left;
    pt[1].x = cx + prect-&gt;left;
    pt[0].y = prect-&gt;top;
    pt[1].y = prect-&gt;bottom;
    Polyline (hdc, pt, 2);
    pt[0].x += cx;
    pt[1].x += cx;
    Polyline (hdc, pt, 2);

    // Draw lines across.
    pt[0].x = prect-&gt;left;
    pt[1].x = prect-&gt;right;
    pt[0].y = cy + prect-&gt;top;
    pt[1].y = cy + prect-&gt;top;
    Polyline (hdc, pt, 2);

    pt[0].y += cy;
    pt[1].y += cy;
    Polyline (hdc, pt, 2);

    // Fill in Xs and Os.
    for (i = 0; i &lt; dim (bBoard); i++)
        DrawXO (hdc, hPen, &amp;rectBoard, i, bBoard[i]);

    SelectObject (hdc, hOldPen);
    DeleteObject (hPen);
    return;
}
</pre>
</td></tr></table>

<P>The action in TicTac1 is centered around three routines: <I>DrawBoard</I>, <I>DrawXO</I>, and <I>OnLButtonUpMain</I>. The first two perform the tasks of drawing the playing board. The routine that determines the location of a tap on the board (and therefore is more relevant to our current train of thought) is <I>OnLButtonUpMain</I>. As the name suggests, this routine is called in response to a WM_LBUTTONUP message. The first action to take is to call

<p><pre>
BOOL PtInRect (const RECT *lprc, POINT pt);
</pre>

<P>which determines whether the tap is even on the game board. The program knows the location of the tap because it's passed in the <I>lParam</I> value of the message. The board rectangle is computed when the program starts in <I>OnSizeMain</I>. Once the tap is localized to the board, the program determines the location of the relevant cell within the playing board by dividing the coordinates of the tap point within the board by the number of cells across and down.

<P>I mentioned that the board rectangle was computed during the <I>OnSizeMain</I> routine, which is called in response to a WM_SIZE message. While it might seem strange that Windows CE supports the WM_SIZE message common to other versions of Windows, it needs to support this message because a window is sized frequently: first right after it's created, and then each time it's minimized and restored. You might think that another possibility for determining the size of the window would be during the WM_CREATE message. The <I>lParam</I> parameter points to a CREATESTRUCT structure that contains, among other things, the initial size and position of the window. The problem with using those numbers is that the size obtained is the total size of the window, not the size of client area, which is what we need. Under Windows CE, most windows have no title bar and no border, but some have both and many have scroll bars, so using these values can cause trouble. So now, with the TicTac1 example, we have a simple program that uses the stylus effectively but isn't complete. To restart the game, we must exit and restart TicTac1. We can't take back a move nor have O start first. We need a method for sending these commands to the program. Sure, using keys would work. Another solution would be to create hot spots on the screen that when tapped, provided the input necessary. However, the standard method of exercising these types of commands in a program is through menus.

</BODY>
</HTML>




