<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The Common Controls</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="163"><H1>The Common Controls</H1></A>

<P>Windows CE's special niche&#8212;small personal productivity devices&#8212;has driven the requirements for the common controls in Windows CE. The frequent need for time and date references for schedule and task management applications has led to inclusion of the date and time picker control and the month calendar control. The small screens of personal productivity devices inspired the space-saving <I>command bar</I>. Mating the command bar with the <I>rebar control</I> that was created for Internet Explorer 3.0 has produced the <I>command bands control</I>. The command bands control provides even more room for menus, buttons, and other controls across the top of a Windows CE application. You've seen glimpses of the command bar control in <A HREF="ch01a.htm">Chapter 1</a> and again in Chapters <A HREF="ch03a.htm">3</a> and <A HREF="ch04a.htm">4</a>. It's time you were formally introduced.

<A NAME="164"><H2>The Command Bar</H2></A>

<P>Briefly, a <I>command bar</I> control combines a menu and a toolbar. This combination is valuable because, as I've pointed out before, the combination of a menu and toolbar on one line saves screen real estate on space-constrained Windows CE displays. To the programmer, the command bar looks like a toolbar with a number of helper functions that make programming the command bar a breeze. In addition to the command bar functions, you can also use most toolbar messages when you're working with command bars.

<P>The command bands control was added to Windows CE in version 2.0. A command bands control is a rebar control that, by default, contains a command bar in each band of the control. The rebar control is a fairly new common control; it's a container of controls that the user can drag around the application window. It was previously known as a <I>Cool Bar</I> when it first appeared in the common control DLL delivered with Internet Explorer 3.0. Given that command bands are nothing more than command bars in a rebar control, knowing how to program a command bar is most of the battle when learning how to program the command bands control.

<A NAME="165"><H3>Creating a command bar</H3></A>

<P>You build a command bar in a number of steps, each defined by a particular function. The command bar is created, the menu is added, buttons are added, other controls are added, tool tips are added, and finally, the Close and Help buttons are appended to the right side of the command bar.

<P>You begin the process of creating a command bar with a call to

<P><pre>
HWND CommandBar_Create (HINSTANCE hInst, HWND hwndParent,
                        int idCmdBar);
</pre>

<P>The function requires the program's instance handle, the handle of the parent window, and an ID value for the control. If successful, the function returns the handle to the newly created command bar control. But a bare command bar isn't much use to the application. It takes a menu and a few buttons jazz it up.

<A NAME="166"><H3>Command bar menus</H3></A>

<P>You can add a menu to a command bar by calling one of two functions. The first function is this:

<P><pre>
BOOL CommandBar_InsertMenubar (HWND hwndCB, HINSTANCE hInst,
                               WORD idMenu, int iButton);
</pre>

<P>The first two parameters of this function are the handle of the command bar and the instance handle of the application. The <I>idMenu</I> parameter is the resource ID of the menu to be loaded into the command bar. The last parameter is the index of the button to the immediate left of the menu. Because the Windows CE guidelines specify that the menu should be at the left end of the command bar, this parameter should be set to 0, which indicates that all the buttons are to the right of the menu.

<P>A shortcoming of the <I>CommandBar_InsertMenubar</I> function is that it requires the menu to be loaded from a resource. You can't configure the menu on the fly. Of course, it would be possible to load a dummy menu and manipulate the contents of the menu with the various menu functions, but here's an easier method.

<P>The function

<P><pre>
BOOL CommandBar_InsertMenubarEx (HWND hwndCB, HINSTANCE hInst,
                                 LPTSTR pszMenu, int iButton);
</pre>

<P>was added in Windows CE 2.0. The difference between <I>CommandBar_InsertMenubarEx</I> and <I>CommandBar_InsertMenubar</I> is the change in the third parameter, <I>pszMenu</I>. This parameter can be either the name of a menu resource or the handle to a menu previously created by the program. If the <I>pszMenu</I> parameter is a menu handle, the <I>hInst</I> parameter must be NULL.

<P>Once a menu has been loaded into a command bar, the handle to the menu can be retrieved at any time using

<P><pre>
HMENU CommandBar_GetMenu (HWND hwndCB, int iButton);
</pre>

<P>The second parameter, <I>iButton</I>, is the index of the button to the immediate left of the menu. This mechanism provides the ability to identify more than one menu on the command bar. However, given the Windows CE design guidelines, you should see only one menu on the bar. With the menu handle, you can manipulate the structure of the menu using the many menu functions available.

<P>If an application modifies the menu on the command bar, the application must call

<P><pre>
BOOL CommandBar_DrawMenuBar (HWND hwndCB, int iButton);
</pre>

<P>which forces the menu on the command bar to be redrawn. Here again, the parameters are the handle to the command bar and the index of the button to the left of the menu. Under Windows CE, you must use <I>CommandBar_DrawMenuBar</I> instead of <I>DrawMenuBar</I>, which is the standard function used to redraw the menu under other versions of Windows.

<A NAME="167"><H3>Command bar buttons</H3></A>

<P>Adding buttons to a command bar is a two-step process, and is similar to adding buttons to a toolbar. First the bitmap images for the buttons must be added to the command bar. Second the buttons are added, with each of the buttons referencing one of the images in the bitmap list that was previously added.

<P>The command bar maintains its own list of bitmaps for the buttons in an internal image list. Bitmaps can be added to this image list one at a time or as a group of images contained in a long and narrow bitmap. For example, for a bitmap to contain four 16-by-15-bit images, the dimensions of the bitmap added to the command bar would be 64 by 15 bits. Figure 5-2 shows this bitmap image layout.

<P><A HREF="javascript:fullSize('f05rg02x.htm')"> <img src="f05rg02.jpg" width=404 height=133 border="0" ALT="Click to view at full size."></a>
<!-- caption --><P><B>Figure 5-2.</B> <I>Layout of a bitmap that contains four 16-by-15-bit images.</I><!-- /caption -->

<P>Loading a image bitmap is accomplished using

<P><pre>
int CommandBar_AddBitmap (HWND hwndCB, HINSTANCE hInst, int idBitmap,
                          int iNumImages, int iReserved, int iReserved);
</pre>

<P>This first two parameters are, as is usual with a command bar function, the handle to the command bar and the instance handle of the executable. The third parameter, <I>idBitmap</I>, is the resource ID of the bitmap image. The fourth parameter, <I>iNumImages</I>, should contain the number of images in the bitmap being loaded. Multiple bitmap images can be loaded into the same command bar by calling <I>CommandBar_AddBitmap</I> as many times as is needed.

<P>Two predefined bitmaps provide a number of images that are commonly used in command bars and toolbars. You load these images by setting the <I>hInst</I> parameter in <I>CommandBar_AddBitmap</I> to HINST_COMMCTRL and setting the <I>idBitmap</I> parameter to either IDB_STD_SMALL_COLOR or IDB_VIEW_SMALL_COLOR. The images contained in these bitmaps are shown in Figure 5-3. The buttons on the top line contain the bitmaps from the standard bitmap while the second-line buttons contain the bitmaps from the standard view bitmap.

<P><img src="f05rg03.gif" width=384 height=78 border="0">
<!-- caption --><P><B>Figure 5-3.</B> <I>Images in the two standard bitmaps provided by the common control DLL.</I><!-- /caption -->

<P>The index values to these images are defined in commctrl.h, so you don't need to know the exact order in the bitmaps. The constants are

<P><pre>
Constants to access the standard bitmap
STD_CUT                     Edit/Cut button image
STD_COPY                    Edit/Copy button image
STD_PASTE                   Edit/Paste button image
STD_UNDO                    Edit/Undo button image
STD_REDOW                   Edit/Redo button image
STD_DELETE                  Edit/Delete button image
STD_FILENEW                 File/New button image
STD_FILEOPE                 File/Open button image
STD_FILESAVE                File/Save button image
STD_PRINTPRE                Print preview button image
STD_PROPERTIES              Properties button image
STD_HELP                    Help button (Use Commandbar_Addadornments
                            function to add a help button to the
                            command bar.)
STD_FIND                    Find button image
STD_REPLACE                 Replace button image
STD_PRINT                   Print button image

Constants to access the standard view bitmap
VIEW_LARGEICONS             View/Large Icons button image
VIEW_SMALLICONS             View/Small Icons button image
VIEW_LIST                   View/List button image
VIEW_DETAILS                View/Details button image
VIEW_SORTNAME               Sort by name button image
VIEW_SORTSIZE               Sort by size button image
VIEW_SORTDATE               Sort by date button image
VIEW_SORTTYPE               Sort by type button image
VIEW_PARENTFOLDER           Go to Parent folder button image
VIEW_NETCONNECT             Connect network drive button image
VIEW_NETDISCONNECT          Disconnect network drive button image
VIEW_NEWFOLDER              Create new folder button image
</pre>

<A NAME="168"><H3>Referencing images</H3></A>

<P>The images loaded into the command bar are referenced by their index into the list of images. For example, if the bitmap loaded contained five images, and the image to be referenced was the fourth image into the bitmap, the zero-based index value would be 3.

<P>If more than one set of bitmap images was added to the command bar using multiple calls to <I>CommandBar_AddBitmap</I>, the images' subsequent lists are referenced according to the previous count of images plus the index into that list. For example, if two calls were made to <I>CommandBar_AddBitmap</I> to add two sets of images, with the first call adding five images and the second adding four images, the third image of the second set would be referenced with the total number of images added in the first bitmap (5) plus the index into the second bitmap (2) resulting in an index value of 5 + 2 = 7.

<P>Once the bitmaps have been loaded, the buttons can be added using one of two functions. The first function is this one:

<P><pre>
BOOL CommandBar_AddButtons (HWND hwndCB, UINT uNumButtons,
                            LPTBBUTTON lpButtons);
</pre>

<P><I>CommandBar_AddButtons</I> adds a series of buttons to the command bar at one time. The function is passed a count of buttons and a pointer to an array of TBBUTTON structures. Each element of the array describes one button. The TBBUTTON structure is defined as the following:

<P><pre>
typedef struct {
    int iBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
    DWORD dwData;
    int iString;
} TBBUTTON;
</pre>

<P>The <I>iBitmap</I> field specifies the bitmap image to be used by the button. This is, as I just explained, the zero-based index into the list of images. The second parameter is the command ID of the button. This ID value is sent via a WM_COMMAND message to the parent when a user clicks the button.

<P>The <I>fsState</I> field specifies the initial state of the button. The allowable values in this field are the following:

<UL>
<p><LI><I>TBSTATE_ENABLED</I> The button is enabled. If this flag isn't specified, the button is disabled and is grayed.
<P><LI><I>TBSTATE_HIDDEN</I> The button isn't visible on the command bar.
<P><LI><I>TBSTATE_PRESSED</I> This button is displayed in a depressed state.
<P><LI><I>TBSTATE_CHECKED</I> The button is initially checked. This state can be used only if the button has the TBSTYLE_CHECKED style.
<p><LI><I>TBSTATE_INDETERMINATE</I> The button is grayed.
</UL>

<P>One last flag is specified in the documentation, TBSTATE_WRAP, but it doesn't have a valid use in a command bar. This flag is used by toolbars when a toolbar wraps across more than one line.

<P>The <I>fsStyle</I> field specifies the initial style of the button, which defines how the button acts. The button can be defined as a standard push button, a check button, a drop-down button, or a check button that resembles a radio button but allows only one button in a group to be checked. The possible flags for the <I>fsStyle</I> field are the following:

<UL>
<p><LI><I>TBSTYLE_BUTTON</I> The button looks like a standard push button.
<P><LI><I>TBSTYLE_CHECK</I> The button is a check button that toggles between checked and unchecked states each time the user clicks the button.
<P><LI><I>TBSTYLE_GROUP</I> Defines the start of a group of buttons.
<P><LI><I>TBSTYLE_CHECKGROUP</I> The button is a member of a group of check buttons that act like a radio buttons in that only one button in the group is checked at any one time.
<P><LI><I>TBSTYLE_DROPDOWN</I> The button is a drop-down list button.
<P><LI><I>TBSTYLE_AUTOSIZE</I> The button's size is defined by the button text.
<p><LI><I>TBSTYLE_SEP</I> Defines a separator (instead of a button) that inserts a small space between buttons.
</UL>

<P>The <I>dwData</I> field of the TBBUTTON structure is an application-defined value. This value can be set and queried by the application using the TB_SETBUTTONINFO and TB_ GETBUTTONINFO messages. The <I>iString</I> field defines the index into the command bar string array that contains the text for the button. The <I>iString</I> field can also be filled with a pointer to a string that contains the text for the button.

<P>The other function that adds buttons to a command bar is this one:

<P><pre>
BOOL CommandBar_InsertButton (HWND hwndCB, int iButton,
                              LPTBBUTTON lpButton);
</pre>

<P>This function inserts one button into the command bar to the left of the button referenced by the <I>iButton</I> parameter. The parameters in this function mimic the parameters in <I>CommandBar_AddButtons</I> with the exception that the <I>lpButton </I>parameter points to a single TBBUTTON structure. The <I>iButton</I> parameter specifies the position on the command bar of the new button.

<A NAME="169"><H3>Working with command bar buttons</H3></A>

<P>When a user presses a command bar button other than a drop-down button, the command bar sends a WM_COMMAND message to the parent window of the command bar. So, handling button clicks on the command bar is just like handling menu commands. In fact, since many of the buttons on the command bar have menu command equivalents, it's customary to use the same command IDs for the buttons and the like functioning menus, thus removing the need for any special processing for the command bar buttons.

<P>The command bar maintains the checked and unchecked state of check and checkgroup buttons. After the buttons have been added to the command bar, their states can be queried or set using two messages, TB_ISBUTTONCHECKED and TB_CHECKBUTTON. (The TB_ prefix in these messages indicates the close relationship between the command bar and the toolbar controls.) The TB_ISBUTTONCHECKED message is sent with the ID of the button to be queried passed in the <I>wParam</I> parameter this way:

<P><pre>
fChecked = SendMessage (hwndCB, TB_ISBUTTONCHECKED, wID, 0);
</pre>

<P>where <I>hwndCB</I> is the handle to the command bar containing the button. If the return value from the TB_ISBUTTONCHECKED message is nonzero, the button is checked. To place a button in the checked state, send a TB_CHECKBUTTON message to the command bar, as in

<P><pre>
SendMessage (hwndCB, TB_CHECKBUTTON, wID, TRUE);
</pre>

<P>To uncheck a checked button, replace the TRUE value in <I>lParam</I> with FALSE.

<A NAME="170"><H3>A new look for disabled buttons</H3></A>

<P>Windows CE allows you to easily modify the way a command bar or toolbar button looks when the button is disabled. Command bars and toolbars maintain two image lists: the standard image list that I described previously and a disabled image list used to store bitmaps that you can employ for disabled buttons.

<P>To use this new feature, you need to create and load a second image list for disabled buttons. The easiest way to do this is to create the image list for the normal states of the buttons using the techniques I described when I talked about <I>CommandBar_AddBitmap</I>. (Image lists in toolbars are loaded with the message TB_LOADIMAGES.) Once that image list complete, simply copy the original image list and modify the bitmaps of the images to create disabled counterparts to the original images. Then load the new image list back into the command bar or toolbar. A short code fragment that accomplishes this chore is shown below.

<P><pre>
HBITMAP hBmp, hMask;
HIMAGELIST hilDisabled, hilEnabled;

// Load the bitmap and mask to be used in the disabled image list.
hBmp = LoadBitmap (hInst, TEXT (&quot;DisCross&quot;));
hMask = LoadBitmap (hInst, TEXT (&quot;DisMask&quot;));

// Get the std image list and copy it.
hilEnabled = (HIMAGELIST)SendMessage (hwndCB, TB_GETIMAGELIST, 0, 0);
hilDisabled = ImageList_Duplicate (hilEnabled);

// Replace one bitmap in the disabled list.
ImageList_Replace (hilDisabled, VIEW_LIST, hBmp, hMask);

// Set the disabled image list.
SendMessage (hwndCB, TB_SETDISABLEDIMAGELIST, 0, (LPARAM) hilDisabled);
</pre>

<P>The code fragment first loads a bitmap and a mask bitmap that will replace one of the images in the disabled image list. You retrieve the current image list by sending a TB_GETIMAGELIST message to the command bar, and then you duplicate it using <I>ImageList_Duplicate</I>. One image in the image list is then replaced by the bitmap that was loaded earlier.

<P>This example replaces only one image, but in a real-world example many images might be replaced. If all the images were replaced, it might be easier to build the disabled image list from scratch instead of copying the standard image list and replacing a few bitmaps in it. Once the new image list is created, you load it into the command bar by sending a TB_SETDISABLEDIMAGELIST message. The code that I just showed you works just as well for toolbars under Windows CE as it does for command bars.

<A NAME="171"><H3>Drop-down buttons</H3></A>

<P>The drop-down list button is a more complex animal than the standard button on a command bar. The button looks to the user like a button that, when pressed, displays a list of items for the user to select from. To the programmer, a drop-down button is actually a combination of a button and a menu that is displayed when the user clicks on the button. Unfortunately, the command bar does little to support a drop-down button except to modify the button appearance to indicate that the button is a drop-down button and to send a special notification when the button is clicked by the user. It's up to the application to display the menu.

<P>The notification of the user clicking a drop-down button is sent to the parent window of the command bar by a WM_NOTIFY message with a notification value of TBN_DROPDOWN. When the parent window receives the TBN_DROPDOWN notification, it must create a pop-up menu immediately below the drop-down button identified in the notification. The menu is filled by the parent window with whatever selections are appropriate for the button. When one of the menu items is selected, the menu will send a WM_COMMAND message indicating the menu item picked and the menu will be dismissed. The easiest way to understand how to handle a drop-down button notification is to look at the following procedure that handles a TBN_DROPDOWN notification.

<P><pre>
LRESULT DoNotifyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    LPNMHDR pNotifyHeader;
    LPNMTOOLBAR pNotifyToolBar;
    RECT rect;
    TPMPARAMS tpm;
    HMENU hMenu;

    // Get pointer to notify message header.
    pNotifyHeader = (LPNMHDR)lParam;

    if (pNotifyHeader-&gt;code == TBN_DROPDOWN) {

        // Get pointer to toolbar notify structure.
        pNotifyToolBar = (LPNMTOOLBAR)lParam;

        // Get the rectangle of the drop-down button.
        SendMessage (pNotifyHeader-&gt;hwndFrom, TB_GETRECT,
                     pNotifyToolBar-&gt;iItem, (LPARAM)&amp;rect);

        // Convert rect into screen coordinates.  The rect is
        // considered here to be an array of 2 POINT  structures.
        MapWindowPoints (pNotifyHeader-&gt;hwndFrom, HWND_DESKTOP,
                         (LPPOINT)&amp;rect, 2);

        // Prevent the menu from covering the button.
        tpm.cbSize = sizeof (tpm);
        CopyRect (&amp;tpm.rcExclude, &amp;rect);

        // Load the menu resource to display under the button.
        hMenu = GetSubMenu (LoadMenu (hInst, TEXT (&quot;popmenu&quot;)),0);

        // Display the menu.  This function returns after the
        // user makes a selection or dismisses the menu.
        TrackPopupMenuEx (hMenu, TPM_LEFTALIGN | TPM_VERTICAL,
                          rect.left, rect.bottom, hWnd, &amp;tpm);
    }
    return 0;
}
</pre>

<P>After the code determines that the message is a TBN_DROPDOWN notification, the first task of the notification handler code is to get the rectangle of the drop-down button. The rectangle is queried so that the drop-down menu can be positioned immediately below the button. To do this, the routine sends a TB_GETRECT message to the command bar with the ID of the drop-down button passed in <I>wParam</I> and a pointer to a rectangle structure in <I>lParam</I>.

<P>Since the rectangle returned is in the coordinate base of the parent window, and pop-up menus are positioned in screen coordinates, the coordinates must be converted from one basis to the other. You accomplish this using the function

<P><pre>
MapWindowPoints (HWND hwndFrom, HWND hwndTo,
                 LPPOINT lppoints, UINT cPoints);
</pre>

<P>The first parameter is the handle of the window in which the coordinates are originally based. The second parameter is the handle of the window to which you want to map the coordinates. The third parameter is a pointer to an array of points to be translated; the last parameter is the number of points in the array. In the routine I just showed you, the window handles are the command bar handle and the desktop window handle, respectively.

<P>Once the rectangle has been translated into desktop coordinates, the pop-up, or context, menu can be created. You do this by first loading the menu from the resource, then displaying the menu with a call to <I>TrackPopupMenuEx</I>. That function is prototyped as

<P><pre>
BOOL TrackPopupMenuEx (HMENU hmenu, UINT fuFlags, int x, int y,
                       HWND hwnd, LPTPMPARAMS lptpm);
</pre>

<P>The <I>hMenu</I> parameter is the handle of the menu to be displayed. The <I>hwnd</I> parameter identifies the window to receive the WM_COMMAND message if a menu item is selected. The TPMPARAMS structure contains a rectangle that won't be covered up by the menu when it is displayed. For our purposes, this rectangle is set to the dimensions of the drop-down button so that the button won't be covered by the pop-up menu. The <I>fuFlags</I> field can contain a number of values that define the placement of the menu. For drop-down buttons, the only flag needed is TPM_VERTICAL. If TMP_VERTICAL is set, the menu leaves uncovered as much of the horizontal area of the exclude rectangle as possible. The <I>TrackPopupMenuEx</I> function doesn't return until an item on the menu has been selected or the menu has been dismissed by the user tapping on another part of the screen.

<A NAME="172"><H3>Combo boxes on the command bar</H3></A>

<P>Combo boxes on a command bar are much easier to implement than drop-down buttons. You add a combo box by calling

<P><pre>
HWND CommandBar_InsertComboBox (HWND hwndCB, HINSTANCE hInst,
                                int iWidth, UINT dwStyle,
                                WORD idComboBox,
                                int iButton);
</pre>

<P>This function inserts a combo box on the command bar to the left of the button indicated by the <I>iButton</I> parameter. The width of the combo box is specified, in pixels, by the <I>iWidth</I> parameter. The <I>dwStyle</I> parameter specifies the style of the combo box. The allowable style flags are any valid Windows CE combo box style and window styles. The function automatically adds the WS_CHILD and WS_VISIBLE flags when creating the combo box. The <I>idComboBox</I> parameter is the ID for the combo box that will be used when WM_COMMAND messages are sent notifying the parent window of a combo box event. Experienced Windows programmers will be happy to know that <I>CommandBar_InsertComboBox</I> takes care of all the &quot;parenting&quot; problems that occur when a control is added to a standard Windows toolbar. That one function call is all that is needed to create a properly functioning combo box on the command bar.

<P>Once a combo box is created, you program it on the command bar the same way you would a stand-alone combo box. Since the combo box is a child of the command bar, you must query the window handle of the combo box by passing the handle of the command bar to <I>GetDlgItem</I> with the ID value of the combo box, as in the following code:

<P><pre>
hwndCombobox = GetDlgItem (GetDlgItem (hWnd, IDC_CMDBAR),
                           IDC_COMBO));
</pre>

<P>However, the WM_COMMAND messages from the combo box are sent directly to the parent of the command bar, so handling combo box events is identical to handling them from a combo box created as a child of the application's top-level window.

<A NAME="173"><H3>Command bar tool tips</H3></A>

<P>Tool tips are small windows that display descriptive text that labels a command bar button when the stylus is held down over the control. Tool tips under Windows CE are implemented in a completely different way from how they're implemented under Windows 98 and Windows NT.

<P>You add tool tips to a command bar by using this function:

<P><pre>
BOOL CommandBar_AddToolTips (HWND hwndCB, UINT uNumToolTips,
                             LPTSTR lpToolTips);
</pre>

<P>The <I>lpToolTips</I> parameter must point to an array of pointers to strings. The <I>uNumToolTips</I> parameter should be set to the number of elements in the string pointer array. The <I>CommandBar_AddToolTips</I> function doesn't copy the strings into its own storage. Instead, the location of the string array is saved. This means that the block of memory containing the string array must not be released until the command bar is destroyed.

<P>Each string in the array becomes the tool tip text for a control or separator on the command bar excluding the menu. The first string in the array becomes the tool tip for the first control or separator, the second string is assigned to the second control or separator, and so on. So, even though combo boxes and separators don't display tool tips, they must have entries in the string array so that all the text lines up with the proper buttons.

<A NAME="174"><H3>Other command bar functions</H3></A>

<P>A number of other functions assist in command bar management. The <I>CommandBar_Height</I> function returns the height of the command bar and is used in all the example programs that use the command bar. Likewise, the <I>CommandBar_AddAdornments</I> function is also used whenever a command bar is used. This function, prototyped as

<P><pre>
BOOL CommandBar_AddAdornments (HWND hwndCB, DWORD dwFlags,
                               DWORD dwReserved);
</pre>

<P>places a Close button and, if you want, a Help button and an OK button on the extreme right of the command bar. You pass a CMDBAR_HELP flag to the <I>dwFlags</I> parameter to add a Help button, and you pass a CMDBAR_OK flag to add an OK button.

<P>The Help button is treated differently from other buttons on the command bar. When the Help button is pressed, the command bar sends a WM_HELP message to the owner of the command bar instead of the standard WM_COMMAND message. The OK button's action is more traditional. When it is pressed, a WM_COMMAND message is sent with a control ID of IDOK. <I>CommandBar_AddAdornments</I> must be called after all other conrols of the command bar have been added.

<P>A command bar can be hidden by calling

<P><pre>
BOOL CommandBar_Show (HWND hwndCB, BOOL fShow);
</pre>

<P>The <I>fShow</I> parameter is set to TRUE to show the command bar and FALSE to hide a command bar. The visibility of a command bar can be queried with this:

<P><pre>
BOOL CommandBar_IsVisible (HWND hwndCB);
</pre>

<P>Finally, a command bar can be destroyed using this:

<P><pre>
void CommandBar_Destroy (HWND hwndCB);
</pre>

<P>Although a command bar is automatically destroyed when its parent window is destroyed, sometimes it's more convenient to destroy a command bar manually. This is often done if a new command bar is needed for a different mode of the application. Of course, you can create multiple command bars, hiding all but one and switching between them by showing only one at a time, but this isn't good programming practice under Windows CE because all those hidden command bars take up valuable RAM that could be used elsewhere. The proper method is to destroy and create command bars on the fly. You can create a command bar fast enough so that a user shouldn't notice any delay in the application when a new command bar is created.

<A NAME="175"><H3>Design guidelines for command bars</H3></A>

<P>Because command bars are a major element of Windows CE applications, it's not surprising that Microsoft has a rather strong set of rules for their use. Many of these rules are similar to the design guidelines for other versions of Windows, such as the recommendations for the ordering of main menu items and the use of tool tips. Most of these guidelines are already second nature for Windows programmers.

<P>The menu should be the left-most item on the command bar. The order of the main menu items should be from left to right: File, Edit, View, Insert, Format, Tools, and Window. Of course, most applications have all of those menu items but the order of the items used should follow the suggested order. For buttons, the order is from left to right; New, Open, Save, and Print for file actions; and Bold, Italic, and Underline for font style.

<A NAME="176"><H2>The CmdBar Example Program</H2></A>

<P>The CmdBar example demonstrates the basics of command bar operation. On startup, the example creates a bar with only a menu and a close button. Selecting the different items from the view menu creates various command bars showing the capabilities of the command bar control. The source code for CmdBar is shown in Figure 5-4.

<P><B>Figure 5-4.</B> <I>The CmdBar program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="177"><H3>CmdBar.rc</H3></A>

<P><pre>
//======================================================================
// Resource file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &quot;windows.h&quot;
#include &quot;CmdBar.h&quot;                    // Program-specific stuff

//----------------------------------------------------------------------
// Icons and bitmaps
//
ID_ICO  ICON   &quot;cmdbar.ico&quot;      // Program icon
DisCross      BITMAP &quot;cross.bmp&quot;       // Disabled button image
DisMask       BITMAP &quot;mask.bmp&quot;        // Disabled button image mask
SortDropBtn   BITMAP &quot;sortdrop.bmp&quot;    // Sort drop-down button image

//----------------------------------------------------------------------
// Menu
//
ID_MENU MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_EXIT
    END

    POPUP &quot;&amp;View&quot;
    BEGIN
        MENUITEM &quot;&amp;Standard&quot;,                   IDM_STDBAR
        MENUITEM &quot;&amp;View&quot;,                       IDM_VIEWBAR
        MENUITEM &quot;&amp;Combination&quot;,                IDM_COMBOBAR
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About...&quot;,                   IDM_ABOUT
    END
END

popmenu MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;Sort&quot;
    BEGIN
        MENUITEM &quot;&amp;Name&quot;,                       IDC_SNAME
        MENUITEM &quot;&amp;Type&quot;,                       IDC_STYPE
        MENUITEM &quot;&amp;Size&quot;,                       IDC_SSIZE
        MENUITEM &quot;&amp;Date&quot;,                       IDC_SDATE
    END
END

//----------------------------------------------------------------------
// About box dialog template
//
aboutbox DIALOG discardable 10, 10, 160, 40
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU |
       DS_CENTER | DS_MODALFRAME
CAPTION &quot;About&quot;
BEGIN
    ICON  ID_ICON,                    -1,   5,   5,  10,  10
    LTEXT &quot;CmdBar - Written for the book Programming Windows \
           CE Copyright 1998 Douglas Boling&quot;
                                      -1,  40,   5, 110,  30
END
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="178"><H3>CmdBar.h</H3></A>

<P><pre>
//======================================================================

// Header file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
};
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR          1                  // Command band ID
#define  ID_ICO              10                 // Icon resource ID
#define  ID_MENU             11                 // Main menu resource ID
#define  IDC_COMBO           12                 // Combo box on cmd bar ID

// Menu item IDs
#define  IDM_EXIT            101                // File menu
#define  IDM_STDBAR          111                // View menu
#define  IDM_VIEWBAR         112
#define  IDM_COMBOBAR        113
#define  IDM_ABOUT           120                // Help menu

// Command bar button IDs
#define  IDC_NEW             201
#define  IDC_OPE             202
#define  IDC_SAVE            203
#define  IDC_CUT             204
#define  IDC_COPY            205
#define  IDC_PASTE           206
#define  IDC_PROP            207

#define  IDC_LICO            301
#define  IDC_SICO            302
#define  IDC_LIST            303
#define  IDC_RPT             304
#define  IDC_SNAME           305
#define  IDC_STYPE           306
#define  IDC_SSIZE           307
#define  IDC_SDATE           308
#define  IDC_DPSORT          350

#define  STD_BMPS            (STD_PRINT+1)      // Number of bmps in
                                                // std imglist
#define  VIEW_BMPS           (VIEW_NEWFOLDER+1) // Number of bmps in
                                                // view imglist

//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoNotifyMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);

// Command functions
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandVStd (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandVView (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandVCombo (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAbout (HWND, WORD, HWND, WORD);

// Dialog procedures
BOOL CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="179"><H3>CmdBar.c</H3></A>

<P><pre>

//======================================================================
// CmdBar - Command bar demonstration
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;CmdBar.h&quot;                  // Program-specific stuff
//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;CmdBar&quot;);
HINSTANCE hInst;                     // Program instance handle

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_COMMAND, DoCommandMain,
    WM_NOTIFY, DoNotifyMain,
    WM_DESTROY, DoDestroyMain,
};

// Command Message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDM_EXIT, DoMainCommandExit,
    IDM_STDBAR, DoMainCommandVStd,
    IDM_VIEWBAR, DoMainCommandVView,
    IDM_COMBOBAR, DoMainCommandVCombo,
    IDM_ABOUT, DoMainCommandAbout,
};

// Standard file bar button structure
const TBBUTTON tbCBStdBtns[] = {
//  BitmapIndex       Command    State       Style       UserData String
    {0,               0,         0,          TBSTYLE_SEP,       0,   0},
    {STD_FILENEW,     IDC_NEW,   TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,    0,   0},
    {STD_FILEOPEN,    IDC_OPEN,  TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,    0,   0},
    {STD_FILESAVE,    IDC_SAVE,  TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,    0,   0},
    {0,                 0,       0,          TBSTYLE_SEP,       0,   0},
    {STD_CUT,         IDC_CUT,   TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,    0,   0},
    {STD_COPY,        IDC_COPY,  TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,    0,   0},
    {STD_PASTE,       IDC_PASTE, TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,    0,   0},
    {0,                 0,       0,          TBSTYLE_SEP,       0,   0},
    {STD_PROPERTIES,  IDC_PROP,  TBSTATE_ENABLED,
        TBSTYLE_BUTTON,    0,   0}
};
// Standard view bar button structure
const TBBUTTON tbCBViewBtns[] = {
//  BitmapIndex       Command    State       Style        UserData String
    {0,               0,         0,          TBSTYLE_SEP,        0,  0},
    {VIEW_LARGEICONS, IDC_LICON, TBSTATE_ENABLED | TBSTATE_CHECKED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_SMALLICONS, IDC_SICON, TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_LIST,       IDC_LIST,  0,          TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_DETAILS,    IDC_RPT,   TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {0,               0,         TBSTATE_ENABLED,
                                             TBSTYLE_SEP,        0,  0},
    {VIEW_SORTNAME,   IDC_SNAME, TBSTATE_ENABLED | TBSTATE_CHECKED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_SORTTYPE,   IDC_STYPE, TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_SORTSIZE,   IDC_SSIZE, TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_SORTDATE,   IDC_SDATE, TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {0,               0,         0,          TBSTYLE_SEP,        0,  0},
};
// Tooltip string list for view bar
const TCHAR *pViewTips[] = {TEXT (&quot;&quot;),
                            TEXT (&quot;Large&quot;),
                            TEXT (&quot;Small&quot;),
                            TEXT (&quot;List&quot;),
                            TEXT (&quot;Details&quot;),
                            TEXT (&quot;&quot;),
                            TEXT (&quot;Sort by Name&quot;),
                            TEXT (&quot;Sort by Type&quot;),
                            TEXT (&quot;Sort by Size&quot;),
                            TEXT (&quot;Sort by Date&quot;),
};

// Combination standard and view bar button structure
const TBBUTTON tbCBCmboBtns[] = {
//  BitmapIndex       Command    State       Style        UserData String
    {0,               0,         0,          TBSTYLE_SEP,        0,  0},
    {STD_FILENEW,     IDC_NEW,   TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,     0,  0},
    {STD_FILEOPEN,    IDC_OPEN,  TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,     0,  0},
    {STD_PROPERTIES,  IDC_PROP,  TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,     0,  0},
    {0,               0,         0,          TBSTYLE_SEP,        0,  0},
    {STD_CUT,         IDC_CUT,   TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,     0,  0},
    {STD_COPY,        IDC_COPY,  TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,     0,  0},
    {STD_PASTE,       IDC_PASTE, TBSTATE_ENABLED,
                                             TBSTYLE_BUTTON,     0,  0},
    {0,               0,         0,          TBSTYLE_SEP,        0,  0},
    {STD_BMPS + VIEW_LARGEICONS,
                      IDC_LICON, TBSTATE_ENABLED | TBSTATE_CHECKED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {STD_BMPS + VIEW_SMALLICONS,
                      IDC_SICON, TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {STD_BMPS + VIEW_LIST,
                      IDC_LIST,  TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {STD_BMPS + VIEW_DETAILS,
                      IDC_RPT,   TBSTATE_ENABLED,
                                             TBSTYLE_CHECKGROUP, 0,  0},
    {0,               0,         0,          TBSTYLE_SEP,        0,  0},
    {STD_BMPS + VIEW_BMPS,
                      IDC_DPSORT,TBSTATE_ENABLED,
                                             TBSTYLE_DROPDOWN,   0,  0}
};

//======================================================================
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    HWND hwndMain;
    MSG msg;
    int rc = 0;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;
    INITCOMMONCONTROLSEX icex;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    // Load the command bar common control class.
    icex.dwSize = sizeof (INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_BAR_CLASSES;
    InitCommonControlsEx (&amp;icex);
    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow){
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,            // Window class
                         TEXT (&quot;CmdBar Demo&quot;), // Window title
                         WS_VISIBLE,           // Style flags
                         CW_USEDEFAULT,        // x position
                         CW_USEDEFAULT,        // y position
                         CW_USEDEFAULT,        // Initial width
                         CW_USEDEFAULT,        // Initial height
                         NULL,                 // Parent
                         NULL,                 // Menu, must be null
                         hInstance,            // Application instance
                         NULL);                // Pointer to create
                                               // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {
    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    HWND hwndCB;

    // Create a minimal command bar that only has a menu and an
    // exit button.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Insert the menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);

    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window.
//
LRESULT DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT  i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD (wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code)
            return (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl,
                                              wNotifyCode);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoNotifyMain - Process WM_NOTIFY message for window.
//
LRESULT DoNotifyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    LPNMHDR pNotifyHeader;
    LPNMTOOLBAR pNotifyToolBar;
    RECT rect;
    TPMPARAMS tpm;
    HMENU hMenu;

    // Get pointer to notify message header.
    pNotifyHeader = (LPNMHDR)lParam;

    if (pNotifyHeader-&gt;code == TBN_DROPDOWN) {

        // Get pointer to toolbar notify structure.
        pNotifyToolBar = (LPNMTOOLBAR)lParam;

        if (pNotifyToolBar-&gt;iItem == IDC_DPSORT) {

            // Get the rectangle of the drop-down button.
            SendMessage (pNotifyHeader-&gt;hwndFrom, TB_GETRECT,
                         pNotifyToolBar-&gt;iItem, (LPARAM)&amp;rect);

            // Convert rect into screen coordinates.  The rect is
            // considered here to be an array of 2 POINT structures.
            MapWindowPoints (pNotifyHeader-&gt;hwndFrom, HWND_DESKTOP,
                             (LPPOINT)&amp;rect, 2);

            // Prevent the menu from covering the button.
            tpm.cbSize = sizeof (tpm);
            CopyRect (&amp;tpm.rcExclude, &amp;rect);

            hMenu = GetSubMenu (LoadMenu (hInst, TEXT (&quot;popmenu&quot;)),0);
            TrackPopupMenuEx (hMenu, TPM_LEFTALIGN | TPM_VERTICAL,
                              rect.left, rect.bottom, hWnd, &amp;tpm);
        }
    }
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
//======================================================================
// Command handler routines
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
<P>LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    SendMessage (hWnd, WM_CLOSE, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandViewStd - Displays a standard edit-centric cmd bar
//
LPARAM DoMainCommandVStd (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {
    HWND hwndCB;

    // If a command bar exists, kill it.
    if (hwndCB = GetDlgItem (hWnd, IDC_CMDBAR))
        CommandBar_Destroy (hwndCB);

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Insert a menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);

    // Insert buttons.
    CommandBar_AddBitmap (hwndCB, HINST_COMMCTRL, IDB_STD_SMALL_COLOR,
                          STD_BMPS, 0, 0);

    CommandBar_AddButtons (hwndCB, dim(tbCBStdBtns), tbCBStdBtns);

    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandVView - Displays a standard edit-centric cmd bar
//
LPARAM DoMainCommandVView (HWND hWnd, WORD idItem, HWND hwndCtl,
                           WORD wNotifyCode) {
    INT i;
    HWND hwndCB;
    TCHAR szTmp[64];
    HBITMAP hBmp, hMask;
    HIMAGELIST hilDisabled, hilEnabled;

    // If a command bar exists, kill it.
    if (hwndCB = GetDlgItem (hWnd, IDC_CMDBAR))
        CommandBar_Destroy (hwndCB);

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Insert a menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);

    // Insert buttons, first add a bitmap and then the buttons.
    CommandBar_AddBitmap (hwndCB, HINST_COMMCTRL, IDB_VIEW_SMALL_COLOR,
                          VIEW_BMPS, 0, 0);

    // Load bitmaps for disabled image.
    hBmp = LoadBitmap (hInst, TEXT (&quot;DisCross&quot;));
    hMask = LoadBitmap (hInst, TEXT (&quot;DisMask&quot;));

    // Get the current image list and copy.
    hilEnabled = (HIMAGELIST)SendMessage (hwndCB, TB_GETIMAGELIST, 0, 0);
    hilDisabled = ImageList_Duplicate (hilEnabled);

    // Replace a button image with the disabled image.
    ImageList_Replace (hilDisabled, VIEW_LIST, hBmp, hMask);

    // Set disabled image list.
    SendMessage (hwndCB,  TB_SETDISABLEDIMAGELIST, 0,
                 (LPARAM)hilDisabled);

    // Add buttons to the command bar.
    CommandBar_AddButtons (hwndCB, dim(tbCBViewBtns), tbCBViewBtns);

    // Add tooltips to the command bar.
    CommandBar_AddToolTips (hwndCB, dim(pViewTips), pViewTips);

    // Add a combo box between the view icons and the sort icons.
    CommandBar_InsertComboBox (hwndCB, hInst, 75,
                               CBS_DROPDOWNLIST | WS_VSCROLL,
                               IDC_COMBO, 6);
    // Fill in combo box.
    for (i = 0; i &lt; 10; i++) {
        wsprintf (szTmp, TEXT (&quot;Item %d&quot;), i);
        SendDlgItemMessage (hwndCB, IDC_COMBO, CB_INSERTSTRING, -1,
                            (LPARAM)szTmp);
    }
    SendDlgItemMessage (hwndCB, IDC_COMBO, CB_SETCURSEL, 0, 0);

    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandVCombo - Displays a combination of file and edit buttons
//
LPARAM DoMainCommandVCombo (HWND hWnd, WORD idItem, HWND hwndCtl,
                            WORD wNotifyCode) {
    HWND hwndCB;

    // If a command bar exists, kill it.
    if (hwndCB = GetDlgItem (hWnd, IDC_CMDBAR))
        CommandBar_Destroy (hwndCB);

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Insert a menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);

    // Add two bitmap lists plus custom bmp for drop-down button.
    CommandBar_AddBitmap (hwndCB, HINST_COMMCTRL, IDB_STD_SMALL_COLOR,
                          STD_BMPS, 0, 0);
    CommandBar_AddBitmap (hwndCB, HINST_COMMCTRL, IDB_VIEW_SMALL_COLOR,
                          VIEW_BMPS, 0, 0);
    CommandBar_AddBitmap (hwndCB, NULL,
                          (int)LoadBitmap (hInst, TEXT (&quot;SortDropBtn&quot;)),
                          1, 0, 0);

    CommandBar_AddButtons (hwndCB, dim(tbCBCmboBtns), tbCBCmboBtns);

    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAbout - Process the Help | About menu command.
//
LPARAM DoMainCommandAbout(HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    // Use DialogBox to create modal dialog box.
    DialogBox (hInst, TEXT (&quot;aboutbox&quot;), hWnd, AboutDlgProc);
    return 0;
}
//======================================================================
// About Dialog procedure
//
BOOL CALLBACK AboutDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {

    switch (wMsg) {
        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hWnd, 0);
                    return TRUE;
            }
        break;
    }
    return FALSE;
}
</pre>
</td></tr></table>

<P>Each of the three command bars created in CmdBar demonstrate different capabilities of the command bar control. The first command bar, created in the routine <I>DoMainCommandVStd</I> creates a vanilla command bar with a menu and a set of buttons. The button structure for this command bar is defined in the array <I>tbCBStdBtns,</I> which is defined near the top of CmdBar.C.

<P>The second command bar, created in the routine <I>DoMainCommandVView</I>, contains two groups of checkgroup buttons separated by a combo box. This command bar also demonstrates the use of a separate image for a disabled button. The list view button, the third button on the bar, is disabled. The image for that button in the image list for disabled buttons is replaced with a bitmap that looks like an X.

<P>The <I>DoMainCommandVCombo</I> routine creates the third command bar. It uses both the standard and view bitmap images as well as a custom bitmap for a drop-down button. This command bar demonstrates the technique of referencing the images in an image list that contains multiple bitmaps. The drop-down button is serviced by the <I>OnNotifiyMain</I> routine where a pop-up menu is loaded and displayed when a TBN_DROPDOWN notification is received.

<A NAME="180"><H2>Command Bands</H2></A>

<P>Command bands appeared in Windows CE 2.0 and are a valuable feature, especially in their capacity to contain separate bands that can be dragged around by a user. Each individual band can have a &quot;gripper&quot; that can be used to drag the band to a new position. A band can be in a minimized state, showing only its gripper and, if you want, an icon; in a maximized state, covering up the other bands on the line; or restored, sharing space with the other bands on the same line. You can even move bands to a new row, creating a multiple-row command band.

<P>The standard use of a command bands control is to break up the elements of a command bar&#8212;menu, buttons, and other controls&#8212;into separate bands. This allows users to rearrange these elements as they see fit. Users can also expose or overlap separate bands as needed in order to provide a larger total area for menus, buttons, and other controls.

<A NAME="181"><H3>Creating a command bands control</H3></A>

<P>Creating a command bands control is straightforward, if a bit more involved than creating a command bar control. You create the control by calling

<P><pre>
HWND CommandBands_Create (HINSTANCE hinst, HWND hwndParent, UINT wID,
                          DWORD dwStyles, HIMAGELIST himl);
</pre>

<P>The <I>dwStyles</I> parameter accepts a number of flags that define the look and operation of the command bands control. These styles match the rebar styles; the command bands control is, after all, closely related to the rebar control.

<UL>
<P><LI><I>RBS_AUTOSIZE</I> Bands are automatically reformatted if the size or position of the control is changed.
<P><LI><I>RBS_BANDBORDERS</I> Each band is drawn with lines to separate adjacent bands.
<P><LI><I>RBS_FIXEDORDER</I> Bands can be moved but always remain in the same order.
<P><LI><I>RBS_SMARTLABELS</I> When minimized, a band is displayed with its icon. When restored or maximized, the band's label text is displayed.
<P><LI><I>RBS_VARHEIGHT</I> Each row in the control is vertically sized to the minimum required by the bands on that row. Without this flag, the height of every row is defined by the height of the tallest band in the control.
<P><LI><I>CCS_VERT</I> Creates a vertical command bands control.
<P><LI><I>RBS_VERTICALGRIPPER</I> Displays a gripper appropriate for a vertical command bar. This flag is ignored unless CCS_VERT is set.
</UL>

<P>Of these styles, the RBS_SMARTLABLES and RBS_VARHEIGHT are the two most frequently used flags. The RBS_SMARTLABLES flag lets you choose an attractive appearance for the command bands control without requiring any effort from the application. The RBS_VARHEIGHT flag is important if you use controls in a band other than the default command bar. The CCS_VERT style creates a vertical command bands control, but because Windows CE doesn't support vertical menus, any band with a menu won't be displayed correctly in a vertical band. As you'll see, however, you can hide a particular band when the control is orientated vertically.

<P><div class="sidebar"><blockquote>
<A NAME="182"><H2>Image Lists for Command Bands Controls</H2></A>

<P>I touched on image lists earlier. Command bars and toolbars use image lists internally to manage the images used on buttons. Image lists can be managed in a stand-alone image list control. This control is basically a helper control that assists applications in managing a series of like-size images. The image list control in Windows CE is identical to the image list control under Windows NT and Windows 98, with the exception that the Windows CE version can't contain cursors for systems built without mouse/cursor support. For the purposes of the command bands control, the image list just needs to be created and a set of bitmaps added that will represent the individual bands when they're minimized. An example of the minimal code required for this is shown here:

<P><pre>
himl = ImageList_Create (16, 16, ILC_COLOR, 2, 0);
hBmp = LoadBitmap (hInst, TEXT (&quot;CmdBarBmps&quot;));
ImageList_Add (himl, hBmp, NULL);
DeleteObject (hBmp);
</pre>

<P>The <I>ImageList_Create</I> function takes the dimensions of the images to be loaded, the format of the images (ILC_COLOR is the default), the number of images initially in the list, and the number to be added. The two images are then added by loading a double-wide bitmap that contains two images and calling <I>ImageList_Add</I>. After the bitmap has been loaded into the image list, it should be deleted.</blockquote></div>

<A NAME="183"><H3>Adding bands</H3></A>

<P>You can add bands to your application by passing an array of REBARBANDINFO structures that describe each band to the control. The function is

<P><pre>
BOOL CommandBands_AddBands (HWND hwndCmdBands, HINSTANCE hinst,
                            UINT cBands, LPREBARBANDINFO prbbi);
</pre>

<P>Before you call this function, you must fill out a REBARBANDINFO structure for each of the bands to be added to the control. The structure is defined as

<P><pre>
typedef struct tagREBARBANDINFO{
    UINT cbSize;
    UINT fMask;
    UINT fStyle;
    COLORREF clrFore;
    COLORREF clrBack;
    LPTSTR lpText;
    UINT cch;
    int iImage;
    HWND hwndChild;
    UINT cxMinChild;
    UINT cyMinChild;
    UINT cx;
    HBITMAP hbmBack;
    UINT wID;
    UINT cyChild;
    UINT cyMaxChild;
    UINT cyIntegral;
    UINT cxIdeal;
    LPARAM lParam;
 } REBARBANDINFO;
</pre>

<P>Fortunately, although this structure looks imposing, many of the fields can be ignored because there are default actions for uninitialized fields. As usual with a Windows structure, the <I>cbSize</I> field must be filled with the size of the structure as a fail-safe measure when the structure is passed to Windows. The <I>fMask</I> field is filled with a number of flags that indicate which of the remaining fields in the structure are filled with valid information. I'll describe the flags as I cover each of the fields.

<P>The <I>fStyle</I> field must be filled with the style flags for the band if the RBBIM_STYLE flag is set in the <I>fMask</I> field. The allowable flags are the following:

<UL>
<P><LI><I>RBBS_BREAK</I> The band will start on a new line.
<P><LI><I>RBBS_FIXEDSIZE</I> The band can't be sized. When this flag is specified, the gripper for the band isn't displayed.
<P><LI><I>RBBS_HIDDEN</I> The band won't be visible when the command band is created.
<P><LI><I>RBBS_GRIPPERALWAYS</I> The band will have a sizing grip, even if it's the only band in the command band.
<P><LI><I>RBBS_NOGRIPPER</I> The band won't have a sizing grip. The band therefore can't be moved by the user.
<P><LI><I>RBBS_NOVERT</I> The band won't be displayed if the command bands control is displayed vertically due to the CCS_VERT style.
<P><LI><I>RBBS_CHILDEDGE</I> The band will be drawn with an edge at the top and bottom of the band.
<P><LI><I>RBBS_FIXEDBMP</I> The background bitmap of the band doesn't move when the band is resized.
</UL>

<P>For the most part, these flags are self-explanatory. Although command bands are usually displayed across the top of a window, they can be created as vertical bands and displayed down the left side of a window. In that case, the RBBS_NOVERT style allows the programmer to specify which bands won't be displayed when the command band is in a vertical orientation. Bands containing menus or wide controls are candidates for this flag because they won't be displayed correctly on vertical bands.

<P>You can fill the <I>clrFore</I> and <I>clrBack</I> fields with a color that the command band will use for the foreground and background color when your application draws the band. These fields are used only if the RBBIM_COLORS flag is set in the mask field. These fields, along with the <I>hbmBack</I> field, which specifies a background bitmap for the band, are useful only if the band contains a transparent command bar. Otherwise, the command bar covers most of the area of the band, obscuring any background bitmap or special colors. I'll explain how to make a command bar transparent in the section, &quot;<A HREF="ch05c.htm#184">Configuring individual bands</A>.&quot;

<P>The <I>lpText</I> field specifies the optional text that labels the individual band. This text is displayed at the left end of the bar immediately right of the gripper. The <I>iImage</I> field is used to specify a bitmap that will also be displayed on the left end of the bar. The <I>iImage</I> field is filled with an index to the list of images contained in the image list control. The text and bitmap fields take added significance when paired with the RBS_SMARTLABELS style of the command band control. When that style is specified, the text is displayed when the band is restored or maximized and the bitmap is displayed when the band is minimized. This technique is used by the H/PC Explorer on its command band control.

<P>The <I>wID</I> field should be set to an ID value that you use to identify the band. The band ID is important if you plan on configuring the bands after they have been created or if you think you'll be querying their state. Even if you don't plan to use band IDs in your program, it's important that each band ID be unique because the control itself uses the IDs to manage the bands. This field is checked only if the RBBIM_ID flag is set in the <I>fMask</I> field.

<P>The <I>hwndChild</I> field is used if the default command bar control in a band is replaced by another control. To replace the command bar control, the new control must first be created and the window handle of the control then placed in the <I>hwndChild</I> field. The <I>hwndChild</I> field is checked only if the RBBIM_CHILD flag is set in the <I>fMask</I> field.

<P>The <I>cxMinChild</I> and <I>cyMinChild</I> fields define the minimum dimensions to which a band can shrink. When you're using a control other than the default command bar, these fields are useful for defining the height and minimum width (the width when minimized) of the band. These two fields are checked only if the RBBIM_CHILDSIZE flag is set.

<P>The <I>cxIdeal</I> field is used when a band is maximized by the user. If this field isn't initialized, a maximized command band stretches across the entire width of the control. By setting <I>cxIdeal</I>, the application can limit the maximized width of a band, which is handy if the controls on the band take up only part of the total width of the control. This field is checked only if the RBBIM_IDEALSIZE flag is set in the <I>fMask</I> field.

<P>The <I>lParam</I> field gives you a space to store an application-defined value with the band information. This field is checked only if the RBBIM_LPARAM flag is set in the <I>fMask</I> field. The other fields in the REBARBANDINFO apply to the more flexible rebar control, not the command band control. The code below creates a command bands control, initializes an array of three REBARBANDINFO structures, and adds the bands to the control.

<P><pre>
// Create a command bands ctl.
hwndCB = CommandBands_Create (hInst, hWnd, IDC_CMDBAND, RBS_SMARTLABELS |
                              RBS_VARHEIGHT, himl);

// Init common REBARBANDINFO structure fields.
for (i = 0; i &lt; dim(rbi); i++) {
    rbi[i].cbSize = sizeof (REBARBANDINFO);
    rbi[i].fMask = RBBIM_ID | RBBIM_IMAGE | RBBIM_SIZE | RBBIM_STYLE;
    rbi[i].fStyle = RBBS_FIXEDBMP;
    rbi[i].wID = IDB_CMDBAND+i;
}
// Init REBARBANDINFO structure for each band.
// 1. Menu band.
rbi[0].fStyle |= RBBS_NOGRIPPER;
rbi[0].cx = 130;
rbi[0].iImage = 0;

// 2. Standard button band.
rbi[1].fMask |= RBBIM_TEXT;
rbi[1].cx = 200;
rbi[1].iImage = 1;
rbi[1].lpText = TEXT (&quot;Std Btns&quot;);

// 3. Edit control band.
hwndChild = CreateWindow (TEXT (&quot;edit&quot;), TEXT (&quot;edit ctl&quot;),
                          WS_VISIBLE | WS_CHILD | WS_BORDER,
                          0, 0, 10, 5, hWnd, (HMENU)IDC_EDITCTL,
                          hInst, NULL);

rbi[2].fMask |= RBBIM_TEXT | RBBIM_STYLE | RBBIM_CHILDSIZE | RBBIM_CHILD;
rbi[2].fStyle |= RBBS_CHILDEDGE;
rbi[2].hwndChild = hwndChild;
rbi[2].cxMinChild = 0;
rbi[2].cyMinChild = 25;
rbi[2].cyChild = 55;
rbi[2].cx = 130;
rbi[2].iImage = 2;
rbi[2].lpText = TEXT (&quot;Edit field&quot;);

// Add bands.
CommandBands_AddBands (hwndCB, hInst, 3, rbi);
</pre>

<P>The command bands control created above has three bands, one containing a menu, one containing a set of buttons, and one containing an edit control instead of a command bar. The control is created with the RBS_SMARTLABELS and RBS_VARHEIGHT styles. The smart labels display an icon when the bar is minimized and a text label when the band isn't minimized. The RBS_VARHEIGHT style allows each line on the control to have a different height.

<P>The common fields of the REBARBANDINFO structures are then initialized in a loop. Then the remaining fields of the structures are customized for each band on the control. The third band, containing the edit control, is the most complex to initialize. This band needs more initialization since the edit control needs to be properly sized to match the standard height of the command bar controls in the other bands.

<P>The <I>iImage</I> field for each band is initialized using an index into an image list that was created and passed to the <I>CommandBands_Create</I> function. The text fields for the second and third bands are filled with labels for those bands. The first band, which contains a menu, doesn't contain a text label because there's no need to label the menu. You also use the RBBS_NOGRIPPER style for the first band so that it can't be moved around the control. This fixes the menu band at its proper place in the control.

<P>Now that we've created the bands, it's time to see how to initialize them.

<A NAME="184"><H3>Configuring individual bands</H3></A>

<P>At this point in the process, the command bands control has been created and the individual bands have been added to the control. We have one more task, which is to configure the individual command bar controls in each band. (Actually, there's little more to configuring the command bar controls than what I've already described for command bars.)

<P>The handle to a command bar contained in a band is retrieved using

<P><pre>
HWND CommandBands_GetCommandBar (HWND hwndCmdBands, UINT uBand);
</pre>

<P>The <I>uBand</I> parameter is the zero-based band index for the band containing the command bar. If you call this function when the command bands control is being initialized, the index value correlates directly with the order in which the bands were added to the control. However, once the user has a chance to drag the bands into a new order, your application must obtain this index indirectly by sending a RB_IDTOINDEX message to the command bands control, as in

<P><pre>
nIndex = SendMessage (hwndCmdBands, RB_IDTOINDEX, ID_BAND, 0);
</pre>

<P>This message is critical for managing the bands because many of the functions and messages for the control require the band index as the method to identify the band. The problem is that the index values are fluid. As the user moves the bands around, these index values change. You can't even count on the index values being consecutive. So, as a rule, never blindly use the index value without first querying the proper value by translating an ID value to an index value with RB_IDTOINDEX.

<P>Once you have the window handle to the command bar, simply add the menu or buttons to the bar using the standard command bar control functions and messages. Most of the time, you'll specify only a menu in the first bar, only buttons in the second bar, and other controls in the third and subsequent bars.

<P>The following code completes the creation process shown in the earlier code fragments. This code initializes the command bar controls in the first two bands. Since the third band has an edit control, you don't need to initialize that band. The final act necessary to complete the command band control initialization is to add the close box to the control using a call to <I>CommandBands_AddAdornments</I>.

<P><pre>
// Add menu to first band.
hwndBand = CommandBands_GetCommandBar (hwndCB, 0);
CommandBar_InsertMenubar (hwndBand, hInst, ID_MENU, 0);

// Add std buttons to second band.
hwndBand = CommandBands_GetCommandBar (hwndCB, 1);
CommandBar_AddBitmap (hwndBand, HINST_COMMCTRL, IDB_STD_SMALL_COLOR,
                      15, 0, 0);
CommandBar_AddButtons (hwndBand, dim(tbCBStdBtns), tbCBStdBtns);

// Add exit button to command band.
CommandBands_AddAdornments (hwndCB, hInst, 0, NULL);
</pre>

<A NAME="185"><H3>Saving the band layout</H3></A>

<P>The configurability of the command bands control presents a problem to the programmer. Users who rearrange the bands expect their customized layout to be restored the next time the application is started. This task is supposed to be made easy using the following function.

<P><pre>
BOOL CommandBands_GetRestoreInformation (HWND hwndCmdBands,
                     UINT uBand, LPCOMMANDBANDSRESTOREINFO pcbr);
</pre>

<P>This function saves the positioning information from an individual band into a COMMANDBANDSRESTOREINFO structure. The function takes the handle of the command bands control and an index value for the band to be queried. The following code fragment shows how to query the information from each of the bands in a command band control.

<P><pre>
// Get the handle of the command bands control.
hwndCB = GetDlgItem (hWnd, IDC_CMDBAND);

// Get information for each band.
for (i = 0; i &lt; NUMBANDS; i++) {

    // Get band index from ID value.
    nBand = SendMessage (hwndCB, RB_IDTOINDEX, IDB_CMDBAND+i, 0);

    // Initialize the size field and get the restore information.
    cbr[i].cbSize = sizeof (COMMANDBANDSRESTOREINFO);
    CommandBands_GetRestoreInformation (hwndCB, nBand, &amp;cbr[i]);
}
</pre>

<P>The code above uses the RB_IDTOINDEX message to convert known band IDs into the unknown band indexes required by <I>CommandBands_GetRestoreInformation</I>. The data from the structure would normally be stored in the system registry. I'll talk about how to read and write registry data in Chapter 7, &quot;<A HREF="ch07a.htm#246">Files, Databases, and the Registry</A>.&quot;

<P>The restore information should be read from the registry when the application is restarted, and used when creating the command bands control.

<P><pre>
// Restore configuration to a command band.
COMMANDBANDSRESTOREINFO cbr[NUMBANDS];
REBARBANDINFO rbi;

// Initialize size field.
rbi.cbSize = sizeof (REBARBANDINFO);

// Set only style and size fields.
rbi.fMask = RBBIM_STYLE | RBBIM_SIZE;

// Set the size and style for all bands.
for (i = 0; i &lt; NUMBANDS; i++) {
    rbi.cx = cbr[i].cxRestored;
    rbi.fStyle = cbr[i].fStyle;

    nBand = SendMessage (hwndCB, RB_IDTOINDEX, cbr[i].wID, 0);
    SendMessage (hwndCB, RB_SETBANDINFO, nBand, (LPARAM)&amp;rbi);
}

// Only after the size is set for all bands can the bands
// needing maximizing be maximized.
for (i = 0; i &lt; NUMBANDS; i++) {
    if (cbr[i].fMaximized) {
        nBand = SendMessage (hwndCB, RB_IDTOINDEX, cbr[i].wID, 0);
        SendMessage (hwndCB, RB_MAXIMIZEBAND, nBand, TRUE);
    }
}
</pre>

<P>This code assumes that the command bands control has already been created in its default configuration. In a real-world application, the restore information for the size and style could be used when first creating the control. In that case, all that would remain would be to maximize the bands depending on the state of the <I>fMaximized</I> field in the COMMANDBANDSRESTOREINFO structure. This last step must take place only after all bands have been created and properly resized.

<P>One limitation of this system of saving and restoring the band layout is that you have no method for determining the order of the bands in the control. The band index isn't likely to provide reliable clues because after the user has rearranged the bands a few times, the indexes are neither consecutive nor in any defined order. The only way around this problem is to constrain the arrangement of the bands so that the user can't reorder the bands. You do this by setting the RBS_FIXEDORDER style. This solves your problem, but doesn't help users if they want a different order. In the example program at the end of this section, I use the band index value to guess at the order. But this method isn't guaranteed to work.

<A NAME="186"><H3>Handling command band messages</H3></A>

<P>The command bands control needs a bit more maintenance than a command bar. The difference is that the control can change height, and thus the window containing the command bands control must monitor the control and redraw and perhaps reformat its client area when the control is resized.

<P>The command bands control sends a number of different WM_NOTIFY messages when the user rearranges the control. To monitor the height of the control, your application needs to check for a RBN_HEIGHTCHANGE notification and to react accordingly. The code below does just this:

<P><pre>
// This code is inside a WM_NOTIFY message handler.
LPNMHDR pnmh;

pnmh = (LPNMHDR)lParam;
if (pnmh-&gt;code == RBN_HEIGHTCHANGE) {
    InvalidateRect (hWnd, NULL, TRUE);
}
</pre>

<P>If a RBN_HEIGHTCHANGE notification is detected, the routine simply invalidates the client area of the window forcing a WM_PAINT message. The code in the paint message then calls

<P><pre>
UINT CommandBands_Height (HWND hwndCmdBands);
</pre>

<P>to query the height of the command bands control and subtracts this height from the client area rectangle.

<P>As with the command bar, the command bands control can be hidden and shown with a helper function:

<P><pre>
BOOL CommandBands_Show (HWND hwndCmdBands, BOOL fShow);
</pre>

<P>The visibility state of the control can be queried using

<P><pre>
BOOL CommandBands_IsVisible (HWND hwndCmdBands);
</pre>

<A NAME="187"><H2>The CmdBand Example Program</H2></A>

<P>The CmdBand program demonstrates a fairly complete command bands control. The example creates three bands: a fixed menu band, a band containing a number of buttons, and a band containing an edit control. Transparent command bars and a background bitmap in each band are used to create a command bands control with a background image.

<P>You can use the View menu to replace the command bands control with a simple command bar by choosing Command Bar from the View menu. You can then recreate and restore the command bands control to its last configuration by choosing Command Bands from the View menu. The code for the CmdBand program is shown in Figure 5-5 .

<P><B>Figure 5-5.</B> <I>The CmdBand program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="188"><H3>CmdBand.rc</H3></A>


<P><pre>
//======================================================================
// Resource file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &quot;windows.h&quot;                 //
#include &quot;CmdBand.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Icons and bitmaps
//
ID_ICO   ICON   &quot;cmdband.ico&quot;    // Program icon
CmdBarBmps     BITMAP &quot;cbarbmps.bmp&quot;   // Bmp used in cmdband image list
CmdBarEditBmp  BITMAP &quot;cbarbmp2.bmp&quot;   // Bmp used in cmdband image list
CmdBarBack     BITMAP &quot;backg2.bmp&quot;     // Bmp used for cmdband background

//----------------------------------------------------------------------
// Menu
//
ID_MENU MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_EXIT
    END
    POPUP &quot;&amp;View&quot;

    BEGIN
        MENUITEM &quot;Command Bar&quot;,                 IDM_VIEWCMDBAR
        MENUITEM &quot;Command Band&quot;,                IDM_VIEWCMDBAND
    END
    POPUP &quot;&amp;Help&quot;

    BEGIN
        MENUITEM &quot;&amp;About...&quot;,                   IDM_ABOUT
    END
END
//----------------------------------------------------------------------
// About box dialog template
//
aboutbox DIALOG discardable 10, 10, 160, 40
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_CENTER |
       DS_MODALFRAME
CAPTION &quot;About&quot;
BEGIN
    ICON  ID_ICON,                    -1,   5,   5,  10,  10
    LTEXT &quot;CmdBand - Written for the book Programming Windows \
           CE Copyright 1998 Douglas Boling&quot;
                                      -1,  40,   5, 110,  30
END
</pre>
</td></tr></table>



<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="189"><H3>CmdBand.h</H3></A>


<P><pre>
//======================================================================
// Header file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
};
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};
//----------------------------------------------------------------------
// Defines used by application
//
#define  IDC_CMDBAND         1                  // Command band ID
#define  IDC_CMDBAR          2                  // Command bar ID

#define  ID_ICO              10                 // Icon ID
#define  ID_MENU             11                 // Main menu resource ID
#define  IDC_EDITCTL         12

#define  IDB_CMDBAND         50                 // Base ID for bands
#define  IDB_CMDBANDMENU     50                 // Menu band ID
#define  IDB_CMDBANDBT       51                 // Button band ID
#define  IDB_CMDBANDEDIT     52                 // Edit control band ID

// Menu item IDs
#define  IDM_EXIT            100

#define  IDM_VIEWCMDBAR      110
#define  IDM_VIEWCMDBAND     111

#define  IDM_ABOUT           120
#define  NUMBANDS            3
//----------------------------------------------------------------------
// Function prototypes
//
int CreateCommandBand (HWND hWnd, BOOL fFirst);
int DestroyCommandBand (HWND hWnd);

int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoNotifyMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);

// Command functions
LPARAM DoMainCommandViewCmdBar (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandVCmdBand (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAbout (HWND, WORD, HWND, WORD);

// Dialog procedures
BOOL CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>

<A NAME="190"><H3>CmdBand.c</H3></A>

<P><pre>
//======================================================================
// CmdBand - Dialog box demonstration
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes

#include &quot;CmdBand.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;CmdBand&quot;);
HINSTANCE hInst;                     // Program instance handle

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_PAINT, DoPaintMain,
    WM_NOTIFY, DoNotifyMain,
    WM_COMMAND, DoCommandMain,
    WM_DESTROY, DoDestroyMain,
};
// Command message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDM_VIEWCMDBAR, DoMainCommandViewCmdBar,
    IDM_VIEWCMDBAND, DoMainCommandVCmdBand,
    IDM_EXIT, DoMainCommandExit,
    IDM_ABOUT, DoMainCommandAbout,
};

// Command band button initialization structure
const TBBUTTON tbCBStdBtns[] = {
//  BitmapIndex      Command  State            Style    UserData  String
    {STD_FILENEW,    210,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
    {STD_FILEOPEN,   211,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
    {STD_FILESAVE,   212,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
    {0,              0,       TBSTATE_ENABLED, TBSTYLE_SEP,    0,    0},
    {STD_CUT,        213,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
    {STD_COPY,       214,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
    {STD_PASTE,      215,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
    {0,              0,       TBSTATE_ENABLED, TBSTYLE_SEP,    0,    0},
    {STD_PROPERTIES, 216,     TBSTATE_ENABLED, TBSTYLE_BUTTON, 0,    0},
};

// Command bar initialization structure
const TBBUTTON tbCBViewBtns[] = {
//  BitmapIndex   Command  State               Style        UserData String
    {0,                 0, 0,                  
                                               TBSTYLE_SEP,        0, 0},
    {VIEW_LARGEICONS, 210, TBSTATE_ENABLED | TBSTATE_CHECKED,
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {VIEW_SMALLICONS, 211, TBSTATE_ENABLED,                  
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {VIEW_LIST,       212, TBSTATE_ENABLED,                  
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {VIEW_DETAILS,    213, TBSTATE_ENABLED,                  
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {0,                 0, 0,                  TBSTYLE_SEP,        0, 0},
    {VIEW_SORTNAME,   214, TBSTATE_ENABLED | TBSTATE_CHECKED,
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {VIEW_SORTTYPE,   215, TBSTATE_ENABLED,                  
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {VIEW_SORTSIZE,   216, TBSTATE_ENABLED,                  
                                               TBSTYLE_CHECKGROUP, 0, 0},
    {VIEW_SORTDATE,   217, TBSTATE_ENABLED,                  
                                               TBSTYLE_CHECKGROUP, 0, 0}
};

// Array that stores the band configuration
COMMANDBANDSRESTOREINFO cbr[NUMBANDS];
INT nBandOrder[NUMBANDS];
//======================================================================
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    HWND hwndMain;
    MSG msg;
    int rc;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;
    INITCOMMONCONTROLSEX icex;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    // Load the command bar common control class.
    icex.dwSize = sizeof (INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_COOL_CLASSES;
    InitCommonControlsEx (&amp;icex);
    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow){
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,             // Window class
                         TEXT (&quot;CmdBand Demo&quot;), // Window title
                         WS_VISIBLE,            // Style flags
                         CW_USEDEFAULT,         // x position
                         CW_USEDEFAULT,         // y position
                         CW_USEDEFAULT,         // Initial width
                         CW_USEDEFAULT,         // Initial height
                         NULL,                  // Parent
                         NULL,                  // Menu, must be null
                         hInstance,             // Application instance
                         NULL);                 // Pointer to create
                                                // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {
    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }

    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}

//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {

    CreateCommandBand (hWnd, TRUE);
    return 0;
}
//----------------------------------------------------------------------
// DoPaintMain - Process WM_PAINT message for window.
//
LRESULT DoPaintMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                     LPARAM lParam) {
    PAINTSTRUCT ps;
    HWND hwndCB;
    RECT rect;
    HDC hdc;
    POINT ptArray[2];

    // Adjust the size of the client rect to take into account
    // the command bar or command bands height.
    GetClientRect (hWnd, &amp;rect);
    if (hwndCB = GetDlgItem (hWnd, IDC_CMDBAND))
        rect.top += CommandBands_Height (hwndCB);
    else
        rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    hdc = BeginPaint (hWnd, &amp;ps);
    ptArray[0].x = rect.left;
    ptArray[0].y = rect.top;
    ptArray[1].x = rect.right;
    ptArray[1].y = rect.bottom;
    Polyline (hdc, ptArray, 2);

    ptArray[0].x = rect.right;
    ptArray[1].x = rect.left;
    Polyline (hdc, ptArray, 2);

    EndPaint (hWnd, &amp;ps);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window.
//
LRESULT DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT  i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD (wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code)
            return (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl,
                                              wNotifyCode);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoNotifyMain - Process WM_NOTIFY message for window.
//
LRESULT DoNotifyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    LPNMHDR pnmh;

    // Parse the parameters.
    pnmh = (LPNMHDR)lParam;
    if (pnmh-&gt;code == RBN_HEIGHTCHANGE) {
        InvalidateRect (hWnd, NULL, TRUE);

    }

    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;

}
//======================================================================
// Command handler routines
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    SendMessage (hWnd, WM_CLOSE, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandVCmdBarStd - Process View | Std Command bar command.
//
LPARAM DoMainCommandViewCmdBar (HWND hWnd, WORD idItem, HWND hwndCtl,
                                WORD wNotifyCode) {
    HWND hwndCB;

    hwndCB = GetDlgItem (hWnd, IDC_CMDBAND);
    if (hwndCB)
        DestroyCommandBand (hWnd);
    else
        return 0;

    // Create a minimal command bar that has only a menu and
    // an exit button.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Insert the menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);

    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    InvalidateRect (hWnd, NULL, TRUE);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandVCmdBand - Process View | Command band command.
//
LPARAM DoMainCommandVCmdBand (HWND hWnd, WORD idItem, HWND hwndCtl,
                              WORD wNotifyCode) {
    HWND hwndCB;
    hwndCB = GetDlgItem (hWnd, IDC_CMDBAR);
    if (hwndCB)
        CommandBar_Destroy (hwndCB);
    else
        return 0;

    CreateCommandBand (hWnd, FALSE);
    InvalidateRect (hWnd, NULL, TRUE);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAbout - Process the Help | About menu command.
//
LPARAM DoMainCommandAbout(HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    // Use DialogBox to create modal dialog box.
    DialogBox (hInst, TEXT (&quot;aboutbox&quot;), hWnd, AboutDlgProc);
    return 0;
}
//======================================================================
// About Dialog procedure
//
BOOL CALLBACK AboutDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                            LPARAM lParam) {
    switch (wMsg) {
        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hWnd, 0);
                    return TRUE;
            }
        break;
    }
    return FALSE;
}
//----------------------------------------------------------------------
// DestroyCommandBand - Destroy command band control after saving
// the current configuration.
//
int DestroyCommandBand (HWND hWnd) {
    HWND hwndCB;
    INT i, nBand, nMaxBand = 0;

   hwndCB = GetDlgItem (hWnd, IDC_CMDBAND);
    for (i = 0; i &lt; NUMBANDS; i++) {

        // Get band index from ID value.
        nBand = SendMessage (hwndCB, RB_IDTOINDEX, IDB_CMDBAND+i, 0);

        // Save the band number to save order of bands.
        nBandOrder[i] = nBand;

        // Get the restore information.
        cbr[i].cbSize = sizeof (COMMANDBANDSRESTOREINFO);
        CommandBands_GetRestoreInformation (hwndCB, nBand, &amp;cbr[i]);
    }
    DestroyWindow (hwndCB);
    return 0;
}
//----------------------------------------------------------------------
// CreateCommandBand - Create a formatted command band control.
//
int CreateCommandBand (HWND hWnd, BOOL fFirst) {
    HWND hwndCB, hwndBand, hwndChild;
    INT i, nBand, nBtnIndex, nEditIndex;
    LONG lStyle;
    HBITMAP hBmp;
    HIMAGELIST himl;
    REBARBANDINFO rbi[NUMBANDS];

    // Create image list control for bitmaps for minimized bands.
    himl = ImageList_Create (16, 16, ILC_COLOR, 3, 0);
    // Load first two images from one bitmap.
    hBmp = LoadBitmap (hInst, TEXT (&quot;CmdBarBmps&quot;));
    ImageList_Add (himl, hBmp, NULL);
    DeleteObject (hBmp);
    // Load third image as a single bitmap.
    hBmp = LoadBitmap (hInst, TEXT (&quot;CmdBarEditBmp&quot;));
    ImageList_Add (himl, hBmp, NULL);
    DeleteObject (hBmp);

    // Create a command band.
    hwndCB = CommandBands_Create (hInst, hWnd, IDC_CMDBAND,
                                  RBS_SMARTLABELS |
                                  RBS_AUTOSIZE | RBS_VARHEIGHT, himl);

    // Load bitmap used as background for command bar.
    hBmp = LoadBitmap (hInst, TEXT (&quot;CmdBarBack&quot;));
    // Initialize common REBARBANDINFO structure fields.
    for (i = 0; i &lt; dim(rbi); i++) {
        rbi[i].cbSize = sizeof (REBARBANDINFO);
        rbi[i].fMask = RBBIM_ID | RBBIM_IMAGE | RBBIM_SIZE |
                       RBBIM_BACKGROUND | RBBIM_STYLE;
        rbi[i].wID = IDB_CMDBAND+i;
        rbi[i].hbmBack = hBmp;
    }

    // If first time, initialize the restore structure since it is
    // used to initialize the band size and style fields.
    if (fFirst) {
        nBtnIndex = 1;
        nEditIndex = 2;
        cbr[0].cxRestored = 130;
        cbr[1].cxRestored = 210;
        cbr[1].fStyle = RBBS_FIXEDBMP;
        cbr[2].cxRestored = 130;
        cbr[2].fStyle = RBBS_FIXEDBMP | RBBS_CHILDEDGE;
    } else {
        // If not first time, set order of bands depending on
        // the last order.
        if (nBandOrder[1] &lt; nBandOrder[2]) {
            nBtnIndex = 1;
            nEditIndex = 2;
        } else {
            nBtnIndex = 2;
            nEditIndex = 1;
        }
    }
    // Initialize REBARBANDINFO structure for each band.
    // 1. Menu band
    rbi[0].fStyle = RBBS_FIXEDBMP | RBBS_NOGRIPPER;
    rbi[0].cx = cbr[0].cxRestored;
    rbi[0].iImage = 0;

    // 2. Standard button band
    rbi[nBtnIndex].fMask |= RBBIM_TEXT;
    rbi[nBtnIndex].iImage = 1;
    rbi[nBtnIndex].lpText = TEXT (&quot;Std Btns&quot;);
    // The next two parameters are initialized from saved data.
    rbi[nBtnIndex].cx = cbr[1].cxRestored;
    rbi[nBtnIndex].fStyle = cbr[1].fStyle;

    // 3. Edit control band
    hwndChild = CreateWindow (TEXT (&quot;edit&quot;), TEXT (&quot;edit ctl&quot;),
                  WS_VISIBLE | WS_CHILD | ES_MULTILINE | WS_BORDER,
                  0, 0, 10, 5, hWnd, (HMENU)IDC_EDITCTL, hInst, NULL);

    rbi[nEditIndex].fMask |= RBBIM_TEXT | RBBIM_STYLE |
                             RBBIM_CHILDSIZE | RBBIM_CHILD;
    rbi[nEditIndex].hwndChild = hwndChild;
    rbi[nEditIndex].cxMinChild = 0;
    rbi[nEditIndex].cyMinChild = 23;
    rbi[nEditIndex].cyChild = 55;
    rbi[nEditIndex].iImage = 2;
    rbi[nEditIndex].lpText = TEXT (&quot;Edit field&quot;);
    // The next two parameters are initialized from saved data.
    rbi[nEditIndex].cx = cbr[2].cxRestored;
    rbi[nEditIndex].fStyle = cbr[2].fStyle;

    // Add bands.
    CommandBands_AddBands (hwndCB, hInst, 3, rbi);

    // Add menu to first band.
    hwndBand = CommandBands_GetCommandBar (hwndCB, 0);
    CommandBar_InsertMenubar (hwndBand, hInst, ID_MENU, 0);

    // Add standard buttons to second band.
    hwndBand = CommandBands_GetCommandBar (hwndCB, nBtnIndex);
    // Insert buttons
    CommandBar_AddBitmap (hwndBand, HINST_COMMCTRL, IDB_STD_SMALL_COLOR,
                          16, 0, 0);
    CommandBar_AddButtons (hwndBand, dim(tbCBStdBtns), tbCBStdBtns);

    // Modify the style flags of each command bar to make transparent.
    for (i = 0; i &lt; NUMBANDS; i++) {
        hwndBand = CommandBands_GetCommandBar (hwndCB, i);
        lStyle = SendMessage (hwndBand, TB_GETSTYLE, 0, 0);
        lStyle |= TBSTYLE_TRANSPARENT;
        SendMessage (hwndBand, TB_SETSTYLE, 0, lStyle);
    }

    // If not the first time the command band has been created, restore
    // the user's last configuration.
    if (!fFirst) {
        for (i = 0; i &lt; NUMBANDS; i++) {
            if (cbr[i].fMaximized) {
                nBand = SendMessage (hwndCB, RB_IDTOINDEX,
                                     cbr[i].wID, 0);
                SendMessage (hwndCB, RB_MAXIMIZEBAND, nBand, TRUE);
            }
        }
    }
    // Add exit button to command band.
    CommandBands_AddAdornments (hwndCB, hInst, 0, NULL);
    return 0;
}
</pre>
</td></tr></table>

<P>CmdBand creates the command band in the <I>CreateCommandBand</I> routine. This routine is initially called in <I>OnCreateMain</I> and later in the <I>DoMainCommandVCmdBand</I> menu handler. The program creates the command bands control using the RBS_SMARTLABELS style along with an image list and text labels to identify each band when it's minimized and when it's restored or maximized. An image list is created and initialized with the bitmaps that are used when the bands are minimized.

<P>The array of REBARBANDINFO structures is initialized to define each of the three bands. If the control had previously been destroyed, data from the COMMANDBANDSRESTOREINFO structure is used to initialize the <I>style</I> and <I>cx</I> fields. The <I>CreateCommandBand</I> routine also makes a guess at the order of the button and edit bands by looking at the band indexes saved when the control was last destroyed. While this method isn't completely reliable for determining the previous order of the bands, it gives you a good estimate.

<P>When the command bands control is created, the command bars in each band are also modified to set the TBS_TRANSPARENT style. This process, along with a background bitmap defined for each band, demonstrates how you can use a background bitmap to make the command bands control have just the right look.

<P>When CmdBand replaces the command bands control with a command bar, the application first calls the <I>DestroyCommandBand</I> function to save the current configuration and then destroy the command bands control. This function uses the <I>CommandBands_GetRestoreInformation</I> to query the size and style of each of the bands. The function also saves the band index for each band to supply the data for the guess on the current order of the button and edit bands. The first band, the menu band, is fixed with the RBBS_NOGRIPPER style, so there's no issue as to its position.

<P>This completes the discussion of the command bar and command bands controls. I talk about these two controls at length because you'll need one or the other for almost every Windows CE application.

<P>For the remainder of the chapter, I'll cover the highlights of some of the other controls. These other controls aren't very different from their counterparts under Windows 98 and Windows NT. I'll spend more time on the controls I think you'll need when writing a Windows CE application. I'll start with the month calendar and the time and date picker controls. These controls are rather new to the common control set and have a direct application to the PIM-like applications that are appropriate for many Windows CE systems. I'll also spend some time covering the list view control, concentrating on features of use to Windows CE developers. The remainder of the common controls, I'll cover just briefly.

<A NAME="191"><H2>The Month Calendar Control</H2></A>

<P>The month calendar control gives you a handy month-view calendar that can be manipulated by users to look up any month, week, or day as far back as the adoption of the Gregorian calendar in September 1752. The control can display as many months as will fit into the size of the control. The days of the month can be highlighted to indicate appointments. The weeks can indicate the current week into the year. Users can spin through the months by tapping on the name of the month or change years by tapping on the year displayed.

<P>Before using the month calendar control, you must initialize the common control library either by calling <I>InitCommonControls</I> or by calling <I>InitCommonControlsEx</I> with the ICC_DATE_CLASSES flag. You create the control by calling <I>CreateWindow</I> with the MONTHCAL_CLASS flag. The style flags for the control are shown here:

<UL>
<P><LI><I>MCS_MULTISELECT</I> The control allows multiple selection of days.
<P><LI><I>MCS_NOTODAY</I> The control won't display today's date under the calendar.
<P><LI><I>MCS_NOTODAYCIRCLE</I> The control won't circle today's date.
<P><LI><I>MCS_WEEKNUMBERS</I> The control displays the week number (1 through 52) to the left of each week in the calendar.
<P><LI><I>MCS_DAYSTATE</I> The control sends notification messages to the parent requesting the days of the month that should be displayed in bold. You use this style to indicate which days have appointments or events scheduled.
</UL>

<A NAME="192"><H3>Initializing the control</H3></A>

<P>In addition to the styles I just described, you can use a number of messages or their corresponding wrapper macros to configure the month calendar control. You can use an MCM_SETFIRSTDAYOFWEEK message to display a different starting day of the week. You can also use the MCM_SETRANGE message to display dates within a given range in the control You can configure date selection to allow the user to choose only single dates or to set a limit to the range of dates that a user can select at any one time. The single/multiple date selection ability is defined by the MCS_MULTISELECT style. If you set this style, you use the MCM_SETMAXSELCOUNT message to set the maximum number of days that can be selected at any one time.

<P>You can set the background and text colors of the control by using the MCM_SETCOLOR message. This message can individually set colors for the different regions within the controls, including the calendar text and background, the header text and background, and the color of the days that precede and follow the days of the month being displayed. This message takes a flag indicating what part of the control to set and a COLORREF value to specify the color.

<P>The month calendar control is designed to display months on an integral basis. That is, if the control is big enough for one and a half months, it displays only one month, centered in the control. You can use the MCM_GETMINREQRECT message to compute the minimum size necessary to display one month. Because the control must first be created before the MCM_GETMINREQRECT can be sent, properly sizing the control is a round-about process. You must create the control, send the MCM_GETMINREQRECT message, and then resize the control using the data returned from the message.

<A NAME="193"><H3>Month calendar notifications</H3></A>

<P>The month calendar control has only three notification messages to send to its parent. Of these, the MCN_GETDAYSTATE notification is the most important. This notification is sent when the control needs to know what days of a month to display in bold. This is done by querying the parent for a series of bit field values encoded in a MONTHDAYSTATE variable. This value is nothing more than a 32-bit value with bits 1 through 31 representing the days 1 through 31 of the month.

<P>When the control needs to display a month, it sends a MCN_GETDAYSTATE notification with a pointer to an NMDAYSTATE structure defined as the following:

<P><pre>
typedef struct {
    NMHDR nmhdr;
    SYSTEMTIME stStart;
    int cDayState;
    LPMONTHDAYSTATE prgDayState;
} NMDAYSTATE;
</pre>

<P>The <I>nmbhdr</I> field is simply the NMHDR structure that's passed with every WM_NOTIFY message. The <I>stStart</I> field contains the starting date for which the control is requesting information. This date is encoded in a standard SYSTEMTIME structure used by all versions of Windows. It's detailed below.

<P><pre>
typedef struct {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME;
</pre>

<P>For this notification, only the <I>wMonth</I>, <I>wDay</I>, and <I>wYear</I> fields are significant.

<P>The <I>cDayState</I> field contains the number of entries in an array of MONTHDAYSTATE values. Even if a month calendar control is displaying only one month, it could request information about the previous and following months if days of those months are needed to fill in the top or bottom lines of the calendar.

<P>The month calendar control sends an MCN_SELCHANGE notification when the user changes the days that are selected in the control. The structure passed with this notification, NMSELCHANGE, contains the newly highlighted starting and ending days. The MCN_SELECT notification is sent when the user double-taps on a day. The same NMSELCHANGE structure is passed with this notification to indicate the days that have been selected.

<A NAME="194"><H2>The Date and Time Picker Control</H2></A>

<P>The date and time picker control looks deceptively simple but is a great tool for any application that needs to ask the user to specify a date. Any programmer that has had to parse, validate, and translate a string into a valid system date or time will appreciate this control.

<P>When used to select a date, the control resembles a combo box, which is an edit field with a down arrow button on the right side. Clicking on the arrow, however, displays a month calendar control showing the current month. Selecting a day in the month dismisses the month calendar control and fills the date and time picker control with that date. When you configure it to query for a time, the date and time picker control resembles an edit field with a spin button on the right end of the control.

<P>The date and time picker control has three default formats: two for displaying the date and one for displaying the time. The control also allows you to provide a formatting string so that users can completely customize the fields in the control. The control even lets you insert application-defined fields in the control.

<A NAME="195"><H3>Creating a date and time picker control</H3></A>

<P>Before you can create the date and time picker control, the common control library must be initialized. If <I>InitCommonControlsEx</I> is used, it must be passed a ICC_DATE_CLASSES flag. The control is created by using <I>CreateWindow</I> with a class of DATETIMEPICK_CLASS. The control defines the following styles:

<UL>
<P><LI><I>DTS_LONGDATEFORMAT</I> The control displays a date in long format, as in Saturday, September 19, 1998. The actual long date format is defined in the system registry.
<P><LI><I>DTS_SHORTDATEFORMAT</I> The control displays a date in short format, as in 9/19/98. The actual short date format is defined in the system registry.
<P><LI><I>DTS_TIMEFORMAT</I> The control displays the time in a format such as 5:50:28 PM. The actual time format is defined in the system registry.
<P><LI><I>DTS_SHOWNONE</I> The control has a check box to indicate that the date is valid.
<P><LI><I>DTS_UPDOWN</I> An up-down control replaces the drop-down button that displays a month calendar control in date view.
<P><LI><I>DTS_APPCANPARSE</I> Allows the user to directly enter text into the control. The control sends a DTN_USERSTRING notification when the user is finished.
</UL>

<P>The first three styles simply specify a default format string. These formats are based on the regional settings in the registry. Since these formats can change if the user picks different regional settings in the Control Panel, the date and time picker control needs to know when these formats change. The system informs top-level windows of these types of changes by sending a WM_SETTINGCHANGE message. An application that uses the date and time picker control and uses one of these default fonts should forward the WM_SETTINGCHANGE message to the control if one is sent. This causes the control to reconfigure the default formats for the new regional settings.

<P>The DTS_APPCANPARSE style enables the user to directly edit the text in the control. If this isn't set, the allowable keys are limited to the cursor keys and the numbers. When a field, such as a month, is highlighted in the edit field and the user presses the 6 key, the month changes to June. With the DTS_APPCANPARSE style, the user can directly type any character into the edit field of the control. When the user has finished, the control sends a DTN_USERSTRING notification to the parent window so that the text can be verified.

<A NAME="196"><H3>Customizing the format</H3></A>

<P>To customize the display format, all you need to do is create a format string and send it to the control using a DTM_SETFORMAT message. The format string can be made up of any of the following codes:

<P><pre>
String      Description
fragment

&quot;d&quot;     One- or two-digit day.
&quot;dd&quot;    Two-digit day. Single digits have a leading zero.
&quot;ddd&quot;   The three-character weekday abbreviation. As in Sun, Mon...
&quot;dddd&quot;  The full weekday name.

&quot;h&quot;     One- or two-digit hour (12-hour format).
&quot;hh&quot;    Two-digit hour (12-hour format) Single digits have a leading zero.
&quot;H&quot;     One- or two-digit hour (24-hour format).
&quot;HH&quot;    Two-digit hour (24-hour format) Single digits have a leading zero.

&quot;m&quot;     One- or two-digit minute.
&quot;mm&quot;    Two-digit minute. Single digits have a leading zero.

&quot;M&quot;     One- or two-digit month.
&quot;MM&quot;    Two-digit month. Single digits have a leading zero.

&quot;MMM&quot;   Three-character month abbreviation.
&quot;MMMM&quot;  Full month name.

&quot;t&quot;     The one-letter AM/PM abbreviation. As in A or P.
&quot;tt&quot;    The two-letter AM/PM abbreviation. As in AM or PM.

&quot;X&quot;     Specifies a callback field that must be parsed by the application.

&quot;y&quot;     One-digit year. As in 8 for 1998.
&quot;yy&quot;    Two-digit year. As in 98 for 1998.
&quot;yyy&quot;   Full four-digit year. As in 1998.
</pre>

<P>Literal strings can be included in the format string by enclosing them in single quotes. For example, to display the string <I>Today is: Saturday, December 5, 1998</I> the format string would be

<P><pre>
Today is: `dddd', `MMMM' `d', `yyy
</pre>

<P>The single quotes enclose the strings that aren't parsed. That includes the <I>Today</I> <I>is:</I> as well as all the separator characters, such as spaces and commas.

<P>The callback field, designated by a series of X characters, provides for the application the greatest degree of flexibility for configuring the display of the date. When the control detects an <I>X</I> field in the format string, it sends a series of notification messages to its owner asking what to display in that field. A format string can have any number of <I>X</I> fields. For example the following string has two <I>X </I>fields.

<P><pre>
`Today `XX' is: ` dddd', `MMMM' `d', `yyy' and is `XXX' birthday'
</pre>

<P>The number of X characters is used by the application only to differentiate the application-defined fields; it doesn't indicate the number of characters that should be displayed in the fields. When the control sends a notification asking for information about an <I>X</I> field, it includes a pointer to the <I>X</I> string so that the application can determine which field is being referenced.

<P>When the date and time picker control needs to display an application-defined <I>X</I> field, it sends two notifications: DTN_FORMATQUERY and DTN_FORMAT. The DTN_FORMATQUERY notification is sent to get the maximum size of the text to be displayed. The DTN_FORMAT notification is then sent to get the actual text for the field. A third notification, DTN_WMKEYDOWN is sent when the user highlights an application-defined field and presses a key. The application is responsible for determining which keys are valid and modifying the date if an appropriate key is pressed.

<A NAME="197"><H2>The List View Control</H2></A>

<P>The list view control is arguably the most complex of the common controls. It displays a list of items in one of four modes: large icon, small icon, list, and report. The Windows CE version of the list view control supports many, but not all, of the valuable new features recently added for Internet Explorer 4.0. Some of these new functions are a great help in the memory-constrained environment of Windows CE. These new features include the ability to manage virtual lists of almost any size, headers that can have images and be rearranged using drag and drop, the ability to indent an entry, and new styles for report mode. The list view control also supports the new custom draw interface, which allows a fairly easy way of changing the appearance of the control.

<P>You register the list view control by calling either <I>InitCommonControls</I> or <I>InitCommonControls</I> using a ICC_LISTVIEW_CLASSES flag. You create the control by calling <I>CreateWindow</I> using the class filled with WC_LISTVIEW. Under Windows CE, the list view control supports all the styles supported by other versions of Windows, including the new LVS_OWNERDATA style that designates the control as a virtual list view control.

<A NAME="198"><H3>New styles in report mode</H3></A>

<P>In addition to the standard list view styles that you can use when creating the list view, the list view control supports a number of <I>extended styles</I>. This rather unfortunate term doesn't refer to the extended styles field in the <I>CreateWindowsEx</I> function. Instead, two messages, LVM_GETEXTENDEDLISTVIEWSTYLE and LVM_SETEXTENDEDLISTVIEWSTYLE, are used to get and set these extended list view styles. The extended styles supported by Windows CE are listed below.

<UL>
<P><LI><I>LVS_EX_CHECKBOXES</I> The control places check boxes next to each item in the control.
<P><LI><I>LVS_EX_HEADERDRAGDROP</I> Allows headers to be rearranged by the user using drag and drop.
<P><LI><I>LVS_EX_GRIDLINES</I> The control draws grid lines around the items in report mode.
<P><LI><I>LVS_EX_SUBITEMIMAGES</I> The control displays images in the subitem columns in report mode.
<P><LI><I>LVS_EX_FULLROWSELECT</I> The control highlights the item's entire row in report mode when that item is selected.
</UL>

<P>Aside from the LVS_EX_CHECKBOXES extended style, which works in all display modes, these new styles all affect the actions of the list view when in report mode. The effort here has clearly been to make the list view control an excellent control for displaying large lists of data.

<P>Note that the list view control under Windows CE doesn't support other extended list view styles, such as LVS_EX_INFOTIP, LVS_EX_ONECLICKACTIVATE, LVS_EX_TWOCLICKACTIVATE, LVS_EX_TRACKSELECT, LVS_EX_REGIONAL, or LVS_EX_FLATSB, supported in some versions of the common control library.

<A NAME="199"><H3>Virtual list view</H3></A>

<P>The virtual list view mode of the list view control is a huge help for Windows CE devices. In this mode, the list view control tracks only the selection and focus state of the items. The application maintains all the other data for the items in the control. This mode is handy for two reasons. First, virtual list view controls are fast. The initialization of the control is almost instantaneous because all that's required is that you set the number of items in the control. The list view control also gives you hints about what items it will be looking for in the near term. This allows applications to cache necessary data in RAM and leave the remainder of the data in a database or file. Without a virtual list view, an application would have to load an entire database or list of items in the list view when it's initialized. With the virtual list view, the application loads only what the control requires to display at any one time.

<P>The second advantage of the virtual list view is RAM savings. Because the virtual list view control maintains little information on each item, the control doesn't keep a huge data array in RAM to support the data. The application manages what data is in RAM with some help from the virtual list view's cache hint mechanism.

<P>The virtual list view has some limitations. The LVS_OWNERDATA style that designates a virtual list view can't be set or cleared after the control has been created. Also, virtual list views don't support drag and drop in large icon or small icon mode. A virtual list view defaults to LVS_AUTOARRANGE style and the LVM_SETITEMPOSITION message isn't supported. Also, the sort styles LVS_SORTASENDING and LVS_SORTDESENDING aren't supported. Even so, the ability to store large lists of items is handy.

<P>To implement a virtual list view, an application needs to create a list view control with an LVS_OWNERDATA style and handle three notifications&#8212;LVN_GETDISPINFO, LVN_ODCACHEHINT, and LVN_ODFINDITEM. The LVN_GETDISPINFO notification should be familiar to those of you who have programmed list view controls before. It has always been sent when the list view control needed information to display an item. In the virtual list view, it's used in a similar manner but the notification is sent to gather all the information about every item in the control.

<P>The virtual list view lets you know what data items it needs using the LVN_ODCACHEHINT notification. This notification passes the starting and ending index of items that the control expects to make use of in the near term. An application can take its cue from this set of numbers to load a cache of those items so that they can be quickly accessed. The hints tend to be requests for the items about to be displayed in the control. Because the number of items can change from view to view in the control, it's helpful that the control tracks this instead of having the application guess which items are going to be needed. Because the control often also needs information about the first and last pages of items, it also helps to cache them so that the frequent requests for those items don't clear the main cache of items that will be needed again soon.

<P>The final notification necessary to manage a virtual list view is the LVN_ODFINDITEM notification. This is sent by the control when it needs to locate an item in response to a key press or in response to an LVM_FINDITEM message.

<A NAME="200"><H2>The LView Example Program</H2></A>

<P>The LView program demonstrates a virtual list view control. The program creates a list view control that displays the contents of a fictional database. A picture of the LView window is shown in Figure 5-6 while the LView code is shown in Figure 5-7.

<P><A HREF="javascript:fullSize('f05rg06x.htm')"> <img src="f05rg06.jpg" width=404 height=303 border="0" ALT="Click to view at full size."></a>
<!-- caption --><P><B>Figure 5-6.</B> <I>The LView window.</I><!-- /caption -->

<P><B>Figure 5-7.</B> <I>The LView program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="201"><H3>LView.rc</H3></A>


<P><pre>
//======================================================================
// Resource file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &quot;windows.h&quot;
#include &quot;LView.h&quot;                     // Program-specific stuff

//----------------------------------------------------------------------
// Icons and bitmaps
//
ID_ICO  ICON   &quot;lview.ico&quot;        // Program icon
docico  ICON   &quot;docicon.ico&quot;      // Document icon
//----------------------------------------------------------------------
// Menu
//
ID_MENU MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_EXIT
    END
    POPUP &quot;&amp;View&quot;
    BEGIN
        MENUITEM &quot;&amp;Lar&amp;ge Icons&quot;,               IDC_LICON
        MENUITEM &quot;&amp;S&amp;mall Icons&quot;,               IDC_SICON
        MENUITEM &quot;&amp;List&quot;,                       IDC_LIST
        MENUITEM &quot;&amp;Details&quot;,                    IDC_RPT
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About&quot;,                      IDM_ABOUT
    END
END
//----------------------------------------------------------------------
// About box dialog template
//
aboutbox DIALOG discardable 10, 10, 160, 40
STYLE  WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | DS_CENTER |
       DS_MODALFRAME
CAPTION &quot;About&quot;
BEGIN
    ICON  ID_ICON,                    -1,   5,   5,  10,  10 

   LTEXT &quot;LView - Written for the book Programming Windows \
           CE Copyright 1998 Douglas Boling&quot;
                                     -1,  40,   5, 110,  30
END
</pre>
</td></tr></table>


<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="202"><H3>LView.h</H3></A>

<P><pre>
//======================================================================
// Header file
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
};
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR   1                         // Command bar ID
#define  IDC_LISTVIEW 2                         // ID for report list box

#define  ID_ICO              10                 // Icon resource ID
#define  ID_MENU             11                 // Main menu resource ID

// Menu item and Command bar IDs
#define  IDM_EXIT            101

#define  IDC_LICO            111
#define  IDC_SICO            112
#define  IDC_LIST            113
#define  IDC_RPT             114
#define  IDM_ABOUT           120
#define  VIEW_BMPS           (VIEW_NEWFOLDER+1) // Number of BMPS in
                                                // view list
//----------------------------------------------------------------------
// Program-specific structures
//

// Defines for simulated database
typedef struct {
    TCHAR szName[32];
    TCHAR szType[32];
    INT nSize;
    INT nImage;
    INT nState;
} LVDATAITEM;
typedef LVDATAITEM *PLVDATAITEM;

//----------------------------------------------------------------------
// Function prototypes
//
// Cache functions
PLVDATAITEM GetItemData (INT nItem);
void InitDatabase (void);
void FlushMainCache (void);
void FlushEndCaches (void);
INT LoadTopCache (void);
INT LoadBotCache (void);
INT LoadMainCache (INT nStart, INT nEnd);

// Database functions
void InitDatabase (void);
PLVDATAITEM GetDatabaseItem (INT nItem);
INT SetDatabaseItem (INT nItem, PLVDATAITEM pIn);
PLVDATAITEM GetItemData (INT nItem);
INT AddItem (HWND, INT, LPTSTR, LPTSTR, INT);

int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Listview compare callback
int CALLBACK CompareLV (LPARAM, LPARAM, LPARAM);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM); 

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoSizeMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoNotifyMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);

// Command functions
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandChView (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandAbout (HWND, WORD, HWND, WORD);

// Dialog procedures
BOOL CALLBACK AboutDlgProc (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>


<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="203"><H3>LView.c</H3></A>

<P><pre>
//======================================================================
// LView - ListView control demonstration
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling

//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;LView.h&quot;                   // Program-specific stuff
//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;LView&quot;);
HINSTANCE hInst;                     // Program instance handle
HWND hMain;

//
// Data for simulated database
//
#define LVCNT 2000
LVDATAITEM lvdatabase[LVCNT];

// Defines and data for list view control cache
#define  CACHESIZE       100
#define  TOPCACHESIZE    100
#define  BOTCACHESIZE    100

INT nCacheItemStart = 0, nCacheSize = 0;
LVDATAITEM lvdiCache[CACHESIZE];
LVDATAITEM lvdiTopCache[TOPCACHESIZE];
LVDATAITEM lvdiBotCache[BOTCACHESIZE];

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_SIZE, DoSizeMain,
    WM_NOTIFY, DoNotifyMain,
    WM_COMMAND, DoCommandMain,
    WM_DESTROY, DoDestroyMain,
};
// Command message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDM_EXIT, DoMainCommandExit,
    IDC_LICON, DoMainCommandChView,
    IDC_SICON, DoMainCommandChView,
    IDC_LIST, DoMainCommandChView,
    IDC_RPT, DoMainCommandChView,
    IDM_ABOUT, DoMainCommandAbout,
};
// Standard file bar button structure
const TBBUTTON tbCBCmboBtns[] = {
//  BitmapIndex       Command    State        Style        UserData String
    {0,               0,         0,           TBSTYLE_SEP,        0,  0},
    {VIEW_LARGEICONS, IDC_LICON, TBSTATE_ENABLED,
                                              TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_SMALLICONS, IDC_SICON, TBSTATE_ENABLED,
                                              TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_LIST,       IDC_LIST,  TBSTATE_ENABLED,
                                              TBSTYLE_CHECKGROUP, 0,  0},
    {VIEW_DETAILS,    IDC_RPT,   TBSTATE_ENABLED | TBSTATE_CHECKED,
                                              TBSTYLE_CHECKGROUP, 0,  0}
};
//======================================================================
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    HWND hwndMain;
    int rc = 0; 

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc; 

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    hMain = hwndMain;
    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS     wc;
    INITCOMMONCONTROLSEX icex;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    // Load the command bar common control class.
    icex.dwSize = sizeof (INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx (&amp;icex);
    // Initialize the fictional database.
    InitDatabase ();
    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow){
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,            // Window class
                         TEXT (&quot;LView&quot;),       // Window title
                         WS_VISIBLE,           // Style flags
                         CW_USEDEFAULT,        // x position
                         CW_USEDEFAULT,        // y position
                         CW_USEDEFAULT,        // Initial width
                         CW_USEDEFAULT,        // Initial height
                         NULL,                 // Parent
                         NULL,                 // Menu, must be null
                         hInstance,            // Application instance
                         NULL);                // Pointer to create
                                               // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    // Flush caches used with list view control.
    FlushMainCache ();
    FlushEndCaches ();
    return nDefRC;
}
//======================================================================
// Message-handling procedures for MainWindow
//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT wMsg, WPARAM wParam,
                             LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc(hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    HWND hwndCB, hwndLV;
    INT i, nHeight;
    LPCREATESTRUCT lpcs;
    HIMAGELIST himlLarge, himlSmall;
    HICON hIcon;

    // Convert lParam into pointer to create structure.
    lpcs = (LPCREATESTRUCT) lParam;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Insert a menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);

    // Add bitmap list followed by buttons.
    CommandBar_AddBitmap (hwndCB, HINST_COMMCTRL, IDB_VIEW_SMALL_COLOR,
                          VIEW_BMPS, 0, 0);
    CommandBar_AddButtons (hwndCB, dim(tbCBCmboBtns), tbCBCmboBtns);
    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    nHeight = CommandBar_Height (hwndCB);
    //
    // Create the list view control.
    //
    hwndLV = CreateWindowEx (0, WC_LISTVIEW, TEXT (&quot;&quot;),
                             LVS_REPORT | LVS_SINGLESEL |
                             LVS_OWNERDATA | WS_VISIBLE | WS_CHILD |
                             WS_VSCROLL, 0, nHeight, lpcs-&gt;cx,
                             lpcs-&gt;cy - nHeight, hWnd,
                             (HMENU)IDC_LISTVIEW,
                             lpcs-&gt;hInstance, NULL);
    // Destroy frame if window not created.
    if (!IsWindow (hwndLV)) {
        DestroyWindow (hWnd);
        return 0;
    }
    // Add columns.
    {
        LVCOLUMN lvc;

        lvc.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_FMT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = 150;
        lvc.pszText = TEXT (&quot;Name&quot;);
        lvc.iSubItem = 0;
        SendMessage (hwndLV, LVM_INSERTCOLUMN, 0, (LPARAM)&amp;lvc);

        lvc.mask |= LVCF_SUBITEM;
        lvc.pszText = TEXT (&quot;Type&quot;);
        lvc.cx = 100;
        lvc.iSubItem = 1;
        SendMessage (hwndLV, LVM_INSERTCOLUMN, 1, (LPARAM)&amp;lvc);

        lvc.mask |= LVCF_SUBITEM;
        lvc.pszText = TEXT (&quot;Size&quot;);
        lvc.cx = 100;
        lvc.iSubItem = 2;
        SendMessage (hwndLV, LVM_INSERTCOLUMN, 2, (LPARAM)&amp;lvc);
    }
    // Add items.
    ListView_SetItemCount (hwndLV, LVCNT);
    LoadTopCache ();
    LoadBotCache (); 

    // Create image list control for bitmaps for minimized bands.
    i = GetSystemMetrics (SM_CXICON);
    himlLarge = ImageList_Create(i, i, ILC_COLOR, 2, 0);
    i = GetSystemMetrics (SM_CXSMICON);
    himlSmall = ImageList_Create(i, i, ILC_COLOR, 2, 0);

    // Load large and small icons into their respective image lists.
    hIcon = LoadIcon (hInst, TEXT (&quot;DocIcon&quot;));
    i = ImageList_AddIcon (himlLarge, hIcon);

    hIcon = LoadImage (hInst, TEXT (&quot;DocIcon&quot;), IMAGE_ICON, 16, 16,
                       LR_DEFAULTCOLOR);
    ImageList_AddIcon (himlSmall, hIcon);

    ListView_SetImageList (hwndLV, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList (hwndLV, himlSmall, LVSIL_SMALL);

    // Set cool new styles.
    ListView_SetExtendedListViewStyle (hwndLV, LVS_EX_GRIDLINES |
                                       LVS_EX_HEADERDRAGDROP |
                                       LVS_EX_FULLROWSELECT);
    return 0;
}
//----------------------------------------------------------------------
// DoSizeMain - Process WM_SIZE message for window.
//
LRESULT DoSizeMain (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam){
    HWND hwndLV;
    RECT rect;

    hwndLV = GetDlgItem (hWnd, IDC_LISTVIEW);

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    SetWindowPos (hwndLV, NULL, rect.left, rect.top,
                  rect.right - rect.left, rect.bottom - rect.top,
                  SWP_NOZORDER);
    return 0;
}
//----------------------------------------------------------------------
// DoNotifyMain - Process WM_NOTIFY message for window.
//

LRESULT DoNotifyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                      LPARAM lParam) {
    int idItem;
    LPNMHDR    pnmh;
    LPNMLISTVIEW pnmlv;
    NMLVDISPINFO *pLVdi;
    PLVDATAITEM pdi;     // Pointer to data
    LPNMLVCACHEHINT pLVch;
    HWND hwndLV;

    // Parse the parameters.
    idItem = (int) wParam;
    pnmh = (LPNMHDR)lParam;
    hwndLV = pnmh-&gt;hwndFrom;

    if (idItem == IDC_LISTVIEW) {
        pnmlv = (LPNMLISTVIEW)lParam;

        switch (pnmh-&gt;code) {
        case LVN_GETDISPINFO:
            pLVdi = (NMLVDISPINFO *)lParam;

            // Get a pointer to the data either from the cache
            // or from the actual database.
            pdi = GetItemData (pLVdi-&gt;item.iItem);

            if (pLVdi-&gt;item.mask &amp; LVIF_IMAGE)
                pLVdi-&gt;item.iImage = pdi-&gt;nImage;

            if (pLVdi-&gt;item.mask &amp; LVIF_PARAM)
                pLVdi-&gt;item.lParam = 0;

            if (pLVdi-&gt;item.mask &amp; LVIF_STATE)
                pLVdi-&gt;item.state = pdi-&gt;nState;

            if (pLVdi-&gt;item.mask &amp; LVIF_TEXT) {
                switch (pLVdi-&gt;item.iSubItem) {
                case 0:
                    lstrcpy (pLVdi-&gt;item.pszText, pdi-&gt;szName);
                    break;
                case 1:
                    lstrcpy (pLVdi-&gt;item.pszText, pdi-&gt;szType);
                    break;
                case 2:
                    wsprintf (pLVdi-&gt;item.pszText, TEXT (&quot;%d&quot;),
                              pdi-&gt;nSize); 
                    break;
                }
            }
            break; 

        case LVN_ODCACHEHINT:
            pLVch = (LPNMLVCACHEHINT)lParam;
            LoadMainCache (pLVch-&gt;iFrom, pLVch-&gt;iTo);
            break;

        case LVN_ODFINDITEM:
            // We should do a reverse look up here to see if
            // an item exists for the text passed.
            return -1;
        }
    }
    return 0;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window.
//
LRESULT DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT  i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD (wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code)
            return (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl,
                                              wNotifyCode);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
//======================================================================
// Command handler routines
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    SendMessage (hWnd, WM_CLOSE, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandChView - Process View xxx command.
//
LPARAM DoMainCommandChView (HWND hWnd, WORD idItem, HWND hwndCtl,
                            WORD wNotifyCode) {
    HWND hwndLV;
    LONG lStyle;

    hwndLV = GetDlgItem (hWnd, IDC_LISTVIEW);

    lStyle = GetWindowLong (hwndLV, GWL_STYLE);
    lStyle &amp;= ~LVS_TYPEMASK;

    switch (idItem) {
    case IDC_LICON:
        lStyle |= LVS_ICON;
        break;
    case IDC_SICON:
        lStyle |= LVS_SMALLICON;
        break;
    case IDC_LIST:
        lStyle |= LVS_LIST;
        break;
    case IDC_RPT:
        lStyle |= LVS_REPORT;
        break;
    }
    SetWindowLong (hwndLV, GWL_STYLE, lStyle);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandAbout - Process the Help | About menu command.
//
LPARAM DoMainCommandAbout(HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) { 

    // Use DialogBox to create modal dialog box.
    DialogBox (hInst, TEXT (&quot;aboutbox&quot;), hWnd, AboutDlgProc);
    return 0;
}
//======================================================================
// About Dialog procedure
//
BOOL CALLBACK AboutDlgProc(HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {

    switch (wMsg) {
        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                case IDOK:
                case IDCANCEL:
                    EndDialog (hWnd, 0);
                    return TRUE;
            }
        break;
    }
    return FALSE;
}
//======================================================================
// Helper routines for list view control management
//----------------------------------------------------------------------
// AddItem - Add an item to the list view control.
//
INT AddItem (HWND hwndCtl, INT nItem, LPTSTR pszName, LPTSTR pszType,
             INT nSize) {
    LVITEM lvi;
    TCHAR szTmp[40];

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem = nItem;
    lvi.iSubItem = 0;
    lvi.pszText = pszName;
    lvi.iImage = 0;
    lvi.lParam = nItem;
    SendMessage (hwndCtl, LVM_INSERTITEM, 0, (LPARAM)&amp;lvi);

    lvi.mask = LVIF_TEXT;
    lvi.iItem = nItem;
    lvi.iSubItem = 1;
    lvi.pszText = pszType;
    SendMessage (hwndCtl, LVM_SETITEM, 0, (LPARAM)&amp;lvi);

    wsprintf (szTmp, TEXT (&quot;%d&quot;), nSize);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = nItem;
    lvi.iSubItem = 2;
    lvi.pszText = szTmp;
    SendMessage (hwndCtl, LVM_SETITEM, 0, (LPARAM)&amp;lvi);

    return 0;
}
//----------------------------------------------------------------------
// GetItemData - This routine returns a pointer to the data.  It
// first checks the caches before calling directly to the database.
//
PLVDATAITEM GetItemData (INT nItem) {
    INT nCacheIndex;
    PLVDATAITEM pdi;

    // See if it's in the top cache.
    if (nItem &lt; TOPCACHESIZE) {

        nCacheIndex = nItem;
        pdi = &amp;lvdiTopCache[nCacheIndex];
    }

    // See if it's in the bottom cache.
    else if (nItem &gt; LVCNT - BOTCACHESIZE) {

        nCacheIndex = nItem - (LVCNT - BOTCACHESIZE);
        pdi = &amp;lvdiBotCache[nCacheIndex];
    }
    // See if item's in the main cache.
    else if ((nItem &gt;= nCacheItemStart) &amp;&amp;
             (nItem &lt; nCacheItemStart + nCacheSize)) {

        nCacheIndex = nItem - nCacheItemStart;
        pdi = &amp;lvdiCache[nCacheIndex];
    }

    // Otherwise it's not in any cache.
    else
        pdi = GetDatabaseItem (nItem);

    return pdi;
} 

//----------------------------------------------------------------------
INT LoadACache (PLVDATAITEM pCache, INT nStart, INT nSize) {
    PLVDATAITEM pdi;
    INT i;

    for (i = 0; i &lt; nSize; i++) {
        // Get a pointer to the data.
        pdi = GetDatabaseItem (nStart+i);

        // Save the data in the cache.
        lstrcpy (pCache[i].szName, pdi-&gt;szName);
        lstrcpy (pCache[i].szType, pdi-&gt;szType);
        pCache[i].nSize = pdi-&gt;nSize;
        pCache[i].nImage = pdi-&gt;nImage;
        pCache[i].nState = pdi-&gt;nState;
    }
    return 0;
}
//----------------------------------------------------------------------
// LoadMainCache - This routine loads the hint cache.  If the
// recommended range is already in the top or bottom caches, the range
// is adjusted to grab items outside the end caches.
//
// The logic expects the total number of items to be greater than the
// size of the start and end caches.
//
INT LoadMainCache (INT nStart, INT nEnd) {
    INT nOverlap;

    // Size the hint range to fit the cache.
    if (nEnd - nStart &gt; CACHESIZE)
        nEnd = nStart + CACHESIZE;

    // See if end of hint in bottom cache.
    if (nEnd &gt; LVCNT - BOTCACHESIZE) {

        // If completely in bottom cache, keep old data.
        if (nStart &gt; LVCNT - BOTCACHESIZE)
            return 0;

        // If partial overlap, adjust end points to get data just
        // above the bottom cache.
        nOverlap = nEnd - (LVCNT - BOTCACHESIZE);
        nEnd = LVCNT - BOTCACHESIZE - 1;
        if (nStart - nOverlap &lt; TOPCACHESIZE)
            nStart = TOPCACHESIZE;
        else
            nStart -= nOverlap;
    }
    // See if start of hint in top cache.
    if (nStart &lt; TOPCACHESIZE) {

        // If completely in top cache, keep old data.
        if (nEnd &lt; TOPCACHESIZE)
            return 0;

        // Adjust the starting value to just beyond top cache end.
        nOverlap = TOPCACHESIZE - nStart;
        nStart = TOPCACHESIZE;
        if (nOverlap + nEnd &gt; (LVCNT - BOTCACHESIZE))
            nEnd = LVCNT - BOTCACHESIZE;
        else
            nEnd += nOverlap;
    }
    // If hint already completely contained in the cache, exit.
    if ((nStart &gt;= nCacheItemStart) &amp;&amp; 
        (nEnd &lt; nCacheItemStart + nCacheSize))
        return 0;

    // Flush old data in cache.  We should really be smart here to
    // see whether part of the data is already in the cache.
    FlushMainCache ();

    // Load the new data.
    nCacheSize = nEnd - nStart;
    nCacheItemStart = nStart;
    LoadACache (lvdiCache, nStart, nCacheSize);
    return 0;
}
//----------------------------------------------------------------------
INT LoadTopCache (void) {

    LoadACache (lvdiTopCache, 0, TOPCACHESIZE);
    return 0;
}
//----------------------------------------------------------------------
INT LoadBotCache (void) {

    LoadACache (lvdiBotCache, LVCNT - BOTCACHESIZE, BOTCACHESIZE);
    return 0;
} 

//----------------------------------------------------------------------
void FlushMainCache (void) {
    INT i;

    // Send the data back to the database.
    for (i = 0; i &lt; nCacheSize; i++) {
        SetDatabaseItem (nCacheItemStart+i, &amp;lvdiCache[i]);
    }
    return;
}
//----------------------------------------------------------------------
void FlushEndCaches (void) {
    INT i;

    // Flush the top cache.
    for (i = 0; i &lt; TOPCACHESIZE; i++) {
        SetDatabaseItem (i, &amp;lvdiCache[i]);
    }
    // Flush the bottom cache.
    for (i = 0; i &lt; BOTCACHESIZE; i++) {
        SetDatabaseItem (LVCNT - BOTCACHESIZE + i, &amp;lvdiBotCache[i]);
    }
    return;
}
//======================================================================
// Code for fictional database to be displayed in the list view control
//
//----------------------------------------------------------------------
// InitDatabaseItem - Copy an item into the database.
//
INT InitDatabaseItem (INT nItem, LPTSTR pszName, LPTSTR pszType,
                      INT nSize) {

    lstrcpy (lvdatabase[nItem].szName, pszName);
    lstrcpy (lvdatabase[nItem].szType, pszType);
    lvdatabase[nItem].nSize = nSize;
    lvdatabase[nItem].nImage = 0;
    lvdatabase[nItem].nState = 0;
    return 0;
}
//----------------------------------------------------------------------
// InitDatabase - Create fictional data for fictional database.
//
void InitDatabase (void) {
    TCHAR szName[64];
    TCHAR szType[64];
    HCURSOR hOldCur;
    INT i;

    hOldCur = SetCursor (LoadCursor (NULL, IDC_WAIT));

    for (i = 0; i &lt; LVCNT; i++) {
        wsprintf (szName, TEXT (&quot;File%d&quot;), i);
        wsprintf (szType, TEXT (&quot;Type%d&quot;), 1000 - i);
        InitDatabaseItem (i, szName, szType, i+1000);
    }
    SetCursor (hOldCur);
    return;
}
//----------------------------------------------------------------------
// GetDatabaseItem - Return a pointer to data in the database.
//
PLVDATAITEM GetDatabaseItem (INT nItem) {

    // Normally, this would be more work. But since
    // we have only a simulated data store, the
    // code is trivial.
    return &amp;lvdatabase[nItem];
}
//----------------------------------------------------------------------
// SetDatabaseItem - Copy data from list view control back into database.
//
INT SetDatabaseItem (INT nItem, PLVDATAITEM pIn) {

    lstrcpy (lvdatabase[nItem].szName, pIn-&gt;szName);
    lstrcpy (lvdatabase[nItem].szType, pIn-&gt;szType);
    lvdatabase[nItem].nSize = pIn-&gt;nSize;
    lvdatabase[nItem].nImage = pIn-&gt;nImage;
    lvdatabase[nItem].nState = pIn-&gt;nState;
    return 0;
}
</pre>
</td></tr></table>


<P>Notice that the size for the database is set to 2000 items by default. Even with this large number, the performance of the list view control is quite acceptable. Most of the brief application startup time is taken up not by initializing the list view control, but just by filling in the dummy database. Support for the virtual list view is centered on the <I>OnNotifyMain</I> routine.

<P>Data for each item is supplied to the list view control through responses to the LVN_GETDISPINFO notification. The flags in the mask field of the LVDISPINFO determine exactly what element of the item is being requested. The code that handles the notification simply requests the item data from the cache and fills in the requested fields.

<P>The cache implemented by LView uses three separate buffers. Two of the buffers are initialized with the first and last 100 items from the database. The third 100-item cache, referred to as the main cache, is loaded using the hints passed by the list view control.

<P>The routine that reads the data from the cache is located in the <I>GetItemData</I> routine. That routine uses the index value of the requested item to see whether the data is in the top or bottom caches, and if not, whether it's in the main cache. If the data isn't in one of the caches, a call to <I>GetDatabaseItem</I> is made to read the data directly from the dummy database.

<P>The routine that handles the cache hints from the list view control is <I>LoadMainCache</I>. This routine is called when the program receives a LVN_ODCACHEHINT notification. The routine takes two parameters, the starting and ending values of the hint passed by the notification. The routine first checks to see if the range of items in the hint lies in the two end caches that store data from the top and bottom of the database. If the range does lie in one of the end caches, the hint is ignored and the main cache is left unchanged. If the hint range isn't in either end cache and isn't already in the current main cache, the main cache is flushed to send any updated information back into the database. The cache is then loaded with data from the database from the range of items indicated by the hint.

<P>The cache hint notifications sent by the list view control aren't necessarily intelligent. The control sends a request for a range of one item if that item is double-clicked by the user. The cache management code should always check to see whether the requested data is already in the cache before flushing and reloading the cache based on a single hint. The cache strategy you use, and the effort you must make to optimize it, of course depends on the access speed of the real data.

</BODY>
</HTML>




