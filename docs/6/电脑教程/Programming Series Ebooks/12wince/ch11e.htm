<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>File Filters</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="431"><H1>File Filters</H1></A>

<P>Windows CE file filters are COM objects that exist on the PC. They're loaded and called by Windows CE Services. When a file is copied to or from the Windows CE device to the PC using Windows CE Services, it checks to see whether a file converter is registered for the file type being transferred. If so, the file filter is loaded and requested to convert the file. All this takes place on the PC side of the link. If a file is being moved from the Windows CE system to the PC&#8212;exported, in Windows CE-speak&#8212;it's copied in its original form to the PC, then converted by the file filter, and finally stored on the PC. Likewise, if a file is being imported to the Windows CE device, it's first converted and then copied to the Windows CE device.

<P>Windows CE file filters are tied closely to the Mobile Devices folder. Only files moved to and from a Windows CE device by users dragging and dropping them in the Mobile Devices folder are converted. If a file is transferred to a Windows CE system by any other method, accessing a file through the Windows CE LAN redirector, for example, the file filter isn't loaded and file won't be converted. Likewise, if a file is downloaded from the Internet using Pocket Inbox, the file won't be converted.

<A NAME="432"><H2>Registering a File Filter</H2></A>

<P>Windows CE Services knows about file filters by looking in the registry. File filters need to be registered in two places. First, file filters should be among the Windows CE Services entries for each registered device under HKEY_CURRENT_USER. Second, they should be registered under the Windows CE Services entries under HKEY_LOCAL_MACHINE so that each filter will be automatically registered for any new devices that link to the PC. The <I>CeUtil</I> functions are helpful when you're registering a file filter because they handle opening the proper subkeys in which you register the file filter.

<P>In addition to registering the file filter itself, you must make a few other new entries in the registry. The COM server that implements the file filter must be registered under [HKEY_CLASSES_ROOT]\CLSID. This registration follows the standard format for a COM object with a few extensions I'll describe in a moment. In addition to registering the COM object, you must also register the file extensions for both the PC file type and the file type for the Windows CE version of the file.

<P>To sum up, a file filter needs to make a number of changes in the registry to properly function. For example, the program that installed the Pocket Word converter, which changes DOC format files used by Microsoft Word to the Pocket Word format PWD used by Pocket Word, must first register the PWD file type under [HKEY_CLASSES_ROOT]. You do this with two entries: one to associate the file extension with a file type and another entry to associate the file type with its name and the default shell actions. For the Pocket Word files, the entries look like this:

<p><pre>
<B>[HKEY_CLASSES_ROOT]\.pwd</B>                  pwdfile
</PRE>

<P>and

<p><pre>
<B>[HKEY_CLASSES_ROOT]\pwdfile</B>             Pocket Word File
   <B>DefaultIcon</B>       c:\Program Files\Windows CE Services\minshell.dll,-204
<B>   Shell
      Open</B>           c:\Program Files\Microsoft Office\Office\WinWord.exe
</PRE>

<P>The Windows CE file type must be registered on the PC even though this file type generally exists only on a Windows CE system.

<P>The DOC file type, which is the PC-side file type of the Pocket Word file filter, is already registered on Windows-based PCs, but if you introduce a new file type for the PC side of your converter it, too, must be registered.

<P>The COM object that implements the Pocket Word file filter is registered in an entry under the [HKEY_CLASSES_ROOT]\CLSID key. The key name is the CLSID for the COM server that provides the file filter. Underneath this key are entries for the object's icon and the location of the DLL that provides this class ID. For Pocket Word, the entry looks like this:

<p><pre>
<B>[HKEY_CLASSES_ROOT]\CLSID\{4D3E2CF2-9B22-11D0-82A3-00AA00C267C1}</B>
      <B>DefaultIcon</B>       c:\Program Files\Windows CE Services\pwdcnv.dll,0
      <B>InProcServer32</B>    c:\Program Files\Windows CE Services\pwdcnv.dll
                        ThreadingModel    Apartment
      <B>PegasusFilter</B>
                        Description       Pocket Word 2.0 Document
                        Import
                        NewExtension      .pwd
</PRE>

<P>The long series of numbers in the key name is the GUID for the PWD file filter. Each object will have a unique GUID that matches the GUID the object checks for when the <I>DllGetClassObject</I> call is made. The <I>DefaultIcon</I> and <I>InProcServer32</I> keys are standard for all COM object servers. The <I>PegasusFilter</I> key is unique to Windows CE file filters. This key contains the <I>Description</I> and <I>NewExtension</I> values that give you the extension and description of the resulting file type of the converter. The <I>Import</I> value indicates that this file filter will be converting files copied from the PC to the Windows CE device. If this filter converted Windows CE format files to PC format files it would have a value named Export under the <I>PegasusFilter </I>key.

<P>Now that the file types and the filter DLL itself have been registered, all that remains is to register the filter with Windows CE Services so that it will be called when a file is copied to or from the Windows CE device. To register the filter so that it will be used on guest devices and all future devices, you add a key with the name of the destination file extension under the key [HKEY_LOCAL_MACHINE]\Software\Microsoft\Windows CE Services\Filters. Under this key, you add entries that associate the import and export action with the CLSID of the COM server that implements the filter.

<P>The file extension that you register is the extension of the source file, whether it's being imported to the Windows CE device or exported to the PC. So a Word document file with the extension DOC wouldn't require any conversion when copied up to a PC, but would need to be converted to the pocket word (PWD) format when it's copied from the PC to the Windows CE. The entry that registers a filter to convert DOC files to PWD format looks like this:

<p><pre>
<B>[HKEY_LOCAL_MACHINE]\Software\Microsoft\Windows CE Services\Filters\.DOC</B>
            DefaultExport     Binary Copy
            DefaultImport     {4D3E2CF2-9B22-11D0-82A3-00AA00C267C1}
       <B>InstalledFilters</B>
            {4D3E2CEC-9B22-11D0-82A3-00AA00C267C1}
            {4D3E2CED-9B22-11D0-82A3-00AA00C267C1}
            {4D3E2CF2-9B22-11D0-82A3-00AA00C267C1}
                  .
                  .
                  .
            {4D3E3068-9B22-11D0-82A3-00AA00C267C1}
</PRE>

<P>This entry registers filters for all files with the DOC file extension. When the file is imported to the Windows CE device, the filter used is contained in the COM server with the CLSID of 4D3E2CF2-9B22-11D0-82A3-00AA00C267C1. When a DOC file is exported from the Windows CE device to the PC, no conversion is needed, so the placeholder <I>Binary Copy</I> is used in place of a CLSID. When Windows CE Services sees this, it simply copies the file without modification. If this entry isn't in the registry, Windows CE Services thinks no filter is registered for this file type and displays a warning to the user when the file is copied. In this case, we don't want to convert a DOC file when it's being exported from the Windows CE device, so the registry has a Binary Copy flag entry for this entry.

<P>Under the <I>InstalledFilters</I> key, you place one or more CLSIDs for different filters. Pocket Word for example, has a number of filters to convert PWD files into Word 97 documents, Word 95 documents, Word Perfect documents, and such. All these selections are presented to the user in the File Conversion dialog box that can be displayed from the Mobile Devices window on the PC.

<P>One limitation of the current registry setup for file filters is that the same CLSID can't be defined to perform both the import and export conversions on a file. This is because the destination file extension is taken from the registry entries under the CLSID key. You can, however, have one COM server that supports two CLSIDs that, in turn, create the appropriate filters for each CLSID.

<P>In addition to registering the file filter generically, you need to register the filter for any devices that already have a partnership with the PC. Otherwise, these devices won't use your filter. To do this, you need to repeat the registration procedures just described in this section under the key [HKEY_CURRENT_USER]\Software\Microsoft\Windows CE Services\Partners\&lt;&lt;Device ID&gt;&gt;\filters.

<P>You register the file filter for a specific device the same way you register the filter generically: by specifying the filter under its file extension.

<P>In the key above, the &lt;&lt;Device ID&gt;&gt; placeholder should be replaced with the device ID of each of the devices for which you want to register the filter. This is where the <I>CeUtil</I> functions come in handy. Using <I>CeSvcEnumDevices</I>, you can specify each device and then open the proper key using <I>CeSvcOpen</I>. So for the remainder of this section, I'll use the <I>CeSvc</I> functions provided by the <I>CeUtil</I> library to abstract the keys instead of talking about the proper registry keys in terms of their absolute key names.

<P>To open the registry key where filters are located, you would use the <I>CeSvcOpen </I>function and pass the constant CESVC_FILTERS. In the subkey name parameter, you would pass the extension of the file filter, as in

<p><pre>
hr = CeSvcOpen (CESVC_FILTERS, [[your file extension]],
                TRUE, &amp;hSvc);
</PRE>

<P>To carry on our example, the key for the Pocket Word converter would be opened this way:


<p><pre>
hr = CeSvcOpen (CESVC_FILTERS, TEXT (&quot;.pwd&quot;), TRUE, &amp;hSvc);
</PRE>

<P>Once the key is opened, you can use <I>CeSvcSetString</I> to write the specific entries in the registry.

<P>In the routine below, a file filter is registered both generically and under each currently registered device. The routines below use the <I>CeSvc</I>xxx functions, although you could use standard registry functions if you feel the need.


<p><pre>
//-----------------------------------------------------------------------
// RegExtensionforDevice - Helper routine that registers the filter for
// one device
//
HRESULT RegExtensionforDevice (HCESVC hSvc, LPTSTR pszGUID,
                               LPTSTR pszExt, BOOL bImport) {
    TCHAR szTag[32];
    HCESVC hKey;
    HRESULT hr;

    if (bImport)
        lstrcpy (szTag, TEXT (&quot;DefaultImport&quot;));
    else
        lstrcpy (szTag, TEXT (&quot;DefaultExport&quot;));
    CeSvcSetString (hSvc, szTag, pszGUID);
    hr = CeSvcOpenEx (hSvc, TEXT (&quot;InstalledFilters&quot;), TRUE, &amp;hKey);
    if (hr) return hr;
    CeSvcSetString (hKey, pszGUID, TEXT (&quot;&quot;));

    return hr;
}

//-----------------------------------------------------------------------
// RegFileExtension - This routine registers a file extension for all
// currently partnered devices as well as for guest devices.
//
HRESULT RegFileExtension (LPTSTR pszGUID, LPTSTR pszExt, BOOL bImport) {
    HRESULT hr;
    HCESVC hSvc, hDev, hDevFilterKey;
    DWORD dwPro, i = 0;
    TCHAR szKeyName[64];

    // Open generic filter key.
    hr = CeSvcOpen (CESVC_FILTERS, pszExt, TRUE, &amp;hSvc);
    if (hr)
        return hr;
    // Call routine to fill in proper keys.
    hr = RegExtensionforDevice (hSvc, pszGUID, pszExt, bImport);
    CeSvcClose (hSvc);

    // Now register for each current partner.
    while (CeSvcEnumProfiles (&amp;hSvc, i++, &amp;dwPro) == 0) {

        // Open key for that partner.
        hr = CeSvcOpen (CESVC_DEVICEX, (LPTSTR)dwPro, FALSE, &amp;hDev);
        if (hr) {
            CeSvcClose (hSvc);
            return hr;
        }
        // Open filter key underneath.
        lstrcpy (szKeyName, TEXT (&quot;Filters\\&quot;));
        lstrcat (szKeyName, pszExt);
        hr = CeSvcOpenEx (hDev, szKeyName, TRUE, &amp;hDevFilterKey);

        // Close this key since we don't need it anymore.
        CeSvcClose (hDev);
        if (hr) {
            CeSvcClose (hSvc);
            return hr;
        }
        // Call routine to fill in proper keys.
        hr = RegExtensionforDevice (hDevFilterKey, pszGUID, pszExt,
                                    bImport);
        // Close filter\extension key.
        CeSvcClose (hDevFilterKey);
    }
    return hr;
}
</PRE>

<P>To register a file filter with the routines, you would call <I>RegFileExtension</I>. This routine first calls <I>RegExtensionforDevice</I> to register the file filter for future partners under HKEY_LOCAL_MACHINE. Then the routine enumerates each currently registered partner and registers the filter for those devices. The GUID and file extension for <I>RegFileExtension</I> are passed as strings. An example call would be

<p><pre>
RegFileExtension (&quot;{2b06f7a1-088e-11d2-93f1-204c4f4f5020}&quot;,
                  &quot;.tst&quot;, TRUE);
</PRE>

<P>For the other parts of the registry initialization, registering file extensions and registering the class library, a simple REG file will do. A REG file is a text file that contains the keys and values to merge into the registry. Following is an example REG file that registers a class library for converting TST files into PTS files on the Windows CE device.


<P><pre>
REGEDIT4

[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}]
@=&quot;CEFileFilter Example&quot;
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}\DefaultIcon]
@=&quot;TstFilt.dll,-100&quot;
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}\InProcServer32]
@=&quot;e:\\CEBOOK\\11. Connecting to the Desktop\\TstFilt\\Debug\\TstFilt.dll&quot;
&quot;ThreadingModel&quot;=&quot;Apartment&quot;
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}\PegasusFilter]
&quot;Import&quot;=&quot;&quot;
&quot;Description&quot;=&quot;TstFilt: Copy a .tst file with no conversion.&quot;
&quot;NewExtension&quot;=&quot;pts&quot;

[HKEY_CLASSES_ROOT\.tst]
@=&quot;tstfile&quot;
[HKEY_CLASSES_ROOT\tstfile]
@=&quot;TstFilt: Desktop TST File&quot;
[HKEY_CLASSES_ROOT\tstfile\DefaultIcon]
@=&quot;e:\\CEBOOK\\11. Connecting to the Desktop\\TstFilt\\Debug\\TstFilt.dll,-100&quot;
[HKEY_CLASSES_ROOT\ptsfile]
@=&quot;TstFilt: HPC TST File&quot;
[HKEY_CLASSES_ROOT\ptsfile\DefaultIcon]
@=&quot;e:\\CEBOOK\\11. Connecting to the Desktop\\TstFilt\\Debug\\TstFilt.dll,-101&quot;
</pre>

<P>Now that we've learned how to register a file filter, let's look into building one.

<A NAME="433"><H2>The File Filter Interfaces</H2></A>

<P>Windows CE file filters are COM in-proc servers that export an <I>ICeFileFilter </I>interface. The filter can also optionally export an <I>ICeFileFilterOptions</I> interface. Mobile Devices indirectly calls these two interfaces using the OLE object manager when it needs to convert a file. When stripped of all the COM paraphernalia, implementing a file filter is nothing more that implementing three functions, two of which are quite trivial.

<P>The <I>ICeFileFilter</I> interface has the following methods:

<UL>
<P><LI><I>ICeFileFilter::NextConvertFile</I> Called to convert a file
<P><LI><I>ICeFileFilter::FilterOptions</I> Called to display a dialog box for filter options during setup
<P><LI><I>ICeFileFilter::FormatMessage</I> Called to convert an error code into a text message to be displayed to the user
</UL>

<A NAME="434"><h3>ICeFileFilter::NextConvertFile</h3></A>

<P>The primary method of a file filter is <I>NextConvertFile</I>. This method is called by the Mobile Devices program when a file needs to be converted from its PC format to its Windows CE format or the reverse. The method actually keeps being called until you tell it to stop. This allows a file filter to create multiple output files for every input file it converts.

<P>The prototype for this method is

<p><pre>
HRESULT ICeFileFilter::NextConvertFile (int nConversion,
                           CFF_CONVERTINFO *pci,
                           CFF_SOURCEFILE *psf,
                           CFF_DESTINATIONFILE *pdf,
                           volatile BOOL *pbCancel,
                           PR_ERROR *perr);
</PRE>

<P>The first parameter, <I>nConversion</I>, is a count value that's incremented each time the method is called for a single file. This means that the first time <I>NextConvertFile</I> is called to convert the file FOO.BAR, <I>nConversion</I> is 0. After you return from <I>NextConvertFile</I>, Mobile Devices calls <I>NextConvertFile</I> again, specifying the same input file, FOO.BAR, and the <I>nConversion</I> parameter is set to 1. Most file filters simply return the error code ERROR_NO_MORE_ITEMS, which tells Mobile Devices that you've completed converting the file. On the other hand, you can continue to process the conversion of FOO.BAR in the second, third, and subsequent calls. Mobile Devices continues to call <I>NextConvertFile</I>, specifying the same input file until you return ERROR_NO_MORE_ITEMS.

<P>The next parameter, <I>pci</I>, is a pointer to a CFF_CONVERTINFO structure, which give you general information about the conversion as well as providing a pointer to the <I>ICeFileFilterSite</I> interface. The structure looks like this:

<p><pre>
typedef struct {
    BOOL bImport;
    HWND hwndParent;
    BOOL bYesToAll;
    ICeFileFilterSite *pffs;
} CFF_CONVERTINFO;
</PRE>

<P>The first field, <I>bImport</I>, is set to TRUE if the file is being copied from the PC to the Windows CE device. The <I>hwndParent</I> parameter is the handle of a window that you can use as the parent window for any dialog boxes that need to be displayed. The <I>bYesToAll</I> field should be set to TRUE if you're copying more than one file. This flag indicates whether the Yes To All button is displayed in the overwrite files dialog box. Finally, the <I>pffs</I> field contains a pointer to an <I>ICeFileFilterSite </I>interface. This interface provides the functions used by the file filter to open and close the source and destination files.

<P><I>ICeFileFilterSite</I> has the following methods:

<UL>
<P><LI><I>ICeFileFilterSite::OpenSourceFile</I> Opens the source file
<P><LI><I>ICeFileFilterSite::OpenDestinationFile</I> Opens the destination file
<P><LI><I>ICeFileFilterSite::CloseSourceFile</I> Closes the source file
<P><LI><I>ICeFileFilterSite::CloseDestinationFile</I> Closes the destination file
<P><LI><I>ICeFileFilterSite::ReportProgress</I> Updates the modeless dialog box that indicates the progress of the conversion
<P><LI><I>ICeFileFilterSite::ReportLoss</I> Causes a dialog box to be displayed that reports to the user that data was lost in the conversion
</UL>

<P>The <I>OpenSourceFile</I> and <I>OpenDestinationFile</I> methods of <I>ICeFileFilterSite</I> return pointers to <I>IStream</I> or <I>IStorage</I> interfaces that are used to read and write these files. The <I>IStream</I> interface is used if the file is opened as a standard flat file while the <I>IStorage</I> interface is returned if the file is opened as an OLE compound document.

<P>The next parameter of <I>NextConvertFile</I>, <I>psf</I>, is a pointer to a CFF_SOURCEFILE structure that gives you information about the source file used in the conversion. The structure is defined as

<p><pre>
typedef struct {
    TCHAR szFullpath[_MAX_PATH];
    TCHAR szPath[_MAX_PATH];
    TCHAR szFilename[_MAX_FNAME];
    TCHAR szExtension[_MAX_EXT];
    DWORD cbSize;
    FILETIME ftCreated;
    FILETIME ftModified;
} CFF_SOURCEFILE;
</PRE>

<P>The <I>szFullPath</I> field contains the fully qualified filename of the source file. The next three fields contain the parsed components of the same name. The <I>cbSize</I> parameter contains the size of the source file, while the <I>ftCreated</I> and <I>ftModified</I> fields contain the time the file was created and last modified.

<P>The <I>pdf</I> parameter points to a CFF_DESTINATIONFILE that defined the particulars of the recommended destination filename. The structure is defined as

<p><pre>
typedef struct {
    TCHAR szFullpath[_MAX_PATH];
    TCHAR szPath[_MAX_PATH];
    TCHAR szFilename[_MAX_FNAME];
    TCHAR szExtension[_MAX_EXT];
} CFF_DESTINATIONFILE;
</PRE>

<P>The structure has the same first four fields as the CFF_SOURCEFILE structure. The difference is that the name in the CFF_DESTINATIONFILE structure is a recommended name. You can override the name of the destination file in the <I>OpenDestinationFile </I>method of <I>ICeFileFilterSite</I>. To do this, use the suggested path of the destination file contained in <I>szPath</I> and append the name and extension with the suggested modifications. Pass this new name to the <I>pszFullPath</I> parameter in <I>OpenDestinationFile</I>. The file filter example at the end of the chapter uses this technique to rename the destination file.

<P>The next parameter of <I>NextConvertFile</I> is <I>pbCancel</I>, a pointer to a BOOL. The <I>pbCancel</I> parameter points to a boolean that is changed to FALSE if the user pressed the Cancel button on the modeless dialog box that's reporting the progress of the conversion. The file filter must check this value periodically to see whether the user has canceled the conversion.

<P>The last parameter, <I>perr</I>, points to an error value that's returned by the <I>NextConvertFile</I> method. If <I>NextConvertFile</I> returns the error code E_FAIL, the value pointed to by <I>perr</I> is used as the error code for the routine. This code is then passed back to the filter for interpretation when you call <I>FormatMessage</I>.

<A NAME="435"><h3>ICeFileFilter::FormatMessage</h3></A>

<P>The <I>FormatMessage</I> method closely follows the syntax of the <I>FormatMessage</I> system call that formats messages using an error code and either the system message table or a string table from a module. For many uses, you can simply pass the call directly from <I>ICeFileFilter::FormatMessage</I> to the Win32 function <I>FormatMessage</I>.

<P><I>ICeFileFilter::FormatMessage</I> has the prototype

<p><pre>
HRESULT ICeFileFilter::FormatMessage (DWORD dwFlags,
                             DWORD dwMessageId,
                             DWORD dwLanguageId, LPTSTR lpBuffer,
                             DWORD nSize, va_list *Arguments,
                             DWORD *pcb);
</PRE>

<P>While the parameter list looks daunting, the best way to handle this method is to create a message resource in the filter and pass the call directly to Win32's <I>FormatMessage</I> with the addition of the flag FORMAT_MESSAGE_FROM_HMODULE to the <I>dwFlags</I> parameter. The only additional processing is to copy the number of bytes returned by Win32's <I>FormatMessage</I> and set the byte count in a variable pointed to by the parameter <I>pcb</I>. An example would be

<p><pre>
//-----------------------------------------------------------------------
// FormatMessage - Called to format error messages
//
STDMETHODIMP MyFileFilter::FormatMessage (DWORD dwFlags,
                            DWORD dwMessageId, DWORD dwLanguageId,
                            LPTSTR lpBuffer, DWORD dwSize,
                            va_list *args, DWORD *pcb) {
    DWORD cMsgLen;

    // Pass the error code on to the Win32 FormatMessage.  Force look
    // into message table of filter by ORing dwFlags with
    // FORMAT_MESSAGE_FROM_HMODULE.
    cMsgLen = ::FormatMessage (dwFlags | FORMAT_MESSAGE_FROM_HMODULE,
                               hInst, dwMessageId, dwLanguageId,
                               lpBuffer, dwSize, args);
    if (cMsgLen)
        *pcb = cMsgLen;
    else
        return E_FAIL;

    return NOERROR;
}
</PRE>

<P>If you're going to use custom filter error messages, you should define them using a constant combined with the macro CF_DECLARE_ERROR. This macro ensures that the error value you choose won't conflict with the standard Win32 error constants. In addition to defining the constants, you associate a string with the constant by including a message table resource in your filter. This, combined with the FORMAT_MESSAGE_FROM_HMODULE flag when you're calling Win32's <I>FormatMessage</I>, causes your message text to be used for your error constants. If the error value returned isn't one you defined, <I>FormatMessage</I> then looks in the system message table for a matching error message.

<A NAME="436"><h3>ICeFileFilter::FilterOptions</h3></A>

<P>The final method of <I>ICeFileFilter</I> is <I>FilterOptions</I>. This method is prototyped as

<p><pre>
HRESULT IPegasusFileFilter::FilterOptions (HWND hwndParent);
</PRE>

<P>The only parameter is a handle to a window that should be used as the parent window for the dialog box. Windows CE Services calls this method when the user requests that the Options dialog box be displayed. However, none of the current versions of Windows CE Services support this Options button&#8212;so while you need to support this method, you can't depend on the user being able to gain access to any dialog box displayed by this method.

<A NAME="437"><H2>The <I>ICeFileFilterOptions</I> Interface</H2></A>
<P>Windows CE file filters can support one other interface, <I>ICeFileFilterOptions</I>. This interface has, aside from the <I>IUnknown</I> methods, only one method: <I>SetFilterOptions</I>. The <I>SetFilterOptions</I> method enables Windows CE Services to tell the file filter whether it can display a modal dialog box during the conversion process. This is necessary because some conversions might take place in the background, where such displays of dialog boxes wouldn't be appropriate.

<P><I>SetFilterOptions</I> is prototyped as

<p><pre>
HRESULT SetFilterOptions (CFF_CONVERTOPTIONS* pco);
</PRE>

<P>The only parameter is a pointer to a CFF_CONVERTOPTIONS structure, which is defined as

<p><pre>
typedef struct {
    ULONG   cbSize;
    BOOL    bNoModalUI;
} CFF_CONVERTOPTIONS;
</PRE>

<P>While it may seem that using a structure to pass one Boolean is overkill, the use of a structure with a <I>size</I> field at the start lets Microsoft think about extending this structure while remaining backward compatible with older file filters.

<A NAME="438"><H2>The DivFile Filter Example</H2></A>

<P>The example shown below is a Windows CE file filter that detects when the user is copying files larger than 100 KB to a Windows CE device and splits the file into separate files on that device. If the file is larger than 100 KB and the version of Windows CE is earlier than 2.1, the DivFile filter splits the file into multiple parts so that it can be stored in the object store of the device. Although the actual limit for files in Windows CE 2.0 and earlier is 4 MB, the 100-KB limit gives you an opportunity to see the splitting in action without having to wait for a file larger than 4 MB to be copied across to a Windows CE device.

<P>The filter defines two new file types, TST for a file on the PC and PTS for <I>pocket test</I>, a sample file type on a Windows CE device. For this example, the splitting function is performed only on TST files larger than 100 KB. The result is a series of files on the Windows CE device, each with a number appended to the original filename and a new file type of PTS. The PTS files can be copied back to the PC unaltered and then rejoined using a binary copy operation, as in

<p><pre>
copy /b file_1.pts+file_2.pts+file_3.pts+file_4.pts original.tst
</PRE>

<P>The first file in this example isn't a source or include file; it's a registry file that registers the file filter, DivFile.reg. Note that since I'm not using an install program that can enumerate the various Windows CE devices already partnered, this filter won't be used until a new device is partnered with the PC or a device is attached as a guest of Windows CE Services. Also, the Explorer doesn't recognize the new file types until the system is rebooted&#8212;or more precisely, until the desktop is restarted. DivFile.reg is shown in Figure 11-8.

<P><!-- caption --><B>Figure 11-8.</B> <I>DivFile.reg.</I><!-- /caption -->


<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="439"><H3>REGEDIT4</H3></A>
<P><pre>
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}]

@=&quot;DivFile Sample&quot;
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}\DefaultIcon]

@=&quot;copy.dll,-100&quot;
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}\InProcServer32]
@=&quot;C:\\Programming Windows CE\\Chap11\\DivFile\\Debug\\DivFile.dll&quot;
&quot;ThreadingModel&quot;=&quot;Apartment&quot;
[HKEY_CLASSES_ROOT\CLSID\{2b06f7a1-088e-11d2-93f1-204c4f4f5020}\PegasusFilter]
&quot;Import&quot;=&quot;&quot;
&quot;Description&quot;=&quot;DivFile: Copy a .tst file with no conversion.&quot;
&quot;NewExtension&quot;=&quot;pts&quot;

[HKEY_CLASSES_ROOT\.tst]
@=&quot;tstfile&quot;
[HKEY_CLASSES_ROOT\tstfile]
@=&quot;DivFile: Desktop TST File&quot;
[HKEY_CLASSES_ROOT\tstfile\DefaultIcon]
@=&quot;C:\\ Programming Windows CE\\Chap11\\DivFile\\Debug\\DivFile.dll,-100&quot;

[HKEY_CLASSES_ROOT\.pts]
@=&quot;ptsfile&quot;
[HKEY_CLASSES_ROOT\ptsfile]
@=&quot;DivFile: HPC TST File&quot;
[HKEY_CLASSES_ROOT\ptsfile\DefaultIcon]
@=&quot;C:\\ Programming Windows CE\\Chap11\\DivFile\\Debug\\DivFile.dll,-101&quot;

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows CE Services\Filters\.tst]
&quot;DefaultImport&quot;=&quot;{2b06f7a1-088e-11d2-93f1-204c4f4f5020}&quot;
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows CE Services\Filters\.tst\
    InstalledFilters]
&quot;{2b06f7a1-088e-11d2-93f1-204c4f4f5020}&quot;=&quot;&quot;
</pre>
</td></tr></table>

<P>The registry file shown here uses the path to the copy of the DivFile.dll on my machine; you'll need to modify the path for your machine. Also, the GUID I generated should be replaced with one you create using GUIDGEN.EXE. The lines in this registry file are grouped into four sections. The first section registers the COM server DLL, DivFile.DLL. The second and third groups of lines register the file types TST and PTS. Finally, the last group of lines registers the file filter in the generic section of Windows CE Services' entries in the registry. You could easily write an install program to automatically register the file filter with the currently partnered Windows CE devices, using the routines I presented earlier in the chapter.

<P>The next file in the example is DivFile.def. The def file describes the exported functions from the DLL. I don't use the declspec macro used in the earlier examples here because of the predefined type definitions of the functions <I>DllGetClassObject</I> and <I>DllCanUnloadNow</I>. Figure 11-9 shows DivFile.def.

<P><B>Figure 11-9.</B> <I>The DivFile.def program.</I>

<p><TABLE cellpadding=5 width="95%"><TR><td>
<P><pre>
;

;Standard COM library DEF file
;



LIBRARY   DIVFILE.DLL

EXPORTS
   DllCanUnloadNow     @1 PRIVATE
   DllGetClassObject   @2 PRIVATE
</pre>
</td></tr></table>

<P>Finally, we get to the source files for the example, DivFile.rc, DivFile.h, and DivFile.cpp shown in Figure 11-10. The resource file declares two icon files that are used for the TST and PTS file types. The header file contains the class definitions for my derivations of the <I>ICeFileFilter</I> and <I>IClassFactory</I> objects. And last but not least, DivFile.cpp is filled mainly with code to support the requirements of a COM server.

<P><!-- caption --><B>Figure 11-10.</B> <I>DivFile source code files.</I><!-- /caption -->

<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="440"><H3>DivFile.rc</H3></A>

<P><pre>
//====================================================================
// Resource file

//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================

100 ICON &quot;PCSide.ico&quot;
101 ICON &quot;CESide.ico&quot;
</PRE>
</td></tr></table>

<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="441"><H3>DivFile.h</H3></A>
<P><pre>
//====================================================================

// Header file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================

// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

// **** Start of Generic COM declarations ****

//====================================================================
// MyClassFactory - Object declaration
//
class MyClassFactory : public IClassFactory {

private:
    long m_lRef;

public:
    MyClassFactory();
    ~MyClassFactory();

    // IUnknown methods
    STDMETHODIMP QueryInterface (THIS_ REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef (THIS);
    STDMETHODIMP_(ULONG) Release (THIS); 
    // IClassFactory methods
    STDMETHODIMP CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,
                                 LPVOID *ppv);
    STDMETHODIMP LockServer (BOOL fLock);
};

// **** End of Generic OLE declarations ****

//-----------------------------------------------------------------------
// Defines used by the DLL
//
#define BUFFSIZE        4096

#define FILESIZELIMIT   (100*1024)
#define FILEBREAKSIZE   (100*1024)

//====================================================================
// MyFileFilter - Object declaration
//
class MyFileFilter : public ICeFileFilter {

private:
    long m_lRef;
    BOOL m_fBreakFile;
    ULONG m_ulTotalMoved;

public:
    MyFileFilter();
    ~MyFileFilter();

    // IUnknown methods
    STDMETHODIMP QueryInterface (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef (THIS);
    STDMETHODIMP_(ULONG) Release (THIS);

    // ICeFileFilter methods
    STDMETHODIMP NextConvertFile (THIS_ int nConversion,
                        PFF_CONVERTINFO *pci, PFF_SOURCEFILE *psf,
                        PFF_DESTINATIONFILE *pdf,
                        volatile BOOL *pbCancel, PF_ERROR *perr);
    STDMETHODIMP FilterOptions (THIS_ HWND hwndParent);

    STDMETHODIMP FormatMessage (THIS_ DWORD dwFlags, DWORD dwMessageId,
                              DWORD dwLanguageId, LPTSTR lpBuffer,
                              DWORD dwSize, va_list *args, DWORD *pcb);
};
</pre>
</td></tr></table>

<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="442"><H3>DivFile.cpp</H3></A>

<P><pre>
//====================================================================

// DivFile - A Windows CE file filter DLL
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff

#define INITGUID
#include &lt;initguid.h&gt;                // GUID defines
#include &lt;replfilt.h&gt;                // Required for file filters
#include &lt;rapi.h&gt;                    // Required for RAPI functions

#include &quot;DivFile.h&quot;

HINSTANCE hInst;                     // DLL instance handle
long g_DllCnt = 0;                   // Global DLL reference count

// Replace this GUID with your own!
// {2B06F7A1-088E-11d2-93F1-204C4F4F5020}
static const GUID CLSID_MyCopyFilter =
{0x2b06f7a1, 0x88e, 0x11d2, {0x93,0xf1,0x20,0x4c,0x4f,0x4f,0x50,0x20}};

//====================================================================
// DllMain - DLL initialization entry point
//
BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD dwReason,
                     LPVOID lpvReserved) {
    hInst = hinstDLL;
    return TRUE;
}
//====================================================================
// DllGetClassObject - Exported function called to get pointer to
// Class factory object
//
STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID *ppv) {
    MyClassFactory *pcf;
    HRESULT hr;

    // See if caller wants us....
    if (IsEqualCLSID (rclsid, CLSID_MyCopyFilter)) {

        // Create class factory object.
        pcf = new MyClassFactory();
        if (pcf == NULL)
            return E_OUTOFMEMORY;

        // Call class factory's query interface method.
        hr = pcf-&gt;QueryInterface (riid, ppv);
        // This will cause an object delete unless interface found.
        pcf-&gt;Release();
        return hr;
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}
//====================================================================
// DllCanUnloadNow - Exported function called when DLL can unload
//
STDAPI DllCanUnloadNow () {

    if (g_DllCnt)
        return S_FALSE;

    return S_OK;
}
//********************************************************************
// MyClassFactory Object implementation
//-----------------------------------------------------------------------
// Object constructor
MyClassFactory::MyClassFactory () {

    m_lRef = 1;     // Set ref count to 1 on create.
    g_DllCnt++;
    return;
}
//-----------------------------------------------------------------------
// Object destructor

MyClassFactory::~MyClassFactory () {
    g_DllCnt&#8212;
    return;
}
//-----------------------------------------------------------------------
// QueryInterface - Called to see what interfaces this object supports
STDMETHODIMP MyClassFactory::QueryInterface (THIS_ REFIID riid,
                                             LPVOID *ppv) {

    // If caller wants our IUnknown or IClassFactory object,
    // return a pointer to the object.
    if (IsEqualIID (riid, IID_IUnknown) ||
        IsEqualIID (riid, IID_IClassFactory)){

        *ppv = (IClassFactory *)this;     // Return pointer to object.
        AddRef();                // Inc ref to prevent delete on return.
        return NOERROR;
    }
    *ppv = NULL;
    return (E_NOINTERFACE);
}
//-----------------------------------------------------------------------
// AddRef - Increment object ref count.
STDMETHODIMP_(ULONG) MyClassFactory::AddRef (THIS) {
    ULONG cnt;

    cnt = (ULONG)InterlockedIncrement (&amp;m_lRef);
    return cnt;
}
//-----------------------------------------------------------------------
// Release - Decrement object ref count.
STDMETHODIMP_(ULONG) MyClassFactory::Release (THIS) {
    ULONG cnt;

    cnt = (ULONG)InterlockedDecrement (&amp;m_lRef);
    if (cnt == 0) {
        delete this;
        return 0;
    }
    return cnt;
}
//-----------------------------------------------------------------------
// LockServer - Called to tell the DLL not to unload even if use cnt 0
STDMETHODIMP MyClassFactory::LockServer (BOOL fLock) {
    if (fLock)
        InterlockedIncrement (&amp;g_DllCnt);
    else
        InterlockedDecrement (&amp;g_DllCnt);

    return NOERROR;
}
//-----------------------------------------------------------------------
// CreateInstance - Called to have class factory object create other
// objects
STDMETHODIMP MyClassFactory::CreateInstance (LPUNKNOWN pUnkOuter,
                                             REFIID riid,
                                            LPVOID *ppv) {
    MyFileFilter *pMyff;
    HRESULT hr;

    if (pUnkOuter)
        return (CLASS_E_NOAGGREGATION);

    if (IsEqualIID (riid, IID_IUnknown) ||
        IsEqualIID (riid, IID_ICeFileFilter)) {

        // Create file filter object.
        pMyff = new MyFileFilter();
        if (!pMyff)
            return E_OUTOFMEMORY;

        // See if object exports the proper interface.
        hr = pMyff-&gt;QueryInterface (riid, ppv);
        // This will cause an object delete unless interface found.
        pMyff-&gt;Release ();
        return hr;
    }
    return E_NOINTERFACE;
}
//********************************************************************
// MyFileFilter Object implementation
//-----------------------------------------------------------------------
// Object constructor
MyFileFilter::MyFileFilter () {

    m_lRef = 1;     // Set ref count to 1 on create.
    return;
}
//-----------------------------------------------------------------------
// Object destructor
MyFileFilter::~MyFileFilter () {
    return;
}
//-----------------------------------------------------------------------
// QueryInterface - Called to see what interfaces this object supports
STDMETHODIMP MyFileFilter::QueryInterface (THIS_ REFIID riid,
                                             LPVOID *ppv) {

    // If caller wants our IUnknown or IID_ICeFileFilter object,
    // return a pointer to the object.
    if (IsEqualIID (riid, IID_IUnknown) ||
        IsEqualIID (riid, IID_ICeFileFilter)){

        // Return pointer to object.
        *ppv = (ICeFileFilter *)this;
        AddRef();                // Inc ref to prevent delete on return.
        return NOERROR;
    }
    *ppv = NULL;
    return (E_NOINTERFACE);
}
//-----------------------------------------------------------------------
// AddRef - Increment object ref count.
STDMETHODIMP_(ULONG) MyFileFilter::AddRef (THIS) {
    ULONG cnt;

    cnt = (ULONG)InterlockedIncrement (&amp;m_lRef);
    return cnt;
}
//-----------------------------------------------------------------------
// Release - Decrement object ref count.
STDMETHODIMP_(ULONG) MyFileFilter::Release (THIS) {
    ULONG cnt;

    cnt = (ULONG)InterlockedDecrement (&amp;m_lRef);
    if (cnt == 0)
        delete this;
    return cnt;
}
//-----------------------------------------------------------------------
// NextConvertFile - Called to convert the next file
STDMETHODIMP MyFileFilter::NextConvertFile (int nConversion,
                              CFF_CONVERTINFO *pci, CFF_SOURCEFILE *psf,
                              CFF_DESTINATIONFILE *pdf,
                              volatile BOOL *pbCancel, CF_ERROR *perr) {
    IStream *pstreamSrc;
    IStream  *pstreamDest;
    ICeFileFilterSite *pffs;
    CEOSVERSIONINFO vi;
    DWORD cBytesRemaining, cBytesRead, cCopySize;
    LARGE_INTEGER largMov;
    TCHAR szNewName[MAX_PATH];
    PBYTE pBuff;
    HRESULT hr;
    int i;

    // If first call for file, see if too large to fit in object store.
    if (nConversion == 0) {
        m_fBreakFile = FALSE;
        m_ulTotalMoved = 0;
        // If import to CE and file &gt; 4 MB, see if too big for
        // object store.
        if ((pci-&gt;bImport) &amp;&amp; psf-&gt;cbSize &gt; FILESIZELIMIT) {

            vi.dwOSVersionInfoSize = sizeof (vi);
            CeGetVersionEx (&amp;vi);
            // If version &lt; 2.1, ask user
            // if we should break file.
            i = (vi.dwMajorVersion &lt;&lt; 8) | vi.dwMinorVersion;
            if (i &lt; 0x20a) {
                i = MessageBox (pci-&gt;hwndParent,
                            TEXT (&quot;The file being copied is too \
large for the object store, would you like to break it into separate \
files?&quot;),
                            TEXT (&quot;Size Filter&quot;), MB_YESNO);
                if (i == IDYES)
                    m_fBreakFile = TRUE;
                else {
                    *perr = HRESULT_TO_PFERROR (hr,ERROR_ACCESS_DENIED);
                    return E_FAIL;
                }
            }
        }
    } else if (m_fBreakFile) {

        if ((UINT)(nConversion * FILEBREAKSIZE) &gt; psf-&gt;cbSize)
            return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    } else
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    // Allocate buffer for transfer.
    pBuff = (PBYTE)LocalAlloc (LPTR, BUFFSIZE);
    if (!pBuff) {
        *perr = HRESULT_TO_PFERROR (hr, E_OUTOFMEMORY);
        return E_FAIL;
    }
    // Get pointer to FileFilterSite interface.
    pffs = pci-&gt;pffs;

    // Open source file.
    hr = pffs-&gt;OpenSourceFile (PF_OPENFLAT, (PVOID *)&amp;pstreamSrc);

    if (!SUCCEEDED (hr)) {
        LocalFree (pBuff);
        *perr = HRESULT_TO_PFERROR (hr, ERROR_ACCESS_DENIED);
        return E_FAIL;
    }
    // Seek to part of file for this section.
    if (m_fBreakFile) {
        largMov.HighPart = 0;
        largMov.LowPart = nConversion * FILEBREAKSIZE;
        hr = pstreamSrc-&gt;Seek (largMov, STREAM_SEEK_SET, NULL);

        // Modify destination name to mark part. New name becomes
        // old name with a number appended for each part.
        wsprintf (szNewName, TEXT (&quot;%s%s_%d.%s&quot;),
                  pdf-&gt;szPath, pdf-&gt;szFilename, nConversion,
                  pdf-&gt;szExtension);

        hr = pffs-&gt;OpenDestinationFile (PF_OPENFLAT, szNewName,
                                        (PVOID *)&amp;pstreamDest);
        if (!SUCCEEDED (hr)) {
            LocalFree (pBuff);
            pffs-&gt;CloseSourceFile (pstreamSrc);
            *perr = HRESULT_TO_PFERROR (hr, ERROR_ACCESS_DENIED);
            return E_FAIL;
        }

    } else
        // Open destination file with default name.
        hr = pffs-&gt;OpenDestinationFile (PF_OPENFLAT, NULL,
                                        (PVOID *)&amp;pstreamDest);
    if (!SUCCEEDED (hr)) {
        LocalFree (pBuff);
        pffs-&gt;CloseSourceFile (pstreamSrc);
        *perr = HRESULT_TO_PFERROR (hr, ERROR_ACCESS_DENIED);
        return E_FAIL;
    }

    // Copy data.
    cCopySize = min (psf-&gt;cbSize - m_ulTotalMoved, FILEBREAKSIZE);
    for (cBytesRemaining = cCopySize; cBytesRemaining &gt; 0; ) {
        // Read the data.
        i = min (BUFFSIZE, cBytesRemaining);
        hr = pstreamSrc-&gt;Read (pBuff, i, &amp;cBytesRead);
        if (cBytesRead == 0)
            break;

        // See if user canceled the transfer.
        if (*pbCancel) {
            hr = ERROR_CANCELLED;
            break;
        }

        // Write the data and update bytes remaining.
        hr = pstreamDest-&gt;Write (pBuff, cBytesRead, NULL);
        if (!SUCCEEDED (hr))
            break;

        // Update transfer totals.
        m_ulTotalMoved += cBytesRead;
        cBytesRemaining -= cBytesRead;

        // Tell the user how far we've gotten.
        pffs-&gt;ReportProgress (m_ulTotalMoved/psf-&gt;cbSize * 100);
    }
    // Close files and clean up.
    pffs-&gt;CloseSourceFile (pstreamSrc);
    pffs-&gt;CloseDestinationFile (TRUE, pstreamDest);
    LocalFree (pBuff);

    if (hr == ERROR_CANCELLED)
        return HRESULT_FROM_WIN32 (ERROR_CANCELLED);

    if (!SUCCEEDED (hr)) {
        *perr = hr;
        return E_FAIL;
    }
    return NOERROR;
}
//-----------------------------------------------------------------------
// FilterOptions - Called to indicate the file filter options
STDMETHODIMP MyFileFilter::FilterOptions (HWND hwndParent) {
    MessageBox (hwndParent, TEXT (&quot;Filter Options Box&quot;), TEXT (&quot;Title&quot;),
                MB_OK);
    return NOERROR;
}
//-----------------------------------------------------------------------
// FormatMessage - Called to format error messages
//
STDMETHODIMP MyFileFilter::FormatMessage (DWORD dwFlags,
                            DWORD dwMessageId, DWORD dwLanguageId,
                            LPTSTR lpBuffer, DWORD dwSize,
                            va_list *args, DWORD *pcb) {
    DWORD cMsgLen;

    // Pass the error code on to the Win32 FormatMessage.  Force look
    // into message table of filter by ORing dwFlags with
    // FORMAT_MESSAGE_FROM_HMODULE.
    cMsgLen = ::FormatMessage (dwFlags | FORMAT_MESSAGE_FROM_HMODULE,
                               hInst, dwMessageId, dwLanguageId,
                               lpBuffer, dwSize, args);
    if (cMsgLen)
        *pcb = cMsgLen;
    else
        return E_FAIL;

    return NOERROR;
}
</pre>
</td></tr></table>

<P>The code that does the actual work of the file filter is contained in <I>NextConvertFile</I>. The routine uses the value in <I>nConversion</I> to see whether this is the first time it is being called to convert the file. If so, the routine checks the file size to see whether it's bigger than the arbitrary file size limit. If so, the user is asked if the file should be split into multiple files.

<P>The routine creates individual destination files by specifying a new name for the destination file when the routine calls <I>OpenDestinationFile</I>. For files that are split, the routine generates each new filename by appending a number to the end of the original filename. Note that the routine takes care to preserve the suggested path for the destination file. This path specifies the temporary directory on the PC that Windows CE Services uses before copying the converted file down to the Windows CE device. At this point, the source file is copied to the new destination file up to the limit of the destination file size. The files are then closed, and <I>NextConvertFile</I> returns.

<P>Windows CE Services calls <I>NextConvertFile</I> again, this time with <I>nConversion</I> incremented. The routine opens a new destination file and the old source file, then seeks to an offset in the source file that matches the last byte read in the previous call. The new data is then copied, and the routine again returns.

<P>This process of calling <I>NextConvertFile</I> is continued until the routine determines that all the source file has been copied into the various destination files. At this point, the routine returns ERROR_NO_MORE_ITEMS, which ends the conversion process for the file.

<P>Now I come to the end of my explanation of the PC-side Windows CE Services. In the next two chapters, I'll return to the Windows CE side of things to look at the shell. The Windows CE shell varies widely across the different platforms. The Handheld PC shell looks on the surface like a standard Windows 95 shell, although the programming interface is much simpler. The Palm-size PC shell, on the other hand, is new and unique.

<div class="note"><blockquote> 
<A NAME="443"><H2>COM Isn't a Four-Letter Word</H2></A>

<P>At this point, I've written 705 pages in a modern Windows programming book, and I have yet to explicate COM. It's amazing in this day and age that we've actually programmed almost an entire Windows system without COM. That avoidance ends here because COM is used extensively on the PC side of the Windows CE data synchronization interfaces.

<P>COM is the acronym for Component Object Model. In brief, COM is formally defined as <I>a binary standard for defining objects</I>. The classical definition of an object is <I>data surrounded by a collection of functions,</I> <I>usually called methods, which act on the data.</I> Sometimes people stretch this classical object definition when they talk about COM. It works out that the only internal data state that some COM objects have is a use count variable. That kind of COM object simply provides an interface that's used for some purpose or another. Plenty of COM objects do maintain some internal data but this condition isn't a requirement of a COM object.

<P>Many people have written and argued about COM. Various programmers think of COM as the Second Coming, the ultimate programming concept, or even the key to World Peace. On the other hand, others think of COM as the devil incarnate, a complex unworkable mess, or most evil of all, a way to keep dozens of authors employed writing books trying to explain it. In my mind, COM is simply a tool. Many books have been written about COM, but only one, <I>Mr. Bunny's Guide to Active X</I>, captures the essence of COM. Check it out if you get the opportunity.

<P>In the Appendix, &quot;<A HREF="appa.htm#3">COM Basics</a>,&quot; I touch ever so lightly on the subject of COM. I talk only about a few interfaces, and then only to the extremely shallow depth necessary to accomplish our task at hand, synchronizing data between a PC and a Windows CE device. This treatment doesn't do justice to COM nor is it meant to. I'm just trying to use a tool to accomplish a job.
</blockquote></div>

</BODY>
</HTML>




