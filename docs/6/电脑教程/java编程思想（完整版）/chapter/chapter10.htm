<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>Thinking in Java | Chinese Version by Trans Bot</title>

<meta name="Microsoft Theme" content="inmotion 111, default"></head>

<body background="../_themes/inmotion/inmtextb.gif" bgcolor="#FFFFCC" text="#000000" link="#800000" vlink="#996633" alink="#FF3399">
<center>
-------------------------------------------------<br>
<br>
<font color=blue><b>本教程由<a href="../about/index.htm">yyc,spirit</a>整理</b></font><br>
<br>
-------------------------------------------------
</center><br><br>

<p>第10章 Java IO系统<br>
<br>
“对语言设计人员来说，创建好的输入／输出系统是一项特别困难的任务。”<br>
<br>
由于存在大量不同的设计方案，所以该任务的困难性是很容易证明的。其中最大的挑战似乎是如何覆盖所有可能的因素。不仅有三种不同的种类的IO需要考虑（文件、控制台、网络连接），而且需要通过大量不同的方式与它们通信（顺序、随机访问、二进制、字符、按行、按字等等）。<br>
Java库的设计者通过创建大量类来攻克这个难题。事实上，Java的IO系统采用了如此多的类，以致刚开始会产生不知从何处入手的感觉（具有讽刺意味的是，Java的IO设计初衷实际要求避免过多的类）。从Java 
1.0升级到Java 1.1后，IO库的设计也发生了显著的变化。此时并非简单地用新库替换旧库，Sun的设计人员对原来的库进行了大手笔的扩展，添加了大量新的内容。因此，我们有时不得不混合使用新库与旧库，产生令人无奈的复杂代码。<br>
本章将帮助大家理解标准Java库内的各种IO类，并学习如何使用它们。本章的第一部分将介绍“旧”的Java 
1.0 IO流库，因为现在有大量代码仍在使用那个库。本章剩下的部分将为大家引入Java 
1.1 IO库的一些新特性。注意若用Java 1.1编译器来编译本章第一部分介绍的部分代码，可能会得到一条“不建议使用该特性”（Deprecated 
feature）警告消息。代码仍然能够使用；编译器只是建议我们换用本章后面要讲述的一些新特性。但我们这样做是有价值的，因为可以更清楚地认识老方法与新方法之间的一些差异，从而加深我们的理解（并可顺利阅读为Java 
1.0写的代码）。<br>
<br>
10.1 输入和输出<br>
可将Java库的IO类分割为输入与输出两个部分，这一点在用Web浏览器阅读联机Java类文档时便可知道。通过继承，从InputStream（输入流）衍生的所有类都拥有名为read()的基本方法，用于读取单个字节或者字节数组。类似地，从OutputStream衍生的所有类都拥有基本方法write()，用于写入单个字节或者字节数组。然而，我们通常不会用到这些方法；它们之所以存在，是因为更复杂的类可以利用它们，以便提供一个更有用的接口。因此，我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供自己期望的功能。我们之所以感到Java的流库（Stream 
Library）异常复杂，正是由于为了创建单独一个结果流，却需要创建多个对象的缘故。<br>
很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都从InputStream继承，而与输出有关的所有类都从OutputStream继承。<br>
<br>
10.1.1 InputStream的类型<br>
InputStream的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream子类）：<br>
(1) 字节数组<br>
(2) String对象<br>
(3) 文件<br>
(4) 
“管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。 
(5) 一系列其他流，以便我们将其统一收集到单独一个流内。<br>
(6) 其他起源地，如Internet连接等（将在本书后面的部分讲述）。<br>
<br>
除此以外，FilterInputStream也属于InputStream的一种类型，用它可为“破坏器”类提供一个基础类，以便将属性或者有用的接口同输入流连接到一起。这将在以后讨论。<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=76 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=90 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor
Arguments</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArray-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Allows a buffer in memory to be
used as an <B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The buffer from which to extract
the bytes.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringBuffer-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Converts a <B>String</B> into an
<B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B>. The underlying
implementation actually uses a <B>StringBuffer</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For reading information from a
file.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B> representing the
file name, or a <B>File</B> or <B>FileDescriptor</B> object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE>
<br>
类 功能 构建器参数／如何使用<br>
<br>
ByteArrayInputStream 允许内存中的一个缓冲区作为InputStream使用 
从中提取字节的缓冲区／作为一个数据源使用。通过将其同一个FilterInputStream对象连接，可提供一个有用的接口<br>
StringBufferInputStream 将一个String转换成InputStream 一个String（字串）。基础的实施方案实际采用一个StringBuffer（字串缓冲）／作为一个数据源使用。通过将其同一个FilterInputStream对象连接，可提供一个有用的接口<br>
FileInputStream 用于从文件读取信息 代表文件名的一个String，或者一个File或FileDescriptor对象／作为一个数据源使用。通过将其同一个FilterInputStream对象连接，可提供一个有用的接口<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Piped-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the data that&#8217;s
being written to the associated <B>PipedOutput-Stream</B>. Implements the
&#8220;piping&#8221; concept.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedOutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data in
multithreading. Connect it to a <B>FilterInputStream</B> object to provide a
useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Sequence-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Coverts two or more
<B>InputStream</B> objects into a single <B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Two <B>InputStream</B> objects or
an <B>Enumeration</B> for a container of <B>InputStream</B>
objects.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to
a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filter-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Abstract class which is an
interface for decorators that provide useful functionality to the other
<B>InputStream</B> classes. See Table 10-3.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-3.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-3.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545385"></A><A NAME="_Toc408018612"></A></TABLE>
<br>
PipedInputString 产生为相关的PipedOutputStream写的数据。实现了“管道化”的概念 
PipedOutputStream／作为一个数据源使用。通过将其同一个FilterInputStream对象连接，可提供一个有用的接口<br>
SequenceInputStream 将两个或更多的InputStream对象转换成单个InputStream使用 
两个InputStream对象或者一个Enumeration，用于InputStream对象的一个容器／作为一个数据源使用。通过将其同一个FilterInputStream对象连接，可提供一个有用的接口<br>
FilterInputStream 
对作为破坏器接口使用的类进行抽象；那个破坏器为其他InputStream类提供了有用的功能。参见表10.3 
参见表10.3／参见表10.3<br>
<br>
10.1.2 OutputStream的类型<br>
这一类别包括的类决定了我们的输入往何处去：一个字节数组（但没有String；假定我们可用字节数组创建一个）；一个文件；或者一个“管道”。<br>
除此以外，FilterOutputStream为“破坏器”类提供了一个基础类，它将属性或者有用的接口同输出流连接起来。这将在以后讨论。<br>

表10.2 OutputStream的类型<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=85 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=94 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
<TH WIDTH=157 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor
Arguments</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=157 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArray-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Creates a buffer in memory. All the
data that you send to the stream is placed in this buffer.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Optional initial size of the
buffer.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of
your data. Connect it to a <B>FilterOutputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For sending information to a
file.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B> representing the
file name, or a <B>File</B> or <B>FileDescriptor</B> object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of
your data. Connect it to a <B>FilterOutputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Piped-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any information you write to this
automatically ends up as input for the associated <B>PipedInput-Stream.</B>
Implements the &#8220;piping&#8221; concept.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedInputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of
your data for multithreading. Connect it to a <B>FilterOutputStream</B> object
to provide a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filter-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Abstract class which is an
interface for decorators that provide useful functionality to the other
<B>OutputStream</B> classes. See Table
</FONT><BR><FONT FACE="Georgia">10-4.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-4.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 10-4.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545386"></A><A NAME="_Toc408018613"></A></TABLE>
<br>
类 功能 构建器参数／如何使用<br>
<br>
ByteArrayOutputStream 
在内存中创建一个缓冲区。我们发送给流的所有数据都会置入这个缓冲区。 
可选缓冲区的初始大小／用于指出数据的目的地。若将其同FilterOutputStream对象连接到一起，可提供一个有用的接口<br>
FileOutputStream 将信息发给一个文件 用一个String代表文件名，或选用一个File或FileDescriptor对象／用于指出数据的目的地。若将其同FilterOutputStream对象连接到一起，可提供一个有用的接口<br>
PipedOutputStream 我们写给它的任何信息都会自动成为相关的PipedInputStream的输出。实现了“管道化”的概念 
PipedInputStream／为多线程处理指出自己数据的目的地／将其同FilterOutputStream对象连接到一起，便可提供一个有用的接口<br>
FilterOutputStream 
对作为破坏器接口使用的类进行抽象处理；那个破坏器为其他OutputStream类提供了有用的功能。参见表10.4 
参见表10.4／参见表10.4<br>
<br>
10.2 增添属性和有用的接口<br>
利用层次化对象动态和透明地添加单个对象的能力的做法叫作“装饰器”（Decorator）方案——“方案”属于本书第16章的主题（注释①）。装饰器方案规定封装于初始化对象中的所有对象都拥有相同的接口，以便利用装饰器的“透明”性质——我们将相同的消息发给一个对象，无论它是否已被“装饰”。这正是在Java 
IO库里存在“过滤器”（Filter）类的原因：抽象的“过滤器”类是所有装饰器的基础类（装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中）。<br>
子类处理要求大量子类对每种可能的组合提供支持时，便经常会用到装饰器——由于组合形式太多，造成子类处理变得不切实际。Java 
IO库要求许多不同的特性组合方案，这正是装饰器方案显得特别有用的原因。但是，装饰器方案也有自己的一个缺点。在我们写一个程序的时候，装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于Java 
IO库操作不便，我们必须创建许多类——“核心”IO类型加上所有装饰器——才能得到自己希望的单个IO对象。<br>
FilterInputStream和FilterOutputStream（这两个名字不十分直观）提供了相应的装饰器接口，用于控制一个特定的输入流（InputStream）或者输出流（OutputStream）。它们分别是从InputStream和OutputStream衍生出来的。此外，它们都属于抽象类，在理论上为我们与一个流的不同通信手段都提供了一个通用的接口。事实上，FilterInputStream和FilterOutputStream只是简单地模仿了自己的基础类，它们是一个装饰器的基本要求。<br>
<br>
10.2.1 通过FilterInputStream从InputStream里读入数据<br>
FilterInputStream类要完成两件全然不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，比如readByte()，readFloat()等等）。伴随对应的DataOutputStream，我们可通过数据“流”将基本类型的数据从一个地方搬到另一个地方。这些“地方”是由表10.1总结的那些类决定的。若读取块内的数据，并自己进行解析，就不需要用到DataInputStream。但在其他许多情况下，我们一般都想用它对自己读入的数据进行自动格式化。<br>
剩下的类用于修改InputStream的内部行为方式：是否进行缓冲，是否跟踪自己读入的数据行，以及是否能够推回一个字符等等。后两种类看起来特别象提供对构建一个编译器的支持（换言之，添加它们为了支持Java编译器的构建），所以在常规编程中一般都用不着它们。<br>
也许几乎每次都要缓冲自己的输入，无论连接的是哪个IO设备。所以IO库最明智的做法就是将未缓冲输入作为一种特殊情况处理，同时将缓冲输入接纳为标准做法。<br>

表10.3 FilterInputStream的类型<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor
Arguments</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Data-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Used in concert with
<B>DataOutputStream</B>, so you can read primitives (int, char, long, etc.) from
a stream in a portable fashion.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains a full interface to allow
you to read primitive types.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Buffered-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use this to prevent a physical read
every time you want more data. You&#8217;re saying &#8220;Use a
buffer.&#8221;</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B>, with optional
buffer size.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t provide an
interface <I>per se</I>, just a requirement that a buffer be used. Attach an
interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumber-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Keeps track of line numbers in the
input stream; you can call <B>getLineNumber(&#160;)</B> and
<B>setLineNumber(int)</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This just adds line numbering, so
you&#8217;ll probably attach an interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Pushback-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Has a one byte push-back buffer so
that you can push back the last character read.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Generally used in the scanner for a
compiler and probably included because the Java compiler needed it. You probably
won&#8217;t use this.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545388"></A><A NAME="_Toc408018615"></A></TABLE>
<br>
类 功能 构建器参数／如何使用<br>
<br>
DataInputStream 与DataOutputStream联合使用，使自己能以机动方式读取一个流中的基本数据类型（int，char，long等等） 
InputStream/包含了一个完整的接口，以便读取基本数据类型<br>
BufferedInputStream 
避免每次想要更多数据时都进行物理性的读取，告诉它“请先在缓冲区里找” 
InputStream，没有可选的缓冲区大小／本身并不能提供一个接口，只是发出使用缓冲区的要求。要求同一个接口对象连接到一起<br>
LineNumberInputStream 跟踪输入流中的行号；可调用getLineNumber()以及setLineNumber(int) 
只是添加对数据行编号的能力，所以可能需要同一个真正的接口对象连接<br>
PushbackInputStream 
有一个字节的后推缓冲区，以便后推读入的上一个字符 InputStream／通常由编译器在扫描器中使用，因为Java编译器需要它。一般不在自己的代码中使用<br>
<br>
10.2.2 通过FilterOutputStream向OutputStream里写入数据<br>
与DataInputStream对应的是DataOutputStream，后者对各个基本数据类型以及String对象进行格式化，并将其置入一个数据“流”中，以便任何机器上的DataInputStream都能正常地读取它们。所有方法都以“wirte”开头，例如writeByte()，writeFloat()等等。<br>
若想进行一些真正的格式化输出，比如输出到控制台，请使用PrintStream。利用它可以打印出所有基本数据类型以及String对象，并可采用一种易于查看的格式。这与DataOutputStream正好相反，后者的目标是将那些数据置入一个数据流中，以便DataInputStream能够方便地重新构造它们。System.out静态对象是一个PrintStream。<br>
PrintStream内两个重要的方法是print()和println()。它们已进行了覆盖处理，可打印出所有数据类型。print()和println()之间的差异是后者在操作完毕后会自动添加一个新行。<br>
BufferedOutputStream属于一种“修改器”，用于指示数据流使用缓冲技术，使自己不必每次都向流内物理性地写入数据。通常都应将它应用于文件处理和控制器IO。<br>
表10.4 FilterOutputStream的类型<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=85 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Function</FONT><BR></P></DIV>
</TH>
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Constructor Arguments
</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How to use it</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Data-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Used in concert with
<B>DataInputStream</B> so you can write primitives (int, char, long, etc.) to a
stream in a portable fashion.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains full interface to allow
you to write primitive types.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For producing formatted output.
While <B>DataOutputStream</B> handles the <I>storage</I> of data,
<B>PrintStream</B> handles <I>display</I>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B>, with optional
boolean indicating that the buffer is flushed with every
newline.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Should be the &#8220;final&#8221;
wrapping for your <B>OutputStream</B> object. You&#8217;ll probably use this a
lot.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Buffered-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use this to prevent a physical
write every time you send a piece of data. You&#8217;re saying &#8220;Use a
buffer.&#8221; You can call <B>flush(&#160;)</B> to flush the
buffer.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B>, with optional
buffer size.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t provide an
interface <I>per se</I>, just a requirement that a buffer is used. Attach an
interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545389"></A><A NAME="_Toc408018616"></A></TABLE>
<br>
类 功能 构建器参数／如何使用<br>
<br>
DataOutputStream 与DataInputStream配合使用，以便采用方便的形式将基本数据类型（int，char，long等）写入一个数据流 
OutputStream／包含了完整接口，以便我们写入基本数据类型<br>
PrintStream 用于产生格式化输出。DataOutputStream控制的是数据的“存储”，而PrintStream控制的是“显示” 
OutputStream，可选一个布尔参数，指示缓冲区是否与每个新行一同刷新／对于自己的OutputStream对象，应该用“final”将其封闭在内。可能经常都要用到它<br>
BufferedOutputStream 
用它避免每次发出数据的时候都要进行物理性的写入，要求它“请先在缓冲区里找”。可调用flush()，对缓冲区进行刷新 
OutputStream，可选缓冲区大小／本身并不能提供一个接口，只是发出使用缓冲区的要求。需要同一个接口对象连接到一起<br>
<br>
10.3 本身的缺陷：RandomAccessFile<br>
RandomAccessFile用于包含了已知长度记录的文件，以便我们能用seek()从一条记录移至另一条；然后读取或修改那些记录。各记录的长度并不一定相同；只要知道它们有多大以及置于文件何处即可。<br>
首先，我们有点难以相信RandomAccessFile不属于InputStream或者OutputStream分层结构的一部分。除了恰巧实现了DataInput以及DataOutput（这两者亦由DataInputStream和DataOutputStream实现）接口之外，它们与那些分层结构并无什么关系。它甚至没有用到现有InputStream或OutputStream类的功能——采用的是一个完全不相干的类。该类属于全新的设计，含有自己的全部（大多数为固有）方法。之所以要这样做，是因为RandomAccessFile拥有与其他IO类型完全不同的行为，因为我们可在一个文件里向前或向后移动。不管在哪种情况下，它都是独立运作的，作为Object的一个“直接继承人”使用。<br>
从根本上说，RandomAccessFile类似DataInputStream和DataOutputStream的联合使用。其中，getFilePointer()用于了解当前在文件的什么地方，seek()用于移至文件内的一个新地点，而length()用于判断文件的最大长度。此外，构建器要求使用另一个自变量（与C的fopen()完全一样），指出自己只是随机读（&quot;r&quot;），还是读写兼施（&quot;rw&quot;）。这里没有提供对“只写文件”的支持。也就是说，假如是从DataInputStream继承的，那么RandomAccessFile也有可能能很好地工作。<br>
还有更难对付的。很容易想象我们有时要在其他类型的数据流中搜索，比如一个ByteArrayInputStream，但搜索方法只有RandomAccessFile才会提供。而后者只能针对文件才能操作，不能针对数据流操作。此时，BufferedInputStream确实允许我们标记一个位置（使用mark()，它的值容纳于单个内部变量中），并用reset()重设那个位置。但这些做法都存在限制，并不是特别有用。<br>
<br>
10.4 File类<br>
File类有一个欺骗性的名字——通常会认为它对付的是一个文件，但实情并非如此。它既代表一个特定文件的名字，也代表目录内一系列文件的名字。若代表一个文件集，便可用list()方法查询这个集，返回的是一个字串数组。之所以要返回一个数组，而非某个灵活的集合类，是因为元素的数量是固定的。而且若想得到一个不同的目录列表，只需创建一个不同的File对象即可。事实上，“FilePath”（文件路径）似乎是一个更好的名字。本节将向大家完整地例示如何使用这个类，其中包括相关的FilenameFilter（文件名过滤器）接口。<br>
<br>
10.4.1 目录列表器<br>
现在假设我们想观看一个目录列表。可用两种方式列出File对象。若在不含自变量（参数）的情况下调用list()，会获得File对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择File对象来完成显示。<br>
下面是用于这个例子的代码（或在执行该程序时遇到困难，请参考第3章3.1.2小节“赋值”）：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DirList.java</font>
<font color=#009900>// Displays directory listing</font>
<font color=#0000ff>package</font> c10;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
      String[] list;
      <font color=#0000ff>if</font>(args.length == 0)
        list = path.list();
      <font color=#0000ff>else</font> 
        list = path.list(<font color=#0000ff>new</font> DirFilter(args[0]));
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
        System.out.println(list[i]);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
}

<font color=#0000ff>class</font> DirFilter <font color=#0000ff>implements</font> FilenameFilter {
  String afn;
  DirFilter(String afn) { <font color=#0000ff>this</font>.afn = afn; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Strip path information:</font>
    String f = <font color=#0000ff>new</font> File(name).getName();
    <font color=#0000ff>return</font> f.indexOf(afn) != -1;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
DirFilter类“实现”了interface FilenameFilter（关于接口的问题，已在第7章进行了详述）。下面让我们看看FilenameFilter接口有多么简单：<br>
<br>
public interface FilenameFilter {<br>
boolean accept(文件目录, 字串名);<br>
}<br>
<br>
它指出这种类型的所有对象都提供了一个名为accept()的方法。之所以要创建这样的一个类，背后的全部原因就是把accept()方法提供给list()方法，使list()能够“回调”accept()，从而判断应将哪些文件名包括到列表中。因此，通常将这种技术称为“回调”，有时也称为“算子”（也就是说，DirFilter是一个算子，因为它唯一的作用就是容纳一个方法）。由于list()采用一个FilenameFilter对象作为自己的自变量使用，所以我们能传递实现了FilenameFilter的任何类的一个对象，用它决定（甚至在运行期）list()方法的行为方式。回调的目的是在代码的行为上提供更大的灵活性。<br>
通过DirFilter，我们看出尽管一个“接口”只包含了一系列方法，但并不局限于只能写那些方法（但是，至少必须提供一个接口内所有方法的定义。在这种情况下，DirFilter构建器也会创建）。<br>
accept()方法必须接纳一个File对象，用它指示用于寻找一个特定文件的目录；并接纳一个String，其中包含了要寻找之文件的名字。可决定使用或忽略这两个参数之一，但有时至少要使用文件名。记住list()方法准备为目录对象中的每个文件名调用accept()，核实哪个应包含在内——具体由accept()返回的“布尔”结果决定。<br>
为确定我们操作的只是文件名，其中没有包含路径信息，必须采用String对象，并在它的外部创建一个File对象。然后调用getName()，它的作用是去除所有路径信息（采用与平台无关的方式）。随后，accept()用String类的indexOf()方法检查文件名内部是否存在搜索字串&quot;afn&quot;。若在字串内找到afn，那么返回值就是afn的起点索引；但假如没有找到，返回值就是-1。注意这只是一个简单的字串搜索例子，未使用常见的表达式“通配符”方案，比如&quot;fo?.b?r*&quot;；这种方案更难实现。<br>
list()方法返回的是一个数组。可查询这个数组的长度，然后在其中遍历，选定数组元素。与C和C++的类似行为相比，这种于方法内外方便游历数组的行为无疑是一个显著的进步。<br>
<br>
1. 匿名内部类<br>
下例用一个匿名内部类（已在第7章讲述）来重写显得非常理想。首先创建了一个filter()方法，它返回指向FilenameFilter的一个句柄：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DirList2.java</font>
<font color=#009900>// Uses Java 1.1 anonymous inner classes</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> FilenameFilter 
  filter(<font color=#0000ff>final</font> String afn) {
    <font color=#009900>// Creation of anonymous inner class:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> FilenameFilter() {
      String fn = afn;
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String n) {
        <font color=#009900>// Strip path information:</font>
        String f = <font color=#0000ff>new</font> File(n).getName();
        <font color=#0000ff>return</font> f.indexOf(fn) != -1;
      }
    }; <font color=#009900>// End of anonymous inner class</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
      String[] list;
      <font color=#0000ff>if</font>(args.length == 0)
        list = path.list();
      <font color=#0000ff>else</font> 
        list = path.list(filter(args[0]));
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
        System.out.println(list[i]);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
注意filter()的自变量必须是final。这一点是匿名内部类要求的，使其能使用来自本身作用域以外的一个对象。<br>
之所以认为这样做更好，是由于FilenameFilter类现在同DirList2紧密地结合在一起。然而，我们可采取进一步的操作，将匿名内部类定义成list()的一个参数，使其显得更加精简。如下所示：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: DirList3.java</font>
<font color=#009900>// Building the anonymous inner class "in-place"</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList3 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(<font color=#0000ff>final</font> String[] args) {
    <font color=#0000ff>try</font> {
      File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
      String[] list;
      <font color=#0000ff>if</font>(args.length == 0)
        list = path.list();
      <font color=#0000ff>else</font> 
        list = path.list(
          <font color=#0000ff>new</font> FilenameFilter() {
            <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
            accept(File dir, String n) {
              String f = <font color=#0000ff>new</font> File(n).getName();
              <font color=#0000ff>return</font> f.indexOf(args[0]) != -1;
            }
          });
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
        System.out.println(list[i]);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
main()现在的自变量是final，因为匿名内部类直接使用args[0]。<br>
这展示了如何利用匿名内部类快速创建精简的类，以便解决一些复杂的问题。由于Java中的所有东西都与类有关，所以它无疑是一种相当有用的编码技术。它的一个好处是将特定的问题隔离在一个地方统一解决。但在另一方面，这样生成的代码不是十分容易阅读，所以使用时必须慎重。<br>
<br>
2. 顺序目录列表<br>
经常都需要文件名以排好序的方式提供。由于Java 1.0和Java 1.1都没有提供对排序的支持（从Java 
1.2开始提供），所以必须用第8章创建的SortVector将这一能力直接加入自己的程序。就象下面这样：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SortedDirList.java</font>
<font color=#009900>// Displays sorted directory listing</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> c08.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortedDirList {
  <font color=#0000ff>private</font> File path;
  <font color=#0000ff>private</font> String[] list;
  <font color=#0000ff>public</font> SortedDirList(<font color=#0000ff>final</font> String afn) {
    path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    <font color=#0000ff>if</font>(afn == <font color=#0000ff>null</font>)
      list = path.list();
    <font color=#0000ff>else</font>
      list = path.list(
          <font color=#0000ff>new</font> FilenameFilter() {
            <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
            accept(File dir, String n) {
              String f = <font color=#0000ff>new</font> File(n).getName();
              <font color=#0000ff>return</font> f.indexOf(afn) != -1;
            }
          });
    sort();
  }
  <font color=#0000ff>void</font> print() {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> sort() {
    StrSortVector sv = <font color=#0000ff>new</font> StrSortVector();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      sv.addElement(list[i]);
    <font color=#009900>// The first time an element is pulled from</font>
    <font color=#009900>// the StrSortVector the list is sorted:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      list[i] = sv.elementAt(i);
  }
  <font color=#009900>// Test it:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SortedDirList sd;
    <font color=#0000ff>if</font>(args.length == 0)
      sd = <font color=#0000ff>new</font> SortedDirList(<font color=#0000ff>null</font>);
    <font color=#0000ff>else</font>
      sd = <font color=#0000ff>new</font> SortedDirList(args[0]);
    sd.print();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
这里进行了另外少许改进。不再是将path（路径）和list（列表）创建为main()的本地变量，它们变成了类的成员，使它们的值能在对象“生存”期间方便地访问。事实上，main()现在只是对类进行测试的一种方式。大家可以看到，一旦列表创建完毕，类的构建器就会自动开始对列表进行排序。<br>
这种排序不要求区分大小写，所以最终不会得到一组全部单词都以大写字母开头的列表，跟着是全部以小写字母开头的列表。然而，我们注意到在以相同字母开头的一组文件名中，大写字母是排在前面的——这对标准的排序来说仍是一种不合格的行为。Java 
1.2已成功解决了这个问题。<br>
<br>
10.4.2 检查与创建目录<br>
File类并不仅仅是对现有目录路径、文件或者文件组的一个表示。亦可用一个File对象新建一个目录，甚至创建一个完整的目录路径——假如它尚不存在的话。亦可用它了解文件的属性（长度、上一次修改日期、读／写属性等），检查一个File对象到底代表一个文件还是一个目录，以及删除一个文件等等。下列程序完整展示了如何运用File类剩下的这些方法：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MakeDirectories.java</font>
<font color=#009900>// Demonstrates the use of the File class to</font>
<font color=#009900>// create directories and manipulate files.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MakeDirectories {
  <font color=#0000ff>private</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> String usage =
    <font color=#004488>"Usage:MakeDirectories path1 ...\n"</font> +
    <font color=#004488>"Creates each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -d path1 ...\n"</font> +
    <font color=#004488>"Deletes each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -r path1 path2\n"</font> +
    <font color=#004488>"Renames from path1 to path2\n"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(usage);
    System.exit(1);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fileData(File f) {
    System.out.println(
      <font color=#004488>"Absolute path: "</font> + f.getAbsolutePath() +
      <font color=#004488>"\n Can read: "</font> + f.canRead() +
      <font color=#004488>"\n Can write: "</font> + f.canWrite() +
      <font color=#004488>"\n getName: "</font> + f.getName() +
      <font color=#004488>"\n getParent: "</font> + f.getParent() +
      <font color=#004488>"\n getPath: "</font> + f.getPath() +
      <font color=#004488>"\n length: "</font> + f.length() +
      <font color=#004488>"\n lastModified: "</font> + f.lastModified());
    <font color=#0000ff>if</font>(f.isFile())
      System.out.println(<font color=#004488>"it's a file"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(f.isDirectory())
      System.out.println(<font color=#004488>"it's a directory"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) usage();
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-r"</font>)) {
      <font color=#0000ff>if</font>(args.length != 3) usage();
      File 
        old = <font color=#0000ff>new</font> File(args[1]),
        rname = <font color=#0000ff>new</font> File(args[2]);
      old.renameTo(rname);
      fileData(old);
      fileData(rname);
      <font color=#0000ff>return</font>; <font color=#009900>// Exit main</font>
    }
    <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>boolean</font> del = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-d"</font>)) {
      count++;
      del = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>for</font>( ; count &lt; args.length; count++) {
      File f = <font color=#0000ff>new</font> File(args[count]);
      <font color=#0000ff>if</font>(f.exists()) {
        System.out.println(f + <font color=#004488>" exists"</font>);
        <font color=#0000ff>if</font>(del) {
          System.out.println(<font color=#004488>"deleting..."</font> + f);
          f.delete();
        }
      } 
      <font color=#0000ff>else</font> { <font color=#009900>// Doesn't exist</font>
        <font color=#0000ff>if</font>(!del) {
          f.mkdirs();
          System.out.println(<font color=#004488>"created "</font> + f);
        }
      }
      fileData(f);
    }  
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
在fileData()中，可看到应用了各种文件调查方法来显示与文件或目录路径有关的信息。<br>
main()应用的第一个方法是renameTo()，利用它可以重命名（或移动）一个文件至一个全新的路径（该路径由参数决定），它属于另一个File对象。这也适用于任何长度的目录。<br>
若试验上述程序，就可发现自己能制作任意复杂程度的一个目录路径，因为mkdirs()会帮我们完成所有工作。在Java 
1.0中，-d标志报告目录虽然已被删除，但它依然存在；但在Java 1.1中，目录会被实际删除。<br>
<br>
10.5 IO流的典型应用<br>
尽管库内存在大量IO流类，可通过多种不同的方式组合到一起，但实际上只有几种方式才会经常用到。然而，必须小心在意才能得到正确的组合。下面这个相当长的例子展示了典型IO配置的创建与使用，可在写自己的代码时将其作为一个参考使用。注意每个配置都以一个注释形式的编号起头，并提供了适当的解释信息。<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: IOStreamDemo.java</font>
<font color=#009900>// Typical IO Stream Configurations</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.tools.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOStreamDemo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#009900>// 1. Buffered input file</font>
      DataInputStream in =
        <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(args[0])));
      String s, s2 = <font color=#0000ff>new</font> String();
      <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
        s2 += s + <font color=#004488>"\n"</font>;
      in.close();

      <font color=#009900>// 2. Input from memory</font>
      StringBufferInputStream in2 =
          <font color=#0000ff>new</font> StringBufferInputStream(s2);
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in2.read()) != -1)
        System.out.print((<font color=#0000ff>char</font>)c);

      <font color=#009900>// 3. Formatted memory input</font>
      <font color=#0000ff>try</font> {
        DataInputStream in3 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#0000ff>new</font> StringBufferInputStream(s2));
        <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
          System.out.print((<font color=#0000ff>char</font>)in3.readByte());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(
          <font color=#004488>"End of stream encountered"</font>);
      }

      <font color=#009900>// 4. Line numbering &amp; file output</font>
      <font color=#0000ff>try</font> {
        LineNumberInputStream li =
          <font color=#0000ff>new</font> LineNumberInputStream(
            <font color=#0000ff>new</font> StringBufferInputStream(s2));
        DataInputStream in4 =
          <font color=#0000ff>new</font> DataInputStream(li);
        PrintStream out1 =
          <font color=#0000ff>new</font> PrintStream(
            <font color=#0000ff>new</font> BufferedOutputStream(
              <font color=#0000ff>new</font> FileOutputStream(
                <font color=#004488>"IODemo.out"</font>)));
        <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
          out1.println(
            <font color=#004488>"Line "</font> + li.getLineNumber() + s);
        out1.close(); <font color=#009900>// finalize() not reliable!</font>
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(
          <font color=#004488>"End of stream encountered"</font>);
      }

      <font color=#009900>// 5. Storing &amp; recovering data</font>
      <font color=#0000ff>try</font> {
        DataOutputStream out2 =
          <font color=#0000ff>new</font> DataOutputStream(
            <font color=#0000ff>new</font> BufferedOutputStream(
              <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
        out2.writeBytes(
          <font color=#004488>"Here's the value of pi: \n"</font>);
        out2.writeDouble(3.14159);
        out2.close();
        DataInputStream in5 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#0000ff>new</font> BufferedInputStream(
              <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
        System.out.println(in5.readLine());
        System.out.println(in5.readDouble());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(
          <font color=#004488>"End of stream encountered"</font>);
      }

      <font color=#009900>// 6. Reading/writing random access files</font>
      RandomAccessFile rf =
        <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        rf.writeDouble(i*1.414);
      rf.close();

      rf =
        <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
      rf.seek(5*8);
      rf.writeDouble(47.0001);
      rf.close();

      rf =
        <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"r"</font>);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        System.out.println(
          <font color=#004488>"Value "</font> + i + <font color=#004488>": "</font> +
          rf.readDouble());
      rf.close();

      <font color=#009900>// 7. File input shorthand</font>
      InFile in6 = <font color=#0000ff>new</font> InFile(args[0]);
      String s3 = <font color=#0000ff>new</font> String();
      System.out.println(
        <font color=#004488>"First line in file: "</font> +
        in6.readLine());
        in6.close();

      <font color=#009900>// 8. Formatted file output shorthand</font>
      PrintFile out3 = <font color=#0000ff>new</font> PrintFile(<font color=#004488>"Data2.txt"</font>);
      out3.print(<font color=#004488>"Test of PrintFile"</font>);
      out3.close();

      <font color=#009900>// 9. Data file output shorthand</font>
      OutFile out4 = <font color=#0000ff>new</font> OutFile(<font color=#004488>"Data3.txt"</font>);
      out4.writeBytes(<font color=#004488>"Test of outDataFile\n\r"</font>);
      out4.writeChars(<font color=#004488>"Test of outDataFile\n\r"</font>);
      out4.close();

    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"File Not Found:"</font> + args[0]);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(<font color=#004488>"IO Exception"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
10.5.1 输入流<br>
当然，我们经常想做的一件事情是将格式化的输出打印到控制台，但那已在第5章创建的com.bruceeckel.tools中得到了简化。<br>
第1到第4部分演示了输入流的创建与使用（尽管第4部分展示了将输出流作为一个测试工具的简单应用）。<br>
<br>
1. 缓冲的输入文件<br>
为打开一个文件以便输入，需要使用一个FileInputStream，同时将一个String或File对象作为文件名使用。为提高速度，最好先对文件进行缓冲处理，从而获得用于一个BufferedInputStream的构建器的结果句柄。为了以格式化的形式读取输入数据，我们将那个结果句柄赋给用于一个DataInputStream的构建器。DataInputStream是我们的最终（final）对象，并是我们进行读取操作的接口。<br>
在这个例子中，只用到了readLine()方法，但理所当然任何DataInputStream方法都可以采用。一旦抵达文件末尾，readLine()就会返回一个null（空），以便中止并退出while循环。<br>
“String s2”用于聚集完整的文件内容（包括必须添加的新行，因为readLine()去除了那些行）。随后，在本程序的后面部分中使用s2。最后，我们调用close()，用它关闭文件。从技术上说，会在运行finalize()时调用close()。而且我们希望一旦程序退出，就发生这种情况（无论是否进行垃圾收集）。然而，Java 
1.0有一个非常突出的错误（Bug），造成这种情况不会发生。在Java 1.1中，必须明确调用System.runFinalizersOnExit(true)，用它保证会为系统中的每个对象调用finalize()。然而，最安全的方法还是为文件明确调用close()。<br>
<br>
2. 从内存输入<br>
这一部分采用已经包含了完整文件内容的String s2，并用它创建一个StringBufferInputStream（字串缓冲输入流）——作为构建器的参数，要求使用一个String，而非一个StringBuffer）。随后，我们用read()依次读取每个字符，并将其发送至控制台。注意read()将下一个字节返回为int，所以必须将其造型为一个char，以便正确地打印。<br>
<br>
3. 格式化内存输入<br>
StringBufferInputStream的接口是有限的，所以通常需要将其封装到一个DataInputStream内，从而增强它的能力。然而，若选择用readByte()每次读出一个字符，那么所有值都是有效的，所以不可再用返回值来侦测何时结束输入。相反，可用available()方法判断有多少字符可用。下面这个例子展示了如何从文件中一次读出一个字符：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: TestEOF.java</font>
<font color=#009900>// Testing for the end of file while reading</font>
<font color=#009900>// a byte at a time.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestEOF {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      DataInputStream in = 
        <font color=#0000ff>new</font> DataInputStream(
         <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"TestEof.java"</font>)));
      <font color=#0000ff>while</font>(in.available() != 0)
        System.out.print((<font color=#0000ff>char</font>)in.readByte());
    } <font color=#0000ff>catch</font> (IOException e) {
      System.err.println(<font color=#004488>"IOException"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
注意取决于当前从什么媒体读入，avaiable()的工作方式也是有所区别的。它在字面上意味着“可以不受阻塞读取的字节数量”。对一个文件来说，它意味着整个文件。但对一个不同种类的数据流来说，它却可能有不同的含义。因此在使用时应考虑周全。<br>
为了在这样的情况下侦测输入的结束，也可以通过捕获一个违例来实现。然而，若真的用违例来控制数据流，却显得有些大材小用。<br>
<br>
4. 行的编号与文件输出<br>
这个例子展示了如何LineNumberInputStream来跟踪输入行的编号。在这里，不可简单地将所有构建器都组合起来，因为必须保持LineNumberInputStream的一个句柄（注意这并非一种继承环境，所以不能简单地将in4造型到一个LineNumberInputStream）。因此，li容纳了指向LineNumberInputStream的句柄，然后在它的基础上创建一个DataInputStream，以便读入数据。<br>
这个例子也展示了如何将格式化数据写入一个文件。首先创建了一个FileOutputStream，用它同一个文件连接。考虑到效率方面的原因，它生成了一个BufferedOutputStream。这几乎肯定是我们一般的做法，但却必须明确地这样做。随后为了进行格式化，它转换成一个PrintStream。用这种方式创建的数据文件可作为一个原始的文本文件读取。<br>
标志DataInputStream何时结束的一个方法是readLine()。一旦没有更多的字串可以读取，它就会返回null。每个行都会伴随自己的行号打印到文件里。该行号可通过li查询。<br>
可看到用于out1的、一个明确指定的close()。若程序准备掉转头来，并再次读取相同的文件，这种做法就显得相当有用。然而，该程序直到结束也没有检查文件IODemo.txt。正如以前指出的那样，如果不为自己的所有输出文件调用close()，就可能发现缓冲区不会得到刷新，造成它们不完整。。<br>
<br>
10.5.2 输出流<br>
两类主要的输出流是按它们写入数据的方式划分的：一种按人的习惯写入，另一种为了以后由一个DataInputStream而写入。RandomAccessFile是独立的，尽管它的数据格式兼容于DataInputStream和DataOutputStream。<br>
<br>
5. 保存与恢复数据<br>
PrintStream能格式化数据，使其能按我们的习惯阅读。但为了输出数据，以便由另一个数据流恢复，则需用一个DataOutputStream写入数据，并用一个DataInputStream恢复（获取）数据。当然，这些数据流可以是任何东西，但这里采用的是一个文件，并进行了缓冲处理，以加快读写速度。<br>
注意字串是用writeBytes()写入的，而非writeChars()。若使用后者，写入的就是16位Unicode字符。由于DataInputStream中没有补充的“readChars”方法，所以不得不用readChar()每次取出一个字符。所以对ASCII来说，更方便的做法是将字符作为字节写入，在后面跟随一个新行；然后再用readLine()将字符当作普通的ASCII行读回。<br>
writeDouble()将double数字保存到数据流中，并用补充的readDouble()恢复它。但为了保证任何读方法能够正常工作，必须知道数据项在流中的准确位置，因为既有可能将保存的double数据作为一个简单的字节序列读入，也有可能作为char或其他格式读入。所以必须要么为文件中的数据采用固定的格式，要么将额外的信息保存到文件中，以便正确判断数据的存放位置。<br>
<br>
6. 读写随机访问文件<br>
正如早先指出的那样，RandomAccessFile与IO层次结构的剩余部分几乎是完全隔离的，尽管它也实现了DataInput和DataOutput接口。所以不可将其与InputStream及OutputStream子类的任何部分关联起来。尽管也许能将一个ByteArrayInputStream当作一个随机访问元素对待，但只能用RandomAccessFile打开一个文件。必须假定RandomAccessFile已得到了正确的缓冲，因为我们不能自行选择。<br>
可以自行选择的是第二个构建器参数：可决定以“只读”（r）方式或“读写”（rw）方式打开一个RandomAccessFile文件。<br>
使用RandomAccessFile的时候，类似于组合使用DataInputStream和DataOutputStream（因为它实现了等同的接口）。除此以外，还可看到程序中使用了seek()，以便在文件中到处移动，对某个值作出修改。<br>
<br>
10.5.3 快捷文件处理<br>
由于以前采用的一些典型形式都涉及到文件处理，所以大家也许会怀疑为什么要进行那么多的代码输入——这正是装饰器方案一个缺点。本部分将向大家展示如何创建和使用典型文件读取和写入配置的快捷版本。这些快捷版本均置入packagecom.bruceeckel.tools中（自第5章开始创建）。为了将每个类都添加到库内，只需将其置入适当的目录，并添加对应的package语句即可。<br>
<br>
7. 快速文件输入<br>
若想创建一个对象，用它从一个缓冲的DataInputStream中读取一个文件，可将这个过程封装到一个名为InFile的类内。如下所示：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: InFile.java</font>
<font color=#009900>// Shorthand class for opening an input file</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InFile <font color=#0000ff>extends</font> DataInputStream {
  <font color=#0000ff>public</font> InFile(String filename)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>super</font>(
      <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(filename)));
  }
  <font color=#0000ff>public</font> InFile(File file)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>this</font>(file.getPath());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
无论构建器的String版本还是File版本都包括在内，用于共同创建一个FileInputStream。<br>
就象这个例子展示的那样，现在可以有效减少创建文件时由于重复强调造成的问题。<br>
<br>
8. 快速输出格式化文件<br>
亦可用同类型的方法创建一个PrintStream，令其写入一个缓冲文件。下面是对com.bruceeckel.tools的扩展：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: PrintFile.java</font>
<font color=#009900>// Shorthand class for opening an output file</font>
<font color=#009900>// for human-readable output.</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintFile <font color=#0000ff>extends</font> PrintStream {
  <font color=#0000ff>public</font> PrintFile(String filename)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>super</font>(
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(filename)));
  }
  <font color=#0000ff>public</font> PrintFile(File file)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>this</font>(file.getPath());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
注意构建器不可能捕获一个由基础类构建器“掷”出的违例。<br>
<br>
9. 快速输出数据文件<br>
最后，利用类似的快捷方式可创建一个缓冲输出文件，用它保存数据（与由人观看的数据格式相反）：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: OutFile.java</font>
<font color=#009900>// Shorthand class for opening an output file</font>
<font color=#009900>// for data storage.</font>
<font color=#0000ff>package</font> com.bruceeckel.tools;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> OutFile <font color=#0000ff>extends</font> DataOutputStream {
  <font color=#0000ff>public</font> OutFile(String filename)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>super</font>(
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(filename)));
  }
  <font color=#0000ff>public</font> OutFile(File file)
    <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>this</font>(file.getPath());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
非常奇怪的是（也非常不幸），Java库的设计者居然没想到将这些便利措施直接作为他们的一部分标准提供。<br>
<br>
10.5.4 从标准输入中读取数据<br>
以Unix首先倡导的“标准输入”、“标准输出”以及“标准错误输出”概念为基础，Java提供了相应的System.in，System.out以及System.err。贯这一整本书，大家都会接触到如何用System.out进行标准输出，它已预封装成一个PrintStream对象。System.err同样是一个PrintStream，但System.in是一个原始的InputStream，未进行任何封装处理。这意味着尽管能直接使用System.out和System.err，但必须事先封装System.in，否则不能从中读取数据。<br>
典型情况下，我们希望用readLine()每次读取一行输入信息，所以需要将System.in封装到一个DataInputStream中。这是Java 
1.0进行行输入时采取的“老”办法。在本章稍后，大家还会看到Java 
1.1的解决方案。下面是个简单的例子，作用是回应我们键入的每一行内容：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Echo.java</font>
<font color=#009900>// How to read from standard input</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Echo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    DataInputStream in =
      <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(System.in));
    String s;
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>((s = in.readLine()).length() != 0)
        System.out.println(s);
      <font color=#009900>// An empty line terminates the program</font>
    } <font color=#0000ff>catch</font>(IOException e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
之所以要使用try块，是由于readLine()可能“掷”出一个IOException。注意同其他大多数流一样，也应对System.in进行缓冲。<br>
由于在每个程序中都要将System.in封装到一个DataInputStream内，所以显得有点不方便。但采用这种设计方案，可以获得最大的灵活性。<br>
<br>
10.5.5 管道数据流<br>
本章已简要介绍了PipedInputStream（管道输入流）和PipedOutputStream（管道输出流）。尽管描述不十分详细，但并不是说它们作用不大。然而，只有在掌握了多线程处理的概念后，才可真正体会它们的价值所在。原因很简单，因为管道化的数据流就是用于线程之间的通信。这方面的问题将在第14章用一个示例说明。<br>
<br>
10.6 StreamTokenizer<br>
尽管StreamTokenizer并不是从InputStream或OutputStream衍生的，但它只随同InputStream工作，所以十分恰当地包括在库的IO部分中。<br>
StreamTokenizer类用于将任何InputStream分割为一系列“记号”（Token）。这些记号实际是一些断续的文本块，中间用我们选择的任何东西分隔。例如，我们的记号可以是单词，中间用空白（空格）以及标点符号分隔。<br>
下面是一个简单的程序，用于计算各个单词在文本文件中重复出现的次数：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SortedWordCount.java</font>
<font color=#009900>// Counts words in a file, outputs</font>
<font color=#009900>// results in sorted form.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> c08.*; <font color=#009900>// Contains StrSortVector</font>

<font color=#0000ff>class</font> Counter {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 1;
  <font color=#0000ff>int</font> read() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>void</font> increment() { i++; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SortedWordCount {
  <font color=#0000ff>private</font> FileInputStream file;
  <font color=#0000ff>private</font> StreamTokenizer st;
  <font color=#0000ff>private</font> Hashtable counts = <font color=#0000ff>new</font> Hashtable();
  SortedWordCount(String filename)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>try</font> {
      file = <font color=#0000ff>new</font> FileInputStream(filename);
      st = <font color=#0000ff>new</font> StreamTokenizer(file);
      st.ordinaryChar('.');
      st.ordinaryChar('-');
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"Could not open "</font> + filename);
      <font color=#0000ff>throw</font> e;
    }
  }
  <font color=#0000ff>void</font> cleanup() {
    <font color=#0000ff>try</font> {
      file.close();
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(
        <font color=#004488>"file.close() unsuccessful"</font>);
    }
  }
  <font color=#0000ff>void</font> countWords() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>(st.nextToken() !=
        StreamTokenizer.TT_EOF) {
        String s;
        <font color=#0000ff>switch</font>(st.ttype) {
          <font color=#0000ff>case</font> StreamTokenizer.TT_EOL:
            s = <font color=#0000ff>new</font> String(<font color=#004488>"EOL"</font>);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_NUMBER:
            s = Double.toString(st.nval);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_WORD:
            s = st.sval; <font color=#009900>// Already a String</font>
            <font color=#0000ff>break</font>;
          <font color=#0000ff>default</font>: <font color=#009900>// single character in ttype</font>
            s = String.valueOf((<font color=#0000ff>char</font>)st.ttype);
        }
        <font color=#0000ff>if</font>(counts.containsKey(s))
          ((Counter)counts.get(s)).increment();
        <font color=#0000ff>else</font>
          counts.put(s, <font color=#0000ff>new</font> Counter());
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(
        <font color=#004488>"st.nextToken() unsuccessful"</font>);
    }
  }
  Enumeration values() {
    <font color=#0000ff>return</font> counts.elements();
  }
  Enumeration keys() { <font color=#0000ff>return</font> counts.keys(); }
  Counter getCounter(String s) {
    <font color=#0000ff>return</font> (Counter)counts.get(s);
  }
  Enumeration sortedKeys() {
    Enumeration e = counts.keys();
    StrSortVector sv = <font color=#0000ff>new</font> StrSortVector();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      sv.addElement((String)e.nextElement());
    <font color=#009900>// This call forces a sort:</font>
    <font color=#0000ff>return</font> sv.elements();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      SortedWordCount wc =
        <font color=#0000ff>new</font> SortedWordCount(args[0]);
      wc.countWords();
      Enumeration keys = wc.sortedKeys();
      <font color=#0000ff>while</font>(keys.hasMoreElements()) {
        String key = (String)keys.nextElement();
        System.out.println(key + <font color=#004488>": "</font>
                 + wc.getCounter(key).read());
      }
      wc.cleanup();
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
最好将结果按排序格式输出，但由于Java 1.0和Java 1.1都没有提供任何排序方法，所以必须由自己动手。这个目标可用一个StrSortVector方便地达成（创建于第8章，属于那一章创建的软件包的一部分。记住本书所有子目录的起始目录都必须位于类路径中，否则程序将不能正确地编译）。<br>
为打开文件，使用了一个FileInputStream。而且为了将文件转换成单词，从FileInputStream中创建了一个StreamTokenizer。在StreamTokenizer中，存在一个默认的分隔符列表，我们可用一系列方法加入更多的分隔符。在这里，我们用ordinaryChar()指出“该字符没有特别重要的意义”，所以解析器不会把它当作自己创建的任何单词的一部分。例如，st.ordinaryChar('.')表示小数点不会成为解析出来的单词的一部分。在与Java配套提供的联机文档中，可以找到更多的相关信息。<br>
在countWords()中，每次从数据流中取出一个记号，而ttype信息的作用是判断对每个记号采取什么操作——因为记号可能代表一个行尾、一个数字、一个字串或者一个字符。<br>
找到一个记号后，会查询Hashtable counts，核实其中是否已经以“键”（Key）的形式包含了一个记号。若答案是肯定的，对应的Counter（计数器）对象就会增值，指出已找到该单词的另一个实例。若答案为否，则新建一个Counter——因为Counter构建器会将它的值初始化为1，正是我们计算单词数量时的要求。<br>
SortedWordCount并不属于Hashtable（散列表）的一种类型，所以它不会继承。它执行的一种特定类型的操作，所以尽管keys()和values()方法都必须重新揭示出来，但仍不表示应使用那个继承，因为大量Hashtable方法在这里都是不适当的。除此以外，对于另一些方法来说（比如getCounter()——用于获得一个特定字串的计数器；又如sortedKeys()——用于产生一个枚举），它们最终都改变了SortedWordCount接口的形式。<br>
在main()内，我们用SortedWordCount打开和计算文件中的单词数量——总共只用了两行代码。随后，我们为一个排好序的键（单词）列表提取出一个枚举。并用它获得每个键以及相关的Count（计数）。注意必须调用cleanup()，否则文件不能正常关闭。<br>
采用了StreamTokenizer的第二个例子将在第17章提供。<br>
<br>
10.6.1 StringTokenizer<br>
尽管并不必要IO库的一部分，但StringTokenizer提供了与StreamTokenizer极相似的功能，所以在这里一并讲述。<br>
StringTokenizer的作用是每次返回字串内的一个记号。这些记号是一些由制表站、空格以及新行分隔的连续字符。因此，字串“Where 
is my cat?”的记号分别是“Where”、“is”、“my”和“cat?”。与StreamTokenizer类似，我们可以指示StringTokenizer按照我们的愿望分割输入。但对于StringTokenizer，却需要向构建器传递另一个参数，即我们想使用的分隔字串。通常，如果想进行更复杂的操作，应使用StreamTokenizer。<br>
可用nextToken()向StringTokenizer对象请求字串内的下一个记号。该方法要么返回一个记号，要么返回一个空字串（表示没有记号剩下）。<br>
作为一个例子，下述程序将执行一个有限的句法分析，查询键短语序列，了解句子暗示的是快乐亦或悲伤的含义。<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: AnalyzeSentence.java</font>
<font color=#009900>// Look for particular sequences</font>
<font color=#009900>// within sentences.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AnalyzeSentence {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    analyze(<font color=#004488>"I am happy about this"</font>);
    analyze(<font color=#004488>"I am not happy about this"</font>);
    analyze(<font color=#004488>"I am not! I am happy"</font>);
    analyze(<font color=#004488>"I am sad about this"</font>);
    analyze(<font color=#004488>"I am not sad about this"</font>);
    analyze(<font color=#004488>"I am not! I am sad"</font>);
    analyze(<font color=#004488>"Are you happy about this?"</font>);
    analyze(<font color=#004488>"Are you sad about this?"</font>);
    analyze(<font color=#004488>"It's you! I am happy"</font>);
    analyze(<font color=#004488>"It's you! I am sad"</font>);
  }
  <font color=#0000ff>static</font> StringTokenizer st;
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> analyze(String s) {
    prt(<font color=#004488>"\nnew sentence &gt;&gt; "</font> + s);
    <font color=#0000ff>boolean</font> sad = <font color=#0000ff>false</font>;
    st = <font color=#0000ff>new</font> StringTokenizer(s);
    <font color=#0000ff>while</font> (st.hasMoreTokens()) {
      String token = next();
      <font color=#009900>// Look until you find one of the</font>
      <font color=#009900>// two starting tokens:</font>
      <font color=#0000ff>if</font>(!token.equals(<font color=#004488>"I"</font>) &amp;&amp;
         !token.equals(<font color=#004488>"Are"</font>))
        <font color=#0000ff>continue</font>; <font color=#009900>// Top of while loop</font>
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"I"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"am"</font>)) <font color=#009900>// Must be after I</font>
          <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
        <font color=#0000ff>else</font> {
          String tk3 = next();
          <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>)) {
            sad = <font color=#0000ff>true</font>;
            <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
          }
          <font color=#0000ff>if</font> (tk3.equals(<font color=#004488>"not"</font>)) {
            String tk4 = next();
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"sad"</font>))
              <font color=#0000ff>break</font>; <font color=#009900>// Leave sad false</font>
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"happy"</font>)) {
              sad = <font color=#0000ff>true</font>;
              <font color=#0000ff>break</font>;
            }
          }
        }
      }
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"Are"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"you"</font>))
          <font color=#0000ff>break</font>; <font color=#009900>// Must be after Are</font>
        String tk3 = next();
        <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>))
          sad = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
      }
    }
    <font color=#0000ff>if</font>(sad) prt(<font color=#004488>"Sad detected"</font>);
  }
  <font color=#0000ff>static</font> String next() {
    <font color=#0000ff>if</font>(st.hasMoreTokens()) {
      String s = st.nextToken();
      prt(s);
      <font color=#0000ff>return</font> s;
    } 
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>""</font>;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
对于准备分析的每个字串，我们进入一个while循环，并将记号从那个字串中取出。请注意第一个if语句，假如记号既不是“I”，也不是“Are”，就会执行continue（返回循环起点，再一次开始）。这意味着除非发现一个“I”或者“Are”，才会真正得到记号。大家可能想用==代替equals()方法，但那样做会出现不正常的表现，因为==比较的是句柄值，而equals()比较的是内容。<br>
analyze()方法剩余部分的逻辑是搜索“I am sad”（我很忧伤、“I am 
nothappy”（我不快乐）或者“Are you sad?”（你悲伤吗？）这样的句法格式。若没有break语句，这方面的代码甚至可能更加散乱。大家应注意对一个典型的解析器来说，通常都有这些记号的一个表格，并能在读取新记号的时候用一小段代码在表格内移动。<br>
无论如何，只应将StringTokenizer看作StreamTokenizer一种简单而且特殊的简化形式。然而，如果有一个字串需要进行记号处理，而且StringTokenizer的功能实在有限，那么应该做的全部事情就是用StringBufferInputStream将其转换到一个数据流里，再用它创建一个功能更强大的StreamTokenizer。<br>
<br>
10.7 Java 1.1的IO流<br>
到这个时候，大家或许会陷入一种困境之中，怀疑是否存在IO流的另一种设计方案，并可能要求更大的代码量。还有人能提出一种更古怪的设计吗？事实上，Java 
1.1对IO流库进行了一些重大的改进。看到Reader和Writer类时，大多数人的第一个印象（就象我一样）就是它们用来替换原来的InputStream和OutputStream类。但实情并非如此。尽管不建议使用原始数据流库的某些功能（如使用它们，会从编译器收到一条警告消息），但原来的数据流依然得到了保留，以便维持向后兼容，而且：<br>
(1) 在老式层次结构里加入了新类，所以Sun公司明显不会放弃老式数据流。<br>
(2) 
在许多情况下，我们需要与新结构中的类联合使用老结构中的类。为达到这个目的，需要使用一些“桥”类：InputStreamReader将一个InputStream转换成Reader，OutputStreamWriter将一个OutputStream转换成Writer。<br>
所以与原来的IO流库相比，经常都要对新IO流进行层次更多的封装。同样地，这也属于装饰器方案的一个缺点——需要为额外的灵活性付出代价。<br>
之所以在Java 1.1里添加了Reader和Writer层次，最重要的原因便是国际化的需求。老式IO流层次结构只支持8位字节流，不能很好地控制16位Unicode字符。由于Unicode主要面向的是国际化支持（Java内含的char是16位的Unicode），所以添加了Reader和Writer层次，以提供对所有IO操作中的Unicode的支持。除此之外，新库也对速度进行了优化，可比旧库更快地运行。<br>
与本书其他地方一样，我会试着提供对类的一个概述，但假定你会利用联机文档搞定所有的细节，比如方法的详尽列表等。<br>
<br>
10.7.1 数据的发起与接收<br>
Java 1.0的几乎所有IO流类都有对应的Java 1.1类，用于提供内建的Unicode管理。似乎最容易的事情就是“全部使用新类，再也不要用旧的”，但实际情况并没有这么简单。有些时候，由于受到库设计的一些限制，我们不得不使用Java 
1.0的IO流类。特别要指出的是，在旧流库的基础上新加了java.util.zip库，它们依赖旧的流组件。所以最明智的做法是“尝试性”地使用Reader和Writer类。若代码不能通过编译，便知道必须换回老式库。<br>
下面这张表格分旧库与新库分别总结了信息发起与接收之间的对应关系。<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sources &amp;
Sinks:</FONT><BR><FONT FACE="Georgia">Java 1.0 class</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Corresponding Java 1.1
class</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Reader</B>
</FONT><BR><FONT FACE="Georgia">converter:
<B>InputStreamReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Writer</B>
</FONT><BR><FONT FACE="Georgia">converter:
<B>OutputStreamWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringBufferInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(no corresponding
class)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArrayInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharArrayReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArrayOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharArrayWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE>
<br>
我们发现即使不完全一致，但旧库组件中的接口与新接口通常也是类似的。<br>
<br>
10.7.2 修改数据流的行为<br>
在Java 1.0中，数据流通过FilterInputStream和FilterOutputStream的“装饰器”（Decorator）子类适应特定的需求。Java 
1.1的IO流沿用了这一思想，但没有继续采用所有装饰器都从相同“filter”（过滤器）基础类中衍生这一做法。若通过观察类的层次结构来理解它，这可能令人出现少许的困惑。<br>
在下面这张表格中，对应关系比上一张表要粗糙一些。之所以会出现这个差别，是由类的组织造成的：尽管BufferedOutputStream是FilterOutputStream的一个子类，但是BufferedWriter并不是FilterWriter的子类（对后者来说，尽管它是一个抽象类，但没有自己的子类或者近似子类的东西，也没有一个“占位符”可用，所以不必费心地寻找）。然而，两个类的接口是非常相似的，而且不管在什么情况下，显然应该尽可能地使用新版本，而不应考虑旧版本（也就是说，除非在一些类中必须生成一个Stream，不可生成Reader或者Writer）。<br>
<TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=139 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Filters:</FONT><BR><FONT FACE="Georgia">Java
1.0 class</FONT><BR></P></DIV>
</TH>
<TH WIDTH=198 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Corresponding Java 1.1
class</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterWriter</B>
(<B>abstract</B> class with no subclasses)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedReader</B></FONT><BR><FONT FACE="Georgia">(also
has <B>readLine(&#160;)</B>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">use
<B>DataInputStream</B></FONT><BR><FONT FACE="Georgia">(Except when you
need to use <B>readLine(&#160;)</B>, when you should use a
<B>BufferedReader</B>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumberInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumberReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR><FONT FACE="Georgia">(use
constructor that takes a <B>Reader</B> instead)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PushBackInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PushBackReader</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE>
<br>
过滤器：Java 1.0类 对应的Java 1.1类<br>
<br>
FilterInputStream FilterReader<br>
FilterOutputStream FilterWriter（没有子类的抽象类）<br>
BufferedInputStream BufferedReader（也有readLine()）<br>
BufferedOutputStream BufferedWriter<br>
DataInputStream 使用DataInputStream（除非要使用readLine()，那时需要使用一个BufferedReader）<br>
PrintStream PrintWriter<br>
LineNumberInputStream LineNumberReader<br>
StreamTokenizer StreamTokenizer（用构建器取代Reader）<br>
PushBackInputStream PushBackReader<br>
<br>
有一条规律是显然的：若想使用readLine()，就不要再用一个DataInputStream来实现（否则会在编译期得到一条出错消息），而应使用一个BufferedReader。但除这种情况以外，DataInputStream仍是Java 
1.1 IO库的“首选”成员。<br>
为了将向PrintWriter的过渡变得更加自然，它提供了能采用任何OutputStream对象的构建器。PrintWriter提供的格式化支持没有PrintStream那么多；但接口几乎是相同的。<br>
<br>
10.7.3 未改变的类<br>
显然，Java库的设计人员觉得以前的一些类毫无问题，所以没有对它们作任何修改，可象以前那样继续使用它们：<br>
<br>
没有对应Java 1.1类的Java 1.0类<br>
<br>
DataOutputStream<br>
File<br>
RandomAccessFile<br>
SequenceInputStream<br>
<br>
特别未加改动的是DataOutputStream，所以为了用一种可转移的格式保存和获取数据，必须沿用InputStream和OutputStream层次结构。<br>
<br>
10.7.4 一个例子<br>
为体验新类的效果，下面让我们看看如何修改IOStreamDemo.java示例的相应区域，以便使用Reader和Writer类：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: NewIODemo.java</font>
<font color=#009900>// Java 1.1 IO typical usage</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> NewIODemo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      <font color=#009900>// 1. Reading input by lines:</font>
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(args[0]));
      String s, s2 = <font color=#0000ff>new</font> String();
      <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
        s2 += s + <font color=#004488>"\n"</font>;
      in.close();

      <font color=#009900>// 1b. Reading standard input:</font>
      BufferedReader stdin =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(System.in));      
      System.out.print(<font color=#004488>"Enter a line:"</font>);
      System.out.println(stdin.readLine());

      <font color=#009900>// 2. Input from memory</font>
      StringReader in2 = <font color=#0000ff>new</font> StringReader(s2);
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in2.read()) != -1)
        System.out.print((<font color=#0000ff>char</font>)c);

      <font color=#009900>// 3. Formatted memory input</font>
      <font color=#0000ff>try</font> {
        DataInputStream in3 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#009900>// Oops: must use deprecated class:</font>
            <font color=#0000ff>new</font> StringBufferInputStream(s2));
        <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
          System.out.print((<font color=#0000ff>char</font>)in3.readByte());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(<font color=#004488>"End of stream"</font>);
      }

      <font color=#009900>// 4. Line numbering &amp; file output</font>
      <font color=#0000ff>try</font> {
        LineNumberReader li =
          <font color=#0000ff>new</font> LineNumberReader(
            <font color=#0000ff>new</font> StringReader(s2));
        BufferedReader in4 =
          <font color=#0000ff>new</font> BufferedReader(li);
        PrintWriter out1 =
          <font color=#0000ff>new</font> PrintWriter(
            <font color=#0000ff>new</font> BufferedWriter(
              <font color=#0000ff>new</font> FileWriter(<font color=#004488>"IODemo.out"</font>)));
        <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
          out1.println(
            <font color=#004488>"Line "</font> + li.getLineNumber() + s);
        out1.close();
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(<font color=#004488>"End of stream"</font>);
      }

      <font color=#009900>// 5. Storing &amp; recovering data</font>
      <font color=#0000ff>try</font> {
        DataOutputStream out2 =
          <font color=#0000ff>new</font> DataOutputStream(
            <font color=#0000ff>new</font> BufferedOutputStream(
              <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
        out2.writeDouble(3.14159);
        out2.writeBytes(<font color=#004488>"That was pi"</font>);
        out2.close();
        DataInputStream in5 =
          <font color=#0000ff>new</font> DataInputStream(
            <font color=#0000ff>new</font> BufferedInputStream(
              <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
        BufferedReader in5br =
          <font color=#0000ff>new</font> BufferedReader(
            <font color=#0000ff>new</font> InputStreamReader(in5));
        <font color=#009900>// Must use DataInputStream for data:</font>
        System.out.println(in5.readDouble());
        <font color=#009900>// Can now use the "proper" readLine():</font>
        System.out.println(in5br.readLine());
      } <font color=#0000ff>catch</font>(EOFException e) {
        System.out.println(<font color=#004488>"End of stream"</font>);
      }

      <font color=#009900>// 6. Reading and writing random access</font>
      <font color=#009900>// files is the same as before.</font>
      <font color=#009900>// (not repeated here)</font>

    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.out.println(
        <font color=#004488>"File Not Found:"</font> + args[1]);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.out.println(<font color=#004488>"IO Exception"</font>);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
大家一般看见的是转换过程非常直观，代码看起来也颇相似。但这些都不是重要的区别。最重要的是，由于随机访问文件已经改变，所以第6节未再重复。<br>
第1节收缩了一点儿，因为假如要做的全部事情就是读取行输入，那么只需要将一个FileReader封装到BufferedReader之内即可。第1b节展示了封装System.in，以便读取控制台输入的新方法。这里的代码量增多了一些，因为System.in是一个DataInputStream，而且BufferedReader需要一个Reader参数，所以要用InputStreamReader来进行转换。<br>
在2节，可以看到如果有一个字串，而且想从中读取数据，只需用一个StringReader替换StringBufferInputStream，剩下的代码是完全相同的。<br>
第3节揭示了新IO流库设计中的一个错误。如果有一个字串，而且想从中读取数据，那么不能再以任何形式使用StringBufferInputStream。若编译一个涉及StringBufferInputStream的代码，会得到一条“反对”消息，告诉我们不要用它。此时最好换用一个StringReader。但是，假如要象第3节这样进行格式化的内存输入，就必须使用DataInputStream——没有什么“DataReader”可以代替它——而DataInputStream很不幸地要求用到一个InputStream参数。所以我们没有选择的余地，只好使用编译器不赞成的StringBufferInputStream类。编译器同样会发出反对信息，但我们对此束手无策（注释②）。<br>
StringReader替换StringBufferInputStream，剩下的代码是完全相同的。<br>
<br>
②：到你现在正式使用的时候，这个错误可能已经修正。<br>
<br>
第4节明显是从老式数据流到新数据流的一个直接转换，没有需要特别指出的。在第5节中，我们被强迫使用所有的老式数据流，因为DataOutputStream和DataInputStream要求用到它们，而且没有可供替换的东西。然而，编译期间不会产生任何“反对”信息。若不赞成一种数据流，通常是由于它的构建器产生了一条反对消息，禁止我们使用整个类。但在DataInputStream的情况下，只有readLine()是不赞成使用的，因为我们最好为readLine()使用一个BufferedReader（但为其他所有格式化输入都使用一个DataInputStream）。<br>
若比较第5节和IOStreamDemo.java中的那一小节，会注意到在这个版本中，数据是在文本之前写入的。那是由于Java 
1.1本身存在一个错误，如下述代码所示：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: IOBug.java</font>
<font color=#009900>// Java 1.1 (and higher?) IO Bug</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOBug {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> Exception {
    DataOutputStream out =
      <font color=#0000ff>new</font> DataOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
    out.writeDouble(3.14159);
    out.writeBytes(<font color=#004488>"That was the value of pi\n"</font>);
    out.writeBytes(<font color=#004488>"This is pi</font><font color=#004488>/2:\n"</font>);
    out.writeDouble(3.14159/2);
    out.close();

    DataInputStream in =
      <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
    BufferedReader inbr =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(in));
    <font color=#009900>// The doubles written BEFORE the line of text</font>
    <font color=#009900>// read back correctly:</font>
    System.out.println(in.readDouble());
    <font color=#009900>// Read the lines of text:</font>
    System.out.println(inbr.readLine());
    System.out.println(inbr.readLine());
    <font color=#009900>// Trying to read the doubles after the line</font>
    <font color=#009900>// produces an end-of-file exception:</font>
    System.out.println(in.readDouble());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
看起来，我们在对一个writeBytes()的调用之后写入的任何东西都不是能够恢复的。这是一个十分有限的错误，希望在你读到本书的时候已获得改正。为检测是否改正，请运行上述程序。若没有得到一个违例，而且值都能正确打印出来，就表明已经改正。<br>
<br>
10.7.5 重导向标准IO<br>
Java 1.1在System类中添加了特殊的方法，允许我们重新定向标准输入、输出以及错误IO流。此时要用到下述简单的静态方法调用：<br>
setIn(InputStream)<br>
setOut(PrintStream)<br>
setErr(PrintStream)<br>
如果突然要在屏幕上生成大量输出，而且滚动的速度快于人们的阅读速度，输出的重定向就显得特别有用。在一个命令行程序中，如果想重复测试一个特定的用户输入序列，输入的重定向也显得特别有价值。下面这个简单的例子展示了这些方法的使用：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Redirecting.java</font>
<font color=#009900>// Demonstrates the use of redirection for </font>
<font color=#009900>// standard IO in Java 1.1</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Redirecting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      BufferedInputStream in = 
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(
            <font color=#004488>"Redirecting.java"</font>));
      <font color=#009900>// Produces deprecation message:</font>
      PrintStream out =
        <font color=#0000ff>new</font> PrintStream(
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.out"</font>)));
      System.setIn(in);
      System.setOut(out);
      System.setErr(out);

      BufferedReader br = 
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(System.in));
      String s;
      <font color=#0000ff>while</font>((s = br.readLine()) != <font color=#0000ff>null</font>)
        System.out.println(s);
      out.close(); <font color=#009900>// Remember this!</font>
    } <font color=#0000ff>catch</font>(IOException e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
这个程序的作用是将标准输入同一个文件连接起来，并将标准输出和错误重定向至另一个文件。<br>
这是不可避免会遇到“反对”消息的另一个例子。用-deprecation标志编译时得到的消息如下：<br>
<br>
Note:The constructor java.io.PrintStream(java.io.OutputStream) has been deprecated.<br>
注意：不推荐使用构建器java.io.PrintStream（java.io.OutputStream）。<br>
<br>
然而，无论System.setOut()还是System.setErr()都要求用一个PrintStream作为参数使用，所以必须调用PrintStream构建器。所以大家可能会觉得奇怪，既然Java 
1.1通过反对构建器而反对了整个PrintStream，为什么库的设计人员在添加这个反对的同时，依然为System添加了新方法，且指明要求用PrintStream，而不是用PrintWriter呢？毕竟，后者是一个崭新和首选的替换措施呀？这真令人费解。<br>
<br>
10.8 压缩<br>
Java 1.1也添加一个类，用以支持对压缩格式的数据流的读写。它们封装到现成的IO类中，以提供压缩功能。<br>
此时Java 1.1的一个问题显得非常突出：它们不是从新的Reader和Writer类衍生出来的，而是属于InputStream和OutputStream层次结构的一部分。所以有时不得不混合使用两种类型的数据流（注意可用InputStreamReader和OutputStreamWriter在不同的类型间方便地进行转换）。<br>
<br>
Java 1.1压缩类 功能<br>
<br>
CheckedInputStream GetCheckSum()为任何InputStream产生校验和（不仅是解压）<br>
CheckedOutputStream GetCheckSum()为任何OutputStream产生校验和（不仅是解压）<br>
DeflaterOutputStream 用于压缩类的基础类<br>
ZipOutputStream 一个DeflaterOutputStream，将数据压缩成Zip文件格式<br>
GZIPOutputStream 一个DeflaterOutputStream，将数据压缩成GZIP文件格式<br>
InflaterInputStream 用于解压类的基础类<br>
ZipInputStream 一个DeflaterInputStream，解压用Zip文件格式保存的数据<br>
GZIPInputStream 一个DeflaterInputStream，解压用GZIP文件格式保存的数据<br>
<br>
尽管存在许多种压缩算法，但是Zip和GZIP可能最常用的。所以能够很方便地用多种现成的工具来读写这些格式的压缩数据。<br>
<br>
10.8.1 用GZIP进行简单压缩<br>
GZIP接口非常简单，所以如果只有单个数据流需要压缩（而不是一系列不同的数据），那么它就可能是最适当选择。下面是对单个文件进行压缩的例子：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: GZIPcompress.java</font>
<font color=#009900>// Uses Java 1.1 GZIP compression to compress</font>
<font color=#009900>// a file whose name is passed on the command</font>
<font color=#009900>// line.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GZIPcompress {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(args[0]));
      BufferedOutputStream out =
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> GZIPOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.gz"</font>)));
      System.out.println(<font color=#004488>"Writing file"</font>);
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in.read()) != -1)
        out.write(c);
      in.close();
      out.close();
      System.out.println(<font color=#004488>"Reading file"</font>);
      BufferedReader in2 =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(
            <font color=#0000ff>new</font> GZIPInputStream(
              <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.gz"</font>))));
      String s;
      <font color=#0000ff>while</font>((s = in2.readLine()) != <font color=#0000ff>null</font>)
        System.out.println(s);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
压缩类的用法非常直观——只需将输出流封装到一个GZIPOutputStream或者ZipOutputStream内，并将输入流封装到GZIPInputStream或者ZipInputStream内即可。剩余的全部操作就是标准的IO读写。然而，这是一个很典型的例子，我们不得不混合使用新旧IO流：数据的输入使用Reader类，而GZIPOutputStream的构建器只能接收一个OutputStream对象，不能接收Writer对象。<br>
<br>
10.8.2 用Zip进行多文件保存<br>
提供了Zip支持的Java 1.1库显得更加全面。利用它可以方便地保存多个文件。甚至有一个独立的类来简化对Zip文件的读操作。这个库采采用的是标准Zip格式，所以能与当前因特网上使用的大量压缩、解压工具很好地协作。下面这个例子采取了与前例相同的形式，但能根据我们需要控制任意数量的命令行参数。除此之外，它展示了如何用Checksum类来计算和校验文件的“校验和”（Checksum）。可选用两种类型的Checksum：Adler32（速度要快一些）和CRC32（慢一些，但更准确）。<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ZipCompress.java</font>
<font color=#009900>// Uses Java 1.1 Zip compression to compress</font>
<font color=#009900>// any number of files whose names are passed</font>
<font color=#009900>// on the command line.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ZipCompress {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>try</font> {
      FileOutputStream f =
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.zip"</font>);
      CheckedOutputStream csum =
        <font color=#0000ff>new</font> CheckedOutputStream(
          f, <font color=#0000ff>new</font> Adler32());
      ZipOutputStream out =
        <font color=#0000ff>new</font> ZipOutputStream(
          <font color=#0000ff>new</font> BufferedOutputStream(csum));
      out.setComment(<font color=#004488>"A test of Java Zipping"</font>);
      <font color=#009900>// Can't read the above comment, though</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; args.length; i++) {
        System.out.println(
          <font color=#004488>"Writing file "</font> + args[i]);
        BufferedReader in =
          <font color=#0000ff>new</font> BufferedReader(
            <font color=#0000ff>new</font> FileReader(args[i]));
        out.putNextEntry(<font color=#0000ff>new</font> ZipEntry(args[i]));
        <font color=#0000ff>int</font> c;
        <font color=#0000ff>while</font>((c = in.read()) != -1)
          out.write(c);
        in.close();
      }
      out.close();
      <font color=#009900>// Checksum valid only after the file</font>
      <font color=#009900>// has been closed!</font>
      System.out.println(<font color=#004488>"Checksum: "</font> +
        csum.getChecksum().getValue());
      <font color=#009900>// Now extract the files:</font>
      System.out.println(<font color=#004488>"Reading file"</font>);
      FileInputStream fi =
         <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.zip"</font>);
      CheckedInputStream csumi =
        <font color=#0000ff>new</font> CheckedInputStream(
          fi, <font color=#0000ff>new</font> Adler32());
      ZipInputStream in2 =
        <font color=#0000ff>new</font> ZipInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(csumi));
      ZipEntry ze;
      System.out.println(<font color=#004488>"Checksum: "</font> +
        csumi.getChecksum().getValue());
      <font color=#0000ff>while</font>((ze = in2.getNextEntry()) != <font color=#0000ff>null</font>) {
        System.out.println(<font color=#004488>"Reading file "</font> + ze);
        <font color=#0000ff>int</font> x;
        <font color=#0000ff>while</font>((x = in2.read()) != -1)
          System.out.write(x);
      }
      in2.close();
      <font color=#009900>// Alternative way to open and read</font>
      <font color=#009900>// zip files:</font>
      ZipFile zf = <font color=#0000ff>new</font> ZipFile(<font color=#004488>"test.zip"</font>);
      Enumeration e = zf.entries();
      <font color=#0000ff>while</font>(e.hasMoreElements()) {
        ZipEntry ze2 = (ZipEntry)e.nextElement();
        System.out.println(<font color=#004488>"File: "</font> + ze2);
        <font color=#009900>// ... and extract the data as before</font>
      }
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
对于要加入压缩档的每一个文件，都必须调用putNextEntry()，并将其传递给一个ZipEntry对象。ZipEntry对象包含了一个功能全面的接口，利用它可以获取和设置Zip文件内那个特定的Entry（入口）上能够接受的所有数据：名字、压缩后和压缩前的长度、日期、CRC校验和、额外字段的数据、注释、压缩方法以及它是否一个目录入口等等。然而，虽然Zip格式提供了设置密码的方法，但Java的Zip库没有提供这方面的支持。而且尽管CheckedInputStream和CheckedOutputStream同时提供了对Adler32和CRC32校验和的支持，但是ZipEntry只支持CRC的接口。这虽然属于基层Zip格式的限制，但却限制了我们使用速度更快的Adler32。<br>
为解压文件，ZipInputStream提供了一个getNextEntry()方法，能在有的前提下返回下一个ZipEntry。作为一个更简洁的方法，可以用ZipFile对象读取文件。该对象有一个entries()方法，可以为ZipEntry返回一个Enumeration（枚举）。<br>
为读取校验和，必须多少拥有对关联的Checksum对象的访问权限。在这里保留了指向CheckedOutputStream和CheckedInputStream对象的一个句柄。但是，也可以只占有指向Checksum对象的一个句柄。<br>
Zip流中一个令人困惑的方法是setComment()。正如前面展示的那样，我们可在写一个文件时设置注释内容，但却没有办法取出ZipInputStream内的注释。看起来，似乎只能通过ZipEntry逐个入口地提供对注释的完全支持。<br>
当然，使用GZIP或Zip库时并不仅仅限于文件——可以压缩任何东西，包括要通过网络连接发送的数据。<br>
<br>
10.8.3 Java归档（jar）实用程序<br>
Zip格式亦在Java 1.1的JAR（Java ARchive）文件格式中得到了采用。这种文件格式的作用是将一系列文件合并到单个压缩文件里，就象Zip那样。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。除了可以包括声音和图像文件以外，也可以在其中包括类文件。<br>
涉及因特网应用时，JAR文件显得特别有用。在JAR文件之前，Web浏览器必须重复多次请求Web服务器，以便下载完构成一个“程序片”（Applet）的所有文件。除此以外，每个文件都是未经压缩的。但在将所有这些文件合并到一个JAR文件里以后，只需向远程服务器发出一次请求即可。同时，由于采用了压缩技术，所以可在更短的时间里获得全部数据。另外，JAR文件里的每个入口（条目）都可以加上数字化签名（详情参考Java用户文档）。<br>
一个JAR文件由一系列采用Zip压缩格式的文件构成，同时还有一张“详情单”，对所有这些文件进行了描述（可创建自己的详情单文件；否则，jar程序会为我们代劳）。在联机用户文档中，可以找到与JAR详情单更多的资料（详情单的英语是“Manifest”）。<br>
jar实用程序已与Sun的JDK配套提供，可以按我们的选择自动压缩文件。请在命令行调用它：<br>
<br>
jar [选项] 说明 [详情单] 输入文件<br>
<br>
其中，“选项”用一系列字母表示（不必输入连字号或其他任何指示符）。如下所示：<br>

<br>
c 创建新的或空的压缩档<br>
t 列出目录表<br>
x 解压所有文件<br>
x file 解压指定文件<br>
f 指出“我准备向你提供文件名”。若省略此参数，jar会假定它的输入来自标准输入；或者在它创建文件时，输出会进入标准输出内<br>
m 指出第一个参数将是用户自建的详情表文件的名字<br>
v 产生详细输出，对jar做的工作进行巨细无遗的描述<br>
O 只保存文件；不压缩文件（用于创建一个JAR文件，以便我们将其置入自己的类路径中）<br>
M 不自动生成详情表文件<br>
<br>
在准备进入JAR文件的文件中，若包括了一个子目录，那个子目录会自动添加，其中包括它自己的所有子目录，以此类推。路径信息也会得到保留。<br>
下面是调用jar的一些典型方法：<br>
<br>
jar cf myJarFile.jar *.class<br>
用于创建一个名为myJarFile.jar的JAR文件，其中包含了当前目录中的所有类文件，同时还有自动产生的详情表文件。<br>
<br>
jar cmf myJarFile.jar myManifestFile.mf *.class<br>
与前例类似，但添加了一个名为myManifestFile.mf的用户自建详情表文件。<br>
<br>
jar tf myJarFile.jar<br>
生成myJarFile.jar内所有文件的一个目录表。<br>
<br>
jar tvf myJarFile.jar<br>
添加“verbose”（详尽）标志，提供与myJarFile.jar中的文件有关的、更详细的资料。<br>
<br>
jar cvf myApp.jar audio classes image<br>
假定audio，classes和image是子目录，这样便将所有子目录合并到文件myApp.jar中。其中也包括了“verbose”标志，可在jar程序工作时反馈更详尽的信息。<br>
<br>
如果用O选项创建了一个JAR文件，那个文件就可置入自己的类路径（CLASSPATH）中：<br>
CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;<br>
Java能在lib1.jar和lib2.jar中搜索目标类文件。<br>
<br>
jar工具的功能没有zip工具那么丰富。例如，不能够添加或更新一个现成JAR文件中的文件，只能从头开始新建一个JAR文件。此外，不能将文件移入一个JAR文件，并在移动后将它们删除。然而，在一种平台上创建的JAR文件可在其他任何平台上由jar工具毫无阻碍地读出（这个问题有时会困扰zip工具）。<br>
正如大家在第13章会看到的那样，我们也用JAR为Java Beans打包。<br>
<br>
10.9 对象序列化<br>
Java 1.1增添了一种有趣的特性，名为“对象序列化”（Object 
Serialization）。它面向那些实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。<br>
就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现“有限持久化”。请记住“持久化”意味着对象的“生存时间”并不取决于程序是否正在执行——它存在或“生存”于程序的每一次调用之间。通过序列化一个对象，将其写入磁盘，以后在程序重新调用时重新恢复那个对象，就能圆满实现一种“持久”效果。之所以称其为“有限”，是因为不能用某种“persistent”（持久）关键字简单地地定义一个对象，并让系统自动照看其他所有细节问题（尽管将来可能成为现实）。相反，必须在自己的程序中明确地序列化和组装对象。<br>
语言里增加了对象序列化的概念后，可提供对两种主要特性的支持。Java 
1.1的“远程方法调用”（RMI）使本来存在于其他机器的对象可以表现出好象就在本地机器上的行为。将消息发给远程对象时，需要通过对象序列化来传输参数和返回值。RMI将在第15章作具体讨论。<br>
对象的序列化也是Java Beans必需的，后者由Java 1.1引入。使用一个Bean时，它的状态信息通常在设计期间配置好。程序启动以后，这种状态信息必须保存下来，以便程序启动以后恢复；具体工作由对象序列化完成。<br>
对象的序列化处理非常简单，只需对象实现了Serializable接口即可（该接口仅是一个标记，没有方法）。在Java 
1.1中，许多标准库类都发生了改变，以便能够序列化——其中包括用于基本数据类型的全部封装器、所有集合类以及其他许多东西。甚至Class对象也可以序列化（第11章讲述了具体实现过程）。<br>
为序列化一个对象，首先要创建某些OutputStream对象，然后将其封装到ObjectOutputStream对象内。此时，只需调用writeObject()即可完成对象的序列化，并将其发送给OutputStream。相反的过程是将一个InputStream封装到ObjectInputStream内，然后调用readObject()。和往常一样，我们最后获得的是指向一个上溯造型Object的句柄，所以必须下溯造型，以便能够直接设置。<br>
对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内包含的所有句柄并保存那些对象；接着又能对每个对象内包含的句柄进行追踪；以此类推。我们有时将这种情况称为“对象网”，单个对象可与之建立连接。而且它还包含了对象的句柄数组以及成员对象。若必须自行操纵一套对象序列化机制，那么在代码里追踪所有这些链接时可能会显得非常麻烦。在另一方面，由于Java对象的序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子对序列化机制进行了测试。它建立了许多链接对象的一个“Worm”（蠕虫），每个对象都与Worm中的下一段链接，同时又与属于不同类（Data）的对象句柄数组链接：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Worm.java</font>
<font color=#009900>// Demonstrates object serialization in Java 1.1</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Data <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  Data(<font color=#0000ff>int</font> x) { i = x; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> Integer.toString(i);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Worm <font color=#0000ff>implements</font> Serializable {
  <font color=#009900>// Generate a random int value:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> r() {
    <font color=#0000ff>return</font> (<font color=#0000ff>int</font>)(Math.random() * 10);
  }
  <font color=#0000ff>private</font> Data[] d = {
    <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r())
  };
  <font color=#0000ff>private</font> Worm next;
  <font color=#0000ff>private</font> <font color=#0000ff>char</font> c;
  <font color=#009900>// Value of i == number of segments</font>
  Worm(<font color=#0000ff>int</font> i, <font color=#0000ff>char</font> x) {
    System.out.println(<font color=#004488>" Worm constructor: "</font> + i);
    c = x;
    <font color=#0000ff>if</font>(--i &gt; 0)
      next = <font color=#0000ff>new</font> Worm(i, (<font color=#0000ff>char</font>)(x + 1));
  }
  Worm() {
    System.out.println(<font color=#004488>"Default constructor"</font>);
  }
  <font color=#0000ff>public</font> String toString() {
    String s = <font color=#004488>":"</font> + c + <font color=#004488>"("</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; d.length; i++)
      s += d[i].toString();
    s += <font color=#004488>")"</font>;
    <font color=#0000ff>if</font>(next != <font color=#0000ff>null</font>)
      s += next.toString();
    <font color=#0000ff>return</font> s;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Worm w = <font color=#0000ff>new</font> Worm(6, 'a');
    System.out.println(<font color=#004488>"w = "</font> + w);
    <font color=#0000ff>try</font> {
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"worm.out"</font>));
      out.writeObject(<font color=#004488>"Worm storage"</font>);
      out.writeObject(w);
      out.close(); <font color=#009900>// Also flushes output</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"worm.out"</font>));
      String s = (String)in.readObject();
      Worm w2 = (Worm)in.readObject();
      System.out.println(s + <font color=#004488>", w2 = "</font> + w2);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
    <font color=#0000ff>try</font> {
      ByteArrayOutputStream bout =
        <font color=#0000ff>new</font> ByteArrayOutputStream();
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(bout);
      out.writeObject(<font color=#004488>"Worm storage"</font>);
      out.writeObject(w);
      out.flush();
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            bout.toByteArray()));
      String s = (String)in.readObject();
      Worm w3 = (Worm)in.readObject();
      System.out.println(s + <font color=#004488>", w3 = "</font> + w3);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
更有趣的是，Worm内的Data对象数组是用随机数字初始化的（这样便不用怀疑编译器保留了某种原始信息）。每个Worm段都用一个Char标记。这个Char是在重复生成链接的Worm列表时自动产生的。创建一个Worm时，需告诉构建器希望它有多长。为产生下一个句柄（next），它总是用减去1的长度来调用Worm构建器。最后一个next句柄则保持为null（空），表示已抵达Worm的尾部。<br>
上面的所有操作都是为了加深事情的复杂程度，加大对象序列化的难度。然而，真正的序列化过程却是非常简单的。一旦从另外某个流里创建了ObjectOutputStream，writeObject()就会序列化对象。注意也可以为一个String调用writeObject()。亦可使用与DataOutputStream相同的方法写入所有基本数据类型（它们有相同的接口）。<br>
有两个单独的try块看起来是类似的。第一个读写的是文件，而另一个读写的是一个ByteArray（字节数组）。可利用对任何DataInputStream或者DataOutputStream的序列化来读写特定的对象；正如在关于连网的那一章会讲到的那样，这些对象甚至包括网络。一次循环后的输出结果如下：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w2 = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w3 = :a(262):b(100):c(396):d(480):e(316):f(398)</PRE></FONT></BLOCKQUOTE>
<br>
可以看出，装配回原状的对象确实包含了原来那个对象里包含的所有链接。<br>
注意在对一个Serializable（可序列化）对象进行重新装配的过程中，不会调用任何构建器（甚至默认构建器）。整个对象都是通过从InputStream中取得数据恢复的。<br>
作为Java 1.1特性的一种，我们注意到对象的序列化并不属于新的Reader和Writer层次结构的一部分，而是沿用老式的InputStream和OutputStream结构。所以在一些特殊的场合下，不得不混合使用两种类型的层次结构。<br>
<br>
10.9.1 寻找类<br>
读者或许会奇怪为什么需要一个对象从它的序列化状态中恢复。举个例子来说，假定我们序列化一个对象，并通过网络将其作为文件传送给另一台机器。此时，位于另一台机器的程序可以只用文件目录来重新构造这个对象吗？<br>
回答这个问题的最好方法就是做一个实验。下面这个文件位于本章的子目录下：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Alien.java</font>
<font color=#009900>// A serializable class</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Alien <font color=#0000ff>implements</font> Serializable {
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
用于创建和序列化一个Alien对象的文件位于相同的目录下：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: FreezeAlien.java</font>
<font color=#009900>// Create a serialized output file</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FreezeAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    ObjectOutput out = 
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"file.x"</font>));
    Alien zorcon = <font color=#0000ff>new</font> Alien();
    out.writeObject(zorcon); 
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
该程序并不是捕获和控制违例，而是将违例简单、直接地传递到main()外部，这样便能在命令行报告它们。<br>
程序编译并运行后，将结果产生的file.x复制到名为xfiles的子目录，代码如下：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: ThawAlien.java</font>
<font color=#009900>// Try to recover a serialized file without the </font>
<font color=#009900>// class of object that's stored in that file.</font>
<font color=#0000ff>package</font> c10.xfiles;
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThawAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"file.x"</font>));
    Object mystery = in.readObject();
    System.out.println(
      mystery.getClass().toString());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
该程序能打开文件，并成功读取mystery对象中的内容。然而，一旦尝试查找与对象有关的任何资料——这要求Alien的Class对象——Java虚拟机（JVM）便找不到Alien.class（除非它正好在类路径内，而本例理应相反）。这样就会得到一个名叫ClassNotFoundException的违例（同样地，若非能够校验Alien存在的证据，否则它等于消失）。<br>
恢复了一个序列化的对象后，如果想对其做更多的事情，必须保证JVM能在本地类路径或者因特网的其他什么地方找到相关的.class文件。<br>
<br>
10.9.2 序列化的控制<br>
正如大家看到的那样，默认的序列化机制并不难操纵。然而，假若有特殊要求又该怎么办呢？我们可能有特殊的安全问题，不希望对象的某一部分序列化；或者某一个子对象完全不必序列化，因为对象恢复以后，那一部分需要重新创建。<br>
此时，通过实现Externalizable接口，用它代替Serializable接口，便可控制序列化的具体过程。这个Externalizable接口扩展了Serializable，并增添了两个方法：writeExternal()和readExternal()。在序列化和重新装配的过程中，会自动调用这两个方法，以便我们执行一些特殊操作。<br>
下面这个例子展示了Externalizable接口方法的简单应用。注意Blip1和Blip2几乎完全一致，除了极微小的差别（自己研究一下代码，看看是否能发现）：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Blips.java</font>
<font color=#009900>// Simple use of Externalizable &amp; a pitfall</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip1 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>public</font> Blip1() {
    System.out.println(<font color=#004488>"Blip1 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip1.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip1.readExternal"</font>);
  }
}

<font color=#0000ff>class</font> Blip2 <font color=#0000ff>implements</font> Externalizable {
  Blip2() {
    System.out.println(<font color=#004488>"Blip2 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip2.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip2.readExternal"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blips {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip1 b1 = <font color=#0000ff>new</font> Blip1();
    Blip2 b2 = <font color=#0000ff>new</font> Blip2();
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blips.out"</font>));
      System.out.println(<font color=#004488>"Saving objects:"</font>);
      o.writeObject(b1);
      o.writeObject(b2);
      o.close();
      <font color=#009900>// Now get them back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blips.out"</font>));
      System.out.println(<font color=#004488>"Recovering b1:"</font>);
      b1 = (Blip1)in.readObject();
      <font color=#009900>// OOPS! Throws an exception:</font>
<font color=#009900>//!   System.out.println("Recovering b2:");</font>
<font color=#009900>//!   b2 = (Blip2)in.readObject();</font>
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
该程序输出如下：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal</PRE></FONT></BLOCKQUOTE>
<br>
未恢复Blip2对象的原因是那样做会导致一个违例。你找出了Blip1和Blip2之间的区别吗？Blip1的构建器是“公共的”（public），Blip2的构建器则不然，这样便会在恢复时造成违例。试试将Blip2的构建器属性变成“public”，然后删除//!注释标记，看看是否能得到正确的结果。<br>
恢复b1后，会调用Blip1默认构建器。这与恢复一个Serializable（可序列化）对象不同。在后者的情况下，对象完全以它保存下来的二进制位为基础恢复，不存在构建器调用。而对一个Externalizable对象，所有普通的默认构建行为都会发生（包括在字段定义时的初始化），而且会调用readExternal()。必须注意这一事实——特别注意所有默认的构建行为都会进行——否则很难在自己的Externalizable对象中产生正确的行为。<br>
下面这个例子揭示了保存和恢复一个Externalizable对象必须做的全部事情：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Blip3.java</font>
<font color=#009900>// Reconstructing an externalizable object</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip3 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>int</font> i;
  String s; <font color=#009900>// No initialization</font>
  <font color=#0000ff>public</font> Blip3() {
    System.out.println(<font color=#004488>"Blip3 Constructor"</font>);
    <font color=#009900>// s, i not initialized</font>
  }
  <font color=#0000ff>public</font> Blip3(String x, <font color=#0000ff>int</font> a) {
    System.out.println(<font color=#004488>"Blip3(String x, int a)"</font>);
    s = x;
    i = a;
    <font color=#009900>// s &amp; i initialized only in non-default</font>
    <font color=#009900>// constructor.</font>
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> s + i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip3.writeExternal"</font>);
    <font color=#009900>// You must do this:</font>
    out.writeObject(s); out.writeInt(i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip3.readExternal"</font>);
    <font color=#009900>// You must do this:</font>
    s = (String)in.readObject(); 
    i =in.readInt();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip3 b3 = <font color=#0000ff>new</font> Blip3(<font color=#004488>"A String "</font>, 47);
    System.out.println(b3.toString());
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blip3.out"</font>));
      System.out.println(<font color=#004488>"Saving object:"</font>);
      o.writeObject(b3);
      o.close();
      <font color=#009900>// Now get it back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blip3.out"</font>));
      System.out.println(<font color=#004488>"Recovering b3:"</font>);
      b3 = (Blip3)in.readObject();
      System.out.println(b3.toString());
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
其中，字段s和i只在第二个构建器中初始化，不关默认构建器的事。这意味着假如不在readExternal中初始化s和i，它们就会成为null（因为在对象创建的第一步中已将对象的存储空间清除为1）。若注释掉跟随于“You 
must do this”后面的两行代码，并运行程序，就会发现当对象恢复以后，s是null，而i是零。<br>
若从一个Externalizable对象继承，通常需要调用writeExternal()和readExternal()的基础类版本，以便正确地保存和恢复基础类组件。<br>
所以为了让一切正常运作起来，千万不可仅在writeExternal()方法执行期间写入对象的重要数据（没有默认的行为可用来为一个Externalizable对象写入所有成员对象）的，而是必须在readExternal()方法中也恢复那些数据。初次操作时可能会有些不习惯，因为Externalizable对象的默认构建行为使其看起来似乎正在进行某种存储与恢复操作。但实情并非如此。<br>
<br>
1. transient（临时）关键字<br>
控制序列化过程时，可能有一个特定的子对象不愿让Java的序列化机制自动保存与恢复。一般地，若那个子对象包含了不想序列化的敏感信息（如密码），就会面临这种情况。即使那种信息在对象中具有“private”（私有）属性，但一旦经序列化处理，人们就可以通过读取一个文件，或者拦截网络传输得到它。<br>
为防止对象的敏感部分被序列化，一个办法是将自己的类实现为Externalizable，就象前面展示的那样。这样一来，没有任何东西可以自动序列化，只能在writeExternal()明确序列化那些需要的部分。<br>
然而，若操作的是一个Serializable对象，所有序列化操作都会自动进行。为解决这个问题，可以用transient（临时）逐个字段地关闭序列化，它的意思是“不要麻烦你（指自动机制）保存或恢复它了——我会自己处理的”。<br>
例如，假设一个Login对象包含了与一个特定的登录会话有关的信息。校验登录的合法性时，一般都想将数据保存下来，但不包括密码。为做到这一点，最简单的办法是实现Serializable，并将password字段设为transient。下面是具体的代码：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: Logon.java</font>
<font color=#009900>// Demonstrates the "transient" keyword</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Logon <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> Date date = <font color=#0000ff>new</font> Date();
  <font color=#0000ff>private</font> String username;
  <font color=#0000ff>private</font> <font color=#0000ff>transient</font> String password;
  Logon(String name, String pwd) {
    username = name;
    password = pwd;
  }
  <font color=#0000ff>public</font> String toString() {
    String pwd =
      (password == <font color=#0000ff>null</font>) ? <font color=#004488>"(n</font><font color=#004488>/a)"</font> : password;
    <font color=#0000ff>return</font> <font color=#004488>"logon info: \n   "</font> +
      <font color=#004488>"username: "</font> + username +
      <font color=#004488>"\n   date: "</font> + date.toString() +
      <font color=#004488>"\n   password: "</font> + pwd;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Logon a = <font color=#0000ff>new</font> Logon(<font color=#004488>"Hulk"</font>, <font color=#004488>"myLittlePony"</font>);
    System.out.println( <font color=#004488>"logon a = "</font> + a);
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Logon.out"</font>));
      o.writeObject(a);
      o.close();
      <font color=#009900>// Delay:</font>
      <font color=#0000ff>int</font> seconds = 5;
      <font color=#0000ff>long</font> t = System.currentTimeMillis()
             + seconds * 1000;
      <font color=#0000ff>while</font>(System.currentTimeMillis() &lt; t)
        ;
      <font color=#009900>// Now get them back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Logon.out"</font>));
      System.out.println(
        <font color=#004488>"Recovering object at "</font> + <font color=#0000ff>new</font> Date());
      a = (Logon)in.readObject();
      System.out.println( <font color=#004488>"logon a = "</font> + a);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
可以看到，其中的date和username字段保持原始状态（未设成transient），所以会自动序列化。然而，password被设为transient，所以不会自动保存到磁盘；另外，自动序列化机制也不会作恢复它的尝试。输出如下：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: myLittlePony
Recovering object at Sun Mar 23 18:25:59 PST 1997
logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: (n/a)</PRE></FONT></BLOCKQUOTE>
<br>
一旦对象恢复成原来的样子，password字段就会变成null。注意必须用toString()检查password是否为null，因为若用过载的“+”运算符来装配一个String对象，而且那个运算符遇到一个null句柄，就会造成一个名为NullPointerException的违例（新版Java可能会提供避免这个问题的代码）。<br>
我们也发现date字段被保存到磁盘，并从磁盘恢复，没有重新生成。<br>
由于Externalizable对象默认时不保存它的任何字段，所以transient关键字只能伴随Serializable使用。<br>
<br>
2. Externalizable的替代方法<br>
若不是特别在意要实现Externalizable接口，还有另一种方法可供选用。我们可以实现Serializable接口，并添加（注意是“添加”，而非“覆盖”或者“实现”）名为writeObject()和readObject()的方法。一旦对象被序列化或者重新装配，就会分别调用那两个方法。也就是说，只要提供了这两个方法，就会优先使用它们，而不考虑默认的序列化机制。<br>
这些方法必须含有下列准确的签名：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  writeObject(ObjectOutputStream stream)
    <font color=#0000ff>throws</font> IOException;

<font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  readObject(ObjectInputStream stream)
    <font color=#0000ff>throws</font> IOException, ClassNotFoundException</PRE></FONT></BLOCKQUOTE>
<br>
从设计的角度出发，情况变得有些扑朔迷离。首先，大家可能认为这些方法不属于基础类或者Serializable接口的一部分，它们应该在自己的接口中得到定义。但请注意它们被定义成“private”，这意味着它们只能由这个类的其他成员调用。然而，我们实际并不从这个类的其他成员中调用它们，而是由ObjectOutputStream和ObjectInputStream的writeObject()及readObject()方法来调用我们对象的writeObject()和readObject()方法（注意我在这里用了很大的抑制力来避免使用相同的方法名——因为怕混淆）。大家可能奇怪ObjectOutputStream和ObjectInputStream如何有权访问我们的类的private方法——只能认为这是序列化机制玩的一个把戏。<br>
在任何情况下，接口中的定义的任何东西都会自动具有public属性，所以假若writeObject()和readObject()必须为private，那么它们不能成为接口（interface）的一部分。但由于我们准确地加上了签名，所以最终的效果实际与实现一个接口是相同的。<br>
看起来似乎我们调用ObjectOutputStream.writeObject()的时候，我们传递给它的Serializable对象似乎会被检查是否实现了自己的writeObject()。若答案是肯定的是，便会跳过常规的序列化过程，并调用writeObject()。readObject()也会遇到同样的情况。<br>
还存在另一个问题。在我们的writeObject()内部，可以调用defaultWriteObject()，从而决定采取默认的writeObject()行动。类似地，在readObject()内部，可以调用defaultReadObject()。下面这个简单的例子演示了如何对一个Serializable对象的存储与恢复进行控制：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: SerialCtl.java</font>
<font color=#009900>// Controlling serialization by adding your own</font>
<font color=#009900>// writeObject() and readObject() methods.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SerialCtl <font color=#0000ff>implements</font> Serializable {
  String a;
  <font color=#0000ff>transient</font> String b;
  <font color=#0000ff>public</font> SerialCtl(String aa, String bb) {
    a = <font color=#004488>"Not Transient: "</font> + aa;
    b = <font color=#004488>"Transient: "</font> + bb;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> a + <font color=#004488>"\n"</font> + b;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    writeObject(ObjectOutputStream stream)
      <font color=#0000ff>throws</font> IOException {
    stream.defaultWriteObject();
    stream.writeObject(b);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    readObject(ObjectInputStream stream)
      <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    stream.defaultReadObject();
    b = (String)stream.readObject();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SerialCtl sc = 
      <font color=#0000ff>new</font> SerialCtl(<font color=#004488>"Test1"</font>, <font color=#004488>"Test2"</font>);
    System.out.println(<font color=#004488>"Before:\n"</font> + sc);
    ByteArrayOutputStream buf = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    <font color=#0000ff>try</font> {
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(buf);
      o.writeObject(sc);
      <font color=#009900>// Now get it back:</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            buf.toByteArray()));
      SerialCtl sc2 = (SerialCtl)in.readObject();
      System.out.println(<font color=#004488>"After:\n"</font> + sc2);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
在这个例子中，一个String保持原始状态，其他设为transient（临时），以便证明非临时字段会被defaultWriteObject()方法自动保存，而transient字段必须在程序中明确保存和恢复。字段是在构建器内部初始化的，而不是在定义的时候，这证明了它们不会在重新装配的时候被某些自动化机制初始化。<br>
若准备通过默认机制写入对象的非transient部分，那么必须调用defaultWriteObject()，令其作为writeObject()中的第一个操作；并调用defaultReadObject()，令其作为readObject()的第一个操作。这些都是不常见的调用方法。举个例子来说，当我们为一个ObjectOutputStream调用defaultWriteObject()的时候，而且没有为其传递参数，就需要采取这种操作，使其知道对象的句柄以及如何写入所有非transient的部分。这种做法非常不便。<br>
transient对象的存储与恢复采用了我们更熟悉的代码。现在考虑一下会发生一些什么事情。在main()中会创建一个SerialCtl对象，随后会序列化到一个ObjectOutputStream里（注意这种情况下使用的是一个缓冲区，而非文件——与ObjectOutputStream完全一致）。正式的序列化操作是在下面这行代码里发生的：<br>
o.writeObject(sc);<br>
其中，writeObject()方法必须核查sc，判断它是否有自己的writeObject()方法（不是检查它的接口——它根本就没有，也不是检查类的类型，而是利用反射方法实际搜索方法）。若答案是肯定的，就使用那个方法。类似的情况也会在readObject()上发生。或许这是解决问题唯一实际的方法，但确实显得有些古怪。<br>
<br>
3. 版本问题<br>
有时候可能想改变一个可序列化的类的版本（比如原始类的对象可能保存在数据库中）。尽管这种做法得到了支持，但一般只应在非常特殊的情况下才用它。此外，它要求操作者对背后的原理有一个比较深的认识，而我们在这里还不想达到这种深度。JDK 
1.1的HTML文档对这一主题进行了非常全面的论述（可从Sun公司下载，但可能也成了Java开发包联机文档的一部分）。<br>
<br>
10.9.3 利用“持久性”<br>
一个比较诱人的想法是用序列化技术保存程序的一些状态信息，从而将程序方便地恢复到以前的状态。但在具体实现以前，有些问题是必须解决的。如果两个对象都有指向第三个对象的句柄，该如何对这两个对象序列化呢？如果从两个对象序列化后的状态恢复它们，第三个对象的句柄只会出现在一个对象身上吗？如果将这两个对象序列化成独立的文件，然后在代码的不同部分重新装配它们，又会得到什么结果呢？<br>
下面这个例子对上述问题进行了很好的说明：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: MyWorld.java</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> House <font color=#0000ff>implements</font> Serializable {}

<font color=#0000ff>class</font> Animal <font color=#0000ff>implements</font> Serializable {
  String name;
  House preferredHouse;
  Animal(String nm, House h) { 
    name = nm; 
    preferredHouse = h;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> name + <font color=#004488>"["</font> + <font color=#0000ff>super</font>.toString() + 
      <font color=#004488>"], "</font> + preferredHouse + <font color=#004488>"\n"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MyWorld {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    House house = <font color=#0000ff>new</font> House();
    Vector  animals = <font color=#0000ff>new</font> Vector();
    animals.addElement(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Bosco the dog"</font>, house));
    animals.addElement(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Ralph the hamster"</font>, house));
    animals.addElement(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Fronk the cat"</font>, house));
    System.out.println(<font color=#004488>"animals: "</font> + animals);

    <font color=#0000ff>try</font> {
      ByteArrayOutputStream buf1 = 
        <font color=#0000ff>new</font> ByteArrayOutputStream();
      ObjectOutputStream o1 =
        <font color=#0000ff>new</font> ObjectOutputStream(buf1);
      o1.writeObject(animals);
      o1.writeObject(animals); <font color=#009900>// Write a 2nd set</font>
      <font color=#009900>// Write to a different stream:</font>
      ByteArrayOutputStream buf2 = 
        <font color=#0000ff>new</font> ByteArrayOutputStream();
      ObjectOutputStream o2 =
        <font color=#0000ff>new</font> ObjectOutputStream(buf2);
      o2.writeObject(animals);
      <font color=#009900>// Now get them back:</font>
      ObjectInputStream in1 =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            buf1.toByteArray()));
      ObjectInputStream in2 =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(
            buf2.toByteArray()));
      Vector animals1 = (Vector)in1.readObject();
      Vector animals2 = (Vector)in1.readObject();
      Vector animals3 = (Vector)in2.readObject();
      System.out.println(<font color=#004488>"animals1: "</font> + animals1);
      System.out.println(<font color=#004488>"animals2: "</font> + animals2);
      System.out.println(<font color=#004488>"animals3: "</font> + animals3);
    } <font color=#0000ff>catch</font>(Exception e) {
      e.printStackTrace();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
这里一件有趣的事情是也许是能针对一个字节数组应用对象的序列化，从而实现对任何Serializable（可序列化）对象的一个“全面复制”（全面复制意味着复制的是整个对象网，而不仅是基本对象和它的句柄）。复制问题将在第12章进行全面讲述。<br>
Animal对象包含了类型为House的字段。在main()中，会创建这些Animal的一个Vector，并对其序列化两次，分别送入两个不同的数据流内。这些数据重新装配并打印出来后，可看到下面这样的结果（对象在每次运行时都会处在不同的内存位置，所以每次运行的结果有区别）：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>animals: [Bosco the dog[Animal@1cc76c], House@1cc769
, Ralph the hamster[Animal@1cc76d], House@1cc769
, Fronk the cat[Animal@1cc76e], House@1cc769
]
animals1: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals2: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals3: [Bosco the dog[Animal@1cca52], House@1cca5c
, Ralph the hamster[Animal@1cca5d], House@1cca5c
, Fronk the cat[Animal@1cca61], House@1cca5c
]</PRE></FONT></BLOCKQUOTE>
<br>
当然，我们希望装配好的对象有与原来不同的地址。但注意在animals1和animals2中出现了相同的地址，其中包括共享的、对House对象的引用。在另一方面，当animals3恢复以后，系统没有办法知道另一个流内的对象是第一个流内对象的化身，所以会产生一个完全不同的对象网。<br>
只要将所有东西都序列化到单独一个数据流里，就能恢复获得与以前写入时完全一样的对象网，不会不慎造成对象的重复。当然，在写第一个和最后一个对象的时间之间，可改变对象的状态，但那必须由我们明确采取操作——序列化时，对象会采用它们当时的任何状态（包括它们与其他对象的连接关系）写入。<br>
若想保存系统状态，最安全的做法是当作一种“微观”操作序列化。如果序列化了某些东西，再去做其他一些工作，再来序列化更多的东西，以此类推，那么最终将无法安全地保存系统状态。相反，应将构成系统状态的所有对象都置入单个集合内，并在一次操作里完成那个集合的写入。这样一来，同样只需一次方法调用，即可成功恢复之。<br>
下面这个例子是一套假想的计算机辅助设计（CAD）系统，对这一方法进行了很好的演示。此外，它还为我们引入了static字段的问题——如留意联机文档，就会发现Class是“Serializable”（可序列化）的，所以只需简单地序列化Class对象，就能实现static字段的保存。这无论如何都是一种明智的做法。<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: CADState.java</font>
<font color=#009900>// Saving and restoring the state of a </font>
<font color=#009900>// pretend CAD system.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Shape <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> 
    RED = 1, BLUE = 2, GREEN = 3;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> xPos, yPos, dimension;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor);
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor();
  <font color=#0000ff>public</font> Shape(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    xPos = xVal;
    yPos = yVal;
    dimension = dim;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> getClass().toString() + 
      <font color=#004488>" color["</font> + getColor() +
      <font color=#004488>"] xPos["</font> + xPos +
      <font color=#004488>"] yPos["</font> + yPos +
      <font color=#004488>"] dim["</font> + dimension + <font color=#004488>"]\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Shape randomFactory() {
    <font color=#0000ff>int</font> xVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> yVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> dim = r.nextInt() % 100;
    <font color=#0000ff>switch</font>(counter++ % 3) {
      <font color=#0000ff>default</font>: 
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle(xVal, yVal, dim);
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square(xVal, yVal, dim);
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Line(xVal, yVal, dim);
    }
  }
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> Circle(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color;
  <font color=#0000ff>public</font> Square(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
    color = RED;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Line <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  serializeStaticState(ObjectOutputStream os)
      <font color=#0000ff>throws</font> IOException {
    os.writeInt(color);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  deserializeStaticState(ObjectInputStream os)
      <font color=#0000ff>throws</font> IOException {
    color = os.readInt();
  }
  <font color=#0000ff>public</font> Line(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CADState {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
      <font color=#0000ff>throws</font> Exception {
    Vector shapeTypes, shapes;
    <font color=#0000ff>if</font>(args.length == 0) {
      shapeTypes = <font color=#0000ff>new</font> Vector();
      shapes = <font color=#0000ff>new</font> Vector();
      <font color=#009900>// Add handles to the class objects:</font>
      shapeTypes.addElement(Circle.<font color=#0000ff>class</font>);
      shapeTypes.addElement(Square.<font color=#0000ff>class</font>);
      shapeTypes.addElement(Line.<font color=#0000ff>class</font>);
      <font color=#009900>// Make some shapes:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        shapes.addElement(Shape.randomFactory());
      <font color=#009900>// Set all the static colors to GREEN:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        ((Shape)shapes.elementAt(i))
          .setColor(Shape.GREEN);
      <font color=#009900>// Save the state vector:</font>
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"CADState.out"</font>));
      out.writeObject(shapeTypes);
      Line.serializeStaticState(out);
      out.writeObject(shapes);
    } <font color=#0000ff>else</font> { <font color=#009900>// There's a command-line argument</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(args[0]));
      <font color=#009900>// Read in the same order they were written:</font>
      shapeTypes = (Vector)in.readObject();
      Line.deserializeStaticState(in);
      shapes = (Vector)in.readObject();
    }
    <font color=#009900>// Display the shapes:</font>
    System.out.println(shapes);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<br>
Shape（几何形状）类“实现了可序列化”（implements Serializable），所以从Shape继承的任何东西也都会自动“可序列化”。每个Shape都包含了数据，而且每个衍生的Shape类都包含了一个特殊的static字段，用于决定所有那些类型的Shape的颜色（如将一个static字段置入基础类，结果只会产生一个字段，因为static字段未在衍生类中复制）。可对基础类中的方法进行覆盖处理，以便为不同的类型设置颜色（static方法不会动态绑定，所以这些都是普通的方法）。每次调用randomFactory()方法时，它都会创建一个不同的Shape（Shape值采用随机值）。<br>
Circle（圆）和Square（矩形）属于对Shape的直接扩展；唯一的差别是Circle在定义时会初始化颜色，而Square在构建器中初始化。Line（直线）的问题将留到以后讨论。<br>
在main()中，一个Vector用于容纳Class对象，而另一个用于容纳形状。若不提供相应的命令行参数，就会创建shapeTypes 
Vector，并添加Class对象。然后创建shapes Vector，并添加Shape对象。接下来，所有static 
color值都会设成GREEN，而且所有东西都会序列化到文件CADState.out。<br>
若提供了一个命令行参数（假设CADState.out），便会打开那个文件，并用它恢复程序的状态。无论在哪种情况下，结果产生的Shape的Vector都会打印出来。下面列出它某一次运行的结果：<br>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&gt;java CADState
[<font color=#0000ff>class</font> Circle color[3] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[3] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[3] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[3] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[3] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[3] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[3] xPos[17] yPos[90] dim[-76]
]

&gt;java CADState CADState.out
[<font color=#0000ff>class</font> Circle color[1] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[0] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[1] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[0] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[1] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[0] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[1] xPos[17] yPos[90] dim[-76]
]</PRE></FONT></BLOCKQUOTE>
<br>
从中可以看出，xPos，yPos以及dim的值都已成功保存和恢复出来。但在获取static信息时却出现了问题。所有“3”都已进入，但没有正常地出来。Circle有一个1值（定义为RED），而Square有一个0值（记住，它们是在构建器里初始化的）。看上去似乎static根本没有得到初始化！实情正是如此——尽管类Class是“可以序列化的”，但却不能按我们希望的工作。所以假如想序列化static值，必须亲自动手。<br>
这正是Line中的serializeStaticState()和deserializeStaticState()两个static方法的用途。可以看到，这两个方法都是作为存储和恢复进程的一部分明确调用的（注意写入序列化文件和从中读回的顺序不能改变）。所以为了使CADState.java正确运行起来，必须采用下述三种方法之一：<br>
(1) 为几何形状添加一个serializeStaticState()和deserializeStaticState()。<br>
(2) 删除Vector shapeTypes以及与之有关的所有代码<br>
(3) 在几何形状内添加对新序列化和撤消序列化静态方法的调用<br>
要注意的另一个问题是安全，因为序列化处理也会将private数据保存下来。若有需要保密的字段，应将其标记成transient。但在这之后，必须设计一种安全的信息保存方法。这样一来，一旦需要恢复，就可以重设那些private变量。<br>
<br>
10.10 总结<br>
Java IO流库能满足我们的许多基本要求：可以通过控制台、文件、内存块甚至因特网（参见第15章）进行读写。可以创建新的输入和输出对象类型（通过从InputStream和OutputStream继承）。向一个本来预期为收到字串的方法传递一个对象时，由于Java已限制了“自动类型转换”，所以会自动调用toString()方法。而我们可以重新定义这个toString()，扩展一个数据流能接纳的对象种类。<br>
在IO数据流库的联机文档和设计过程中，仍有些问题没有解决。比如当我们打开一个文件以便输出时，完全可以指定一旦有人试图覆盖该文件就“掷”出一个违例——有的编程系统允许我们自行指定想打开一个输出文件，但唯一的前提是它尚不存在。但在Java中，似乎必须用一个File对象来判断某个文件是否存在，因为假如将其作为FileOutputStream或者FileWriter打开，那么肯定会被覆盖。若同时指定文件和目录路径，File类设计上的一个缺陷就会暴露出来，因为它会说“不要试图在单个类里做太多的事情”！<br>
IO流库易使我们混淆一些概念。它确实能做许多事情，而且也可以移植。但假如假如事先没有吃透装饰器方案的概念，那么所有的设计都多少带有一点盲目性质。所以不管学它还是教它，都要特别花一些功夫才行。而且它并不完整：没有提供对输出格式化的支持，而其他几乎所有语言的IO包都提供了这方面的支持（这一点没有在Java 
1.1里得以纠正，它完全错失了改变库设计方案的机会，反而增添了更特殊的一些情况，使复杂程度进一步提高）。Java 
1.1转到那些尚未替换的IO库，而不是增加新库。而且库的设计人员似乎没有很好地指出哪些特性是不赞成的，哪些是首选的，造成库设计中经常都会出现一些令人恼火的反对消息。<br>
然而，一旦掌握了装饰器方案，并开始在一些较为灵活的环境使用库，就会认识到这种设计的好处。到那个时候，为此多付出的代码行应该不至于使你觉得太生气。<br>
<br>
10.11 练习<br>
(1) 打开一个文本文件，每次读取一行内容。将每行作为一个String读入，并将那个String对象置入一个Vector里。按相反的顺序打印出Vector中的所有行。<br>
(2) 修改练习1，使读取那个文件的名字作为一个命令行参数提供。<br>
(3) 修改练习2，又打开一个文本文件，以便将文字写入其中。将Vector中的行随同行号一起写入文件。<br>
(4) 修改练习2，强迫Vector中的所有行都变成大写形式，将结果发给System.out。<br>
(5) 修改练习2，在文件中查找指定的单词。打印出包含了欲找单词的所有文本行。<br>
(6) 在Blips.java中复制文件，将其重命名为BlipCheck.java。然后将类Blip2重命名为BlipCheck（在进程中将其标记为public）。删除文件中的//!记号，并执行程序。接下来，将BlipCheck的默认构建器变成注释信息。运行它，并解释为什么仍然能够工作。<br>
(7) 在Blip3.java中，将接在“You must do this:”字样后的两行变成注释，然后运行程序。解释得到的结果为什么会与执行了那两行代码不同。<br>
(8) 转换SortedWordCount.java程序，以便使用Java 1.1 IO流。<br>
(9) 根据本章正文的说明修改程序CADState.java。<br>
(10) 在第7章（中间部分）找到GreenhouseControls.java示例，它应该由三个文件构成。在GreenhouseControls.java中，Restart()内部类有一个硬编码的事件集。请修改这个程序，使其能从一个文本文件里动态读取事件以及它们的相关时间。</p>

<!--msthemeseparator--><p align="center"><img src="../_themes/inmotion/inmhorsa.gif" width="300" height="10"></p>

<p align="center"><a href="http://www.bruceeckel.com">英文版主页</a> | <a href="../index.htm">中文版主页</a> |  <a href="../index.htm">详细目录</a> 
| <a href="../about/index.htm">关于译者</a></p>
</body>
</html>
