<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>Thinking in Java | Contents</title>

<meta name="Microsoft Theme" content="inmotion 111, default"></head>

<body bgcolor="#FFFFCC" text="#000000" link="#800000" vlink="#996633" alink="#FF3399">

<center>
-------------------------------------------------<br>
<br>
<font color=blue><b>本教程由<a href="../about/index.htm">yyc,spirit</a>整理</b></font><br>
<br>
-------------------------------------------------
</center><br><br>

<p align="center"><big><strong>“Thinking in Java”详细目录</strong></big></p>

<p>　</p>

<p><a href="./blah/index.htm">写在前面的话</a></p>

<p><a href="./introduction/index.htm">引言</a><br>
1. 前提<br>
2. Java的学习<br>
3. 目标<br>
4. 联机文档<br>
5. 章节<br>
6. 练习<br>
7. 多媒体CD-ROM<br>
8. 源代码<br>
9. 编码样式<br>
10. Java版本<br>
11. 课程和培训<br>
12. 错误<br>
13. 封面设计<br>
14. 致谢<br>
<br>
<a href="./chapter/chapter1.htm">第1章 对象入门</a><br>
1.1 抽象的进步<br>
1.2 对象的接口<br>
1.3 实现方案的隐藏<br>
1.4 方案的重复使用<br>
1.5 继承：重新使用接口<br>
1.5.1 改善基础类<br>
1.5.2 等价和类似关系<br>
1.6 多形对象的互换使用<br>
1.6.1 动态绑定<br>
1.6.2 抽象的基础类和接口<br>
1.7 对象的创建和存在时间<br>
1.7.1 集合与继承器<br>
1.7.2 单根结构<br>
1.7.3 集合库与方便使用集合<br>
1.7.4 清除时的困境：由谁负责清除？<br>
1.8 违例控制：解决错误<br>
1.9 多线程<br>
1.10 永久性<br>
1.11 Java和因特网<br>
1.11.1 什么是Web？<br>
1.11.2 客户端编程<br>
1.11.3 服务器端编程<br>
1.11.4 一个独立的领域：应用程序<br>
1.12 分析和设计<br>
1.12.1 不要迷失<br>
1.12.2 阶段0：拟出一个计划<br>
1.12.3 阶段1：要制作什么？<br>
1.12.4 阶段2：开始构建？<br>
1.12.5 阶段3：正式创建<br>
1.12.6 阶段4：校订<br>
1.12.7 计划的回报<br>
1.13 Java还是C++？<br>
<br>
<a href="./chapter/chapter2.htm">第2章 一切都是对象</a><br>
2.1 用句柄操纵对象<br>
2.2 必须创建所有对象<br>
2.2.1 保存在什么地方<br>
2.2.2 特殊情况：主类型<br>
2.2.3 Java中的数组<br>
2.3 绝对不要清除对象<br>
2.3.1 作用域<br>
2.3.2 对象的作用域<br>
2.4 新建数据类型：类<br>
2.4.1 字段和方法<br>
2.5 方法、自变量和返回值<br>
2.5.1 自变量列表<br>
2.6 构建Java程序<br>
2.6.1 名字的可见性<br>
2.6.2 使用其他组件<br>
2.6.3 static关键字<br>
2.7 我们的第一个Java程序<br>
2.8 注释和嵌入文档<br>
2.8.1 注释文档<br>
2.8.2 具体语法<br>
2.8.3 嵌入HTML<br>
2.8.4 @see：引用其他类<br>
2.8.5 类文档标记<br>
2.8.6 变量文档标记<br>
2.8.7 方法文档标记<br>
2.8.8 文档示例<br>
2.9 编码样式<br>
2.10 总结<br>
2.11 练习<br>
<br>
<a href="./chapter/chapter3.htm">第3章 控制程序流程</a><br>
3.1 使用Java运算符<br>
3.1.1 优先级<br>
3.1.2 赋值<br>
3.1.3 算术运算符<br>
3.1.4 自动递增和递减<br>
3.1.5 关系运算符<br>
3.1.6 逻辑运算符<br>
3.1.7 按位运算符<br>
3.1.8 移位运算符<br>
3.1.9 三元if-else运算符<br>
3.1.10 逗号运算符<br>
3.1.11 字串运算符+<br>
3.1.12 运算符常规操作规则<br>
3.1.13 造型运算符<br>
3.1.14 Java没有“sizeof”<br>
3.1.15 复习计算顺序<br>
3.1.16 运算符总结<br>
3.2 执行控制<br>
3.2.1 真和假<br>
3.2.2 if-else<br>
3.2.3 反复<br>
3.2.4 do-while<br>
3.2.5 for<br>
3.2.6 中断和继续<br>
3.2.7 切换<br>
3.3 总结<br>
3.4 练习<br>
<br>
<a href="./chapter/chapter4.htm">第4章 初始化和清除</a><br>
4.1 由构建器保证初始化<br>
4.2 方法过载<br>
4.2.1 区分过载方法<br>
4.2.2 主类型的过载<br>
4.2.3 返回值过载<br>
4.2.4 默认构建器<br>
4.2.5 this关键字<br>
4.3 清除：收尾和垃圾收集<br>
4.3.1 finalize()用途何在<br>
4.3.2 必须执行清除<br>
4.4 成员初始化<br>
4.4.1 规定初始化<br>
4.4.2 构建器初始化<br>
4.5 数组初始化<br>
4.5.1 多维数组<br>
4.6 总结<br>
4.7 练习<br>
<br>
<a href="./chapter/chapter5.htm">第5章 隐藏实施过程</a><br>
5.1 包：库单元<br>
5.1.1 创建独一无二的包名<br>
5.1.2 自定义工具库<br>
5.1.3 利用导入改变行为<br>
5.1.4 包的停用<br>
5.2 Java访问指示符<br>
5.2.1 “友好的”<br>
5.2.2 public：接口访问<br>
5.2.3 private：不能接触<br>
5.2.4 protected：“友好的一种”<br>
5.3 接口与实现<br>
5.4 类访问<br>
5.5 总结<br>
5.6 练习<br>
<br>
<a href="./chapter/chapter6.htm">第6章 类再生</a><br>
6.1 合成的语法<br>
6.2 继承的语法<br>
6.2.1 初始化基础类<br>
6.3 合成与继承的结合<br>
6.3.1 确保正确的清除<br>
6.3.2 名字的隐藏<br>
6.4 到底选择合成还是继承<br>
6.5 protected<br>
6.6 递增开发<br>
6.7 上溯造型<br>
6.7.1 何谓“上溯造型”？<br>
6.8 final关键字<br>
6.8.1 final数据<br>
6.8.2 final方法<br>
6.8.3 final类<br>
6.8.4 final的注意事项<br>
6.9 初始化和类装载<br>
6.9.1 继承初始化<br>
6.10 总结<br>
6.11 练习<br>
<br>
<a href="./chapter/chapter7.htm">第7章 多形性</a><br>
7.1 上溯造型<br>
7.1.1 为什么要上溯造型<br>
7.2 深入理解<br>
7.2.1 方法调用的绑定<br>
7.2.2 产生正确的行为<br>
7.2.3 扩展性<br>
7.3 覆盖与过载<br>
7.4 抽象类和方法<br>
7.5 接口<br>
7.5.1 Java的“多重继承”<br>
7.5.2 通过继承扩展接口<br>
7.5.3 常数分组<br>
7.5.4 初始化接口中的字段<br>
7.6 内部类<br>
7.6.1 内部类和上溯造型<br>
7.6.2 方法和作用域中的内部类<br>
7.6.3 链接到外部类<br>
7.6.4 static内部类<br>
7.6.5 引用外部类对象<br>
7.6.6 从内部类继承<br>
7.6.7 内部类可以覆盖吗？<br>
7.6.8 内部类标识符<br>
7.6.9 为什么要用内部类：控制框架<br>
7.7 构建器和多形性<br>
7.7.1 构建器的调用顺序<br>
7.7.2 继承和finalize()<br>
7.7.3 构建器内部的多形性方法的行为<br>
7.8 通过继承进行设计<br>
7.8.1 纯继承与扩展<br>
7.8.2 下溯造型与运行期类型标识<br>
7.9 总结<br>
7.10 练习<br>
<br>
<a href="./chapter/chapter8.htm">第8章 对象的容纳</a><br>
8.1 数组<br>
8.1.1 数组和第一类对象<br>
8.1.2 数组的返回<br>
8.2 集合<br>
8.2.1 缺点：类型未知<br>
8.3 枚举器（反复器）<br>
8.4 集合的类型<br>
8.4.1 Vector<br>
8.4.2 BitSet<br>
8.4.3 Stack<br>
8.4.4 Hashtable<br>
8.4.5 再论枚举器<br>
8.5 排序<br>
8.6 通用集合库<br>
8.7 新集合<br>
8.7.1 使用Collections<br>
8.7.2 使用Lists<br>
8.7.3 使用Sets<br>
8.7.4 使用Maps<br>
8.7.5 决定实施方案<br>
8.7.6 未支持的操作<br>
8.7.7 排序和搜索<br>
8.7.8 实用工具<br>
8.8 总结<br>
8.9 练习<br>
<br>
<a href="./chapter/chapter9.htm">第9章 违例差错控制</a><br>
9.1 基本违例<br>
9.1.1 违例自变量<br>
9.2 违例的捕获<br>
9.2.1 try块<br>
9.2.2 违例控制器<br>
9.2.3 违例规范<br>
9.2.4 捕获所有违例<br>
9.2.5 重新“掷”出违例<br>
9.3 标准Java违例<br>
9.3.1 RuntimeException的特殊情况<br>
9.4 创建自己的违例<br>
9.5 违例的限制<br>
9.6 用finally清除<br>
9.6.1 用finally做什么<br>
9.6.2 缺点：丢失的违例<br>
9.7 构建器<br>
9.8 违例匹配<br>
9.8.1 违例准则<br>
9.9 总结<br>
9.10 练习<br>
<br>
<a href="./chapter/chapter10.htm">第10章 Java IO系统</a><br>
10.1 输入和输出<br>
10.1.1 InputStream的类型<br>
10.1.2 OutputStream的类型<br>
10.2 增添属性和有用的接口<br>
10.2.1 通过FilterInputStream从InputStream里读入数据<br>
10.2.2 通过FilterOutputStream向OutputStream里写入数据<br>
10.3 本身的缺陷：RandomAccessFile<br>
10.4 File类<br>
10.4.1 目录列表器<br>
10.4.2 检查与创建目录<br>
10.5 IO流的典型应用<br>
10.5.1 输入流<br>
10.5.2 输出流<br>
10.5.3 快捷文件处理<br>
10.5.4 从标准输入中读取数据<br>
10.5.5 管道数据流<br>
10.6 StreamTokenizer<br>
10.6.1 StringTokenizer<br>
10.7 Java 1.1的IO流<br>
10.7.1 数据的发起与接收<br>
10.7.2 修改数据流的行为<br>
10.7.3 未改变的类<br>
10.7.4 一个例子<br>
10.7.5 重定向标准IO<br>
10.8 压缩<br>
10.8.1 用GZIP进行简单压缩<br>
10.8.2 用Zip进行多文件保存<br>
10.8.3 Java归档（jar）实用程序<br>
10.9 对象串联<br>
10.9.1 寻找类<br>
10.9.2 序列化的控制<br>
10.9.3 利用“持久性”<br>
10.10 总结<br>
10.11 练习<br>
<br>
<a href="./chapter/chapter11.htm">第11章 运行期类型鉴定</a><br>
11.1 对RTTI的需要<br>
11.1.1 Class对象<br>
11.1.2 造型前的检查<br>
11.2 RTTI语法<br>
11.3 反射：运行期类信息<br>
11.3.1 一个类方法提取器<br>
11.4 总结<br>
11.5 练习<br>
<br>
<a href="./chapter/chapter12.htm">第12章 传递和返回对象</a><br>
12.1 传递句柄<br>
12.1.1 别名问题<br>
12.2 制作本地副本<br>
12.2.1 按值传递<br>
12.2.2 克隆对象<br>
12.2.3 使类具有克隆能力<br>
12.2.4 成功的克隆<br>
12.2.5 Object.clone()的效果<br>
12.2.6 克隆合成对象<br>
12.2.7 用Vector进行深层复制<br>
12.2.8 通过序列化进行深层复制<br>
12.2.9 使克隆具有更大的深度<br>
12.2.10 为什么有这个奇怪的设计<br>
12.3 克隆的控制<br>
12.3.1 副本构建器<br>
12.4 只读类<br>
12.4.1 创建只读类<br>
12.4.2 “一成不变”的弊端<br>
12.4.3 不变字串<br>
12.4.4 String和StringBuffer类<br>
12.4.5 字串的特殊性<br>
12.5 总结<br>
12.6 练习<br>
<br>
<a href="./chapter/chapter13.htm">第13章 创建窗口和程序片</a><br>
13.1 为何要用AWT？<br>
13.2 基本程序片<br>
13.2.1 程序片的测试<br>
13.2.2 一个更图形化的例子<br>
13.2.3 框架方法的演示<br>
13.3 制作按钮<br>
13.4 捕获事件<br>
13.5 文本字段<br>
13.6 文本区域<br>
13.7 标签<br>
13.8 复选框<br>
13.9 单选钮<br>
13.10 下拉列表<br>
13.11 列表框<br>
13.11.1 handleEvent()<br>
13.12 布局的控制<br>
13.12.1 FlowLayout<br>
13.12.2 BorderLayout<br>
13.12.3 GridLayout<br>
13.12.4 CardLayout<br>
13.12.5 GridBagLayout<br>
13.13 action的替用品<br>
13.14 程序片的局限<br>
13.14.1 程序片的优点<br>
13.15 视窗化应用<br>
13.15.1 菜单<br>
13.15.2 对话框<br>
13.16 新型AWT<br>
13.16.1 新的事件模型<br>
13.16.2 事件和接收者类型<br>
13.16.3 用Java 1.1 AWT制作窗口和程序片<br>
13.16.4 再探早期示例<br>
13.16.5 动态绑定事件<br>
13.16.6 将商业逻辑与UI逻辑区分开<br>
13.16.7 推荐编码方法<br>
13.17 Java 1.1 UI API<br>
13.17.1 桌面颜色<br>
13.17.2 打印<br>
13.17.3 剪贴板<br>
13.18 可视编程和Beans<br>
13.18.1 什么是Bean<br>
13.18.2 用Introspector提取BeanInfo<br>
13.18.3 一个更复杂的Bean<br>
13.18.4 Bean的封装<br>
13.18.5 更复杂的Bean支持<br>
13.18.6 Bean更多的知识<br>
13.19 Swing入门<br>
13.19.1 Swing有哪些优点<br>
13.19.2 方便的转换<br>
13.19.3 显示框架<br>
13.19.4 工具提示<br>
13.19.5 边框<br>
13.19.6 按钮<br>
13.19.7 按钮组<br>
13.19.8 图标<br>
13.19.9 菜单<br>
13.19.10 弹出式菜单<br>
13.19.11 列表框和组合框<br>
13.19.12 滑杆和进度指示条<br>
13.19.13 树<br>
13.19.14 表格<br>
13.19.15 卡片式对话框<br>
13.19.16 Swing消息框<br>
13.19.17 Swing更多的知识<br>
13.20 总结<br>
13.21 练习<br>
<br>
<a href="./chapter/chapter14.htm">第14章 多线程</a><br>
14.1 反应灵敏的用户界面<br>
14.1.1 从线程继承<br>
14.1.2 针对用户界面的多线程<br>
14.1.3 用主类合并线程<br>
14.1.4 制作多个线程<br>
14.1.5 Daemon线程<br>
14.2 共享有限的资源<br>
14.2.1 资源访问的错误方法 <br>
14.2.2 Java如何共享资源<br>
14.2.3 回顾Java Beans<br>
14.3 堵塞<br>
14.3.1 为何会堵塞<br>
14.3.2 死锁<br>
14.4 优先级<br>
14.4.1 线程组<br>
14.5 回顾runnable<br>
14.5.1 过多的线程<br>
14.6 总结<br>
14.7 练习<br>
<br>
<a href="./chapter/chapter15.htm">第15章 网络编程</a><br>
15.1 机器的标识<br>
15.1.1 服务器和客户机<br>
15.1.2 端口：机器内独一无二的场所<br>
15.2 套接字<br>
15.2.1 一个简单的服务器和客户机程序<br>
15.3 服务多个客户<br>
15.4 数据报<br>
15.5 一个Web应用<br>
15.5.1 服务器应用<br>
15.5.2 NameSender程序片<br>
15.5.3 15.5.3 要注意的问题<br>
15.6 Java与CGI的沟通<br>
15.6.1 CGI数据的编码<br>
15.6.2 程序片<br>
15.6.3 用C++写的CGI程序<br>
15.6.4 POST的概念<br>
15.7 用JDBC连接数据库<br>
15.7.1 获得学习示例<br>
15.7.2 查找程序的GUI版本<br>
15.7.3 JDBC API为何如何复杂<br>
15.8 远程方法<br>
15.8.1 远程接口概念<br>
15.8.2 远程接口的实施<br>
15.8.3 创建根与干<br>
15.8.4 使用远程对象<br>
15.8.5 RMI的替选方案<br>
15.9 总结<br>
15.10 练习<br>
<br>
<a href="./chapter/chapter16.htm">第16章 设计范式</a><br>
16.1 范式的概念<br>
16.1.1 单子<br>
16.1.2 范式分类<br>
16.2 观察器范式<br>
16.3 模拟垃圾回收站<br>
16.4 改进设计<br>
16.4.1 “制作更多的对象”<br>
16.4.2 用于原型创建的一个范式<br>
16.5 抽象的应用<br>
16.6 多重派遣<br>
16.6.1 实现双重派遣<br>
16.7 访问器范式<br>
16.8 RTTI有害吗<br>
16.9 总结<br>
16.10 练习<br>
<br>
<a href="./chapter/chapter17.htm">第17章 项目</a><br>
17.1 文字处理<br>
17.1.1 提取代码列表<br>
17.1.2 检查大小写样式<br>
17.2 方法查找工具<br>
17.3 复杂性理论<br>
17.4 总结<br>
17.5 练习<br>
<br>
<a href="./chapter/appa.htm">附录A 使用非Java代码</a><br>
A.1 Java固有接口<br>
A.1.1 调用固有方法<br>
A.1.2 访问JNI函数：JNIEnv自变量<br>
A.1.3 传递和使用Java对象<br>
A.1.4 JNI和Java违例<br>
A.1.5 JNI和线程处理<br>
A.1.6 使用现成代码<br>
A.2 微软的解决方案<br>
A.3 J/Direct<br>
A.3.1 @dll.import引导命令<br>
A.3.2 com.ms.win32包<br>
A.3.3 汇集<br>
A.3.4 编写回调函数<br>
A.3.5 其他J/Direct特性<br>
A.4 本原接口（RNI）<br>
A.4.1 RNI总结<br>
A.5 Java/COM集成<br>
A.5.1 COM基础<br>
A.5.2 MS Java/COM集成<br>
A.5.3 用Java设计COM服务器<br>
A.5.4 用Java设计COM客户<br>
A.5.5 ActiveX/Beans集成<br>
A.5.6 固有方法与程序片的注意事项<br>
A.6 CORBA<br>
A.6.1 CORBA基础<br>
A.6.2 一个例子<br>
A.6.3 Java程序片和CORBA<br>
A.6.4 比较CORBA与RMI<br>
A.7 总结<br>
<br>
<a href="./chapter/appb.htm">附录B 对比C++和Java</a><br>
<br>
<a href="./chapter/appc.htm">附录C Java编程规则</a><br>
<br>
<a href="./chapter/appd.htm">附录D 性能</a><br>
D.1 基本方法<br>
D.2 寻找瓶颈<br>
D.2.1 安插自己的测试代码<br>
D.2.2 JDK性能评测[2]<br>
D.2.3 特殊工具<br>
D.2.4 性能评测的技巧<br>
D.3 提速方法<br>
D.3.1 常规手段<br>
D.3.2 依赖语言的方法<br>
D.3.3 特殊情况<br>
D.4 参考资源<br>
D.4.1 性能工具<br>
D.4.2 Web站点<br>
D.4.3 文章<br>
D.4.4 Java专业书籍<br>
D.4.5 一般书籍<br>
<br>
<a href="./chapter/appe.htm">附录E 关于垃圾收集的一些话</a><br>
<br>
<a href="./chapter/appf.htm">附录F 推荐读物</a></p>

<!--msthemeseparator-->

<p align="center"><a href="http://www.bruceeckel.com">英文版主页</a> | <a href="./index.htm">中文版主页</a> | <a href="index.htm">详细目录</a> | <a href="./about/index.htm">关于译者</a></p>
</body>
</html>
