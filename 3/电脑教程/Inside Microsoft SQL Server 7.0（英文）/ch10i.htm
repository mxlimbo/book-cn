<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Environmental Concerns</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch10h.htm">[Previous]</A> <A HREF="ch10j.htm">[Next]</A><P>

<A NAME="411"><H1>Environmental Concerns</H1></A>

<P>To finish this discussion of Transact-SQL programming, we'll briefly look 
at some of the environmental concerns that you need to be aware of in 
your programming&#8212;for example, we'll discuss case sensitivity, which can greatly 
affect your applications. We'll also look at nullability issues and ANSI compatibility.</P>

<A NAME="412"><H2>Case Sensitivity</H2></A>

<P>Various options and settings affect the semantics of your Transact-SQL 
statements. You must be sure that your Transact-SQL code can work regardless 
of the setting, or you must control the environment so that you know what 
the setting is.</P>

<P>Case sensitivity is by far the most common environmental problem, 
and it is simple to avoid. You should seriously consider doing most of 
your development in a case-sensitive environment, even if you will deploy 
your application mostly in a case-insensitive environment. The reason is simple: 
nearly all operations that work in a case-sensitive environment will also work in a 
case-insensitive environment, but the converse is not true. For example, if we 
write the statement <I>select * from authors</I> in the 
<I>pubs</I> database of a case-sensitive environment, it will work equally well in a case-insensitive environment. On the 
other hand, the statement <I>SELECT * FROM AUTHORS 
</I>will work fine in a case-insensitive environment but will fail in a case-sensitive environment. The 
table in <I>pubs</I> is actually named 
<I>authors</I>, which is lowercase. The only statement 
that would work in a case-sensitive environment but fail in a case-insensitive 
environment is the declaration of an object name, a column name, or a variable 
name. For example, with the statement <I>declare @myvar 
int</I>, another statement declaring <I>@MYVAR 
int</I> would work fine in a case-sensitive environment because the 
two names are distinct, but it would fail in a case-insensitive environment 
because the names would be considered duplicates.</P>

<P>The easiest way to determine whether your environment is case 
sensitive is to perform a SELECT statement with a WHERE clause that compares a 
lowercase letter with its uppercase counterpart&#8212;you wouldn't need to access a 
table to do this. The following simple SELECT statement returns 1 if the server 
is case sensitive and 0 if the server is case insensitive:</P>

<table cellpadding=5 width="95%"><tr><td>
<p><pre>
SELECT CASE
    WHEN ('A'='a') THEN 0
    ELSE 1
END
</pre></p>
</td></tr></table>

<P>Case sensitivity is just one of the issues surrounding the character set 
used by SQL Server. The character set choice will affect both the rows selected 
and their ordering in the result set for a query such as this:</P>

<table cellpadding=5 width="95%"><tr><td>
<p><pre>
SELECT au_lname, au_fname FROM authors
    WHERE au_lname='Jos&eacute;'
ORDER BY au_lname, au_fname
</pre></p>
</td></tr></table>

<P>If you never use characters that are not in the standard ASCII 
character set, case sensitivity is really your primary issue. But if your data has special 
characters like the <I>&eacute; </I>in this example, be sure that you understand character-set 
issues. (For more information, see <A HREF="ch04a.htm">Chapter 4</A>.)</P>

<A NAME="413"><H2>Nullability and ANSI Compliance Settings</H2></A>

<P>To pass the NIST test suite for ANSI SQL-92 compliance, various options 
had to be enabled in SQL Server because of subtle differences in semantics 
between the traditional SQL Server behavior and what is mandated by ANSI. We 
already covered the majority of these issues in earlier chapters. To preserve 
backward compatibility, the prior behavior couldn't simply be changed. So options 
were added (or in a few cases, previous options were toggled on) to change 
the semantics to comply with the ANSI SQL requirements. These options are 
summarized below, along with the statement used to change the behavior:</P>

<UL>
<P><LI>
Disable SQL Server's = NULL extension (<I>SET ANSI_NULLS ON</I>).
</LI></P>

<P><LI>
Automatically display a warning if a truncation would occur 
because the target column is too small to accept a value. By default, 
SQL Server truncates without any warning (<I>SET ANSI_WARNINGS 
ON</I>).
</LI></P>

<P><LI>
Always right-pad 
<I>char</I> columns, and don't trim trailing blanks 
that were entered in <I>varchar</I> columns, as SQL Server would do by 
default (<I>SET ANSI_PADDING ON</I>).
</LI></P>

<P><LI>
Make statements implicitly part of a transaction, requiring a 
subsequent COMMIT or ROLLBACK (<I>SET IMPLICIT 
TRANSACTIONS ON</I>).
</LI></P>

<P><LI>
Terminate a query if an overflow or divide-by-zero error occurs 
(<I>SET ARITHABORT ON</I>). By default, SQL Server returns NULL 
for these operators, issues a warning message, and proceeds.
</LI></P>

<P><LI>
Close any open cursors upon COMMIT of a transaction. By 
default, SQL Server keeps the cursor open so that it can be reused 
without incurring the overhead of reopening it 
(<I>SET CURSOR_CLOSE_ON_COMMIT ON</I>).
</LI></P>

<P><LI>
Allow identifier names to include SQL Server keywords if the 
identifier is included in double quotation marks, which by default is 
not allowed. This causes single and double quotation marks to be 
treated differently (<I>SET QUOTED_IDENTIFIER ON</I>).
</LI></P>

<P><LI>
By default, create as NOT NULL a column in a CREATE 
TABLE statement that is not specified as NULL or NOT NULL. 
<I>SET ANSI_NULL_DFLT_ON ON</I> toggles this so that the column can 
be created with NULL. (We recommend that you always specify NULL or NOT NULL so that this setting option is irrelevant.) The nullability of a column not explicitly declared is determined 
by the setting at the time the table was created, which could be 
different from the current setting.
</LI></P>
</UL>

 <P>All the previous options can be set individually, but you might want to 
avoid doing that because there are 256 (2<SUP>8</SUP>) permutations to consider. You might 
want to set a few of the options individually, such as 
<I>SET ARITHABORT</I> or <I>SET ARITHIGNORE.</I> But by and large, you should either leave them all at 
their default settings or change them as a group to the ANSI SQL-92 
behavior. These options can be enabled as a group by setting 
<I>SET ANSI_DEFAULTS ON.</I></P>

<P>The ability to set these options on a per-connection basis makes life 
interesting for you as a SQL Server application programmer. Your challenge is 
to recognize and deal with the fact that these settings will change the behavior 
of your code. Basically, that means you need to adopt some form of the 
following four strategies:</P>

<UL>
<P><LI>
<B>The Optimistic Approach</B> Hope that none of your users or the 
person doing database administration will change such a setting. 
Augment your optimism by educating users not to change these settings.
</LI></P>

<P><LI>
<B>The Flexible Approach</B> Try to write all your procedures to accommodate all permutations of the settings of all the 
various options (usually not practical).
</LI></P>

<P><LI>
<B>The Hard-Line Approach</B> Explicitly set your preferences at 
startup and periodically recheck them to determine that they have not 
been subsequently altered. Simply refuse to run if the settings are 
not exactly what you expect.
</LI></P>

<P><LI>
<B>The Clean Room Approach</B> Have a &quot;sealed&quot; system that 
prevents anyone from having direct access to change such a setting.
</LI></P>
</UL>

<P>Whichever of these approaches you take is your choice, but recognize 
that if you don't think about the issue at all, you have basically settled for 
the Optimistic Approach. This approach is certainly adequate for many 
applications for which it's pretty clear that the user community would have neither the 
desire nor the ability to make environmental changes. But if you're deploying an 
application and the machine running SQL Server will be accessed by 
applications that you don't control, it is probably an overly simplistic approach. 
Philosophically, the Flexible Approach is nice, but it probably isn't realistic unless the 
application is quite simple.</P>

<P>You can change the SQL Server default values for the server as a whole 
by using <I>sp_configure 'user options'</I>. A specific user connection can then 
further refine the environment by issuing one of the specific SET statements we 
just discussed. The system function @@OPTIONS can then be examined by any 
connection to see the current settings for that connection. The @@OPTIONS 
function and the value to be set using <I>sp_configure 'user 
options'</I> are a bit mask with the values depicted in Table 10-2.</P>

<p><table cellpadding=5 width="95%">
<tr>
<th>Decimal Value</th>    
<th>Hexadecimal Value</th>     
<th>Option and Description</th>
</tr>
<tr>
<td valign="top">2</td>          
<td valign="top">0x0002</td>     
<td valign="top">IMPLICIT_TRANSACTIONS. Controls whether a transaction is started implicitly when a statement is executed.</td>
</tr>
<tr>
<td valign="top">4</td>          
<td valign="top">0x0004</td>     
<td valign="top">CURSOR_CLOSE_ON_COMMIT. Controls behavior of cursors once a commit has been performed.</td>
</tr>
<tr>				
<td valign="top">8</td>          
<td valign="top">0x0008</td>     
<td valign="top">ANSI_WARNINGS. Controls truncation and NULL in aggregate warnings.</td>
</tr>
<tr>		
<td valign="top">16</td>         
<td valign="top">0x0010</td>
<td valign="top">ANSI_PADDING. Controls padding of variables.</td>
</tr>
<tr>
<td valign="top">32</td>
<td valign="top">0x0020</td>    
<td valign="top">ANSI_NULLS. Controls NULL handling by using equality operators.</td>
</tr>
<tr>
<td valign="top">64</td>
<td valign="top">0x0040</td>    
<td valign="top">ARITHABORT. Terminates a query when an overflow or divide-by-zero error occurs during query execution.</td>
</tr>
<tr>
<td valign="top">128</td>
<td valign="top">0x0080</td>   
<td valign="top">ARITHIGNORE. Returns NULL when an overflow or divide-by-zero error occurs during a query.</td>
</tr>
<tr>
<td valign="top">256</td>
<td valign="top">0x0100</td>   
<td valign="top">QUOTED_IDENTIFIER. Differentiates between single and double quotation marks when evaluating an expression, allowing object names to include characters that would otherwise not conform to naming rules or would collide with a reserved word or a keyword.</td>
</tr>
<tr>
<td valign="top">512</td>     
<td valign="top">0x0200</td>     
<td valign="top">NOCOUNT. Turns off the message returned at the end of each statement that states how many rows were affected by the statement.</td>
</tr>
<tr>
<td valign="top">1024</td>    
<td valign="top">0x0400</td>     
<td valign="top">ANSI_NULL_DFLT_ON. Alters the session's behavior to use ANSI compatibility for nullability. New columns defined without explicit nullability will be defined to allow NULLs.</td>
</tr>
<tr>
<td valign="top">2048</td>    
<td valign="top">0x0800</td>     
<td valign="top">ANSI_NULL_DFLT_OFF. Alters the session's behavior to not use 
ANSI compatibility for nullability. New columns defined without explicit nullability will be defined to prohibit NULLS.</td>
</tr></table></p>

</P>
<P>
<!-- caption --><B>Table 10-2.</B> <I>Bit mask values for SQL Server options.</I><!-- /caption -->
</P>


<P>By default, none of these options is enabled for SQL Server itself. So in 
a brand-new installation, the run value for <I>sp_configure 'user 
options'</I> will be 0. A system administrator can set this so that all connections have the same 
initial default settings. If you query the value of @@OPTIONS from an application 
that has not modified the environment, the value will also be 0. However, be 
aware that many applications, or even the SQL Server ODBC or OLE DB drivers 
that the application uses, might have changed the environment. Note that 
this includes the SQL Server Query Analyzer, which uses ODBC. To change 
the default behavior, simply set the corresponding bit by doing a bitwise OR 
with the previous value. For example, suppose that your run value is 512, 
which indicates that NOCOUNT is the only option turned on. You want to 
leave NOCOUNT enabled, but you also want to enable option value 32, 
which controls how NULLs are handled when using equality comparisons. You'd 
simply pass the decimal value 544 (or 0x220) to 
<I>sp_configure 'user options'</I>, which is the result of doing a bitwise OR between the two options (for 
example, SELECT 32|512).</P>

<P>You can examine current options that have been set using 
<I>DBCC USER OPTIONS</I>. The output is similar to the code below.</P>

<table cellpadding=5 width="95%"><tr><td>
<p><pre>
Set Option    Value
----------    ----------
textsize      64512
language      us_english
dateformat    mdy
datefirst     7
arithabort    SET
nocount       SET
</pre></p>
</td></tr></table>

<P>This DBCC command shows only options that have been set&#8212;it 
doesn't show all the current settings for <I>sp_configure 'user 
options'</I>. But you can also decode your current connection settings pretty easily from @@OPTIONS 
using something like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<p><pre>
SELECT &quot;IMPLICIT TRANSACTIONS&quot;, CASE WHEN
    (@@OPTIONS &amp; 0x0002 &gt; 0) THEN 'ON' ELSE 'OFF' END
UNION
SELECT &quot;CURSOR_CLOSE_ON_COMMIT&quot;, CASE WHEN
    (@@OPTIONS &amp; 0x0004 &gt; 0) THEN 'ON' ELSE 'OFF' END
UNION
SELECT &quot;ANSI_WARNINGS&quot;,CASE WHEN (@@OPTIONS &amp; 0x0008 &gt; 0) THEN
    'ON' ELSE 'OFF' END
UNION
SELECT &quot;ANSI_PADDINGS&quot;, CASE WHEN (@@OPTIONS &amp; 0x0010 &gt; 0) THEN 
    'ON' ELSE 'OFF' END
UNION
SELECT &quot;ANSI_NULLS&quot;, CASE WHEN (@@OPTIONS &amp; 0x0020 &gt; 0) THEN 'ON'
    ELSE 'OFF' END
UNION
SELECT &quot;ARITHABORT&quot;, CASE WHEN (@@OPTIONS &amp; 0x0040 &gt; 0) THEN 'ON' 
    ELSE 'OFF' END
UNION
SELECT &quot;ARITHIGNORE&quot;, CASE WHEN (@@OPTIONS &amp; 0x0080 &gt; 0)
    THEN 'ON' ELSE 'OFF' END
UNION
SELECT &quot;QUOTED_IDENTIFIER&quot;, CASE WHEN (@@OPTIONS &amp; 0x0100 &gt; 0)
    THEN 'ON' ELSE 'OFF' END
UNION
SELECT &quot;NOCOUNT&quot;, CASE WHEN (@@OPTIONS &amp; 0x0200 &gt; 0) THEN 'ON'
    ELSE 'OFF' END
UNION
SELECT &quot;ANSI_NULL_DFLT_ON&quot;, CASE WHEN (@@OPTIONS &amp; 0x0400 &gt; 0)
    THEN 'ON' ELSE 'OFF' END
UNION
SELECT &quot;ANSI_NULL_DFLT_OFF&quot;, CASE WHEN (@@OPTIONS &amp; 0x0800 &gt; 0)
    THEN 'ON' ELSE 'OFF' END
ORDER BY &quot;OPTION&quot;
</pre></p>
</td></tr></table>

<P>Here's the result:</P>

<table cellpadding=5 width="95%"><tr><td>
<p><pre>
OPTION                   SETTING
----------------------   -------
ANSI_NULL_DFLT_OFF       OFF
ANSI_NULL_DFLT_ON        OFF
ANSI_NULLS               OFF
ANSI_PADDINGS            OFF
ANSI_WARNINGS            OFF
ARITHABORT               OFF
ARITHIGNORE              OFF
CURSOR_CLOSE_ON_COMMIT   OFF
IMPLICIT TRANSACTIONS    OFF
NOCOUNT                  ON
QUOTED_IDENTIFIER        OFF
</pre></p>
</td></tr></table>

<P>Unfortunately, running the previous SELECT statement will not give 
you a complete picture. As we saw in <A HREF="ch05a.htm">Chapter 5</A>, many of the options, especially 
those involving NULL handling, can also be changed at the database level by 
using <I>sp_dboption</I>. To really get the full picture, you must examine @@OPTIONS 
for your current session in addition to 
<I>sp_dboption</I> for your current database.</P>

<A NAME="414"><H2>Locale-Specific SET Options</H2></A>

<P>Beware of the locale-specific SET options. SET DATEFORMAT and 
SET DATEFIRST change the recognized default date format. If 
DATEFORMAT is changed to <I>dmy</I> instead of the (U.S.) default 
<I>mdy</I>, a date such as <I>'12/10/98'</I> will be interpreted as October 12, 1998.  A good strategy for dates is to 
always use the ISO format<I> yyyymmdd</I>, which is recognized no matter what the 
setting of DATEFORMAT is.</P>

<P>DATEFIRST affects what is considered the first day of the week. By 
default (in the United States), it has the value 7 (Sunday). Date functions that work 
with the day-of-week as a value between 1 and 7 will be affected by this setting. 
These day-of-week values can be confusing, since their numbering depends on 
the DATEFIRST value; but the values for DATEFIRST don't change. For 
example, as far as DATEFIRST is considered, Sunday's value is 
always 7. But having then designated Sunday (7) as DATEFIRST, if you executed the statement 
<I>SELECT DATEPART(dw,GETDATE())</I> and your date falls on a Sunday, the 
statement will return 1. You just defined Sunday to be the first day of the week, so 1 is 
correct.</P>

</BODY>
</HTML>



