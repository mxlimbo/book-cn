<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Temporary Tables</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06h.htm">[Previous]</A> <A HREF="ch06j.htm">[Next]</A><P>

<A NAME="260"><H1>Temporary Tables</H1></A>

<p>Temporary tables are useful workspaces, like scratch pads, that you can use to try out intermediate data processing or to share work-in-progress with other connections. You can create temporary tables from within any database, but they exist in only the<i> tempdb</i> database, which is created every time the server is restarted. Don't assume that temporary tables aren't logged: temporary tables, and actions on those tables, are logged in <i>tempdb </i>so that transactions can be rolled back as necessary. However, the log isn't used for recovery of the database at system restart because the database is entirely re-created. Likewise, <i>tempdb</i> is never restored from a backup, so the log in <i>tempdb</i> is never needed for restoring the database. Unlike earlier versions of SQL Server, SQL Server 7 can log just enough information to allow rollback of transactions, without logging the additional information that would be necessary to recover those transactions, either at system startup or when recovering from a backup. This reduced logging means that data modification operations on tables in <i>tempdb</i> can be up to four times faster than the same operations in other databases. You can use temporary tables in three ways in SQL Server: privately, globally, and directly.</p>

<A NAME="261"><H2>Private Temporary Tables (#)</H2></A>

<p>By prefixing a table name with a single pound sign (#)&#8212;for example, CREATE TABLE<i> #my_table</i>&#8212;the table can be created from within any database as a private temporary table. Only the connection that created the table can access the table, making it truly private. Privileges can't be granted to another connection. As a temporary table, it exists for the life of that connection only; that connection can drop the table via DROP TABLE. Because the scoping of a private temporary table is specific to the connection that created it, you won't encounter a name collision should you choose a table name that's used in another connection. Private temporary tables are analogous to local variables&#8212;each connection has its own private version, and private temporary tables that are held by other connections are irrelevant. (However, temporary tables do differ from local variables in one crucial way: temporary tables exist for the life of the session, while local variables exist only for a single batch.)</p>

<A NAME="262"><H2>Global Temporary Tables (##)</H2></A>

<p>By prefixing the table name with double pound signs (##)&#8212;for example, CREATE TABLE<i> ##our_table</i>&#8212;a global temporary table can be created from within any database and any connection. Any connection can subsequently access the table for retrieval or data modification, even without specific permission. Unlike private temporary tables, all connections can use the single copy of a global temporary table. Therefore, you can encounter a name collision if another connection has created a global temporary table of the same name, and the CREATE TABLE statement will fail.</p>

<p>A global temporary table exists until the creating connection terminates and all current use of the table completes. After the creating connection terminates, however, only those connections already accessing it are allowed to finish, and no further use of the table is allowed. If you want a global temporary table to exist permanently, you can create the table in a stored procedure that's marked to autostart whenever SQL Server is started. That procedure can be put to sleep using WAITFOR and it will never terminate, so the table will never be dropped. Or you can choose to use <i>tempdb </i>directly, which is discussed next.</p>

<A NAME="263"><h2>Direct Use of <i>tempdb</i></h2></A>
<p>Realizing that <i>tempdb</i> is re-created every time SQL Server is started, you can use <i>tempdb</i> to create a table or you can fully qualify the table name to include the database name <i>tempdb</i> in the CREATE TABLE statement issued from another database. To do this, you need to establish <i>create table</i> privileges in <i>tempdb</i>. You can set up privileges in <i>tempdb</i> in one of two ways every time SQL Server starts: you can set the privileges in <i>model</i> (the template database) so that they are copied to <i>tempdb</i> when it's created at system restart, or you can have an <i>autostart</i> procedure set the <i>tempdb</i> privileges every time SQL Server is started. One reason to consider <i>not</i> setting the privileges for <i>tempdb</i> in the <i>model</i> database is because <i>tempdb</i> isn't the only database that will be affected. Any new database you create will inherit those permissions too.</p>

<p>Tables directly created in <i>tempdb</i> can exist even after the creating connection is terminated, and the creator can specifically grant and revoke access permissions to specific users:</p>

<p>
<table cellpadding="5" width="95%">
	<tr>
		<td>
<pre>&#8212; Creating a table in tempdb from pubs. Another method would be 
&#8212; to first do a 'use tempdb' instead of fully qualifying 
&#8212; the name.
CREATE TABLE tempdb.dbo.testtemp
(col1 int)
</pre></td>
		</tr>
	</table></p>

<A NAME="264"><H2>Constraints on Temporary Tables</H2></A>

<p>A few articles about SQL Server erroneously state that constraints don't work on temporary tables. However, all constraints work on temporary tables explicitly built in <i>tempdb</i> (not using the # or ## prefixes). All constraints except FOREIGN KEY constraints work with tables using the # (private) and ## (global) prefixes. FOREIGN KEY references on private and global temporary tables are designed not to be enforced, because such a reference could prevent the temporary table from being dropped at close-connection time (for private temporary tables) or when a table goes out of scope (for global temporary tables) if the referencing table wasn't dropped first.</p>

</BODY>
</HTML>



