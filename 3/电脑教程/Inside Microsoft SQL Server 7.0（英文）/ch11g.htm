<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Cursor Variables</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch11f.htm">[Previous]</A> <A HREF="ch11h.htm">[Next]</A><P>

<A NAME="452"><H1>Cursor Variables</H1></A>

<P>SQL Server 7 lets you declare variables with a type of cursor. Besides 
scalar (single-valued) variables, cursor variables are the only type of variable 
possible. To assign to a cursor variable, you use the SET statement. (Cursor 
variables cannot be assigned a value with an assignment SELECT, as scalar values 
can.) Cursor variables can be either the source or the target in SET assignment 
statements, and they can be used as the type for output parameters. They can be 
used in any of the cursor management statements: OPEN, FETCH, CLOSE, 
and DEALLOCATE. However, you cannot have a column in a table of type 
<I>cursor,</I> and input parameters to stored procedures cannot be cursors.</P>

<P>The following example declares a cursor and then sets a variable to 
reference the same result set:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
DECLARE declared_cursor CURSOR FOR SELECT au_lname FROM authors
DECLARE @cursor_var cursor
SET @cursor_var = declared_cursor
</PRE></P>
</td></tr></table>

<P>The declared cursor and the cursor variable are almost synonymous. 
You can use either the declared name or the cursor variable name to open the 
cursor&#8212;they are two references to the same internal structure. You can open the 
cursor with this statement:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
OPEN @cursor_var
</PRE></P>
</td></tr></table>

<P>Once you do this, the cursor is open. If you then try to open it with 
the declared name</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
OPEN declared_cursor
</PRE></P>
</td></tr></table>

<P>you get this error:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
Msg 16905, Level 16, State 1
The cursor is already open.
</PRE></P>
</td></tr></table>

<P>If you issue one FETCH with the declared cursor, a subsequent 
FETCH from the cursor variable retrieves the next row. A CLOSE using either 
reference closes the cursor, and no more rows can be fetched. The only time the 
two references are treated differently is in the DEALLOCATE statement. 
Deallocating one of the references means only that you can no longer access the cursor 
using that reference. The internal data structures are not freed until the last 
reference is deallocated. If the cursor has not yet been closed, only the deallocation of 
the last reference closes it.</P>

<P>You can have more than one cursor variable referencing the same 
cursor, as the following example shows:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
DECLARE declared_cursor CURSOR LOCAL 
FOR SELECT title_id, price from titles
DECLARE @cursor_var_a CURSOR
DECLARE @cursor_var_b CURSOR
SET @cursor_var_a = declared_cursor
SET @cursor_var_b = @cursor_var_a
OPEN @cursor_var_a      -- opens declared cursor
FETCH @cursor_var_b     -- fetches row 1 from declared_cursor
FETCH declared_cursor   -- fetches row 2
DEALLOCATE declared_cursor
-- keeps cursor open since other references remain,
-- but can't use declared_cursor name to reference the cursor
</PRE></P>
</td></tr></table>

<P>One main use of cursor variables is for output parameters. There are 
four stored procedures for retrieving information about cursors, and each returns 
its information in a cursor. We'll look at these procedures in the next section.</P>

<A NAME="453"><H2>Obtaining Cursor Information</H2></A>

<P>Along with the wealth of cursor functionality in SQL Server 7, you have 
access to a function and several procedures that provide you with information 
about your cursors. However, these procedures are not always easy to use, so we 
have provided some additional procedures that go beyond what is offered with 
the installed SQL Server product.</P>

<A NAME="454"><H3>CURSOR_STATUS</H3></A>

<P>The CURSOR_STATUS() function determines the state of a particular 
cursor or cursor variable. Five possible values can be returned from this function, 
and the meaning of the values is slightly different depending on whether the 
argument is a cursor name or a cursor variable. The function takes two 
arguments; the first one indicates a global cursor, a local cursor, or a cursor variable 
(which is always local). The syntax appears at the top of the next page.</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
CURSOR_STATUS
(
{<B>'</B>local<B>', '</B><I>cursor_name</I><B>'</B>}
| {<B>'</B>global<B>', '</B><I>cursor_name</I><B>'</B>}
| {<B>'</B>variable<B>', '</B><I>cursor_variable</I><B>'</B>}
)
</PRE></P>
</td></tr></table>

<P>Table 11-3 shows the five possible return values and their meanings.</P>

<P><B>Table 11-3.</B> <I>Meanings of return values from the CURSOR_STATUS() function.</I></P>

<table valign="top" cellpadding=5 width="95%">
<tr><th>Return Value</th>
<th>Cursor Name</th>
<th>Cursor Variable</th>
</tr>
<tr>
<td valign="top">1</td>
<td valign="top">The cursor is open, and for static and keyset cursors the result set has at least one row; for dynamic cursors, the result set can have zero, one, or more rows.</td>
<td valign="top">The cursor allocated to this variable is open, and for static and keyset cursors the result set has at least one row; for dynamic cursors, the result set can have zero, one, or more rows.</td>
</tr>
<tr>
<td valign="top">0</td>
<td valign="top">The result set of the cursor is empty. (Dynamic cursors never return this result.)</td>
<td valign="top">The cursor allocated to this variable is open, but the result set is empty. (Dynamic cursors never return this 
result.)</td>
</tr>
<tr>
<td valign="top">-1 </td>
<td valign="top">The cursor is closed.</td>
<td valign="top">The cursor allocated to this variable is closed.</td>
</tr>
<tr>
<td valign="top">-2</td>
<td valign="top">Not applicable.</td>
<td valign="top">No cursor was assigned to this 
OUTPUT variable by the 
previously called procedure.
<I>OR</I>
A cursor was assigned by the previously called procedure, but it was 
in a closed state when the procedure completed. Therefore, the cursor is deallocated and not returned 
to the calling procedure.
<I>OR</I>
There is no cursor assigned to a 
declared cursor variable.</td>
</tr>
<tr>
<td valign="top">-3</td>
<td valign="top">A cursor with the specified name does not exist.</td>
<td valign="top">A cursor variable with the specified 
name does not exist.
 <I>OR</I>
If one exists it has not yet had a
cursor allocated to it.</td>
</tr>
</table>
	   
<P>We'll use the CURSOR_STATUS() function below when we check 
the output parameter from the 
<I>sp_describe_cursor</I> stored procedure.</P>

<A NAME="455"><H3><I>sp_describe_cursor</I></H3></A>
<P>This procedure provides information on one cursor or cursor variable 
whose name must be passed to the procedure. Even though only one row of 
information is returned, you must supply the procedure with an output parameter of 
type <I>cursor</I>. After executing the procedure, you must use the cursor FETCH 
command to retrieve the information from the returned cursor. Here's the syntax for 
calling the stored procedure:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
sp_describe_cursor [@cursor_return =] <I>
output_cursor_variable</I> OUTPUT
{
[, [@cursor_source =] N'local', [@cursor_identity =] N'<I>
local_cursor_name</I>'] |
[, [@cursor_source =] N'global',
[@cursor_identity =] N'<I>global_cursor_name</I>
'] |
[, [@cursor_source =] N'variable', [@cursor_identity =]
N'<I>input_cursor_variable</I>']
}
</PRE></P>
</td></tr></table>

<P>Here's an example of using the procedure and then accessing the 
data returned in the cursor variable. <I>Authors_cursor 
</I>is the cursor for which we want information and 
<I>@Report </I>is a cursor variable to hold the results.</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
DECLARE authors_cursor CURSOR KEYSET FOR
SELECT au_lname
FROM authors
WHERE au_lname LIKE 'S%'

OPEN authors_cursor

-- Declare a cursor variable to hold the cursor output variable
-- from sp_describe_cursor
DECLARE @Report CURSOR

-- Execute sp_describe_cursor into the cursor variable
EXEC master.dbo.sp_describe_cursor 
    @cursor_return = @Report OUTPUT, 
    @cursor_source = 'global', 
    @cursor_identity = 'authors_cursor'

-- Verify that the cursor variable contains information

IF cursor_status('variable', '@Report') != 1
    print 'No information available from the cursor'

ELSE BEGIN   

-- Fetch all the rows from the sp_describe_cursor output cursor
    WHILE (@@fetch_status = 0)
    BEGIN
        FETCH NEXT from @Report
    END
END

-- Close and deallocate the cursor from sp_describe_cursor
IF cursor_status('variable','@Report') &gt;= -1 
BEGIN
    CLOSE @Report
    DEALLOCATE @Report
END

GO

-- Close and deallocate the original cursor
CLOSE authors_cursor
DEALLOCATE authors_cursor
GO
</PRE></P>
</td></tr></table>

<P>Here's some of the information returned:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
reference_name cursor_scope status model concurrency scrollable open_status 
-------------- ------------ ------ ----- ----------- ---------- -----------
authors_cursor 2            0      2     3           1          1



cursor_rows fetch_status column_count row_count last_operation
----------- ------------ ------------ --------- --------------
0           0            1            0         1 
</PRE></P>
</td></tr></table>

<P>Table 11-4 shows some of the return values.</P>
    
<P><b>Table 11-4.</b> <i>Meaning of values returned by sp_describe_cursor.</i></P>
	 
<table valign="top" cellpadding=5 width="95%">
<tr><th>Function</th>
<th>Return Values</th>
</tr>
<tr>
<td valign="top">CURSOR_SCOPE</td>
<td valign="top">1 = LOCAL<BR> 2 = GLOBAL</td>
</tr>
<tr>
<td valign="top">STATUS</td>
<td valign="top">The same values as reported by the 
CURSOR_STATUS() system function, 
described above.</td>
</tr>
<tr>
<td valign="top">MODEL</td>
<td valign="top">1 = Static<BR>
2 = Keyset<BR>
3 = Dynamic<BR>
4 = Fast forward<BR>
</td>
</tr>                   
<tr>
<td valign="top">CONCURRENCY</td>
<td valign="top">1 = Read-only<BR>
2 = Scroll locks<BR>
3 = Optimistic<BR></td>
</tr>
<tr>
<td valign="top">SCROLLABLE</td>
<td valign="top">0 = Forward-only<BR>
1 = Scrollable<BR></td>
</tr>
<tr>
<td valign="top">OPEN_STATUS </td>
<td valign="top">0 = Closed<BR>
1 = Open<BR></td>
</tr>
<tr>
<td valign="top">CURSOR_ROWS</td>
<td valign="top">Number of qualifying rows in the result set.</td>
</tr>
<tr>
<td valign="top">FETCH_STATUS</td>
<td valign="top"> The status of the last fetch on this cursor, as 
indicated by the @@FETCH_STATUS function.<BR>
0 = The fetch was successful.<BR>
-1 = The fetch failed or is beyond the bounds<BR> 
of the cursor.
-2 = The requested row is missing.<BR>
-9 = There was no fetch on the cursor.<BR></td>
</tr>
<tr>
<td valign="top">COLUMN_COUNT</td>
<td valign="top">The number of columns in the cursor result set.</td>
</tr>
<tr>
<td valign="top">ROW_COUNT</td>
<td valign="top">The number of rows affected by the last 
operation on the cursor, as indicated by the 
@@ROWCOUNT function.</td>
</tr>
<tr>
<td valign="top">LAST_OPERATION</td>
<td valign="top">The last operation performed on the cursor. <BR>
0 = No operations have been performed on <BR> 
    the cursor. <BR>
     1 = OPEN <BR>
     2 = FETCH <BR>
     3 = INSERT <BR>
     4 = UPDATE <BR>
     5 = DELETE <BR>
     6 = CLOSE <BR>
     7 = DEALLOCATE <BR></td>
</tr>
</table>

<A NAME="456"><H3><I>sp_cursor_list</I></H3></A>
<P>This procedure returns the same information as 
<I>sp_describe_cursor</I>, but it does so for all cursors. You can specify whether you want all global cursors, all 
local cursors, or both. Here's the syntax:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
sp_cursor_list [@cursor_return =] <I>cursor_variable_name</I> OUTPUT,
[@cursor_scope =] <I>cursor_scope</I>
</PRE></P>
</td></tr></table>

<P>You can actually create your own stored procedure as a wrapper 
around <I>sp_cursor_list.</I> This allows you to avoid the declaration of the 
<I>@Report </I>cursor output parameter every time you want to look at cursor properties. You also 
do not have to code the repeated fetching of rows using this cursor variable. 
Here's an example of what such a procedure might look like. It uses a default of 3 
for the value of <I>scope</I>, which means all cursors, but you can override that when 
you call this new <I>sp_cursor</I>_<I>info</I> procedure, and you can pass a 1 to indicate 
local cursors only or a 2 to indicate global cursors only:</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
use master
go
create proc sp_cursor_info
(@scope int = 3)
as
-- Declare a cursor variable to hold the cursor output variable
-- from sp_cursor_list.

DECLARE @Report CURSOR
-- Execute sp_cursor_list into the cursor variable.

EXEC master.dbo.sp_cursor_list @cursor_return = @Report OUTPUT,

@cursor_scope = @scope
  
-- Fetch all the rows from the sp_cursor_list output cursor.
WHILE (@@FETCH_STATUS = 0)
BEGIN
    FETCH NEXT from @Report
END
  
-- Close and deallocate the cursor from sp_cursor_list.
CLOSE @Report
DEALLOCATE @Report
GO
</PRE></P>
</td></tr></table>

<P>The procedure returns individual cursor rows, one for each cursor 
available in the session. You can expand this procedure even further to populate a 
temporary table with the values in the returned row. You can then use the CASE 
functionality to translate the integer code numbers returned into meaningful strings. 
The companion CD includes a script to build such a procedure, called 
<I>sp_cursor_
details</I>,<I> </I>which calls <I>sp_cursor_list 
</I>and receives the results into a cursor 
variable. By creating the <I>sp_cursor_list</I> and 
<I>sp_cursor_details </I>procedures in your 
<I>master </I>database, you can execute 
<I>sp_cursor_details</I> just like any other 
system-supplied stored procedure. It will always return at least one row of information 
because internally it uses a cursor called @Report to process the results of 
<I>sp_describe_
cursor</I>. If you haven't created any cursors of your own, 
<I>sp_cursor_
details</I> will return output similar to the output below. (This output has been 
split into three sets of columns so it all fits on the page of the book, but the 
output in SQL Server Query Analyzer would be all on one line.</P>

<table valign="top" cellpadding=5 width="95%"><tr><td>
<P><PRE>
Cursor Reference  Declared Name              Scope    Status
----------------- -------------------------- -------- -------------
@Report           _MICROSOFT_SS_0301113436   local    closed

Model        LOCKING    Scrolling    Open Qualifying Rows Fetch Status
------------ ---------- ------------ ---- --------------- -------------
dynamic      read-only  scrollable   no   0               no fetch done

Columns Rows for last operation Last operation Handle
------- ----------------------- -------------- -----------
14      0                       OPEN           301113436
</PRE></P>
</td></tr></table>

<A NAME="457"><H3><I>sp_describe_cursor_tables</I></H3></A>
<P>This procedure reports on the tables accessed by a given cursor. It returns 
its output in a cursor variable, with one row for each table in the specified 
cursor. It returns such information as the name of the table and any optimizer 
hints specified for the table. See the SQL Server online documentation for 
more details.</P>

<A NAME="458"><H3><I>sp_describe_cursor_columns</I></H3></A>
<P>This procedure reports the attributes of the columns in the result set of a 
given cursor. It returns its output in a cursor variable, with one row for each 
column in the SELECT list of the specified cursor. The information 
it returns includes the name of the column, the datatype, the ordinal position of the column, 
and the name of the table from which the cursor is selected. See the SQL 
Server online documentation for more details.</P>

</BODY>
</HTML>



