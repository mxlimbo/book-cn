<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Dealing with NULL</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch07c.htm">[Previous]</A> <A HREF="ch07e.htm">[Next]</A><P>

<A NAME="279"><H1>Dealing with NULL</H1></A>

<P>The FULL OUTER JOIN example shown in Figure 7-4 has a necessary 
twist because of the NULL value that's generated for the missing author 
<I>state</I> column. Note the WHERE<I> </I>clause:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WHERE state &lt;&gt; 'CA' OR state IS NULL
</pre>
</td></tr></table></p>

<P>Without</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
OR state IS NULL
</pre>
</td></tr></table></p>

<P>our favorite row, which contains the title<I> The Psychology of Computer 
Cooking,</I> wouldn't have been selected. Because this title is missing its 
corresponding author, the <I>state</I> column for the query is NULL.</P>

<P>The expression</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
state &lt;&gt; 'CA'
</pre>
</td></tr></table></p>

<P>doesn't evaluate to TRUE for a NULL value. NULL is considered 
unknown. If you were to omit the expression</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
OR state IS NULL
</pre>
</td></tr></table></p>

<P>and execute the query once with the predicate</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
state = 'CA'
</pre>
</td></tr></table></p>

<P>and once with the predicate</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
state &lt;&gt; 'CA'
</pre>
</td></tr></table></p>

<P>it might seem intuitive that, between the two queries, all rows must have 
been selected. But this isn't the case. A NULL 
<I>state</I> satisfies neither condition, and the row with the title 
<I>The Psychology of Computer Cooking</I> wouldn't be part 
of either result.</P>

<P>This example illustrates the essence of <I>three-valued 
logic,</I> so named because a comparison can evaluate to one of three conditions: TRUE, FALSE, 
or Unknown. Dealing with NULL entries requires three-valued logic. If you 
allow NULL entries or have cases in which outer joins are necessary, 
correctly applying three-valued logic is necessary to avoid introducing bugs into your application.</P>

<P>Assume that the table<I> Truth_Table</I> has columns 
<I>X</I> and <I>Y</I>. We have only one row in the table, as follows, with 
<I>X</I> being <I>NULL</I> and <I>Y</I> being 
<I>1</I>:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
X      Y 
----   -
NULL   1
</pre>
</td></tr></table></p>

<P>Without looking ahead, test yourself to see which of the following 
queries returns <I>1</I>:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT 1 FROM Truth_Table WHERE X &lt;&gt; Y -- NOT EQUAL
SELECT 1 FROM Truth_Table WHERE X = Y  -- EQUAL
SELECT 1 FROM Truth_Table WHERE X != Y -- NOT EQUAL
                                       -- (alternative formulation)
SELECT 1 FROM Truth_Table WHERE X &lt; Y  -- LESS THAN
SELECT 1 FROM Truth_Table WHERE X !&lt; Y -- NOT LESS THAN
SELECT 1 FROM Truth_Table WHERE X &gt; Y  -- GREATER THAN
SELECT 1 FROM Truth_Table WHERE X !&gt; Y -- NOT GREATER THAN
</pre>
</td></tr></table></p>

<P>In fact, none of the previous SELECT statements returns 
<I>1</I>, because none of the comparison operations against 
<I>X</I>, which is NULL, evaluate to TRUE. All evaluate to Unknown. Did you score 100 percent? If so, are you 
confident that all your developers would also score 100? If you allow NULL, your 
answer had better be yes.</P>

<P>Further complexity arises when you use expressions that can be 
Unknown with the logical operations of AND, OR, and NOT. Given that an 
expression can be TRUE, FALSE, or Unknown, the truth tables in Table 7-1 below summarize the result of logically combining expressions.</P>

<P>These truth tables can reveal some situations that otherwise might not 
be obvious. For example, you might assume that the condition 
<I>(X &gt;= 0 OR X &lt;= 0) </I>must<B> </B>be TRUE, because 
<I>X</I> for any number always evaluates to TRUE; it 
must be either 0 or greater, or 0 or less. However, if 
<I>X</I> is NULL, then <I>X &gt;= 0</I> is Unknown, and 
<I>X &lt;= 0</I> is also Unknown. Therefore, the expression evaluates 
as <I>Unknown OR Unknown</I>. As the OR truth table shows, this evaluates to 
Unknown. To further illustrate, the following SELECT statement doesn't return a 
<I>1</I>:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT 1 FROM Truth_Table WHERE (X &gt;= 0 OR X &lt;= 0)
</pre>
</td></tr></table></p>

<P><B>Table 7-1.</B> <I>Truth tables showing results of logically combining expressions.</I>
</P>

<p><table cellpadding=5 width="95%">
<tr>
<th>AND with Value</th>     
<th>True</th>     
<th>Unknown</th>     
<th>False</th>
</tr>
<tr>
<td valign="top">TRUE</td>     
<td valign="top">TRUE</td>     
<td valign="top">Unknown</td>     
<td valign="top">FALSE</td>
</tr>
<tr>
<td valign="top">Unknown</td>     
<td valign="top">Unknown</td>     
<td valign="top">Unknown</td>     
<td valign="top">FALSE</td>
</tr>
<tr>
<td valign="top">FALSE</td>     
<td valign="top">FALSE</td>     
<td valign="top">FALSE</td>     
<td valign="top">FALSE</td>
</tr>
<tr>
<th>OR with Value</th>     
<th>True</th>     
<th>Unknown</th>     
<th>False</th>
</tr>
<tr>
<td valign="top">TRUE</td>     
<td valign="top">TRUE</td>     
<td valign="top">TRUE</td>     
<td valign="top">TRUE</td>
</tr>
<tr>
<td valign="top">Unknown</td>     
<td valign="top">TRUE</td>     
<td valign="top">Unknown</td>     
<td valign="top">Unknown</td>
</tr>
<tr>
<td valign="top">FALSE</td>     
<td valign="top">TRUE</td>     
<td valign="top">Unknown</td>     
<td valign="top">FALSE</td>
</tr>
<tr>
<th>NOT</th>     
<th>Evaluates to</th>
<th></th>
<th></th>
</tr>
<tr>
<td valign="top">TRUE</td>     
<td valign="top">FALSE</td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">Unknown</td>     
<td valign="top">Unknown</td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">False</td>     
<td valign="top">TRUE</td>
<td valign="top"></td>
<td valign="top"></td>
</tr></table></p>

<P>And because <I>(X &gt;= 0 OR X &lt;= 0) </I>is Unknown, the condition:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WHERE NOT(X &gt;= 0 OR X &lt;= 0)
</pre>
</td></tr></table></p>

<P>is equivalent (in pseudocode) to:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WHERE NOT (Unknown)
</pre>
</td></tr></table></p>

<P>The NOT truth table shows that <I>NOT 
(Unknown)</I> is Unknown, so the following negation of the previous SELECT statement also returns nothing:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT 1 FROM Truth_Table WHERE NOT(X &gt;= 0 OR X &lt;= 0)
</pre>
</td></tr></table></p>

<P>And, at the possible risk of belaboring this point, since neither 
expression evaluates to TRUE, OR'ing them makes no difference either; consequently, 
this SELECT also returns nothing:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT 1 FROM TRUTH_TABLE 
    WHERE (X &gt;= 0 OR X &lt;= 0) OR NOT(X &gt;= 0 OR X &lt;= 0)
</pre>
</td></tr></table></p>

<P>The fact that none of these SELECT statements evaluates to TRUE, 
even when negating the expression, illustrates that 
<I>not</I> evaluating to TRUE doesn't imply evaluating to FALSE. Rather, it means either evaluating to FALSE 
or evaluating to Unknown.</P>

<P>Two special operators, IS NULL and IS NOT NULL, exist to deal 
with NULL. Checking an expression with one of these operators always evaluates 
to either TRUE or FALSE. No Unknown condition is produced when 
using IS NULL or IS NOT NULL, as shown in Table 7-2.</P>

<P>
<B>Table 7-2.</B> <I>Truth tables for IS NULL and IS NOT NULL.</I>
</P>

<p><table cellpadding=5 width="95%">
<tr>
<th>IS NULL</th>     
<th>Evaluates to</th>    
<th>IS NOT NULL</th>     
<th>Evaluates to</th>
</tr>
<tr>
<td valign="top">TRUE</td>     
<td valign="top">FALSE</td>   
<td valign="top">TRUE</td>     
<td valign="top">TRUE</td>
</tr>
<tr>
<td valign="top">NULL</td>     
<td valign="top">TRUE</td>     
<td valign="top">NULL</td>     
<td valign="top">FALSE</td>
</tr>
<tr>
<td valign="top">FALSE</td>     
<td valign="top">FALSE</td>     
<td valign="top">FALSE</td>     
<td valign="top">TRUE</td>
</tr></table></p>

<P>In the full outer-join query example, the search criteria was</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WHERE state &lt;&gt; 'CA' OR state IS NULL
</pre>
</td></tr></table></p>

<P>For the row with the title <I>The Psychology of Computer 
Cooking</I> (which was produced from the outer-join operation preserving the 
<I>titles</I> row with an un-matched 
<I>authors</I> entry), the <I>authors.state</I> column is NULL. Hence, 
the expression</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
state &lt;&gt; 'CA'
</pre>
</td></tr></table></p>

<P>is Unknown for that row, but the expression</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
state IS NULL
</pre>
</td></tr></table></p>

<P>is TRUE for that row. The full expression evaluates 
to<I> (Unknown OR TRUE)</I>, which is TRUE, and the row qualifies. Without</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
OR state IS NULL
</pre>
</td></tr></table></p>

<P>the expression is only<I> (Unknown)</I>, so the row doesn't qualify.</P>

<A NAME="280"><H2>NULL in the Real World</H2></A>

<P>As you know, we strongly recommend that you minimize the use of NULL. 
In outer-join operations, you should carefully account for NULL values that 
are generated to preserve rows that don't have a match in the table being 
joined. And even if you're comfortable with three-valued logic, your developers 
and anyone querying the data using the SQL language typically won't be; 
therefore, introducing NULL will be a source of bugs just waiting to happen. You 
can, of course, make all column definitions NOT NULL and declare default 
values if no value is specified.</P>

<P>You can often avoid problems of having no matching rows&#8212;without 
the need for outer-join operations&#8212;by 
providing<I> placeholder,</I> or<I> dummy,</I> rows. 
For example, you could easily create a dummy 
<I>titles</I> row and a dummy <I>authors</I> row. By using constraints or triggers, you could insist that every row in 
<I>authors</I> must have a matching entry in 
<I>titleauthor</I>, even if the ultimate matching row in 
<I>titles</I> is simply the dummy row. Likewise, every row 
in<I> titles</I> could be made to reference<I> 
titleauthor</I>, even if the matching row in 
<I>authors</I> is just the dummy row. Having done this, a standard equijoin returns all rows because no 
unmatched rows exist. There's no outer join or NULL complication.</P>

<P>Here's an example: After adding a dummy row for 
<I>authors</I>, one for <I>titles</I>, and one for each unmatched row into the 
<I>titleauthor</I> table, a standard inner join (with INNER specified purely to emphasize the point) is used to produce 
essentially the same results as the FULL OUTER JOIN. The only difference in 
the results is that the placeholder values 
<I>***No Current Author***</I> and <I>***No Current 
Title***</I> are returned instead of NULL.</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BEGIN TRAN -- Transaction will be rolled back so as to avoid
           -- permanent changes

-- Dummy authors row
INSERT authors 
(au_id, au_lname, au_fname, phone, address, city, state, zip, contract)
VALUES 
('000-00-0000', '***No Current Author***',
', 'NONE', 'NONE', 'NONE', 'XX', '99999', 0)


-- Dummy titles row
INSERT titles 
(title_id, title, type, pub_id, price, advance, royalty, ytd_sales,
notes, pubdate)
VALUES 
('ZZ9999', '***No Current Title***',
'NONE', '9999', 0.00, 0, 0, 0, 'NONE', '1900.01.01')


-- Associate authors with no current titles to dummy title
INSERT titleauthor VALUES ('341-22-1782', 'ZZ9999', 0, 0)
INSERT titleauthor VALUES ('527-72-3246', 'ZZ9999', 0, 0)
INSERT titleauthor VALUES ('724-08-9931', 'ZZ9999', 0, 0)
INSERT titleauthor VALUES ('893-72-1158', 'ZZ9999', 0, 0)

-- Associate titles with no current author to dummy author
INSERT titleauthor VALUES ('000-00-0000', 'MC3026', 0, 0)

-- Now do a standard INNER JOIN
SELECT 
'Author'=RTRIM(au_lname) + ', ' + au_fname,
'Title'=title
FROM 
        authors AS A             -- JOIN conditions
        INNER JOIN titleauthor AS TA ON A.au_id=TA.au_id 
        INNER JOIN titles AS T ON t.title_id=TA.title_id
WHERE 
A.state &lt;&gt; 'CA'
ORDER BY 1

ROLLBACK TRAN    -- Undo changes
</pre>
</td></tr></table></p>

<P>This is the result:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Author                       Title
-------------                ------------------
***No Current Author***,     The Psychology of Computer Cooking
Blotchet-Halls, Reginald     Fifty Years in Buckingham Palace
                             Kitchens
DeFrance, Michel             The Gourmet Microwave
del Castillo, Innes          Silicon Valley Gastronomic Treats
Greene, Morningstar          ***No Current Title***
Panteley, Sylvia             Onions, Leeks, and Garlic: Cooking
                             Secrets of the Mediterranean
Ringer, Albert               Is Anger the Enemy?
Ringer, Albert               Life Without Fear
Ringer, Anne                 The Gourmet Microwave
Ringer, Anne                 Is Anger the Enemy?
Smith, Meander               ***No Current Title***
</pre>
</td></tr></table></p>

<P>Earlier, you saw how OUTER JOIN became complicated and prone 
to mistakes. It's comforting to know that, regardless of the order in which 
we specify the tables for the join operation using dummy rows, the semantics 
and results are the same because now this operation is simply an equijoin.</P>

<P>However, dummy values won't solve all the woes created by using 
NULL. First, using dummy values demands more work in your application to 
ensure that relationships to the placeholder values are maintained. Even more 
important, many queries still need to be able to discern that the placeholders are 
special values, or the results of the query could be suspect. For example, if you 
used the placeholder value of 0 (zero) instead of NULL for a 
<I>salary</I> field in an <I>employee</I> table, you'd have to be careful not to use such a value in a query looking 
for average values or minimum salaries, because a salary of 0 would alter your 
average or minimum calculations inappropriately. If the placeholder is simply 
another designation for &quot;unknown,&quot; you must write your queries with that in 
mind. Placeholder values usually solve the issues that arise in joining tables, and 
they can be an effective alternative to using OUTER JOIN. With placeholder 
values, developers are less likely to write incorrect queries, especially those who 
have only basic SQL knowledge.</P>

<P>In the previous example, the na&iuml;ve query returns the same result set as 
the query with an OUTER JOIN and the criteria <I>OR state IS 
NULL</I>. It took careful work to construct the placeholder data and maintain the relationships for 
this to be the case. But the group database expert (probably you!) can do that 
work, and once done, individuals with less SQL or database knowledge won't be 
as likely to introduce bugs in their queries simply because they're unfamiliar 
with the issues of OUTER JOINS and three-valued logic. Sometimes you might 
feel you have to use NULL values; however, if you can minimize or avoid these 
cases, you're wise to do so.</P>

<P>If dummy entries aren't practical for you to use, try a few other tricks. 
A handy and underused function is ISNULL. Using 
ISNULL(<I>expression</I>,<I> value</I>)<B> </B>substitutes the specified value for the expression when the expression 
evaluates to NULL. In the earlier outer-join example, the WHERE clause was 
specified as</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WHERE state &lt;&gt; 'CA' OR state IS NULL
</pre>
</td></tr></table></p>

<P>By using the ISNULL function, a special value (in this case, 
<I>XX</I>) can be assigned to any NULL 
<I>state</I> values. Then the expression <I>&lt;&gt; 
'CA' </I>always evaluates to TRUE or FALSE rather than to Unknown. The 
clause<I> OR state IS NULL</I> isn't needed.</P>

<P>The following query produces the full outer-join result, without 
using IS NULL:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT 
'Author'=RTRIM(au_lname) + ', ' + au_fname,
'Title'=title
FROM 
    authors AS A             -- JOIN CONDITIONS
    FULL OUTER JOIN titleauthor AS TA ON A.au_id=TA.au_id 
    FULL OUTER JOIN titles AS T ON t.title_id=TA.title_id
WHERE 
ISNULL(state, 'XX') &lt;&gt; 'CA'
ORDER BY 1
</pre>
</td></tr></table></p>

<A NAME="281"><H2>IS NULL and = NULL</H2></A>

<P>You've seen how the IS NULL operator exists to handle the special case 
of looking for NULL. Because NULL is considered Unknown, 
ANSI-standard SQL doesn't provide for an equality expression of NULL&#8212;that is, there's 
no <I>WHERE value = NULL</I>. Instead, you must use the IS NULL operator 
<I>WHERE value IS NULL</I>. This can make queries more awkward to write and less 
intuitive to non-SQL experts. One of my favorite SQL gurus at Microsoft, Rick 
Vicik, says tongue-in-cheek that this is because &quot;NULLs are evil and you 
should experience extra pain every time you use one.&quot; And it's somewhat curious, 
or at least nonorthogonal, that ANSI SQL doesn't force an UPDATE 
statement to set a value TO NULL but instead uses the 
<I>=</I> NULL formulation. (Table 7-3 below summarizes this state of affairs.)</P>

<p><div class="note"><blockquote>
<b>NOTE</b><HR>
<I>Orthogonal</I> is an adjective, somewhat jargonish, that's 
often applied to programming languages and APIs. It's a mathematical 
term meaning that the sum of the products of corresponding elements 
in a system equals 0. This implies that a system is orthogonal if all of 
its primitive operations fully describe the base capabilities of the 
system and those primitives are independent and mutually exclusive of 
one another. In broader use, the term also denotes a certain symmetry 
and consistency. For example, an API that has a 
<I>GetData</I> call would also have a 
<I>PutData</I> call, each taking arguments that are as consistent 
as possible between the two. The two APIs make up a mutually 
exclusive domain of operations that you can perform on data, and they 
are named and invoked in a consistent manner. Such a pair of APIs 
would be considered orthogonal. SQL Server 7 has a BULK 
INSERT command but no BULK EXPORT command, so this is 
another example of <I>nonorthogonal</I> behavior.
</blockquote></div></p>

<P>
<B>Table 7-3.</B> <I>ANSI SQL's treatment of NULLs.</I>
</P>

<p><table cellpadding=5 width="95%">
<tr>
<th>ANSI SQL Doesn't Provide for This</th>     
<th>And Provides Only for This</th>
</tr>
<tr>
<td valign="top">SELECT... WHERE salary = NULL</td>     
<td valign="top">SELECT... WHERE salary IS NULL</td>
</tr>
<tr>
<th>Yet ANSI SQL Uses Only This</th>    
<th>And Not Something Like This</th>
</tr>
<tr>
<td valign="top">UPDATE employee SET  salary = NULL</td>   
<td valign="top">UPDATE employee SET salary TO NULL</td>
</tr></table></p>


<P>SQL Server provides an extension to ANSI SQL that allows queries to 
use = NULL as an alternative to IS NULL. (The SET ANSI_NULLS option 
has an oblique reference to this extension, but it's never been thoroughly explained.)</P>

<P>Note that the formulation is not <I>= 
&quot;NULL&quot;&#8212;</I> the quotation marks 
would have the effect of searching for a character string containing the word 
<I>NULL</I>, as opposed to searching for the special meaning of NULL. This way of specifying = NULL is simply a shorthand for IS NULL and provides a more 
convenient formulation of queries, especially by allowing NULL within an IN 
clause. The IN clause is a standard SQL shorthand notation for an expression that checks multiple values, as illustrated below:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th>Multiple OR Conditions</th>     
<th>Equivalent Shorthand Formulation</th>
</tr>
<tr>
<td valign="top">WHERE state = 'CA' OR state = 'WA' OR state ='IL'</td>    
<td valign="top">WHERE state IN ('CA', 'WA', 'IL')</td>
</tr></table></p>

<P>If you wanted to find states that are either one of the three values 
depicted in the previous example or NULL, ANSI SQL prescribes that the condition 
be stated using both an IN clause and an <I>OR state IS 
NULL</I> expression; SQL Server also allows all the conditions to be specified with the IN clause, as shown here:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th>ANSI SQL Prescribes</th>     
<th>SQL Server also Allows</th>
</tr>
<tr>
<td valign="top">WHERE state IN ('CA', 'WA', 'IL') OR state IS NULL</td>     
<td valign="top">WHERE state IN ('CA', 'WA', 'IL', NULL)</td> 
</tr></table></p>

<P>The = NULL shorthand can be particularly handy to use when 
you're dealing with parameters passed to a stored procedure, and this is the main 
reason it exists. Here's an example:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
CREATE PROCEDURE get_employees (@dept char(8), @class char(5))
AS
    SELECT * FROM employee WHERE employee.dept=@dept
        AND employee.class=@class
</pre>
</td></tr></table></p>

<P>By default, we can pass NULL to this procedure for either parameter; 
no special treatment is necessary. But without the = NULL shorthand, we need 
to put in extensive special handling even for this simple procedure:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
CREATE PROCEDURE get_employees (@dept char(8), @class char(5))
AS
    IF (@dept IS NULL AND @class IS NOT NULL)
        SELECT * FROM employee WHERE employee.dept IS NULL
        AND employee.class=@class
    ELSE IF (@dept IS NULL AND @class IS NULL)
        SELECT * FROM employee WHERE employee.dept IS NULL
        AND employee.class IS NULL
    ELSE IF (@dept IS NOT NULL AND @class IS NULL)
        SELECT * FROM employee WHERE employee.dept=@dept
        AND employee.class IS NULL
    ELSE
        SELECT * FROM employee WHERE employee.dept=@dept
        AND employee.class=@class
</pre>
</td></tr></table></p>

<P>This example is pretty trivial, and the situation becomes much more 
complex if you have multiple parameters and any one of them might be NULL. You 
then need a SELECT statement for every combination of parameters that might 
be NULL or NOT NULL. It can get ugly quickly.</P>

<p><div class="warning"><blockquote>
<b>WARNING</b><HR>
The = NULL syntax is only possible when you 
have the ANSI_NULLS and ANSI_DEFAULTS options set to OFF, 
and if you have the database option ANSI NULLS set to FALSE. 
Since the ODBC driver and OLE DB provider can set these options on, 
you need to verify what is in effect for your connection.
</blockquote></div></p>

<P>As mentioned earlier, dealing with NULL becomes an issue of 
nearly religious fervor to some in the database industry. No doubt, a few people 
will find the SQL Server extension that allows an expression to be checked for 
= NULL to be a grave and serious deviation from three-valued logic (which 
is the primary reason this extension hasn't been well-documented, although 
many users have discovered it). As long as you realize that = NULL is purely a 
convenient shorthand for IS NULL, it should be clear to you that no violation of 
three-valued logic has occurred. Those of you who are vehemently opposed to 
such formulations don't have to use these extensions, of course. You can also 
prevent this extension from working by enabling the SET ANSI_NULLS option.</p>

</BODY>
</HTML>



