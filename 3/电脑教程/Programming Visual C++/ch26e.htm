<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The MFC CRectTracker Class</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="565"><H1><B>The MFC <I>CRectTracker</I> Class</B></H1></A>
<P>The <I>CRectTracker</I> class is useful in both OLE and non-OLE programs. It allows the user to move and resize a rectangular object in a view window. There are two important data members: the 
<I>m_nStyle</I> member determines the border, resize handle, and other characteristics; and the 
<I>m_rect</I> member holds the <U>device</U> coordinates for the rectangle.

<P>The important member functions follow.

<h3><B>
void Draw(CDC* <I>pDC</I>) const;
</B></h3>

<P>The <I>Draw</I> function draws the tracker, including border and resize handles, but it does not draw anything inside the rectangle. That's your job.

<h3><B>
BOOL Track(CWnd* <I>pWnd</I>, CPoint 
<I>point</I>, 
     BOOL <I>bAllowInvert</I> = FALSE, CWnd* 
<I>pWndClipTo</I> = NULL);
</B></h3>

<P>You call this function in a <I>WM_LBUTTONDOWN</I> handler. If the cursor is on the rectangle border, the user can resize the tracker by holding down the mouse button; if the cursor is inside the rectangle, the user can move the tracker. If the cursor is outside the rectangle, <I>Track</I> returns 
<I>FALSE</I> immediately; otherwise, <I>Track</I> returns <I>TRUE</I> only when the user releases the mouse button. That means <I>Track</I> works a little like <I>CDialog::DoModal</I>. It contains its own 
message dispatch logic.

<h3><B>
int HitTest(CPoint <I>point</I>) const;
</B></h3>

<P>Call <I>HitTest</I> if you need to distinguish between mouse button hits inside and on the tracker rectangle. The function returns immediately with the hit status in the return value.

<h3><B>
BOOL SetCursor(CWnd* <I>pWnd</I>, UINT 
<I>nHitTest</I>) const;
</B></h3>

<P>Call this function in your view's <I>WM_SETCURSOR</I> handler to ensure that the cursor changes during tracking. If <I>SetCursor</I> returns <I>FALSE</I>, call the base class <I>OnSetCursor</I> function; if <I>SetCursor</I> returns <I>TRUE</I>, you return <I>TRUE</I>.

<A NAME="566"><H2><B><I>CRectTracker</I> Rectangle Coordinate Conversion</B></H2></A>
<P>You must deal with the fact that the <I>CRectTracker::m_rect</I> member stores device coordinates. If you are using a scrolling view or have otherwise changed the mapping mode or viewport origin, you must do coordinate conversion. Here's a strategy:

<OL>
<P><LI>Define a <I>CRectTracker</I> data member in your view class. Use the name <I>m_tracker</I>.
<P><LI>Define a separate data member in your view class to hold the rectangle in logical coordinates. Use the name <I>m_rectTracker</I>.
<P><LI>In your view's <I>OnDraw</I> function, set <I>m_rect</I> to the updated device coordinates, and then draw the tracker. This adjusts for any scrolling since the last <I>OnDraw</I>. Some sample code appears below.

<P><pre>
m_tracker.m_rect = m_rectTracker;
pDC-&gt;LPtoDP(m_tracker.m_rect); // tracker requires device
                               //  coordinates
m_tracker.Draw(pDC);
</pre>
<P><LI>In your mouse button down message handler, call <I>Track</I>, set <I>m_rectTracker</I> to the updated logical coordinates, and call <I>Invalidate</I>, as shown here:

<P><pre>
if (m_tracker.Track(this, point, FALSE, NULL)) {
    CClientDC dc(this);
    OnPrepareDC(&amp;dc);
    m_rectTracker = m_tracker.m_rect;
    dc.DPtoLP(m_rectTracker);
    Invalidate();
}
</pre></ol>

</BODY>
</HTML>



