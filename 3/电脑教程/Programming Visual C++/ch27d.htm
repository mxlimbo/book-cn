<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Streams and the IStream Interface</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="601"><H1><B>Streams and the <I>IStream</I> Interface</B></H1></A>
<P>If you have a stream object, you can manipulate it through the <I>IStream</I> interface. Streams are always located under a root storage or a substorage object. Streams grow automatically (in 512-byte increments) as you write to them. An MFC class for streams, <I>COleStreamFile</I>, makes a stream look like a <I>CFile</I> object. That class won't be of much use to us in this chapter, however.

<P>Once you have a pointer to <I>IStream</I>, a number of functions are available to you for manipulating the stream. Here is a list of all the <I>IStream</I> functions:

<A NAME="602"><h3><B>HRESULT CopyTo(IStream** <I>pStm</I>, ULARGE_INTEGER <I>cb</I>, &#133;);</B></h3></A>
<P>Copies <I>cb</I> bytes from this stream to the named stream. <I>ULARGE_INTEGER</I> is a structure with two 32-bit members&#151;<I>HighPart</I> and <I>LowPart</I>.

<A NAME="603"><h3><B>HRESULT Clone(IStream** <I>ppStm</I>);</B></h3></A>
<P>Creates a new stream object with its own seek pointer that references the bytes in this stream. The bytes are not copied, so changes in one stream are visible in the other.

<A NAME="604"><h3><B>HRESULT Commit(&#133;);</B></h3></A>
<P>Transactions are not currently implemented for streams.

<A NAME="605"><h3><B>HRESULT Read(void const* <I>pv</I>, ULONG <I>cb</I>, ULONG* <I>pcbRead</I>);</B></h3></A>
<P>Tries to read <I>cb</I> bytes from this stream into the buffer pointed to by <I>pv</I>. The variable <I>pcbRead</I> indicates how many bytes were actually read.

<A NAME="606"><h3><B>DWORD Release(void);</B></h3></A>
<P>Closes this stream.

<A NAME="607"><h3><B>HRESULT Revert(void);</B></h3></A>
<P>Has no effect for streams.

<h3><B>HRESULT Seek(LARGE_INTEGER <I>dlibMove</I>,</B><br><B>DWORD <I>dwOrigin</I>, ULARGE_INTEGER*<I> 
NewPosition</I>);</B></h3>
<P>Seeks to the specified position in this stream. The <I>dwOrigin</I> parameter specifies the origin of the offset defined in the <I>NewPosition</I> parameter.

<A NAME="608"><h3><B>HRESULT SetSize(ULARGE_INTEGER <I>libNewSize</I>);</B></h3></A>
<P>Extends or truncates a stream. Streams grow automatically as they are written, but calling <I>SetSize</I> can optimize performance.

<A NAME="609"><h3><B>HRESULT Stat(STATSTG* <I>pStatstg</I>,</B> <B>DWORD</B> <B><I>flag</I>);</B></h3></A>
<P>Fills in the <I>STATSTG</I> structure with useful information about the stream, including the stream name and size. The size is useful if you need to allocate memory for a read.

<A NAME="610"><h3><B>HRESULT Write(void const* <I>pv</I>, ULONG <I>cb</I>, ULONG* <I>pcbWritten</I>);</B></h3></A>
<P>Tries to write <I>cb</I> bytes to this stream from the buffer pointed to by <I>pv</I>. The variable <I>pcbWritten</I> indicates how many bytes were actually written.

<A NAME="611"><H2><B><I>IStream</I> Programming</B></H2></A>
<P>Here is some sample code that creates a stream under a given storage object and writes some bytes from <I>m_buffer</I> to the stream:

<P><pre>
extern IStorage* pStg;
IStream* pStream;
ULONG nBytesWritten;

if (pStg-&gt;CreateStream(L&quot;MyStreamName&quot;,
    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
    0, 0, &amp;pStream) == S_OK) {
    ASSERT(pStream != NULL);
    pStream-&gt;Write(m_buffer, m_nLength, &amp;nBytesWritten);
    pStream-&gt;Release();
}
</pre>

</BODY>
</HTML>



