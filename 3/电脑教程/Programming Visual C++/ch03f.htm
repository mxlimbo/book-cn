<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Drawing Inside the View Window -- The Windows Graphics Device Interface</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="40"><H1>Drawing Inside the View Window&#151;The Windows Graphics Device Interface</H1></A><P>Now you're ready to write code to draw inside the view window. You'll 
be making a few changes directly to the EX03A source code.
<A NAME="41"><H2>The <I>OnDraw</I> Member Function</H2></A><P>Specifically, you'll be fleshing out 
<I>OnDraw</I> in ex03aView.cpp. <I>OnDraw</I> is a virtual member function of the 
<I>CView</I> class that the application framework 
calls every time the view window needs to be repainted. A window needs to 
be repainted if the user resizes the window or reveals a previously hidden part 
of the window, or if the application changes the window's data. If the user 
resizes the window or reveals a hidden area, the application framework 
calls <I>OnDraw</I>, but if a function in your program changes the data, it must 
inform Windows of the change by calling the view's inherited 
<I>Invalidate</I> (or <I>InvalidateRect</I>) member function. This call to 
<I>Invalidate</I> triggers a later call to 
<I>OnDraw</I>.
<P>Even though you can draw inside a window at any time, it's 
recommended that you let window changes accumulate and then process them all together 
in the <I>OnDraw</I> function. That way your program can respond both to 
program-generated events and to Windows-generated events such as size changes.
<A NAME="42"><H2>The Windows Device Context</H2></A><P>Recall from <A HREF="ch01b.htm#5">Chapter 1</A> that Windows doesn't allow direct access to the display hardware but communicates through an abstraction called a &quot;device 
context&quot; that is associated with the window. In the MFC library, the device context is 
a C++ object of class <I>CDC</I> that is passed (by pointer) as a parameter to 
<I>OnDraw</I>. After you have the device context pointer, you can call the many 
<I>CDC</I> member functions that do the work of drawing.
<A NAME="43"><H2>Adding Draw Code to the EX03A Program</H2></A><P>Now let's write the code to draw some text and a circle inside the view 
window. Be sure that the project EX03A is open in Visual 
C++. You can use the Workspace window's ClassView to locate the code for the function (double-click on 
<I>OnDraw</I>), or you can open the source code file ex03aView.cpp from FileView 
and locate the function yourself.<P>
<OL>
<B><LI>Edit the <I>OnDraw</I> function in 
ex03aView.cpp.</B> Find the AppWizard-generated 
<I>OnDraw</I> function in ex03aView.cpp:<P>
<PRE>void CEx03aView::OnDraw(CDC* pDC)
{
    CEx03aDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
}
</PRE>
<P>The following boldface code (which you type in) replaces the 
previous code:<P>
<PRE>void CEx03aView::OnDraw(CDC* pDC)
{
<B>    pDC-&gt;TextOut(0, 0, &quot;Hello, world!&quot;);  // prints in default font
                                          //  &amp; size, top left corner
    pDC-&gt;SelectStockObject(GRAY_BRUSH);   // selects a brush for the
                                          //  circle interior
    pDC-&gt;Ellipse(CRect(0, 20, 100, 120)); // draws a gray circle 
                                          //  100 units in diameter</B>
}
</PRE>
<P>You can safely remove the call to 
<I>GetDocument</I> because we're not dealing with documents yet. The functions 
<I>TextOut</I>, <I>SelectStockObject</I>, and 
<I>Ellipse</I> are all member functions of the application framework's device 
context class <I>CDC</I>. The <I>Ellipse</I> function draws a circle if the bounding 
rectangle's length is equal to its width.
<P>The MFC library provides a handy utility class, 
<I>CRect</I>, for Windows rectangles. A temporary 
<I>CRect</I> object serves as the bounding 
rectangle argument for the ellipse drawing function. You'll see more of the 
<I>CRect</I> class in quite a few of the examples in this book.<P>
<B><LI>Recompile and test EX03A.</B> Choose Build from the Project menu, 
and, if there are no compile errors, test the application again. Now you have 
a program that visibly does something!
</OL>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B><P>
Rest assured that the standard Windows 
<I>WinMain</I> and window procedure functions are hidden away inside the application 
framework. You'll see those functions later in this book, when the MFC 
library frame and application classes are examined. In the meantime, 
you're probably wondering what happened to the WM_PAINT 
message, aren't you? You would expect to do your window drawing in 
response to this Windows message, and you would expect to get your 
device context handle from a <I>PAINTSTRUCT</I> structure returned by the 
Windows <I>BeginPaint</I> function.
<P>It so happens that the application framework has done all the 
dirty work for you and served up a device context (in object pointer 
form) in the virtual function <I>OnDraw</I>. As explained in <A HREF="ch02a.htm">Chapter 2</A>, true 
virtual functions in window classes are an MFC library rarity. MFC 
library message map functions dispatched by the application framework 
handle most Windows messages. MFC version 1.0 programmers always 
defined an <I>OnPaint</I> message map function for their derived window 
classes. Beginning with version 2.5, however, 
<I>OnPaint</I> was mapped in the <I>CView</I> class, and that function made a polymorphic call to 
<I>OnDraw</I>. Why? Because <I>OnDraw</I> needs to support the printer as well as the 
display. Both <I>OnPaint</I> and <I>OnPrint</I> call 
<I>OnDraw</I>, thus enabling the same drawing code to accommodate both the printer and the display.
</BLOCKQUOTE>
</DIV>

</BODY>
</HTML>



