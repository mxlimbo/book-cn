<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>MFC Drag and Drop</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="571"><H1><B>MFC Drag and Drop</B></H1></A>
<P>Drag and drop was the ultimate justification for the data object code you've been looking at. OLE supports this feature with its <I>IDropSource</I> and <I>IDropTarget</I> interfaces plus some library code that manages the drag-and-drop process. The MFC library offers good drag-and-drop support at the view level, so we'll use it. Be aware that drag-and-drop transfers are immediate and independent of 
the clipboard. If the user cancels the operation, there's no &quot;memory&quot; of the object being dragged.

<P>Drag-and-drop transfers should work consistently between applications, between windows of the same application, and within a window. When the user starts the operation, the cursor should change to an arrow_rectangle combination. If the user holds down the Ctrl key, the cursor turns into a plus sign 
(+), which indicates that the object is being copied rather than moved.

<P>MFC also supports drag-and-drop operations for items in compound documents. This is the next level up in MFC OLE support, and it's not covered in this chapter. Look up the OCLIENT example in the online 
documentation under Visual C++ Samples.

<A NAME="572"><H2><B>The Source Side of the Transfer</B></H2></A>
<P>When your source program starts a drag-and-drop operation for a data object, it calls <I>COleDataSource::DoDragDrop</I>. This function internally creates an object of MFC class <I>COleDropSource</I>, which implements the <I>IOleDropSource</I> interface. <I>DoDragDrop</I> is one of those functions that don't return for a while. It returns when the user drops the object or cancels the operation or when a specified number of milliseconds have elapsed.

<P>If you're programming drag-and-drop operations to work with a <I>CRectTracker</I> object, you should call <I>DoDragDrop</I> only when the user clicks <U>inside</U> the tracking rectangle, not on its border. <I>CRectTracker::HitTest</I> gives you that information. When you call <I>DoDragDrop</I>, you need to set a flag that tells you whether the user is dropping the object into the same view (or document) that it was dragged from.

<A NAME="573"><H2><B>The Destination Side of the Transfer</B></H2></A>
<P>If you want to use the MFC library's view class drag-and-drop support, you must add a data member of class <I>COleDropTarget</I> to your derived view class. This class implements the <I>IDropTarget</I> interface, and it holds an <I>IDropSource</I> pointer that links back to the 
<I>COleDropSource</I> object. In your view's <I>OnInitialUpdate</I> function, you call the 
<I>Register</I> member function for the embedded <I>COleDropTarget</I> object.

<P>After you have made your view a drop target, you must override four <I>CView</I> virtual functions, which the framework calls during the drag-and-drop operation. Here's a summary of what they should do, assuming that you're using a tracker.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><I>OnDragEnter</I></td>
<td valign="top">Adjusts the focus rectangle and then calls <I>OnDragOver</I></td></tr>
<tr><td valign="top"><I>OnDragOver</I></td>
<td valign="top">Moves the dotted focus rectangle and sets the drop effect (determines cursor shape)</td></tr>
<tr><td valign="top"><I>OnDragLeave</I></td>
<td valign="top">Cancels the transfer operation; returns the rectangle to its original position and size</td></tr>
<tr><td valign="top"><I>OnDrop</I></td>
<td valign="top">Adjusts the focus rectangle and then calls the <I>DoPaste </I> helper function to get formats from the data object</td></tr>
</table>

<A NAME="574"><H2><B>The Drag-and-Drop Sequence</B></H2></A>
<P>Figure 26-4 illustrates the MFC drag-and-drop process. 

<P><A HREF="javascript:fullSize('f26og04x.htm')"> <img src="f26og04.jpg" width=404 height=209 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 26-4.</B> <I>MFC OLE drag-and-drop processing.</I><!-- /caption -->

<P>Here's a summary of what's going on:
<ol>
<p><li>User presses the left mouse button in the source view window.
<p><li>Mouse button handler calls <I>CRectTracker::HitTest</I> and finds out that the cursor was inside the tracker rectangle.
<p><li>Handler stores formats in a <I>COleDataSource</I> object.
<p><li>Handler calls <I>COleDataSource::DoDragDrop</I> for the data source.
<p><li>User moves the cursor to the view window of the target application.
<p><li>OLE calls<I> IDropTarget::OnDragEnter</I> and <I>OnDragOver</I> for the <I>COleDropTarget</I> object, which calls the corresponding virtual functions in the target's view. The <I>OnDragOver</I> function is passed a <I>COleDataObject</I> pointer for the source object, which the target tests for a format it can understand.
<p><li><I>OnDragOver</I> returns a drop effect code, which OLE uses to set the cursor.
<p><li>OLE calls <I>IDataSource::QueryContinueDrag</I> on the source side to find out whether the drag operation is still in progress. The MFC <I>COleDataSource</I> class responds appropriately.
<p><li>User releases the mouse button to drop the object in the target view window.
<p><li>OLE calls <I>IDropTarget::OnDrop</I>, which calls <I>OnDrop</I> for the target's view. Because <I>OnDrop</I> is passed a <I>COleDataObject</I> pointer, it can retrieve the desired format from that object.
<p><li>When <I>OnDrop</I> returns in the target program, <I>DoDragDrop</I> can return in the source program.
</ol>

</BODY>
</HTML>



