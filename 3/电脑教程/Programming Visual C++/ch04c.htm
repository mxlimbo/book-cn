<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Mapping Modes</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="67"><H1>Mapping Modes</H1></A><P>Up to now, your drawing units have been display pixels, also known as <U>device</U> <U>coordinates</U>. The EX04A drawing units are pixels because the device context has the default <U>mapping</U> <U>mode</U>, <I>MM_TEXT</I>, assigned to it. The statement<P>
<PRE>pDC-&gt;Rectangle(CRect(0, 0, 200, 200));
</PRE>
<P>draws a square of 200-by-200 pixels, with its top-left corner at the top left of the window's client area. (Positive <I>y</I> values increase as you move down the window.) This square would look smaller on a high-resolution display of 1024-by-768 pixels than it would look on a standard VGA display that is 640-by-480 pixels, and it would look tiny if printed on a laser printer with 
600-dpi resolution. (Try EX04A's Print Preview feature to see for yourself.)
<P>What if you want the square to be 4-by-4 centimeters (cm), regardless of the display device? Windows provides a number of other mapping modes, or coordinate systems, that can be associated with the device context. Coordinates in the current mapping mode are called <U>logical</U> <U>coordinates</U>. If you assign the <I>MM_HIMETRIC</I> mapping mode, for example, a logical unit is 
<SUP>1</SUP>/<SUB>100</SUB> millimeter (mm) instead of 1 pixel. In the 
<I>MM_HIMETRIC</I> mapping mode, the <I>y</I> axis runs in the opposite direction to that in the <I>MM_TEXT</I> mode: <I>y</I> values decrease as you move down. Thus, a 4-by-4-cm square is drawn in logical coordinates this way:
<P>
<PRE>pDC-&gt;Rectangle(CRect(0, 0, 4000, -4000));
</PRE>
<P>Looks easy, doesn't it? Well, it isn't, because you can't work only in 
logical coordinates. Your program is always switching between device coordinates and logical coordinates, and you need to know when to convert between them. This section gives you a few rules that could make your programming life easier. First you need to know what mapping modes Windows gives you.
<A NAME="68"><H2>The <I>MM_TEXT</I> Mapping Mode</H2></A><P>At first glance, <I>MM_TEXT</I> appears to be no mapping mode at all, but rather another name for device coordinates. Almost. In <I>MM_TEXT</I>, coordinates map to pixels, values of <I>x</I> increase as you move right, and values of <I>y</I> increase as you move down, but you're allowed to change the origin through calls to the 
<I>CDC</I> functions <I>SetViewportOrg</I> and <I>SetWindowOrg</I>. Here's some code that sets the window origin to (100, 100) in logical coordinate space and then draws a 200-by-200-pixel square offset by (100, 100). (An illustration of the output is shown in Figure 4-2.) The logical point (100, 100) maps to the device point (0, 0). A scrolling window uses this kind of transformation.<P>
<PRE>void CMyView::OnDraw(CDC* pDC)
{
    pDC-&gt;SetMapMode(MM_TEXT);
    pDC-&gt;SetWindowOrg(CPoint(100, 100));
    pDC-&gt;Rectangle(CRect(100, 100, 300, 300));
}
</PRE>
<P><A HREF="javascript:fullSize('F04OG02x.htm')"> <img src="F04OG02.JPG" width=404 height=178 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 4-2.</B> <I>A square drawn after the origin has been moved to (100, 100).</I>
<!-- /caption -->
<A NAME="69"><H2>The Fixed-Scale Mapping Modes</H2></A><P>One important group of Windows mapping modes provides fixed scaling. You have already seen that, in the <I>MM_HIMETRIC</I> mapping mode, <I>x</I> values increase as you move right and <I>y</I> values decrease as you move down. All fixed mapping modes follow this convention, and you can't change it. The only difference among the fixed mapping modes is the actual scale factor, listed in the table shown here.<P>

<TABLE WIDTH="95%" CELLPADDING="5">
<tr><td valign="top"><B>Mapping Mode</B></td><td valign="top"><B>Logical Unit</B></td></tr>
<tr><td valign="top">MM_LOENGLISH</td><td valign="top">0.01 inch</td></tr>
<tr><td valign="top">MM_HIENGLISH</td><td valign="top">0.001 inch</td></tr>
<tr><td valign="top">MM_LOMETRIC</td><td valign="top">0.1 mm</td></tr>
<tr><td valign="top">MM_HIMETRIC</td><td valign="top">0.01 mm</td></tr>
<tr><td valign="top">MM_TWIPS</td><td valign="top"><SUP>1</SUP>/<SUB>1440</SUB> inch</td></tr>
</TABLE>

<P>The last mapping mode, <I>MM_TWIPS</I>, is most often used with printers. One <U>twip</U> unit is <SUP>1</SUP>/<SUB>20</SUB> point. (A <U>point</U> is a type measurement unit. In Windows it equals exactly <SUP>1</SUP>/<SUB>72</SUB> inch.) If the mapping mode is <I>MM_TWIPS</I> and you want, for example, 12-point type, set the character height to 12 &#215; 20, or 240, twips.
<A NAME="70"><H2>The Variable-Scale Mapping Modes</H2></A><P>Windows provides two mapping modes, <I>MM_ISOTROPIC</I> and <I>MM_ANISOTROPIC</I>, that allow you to change the scale factor as well as the origin. With these mapping modes, your drawing can change size as the user changes the size of the window. Also, if you invert the scale of one axis, you can &quot;flip&quot; an image about the other axis and you can define your own arbitrary fixed-scale factors.
<P>With the <I>MM_ISOTROPIC</I> mode, a 1:1 aspect ratio is always preserved. In other words, a circle is always a circle as the scale factor changes. With 
the <I>MM_ANISOTROPIC</I> mode, the <I>x</I> and <I>y</I> scale factors can change independently. Circles can be squished into ellipses.
<P>Here's an <I>OnDraw</I> function that draws an ellipse that fits exactly in 
its window:
<P>
<PRE>void CMyView::OnDraw(CDC* pDC)
{
    CRect rectClient;

    GetClientRect(rectClient);
    pDC-&gt;SetMapMode(MM_ANISOTROPIC);
    pDC-&gt;SetWindowExt(1000, 1000);
    pDC-&gt;SetViewportExt(rectClient.right, -rectClient.bottom);
    pDC-&gt;SetViewportOrg(rectClient.right / 2, rectClient.bottom / 2);

    pDC-&gt;Ellipse(CRect(-500, -500, 500, 500));
}
</PRE>
<P>What's going on here? The functions <I>SetWindowExt</I> and <I>SetViewportExt</I> work together to set the scale, based on the window's current client rectangle returned by the <I>GetClientRect</I> function. The resulting window size is exactly 1000-by-1000 logical units. The <I>SetViewportOrg</I> function sets the origin to the center of the window. Thus, a centered ellipse with a radius of 500 logical units fills the window exactly, as illustrated in Figure 4-3.
<P><A HREF="javascript:fullSize('F04OG03x.htm')"> <img src="F04OG03.JPG" width=404 height=222 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 4-3.</B> <I>A centered ellipse drawn in the </I>MM_ANISOTROPIC<I> mapping mode.</I>
<!-- /caption -->
<P>Here are the formulas for converting logical units to device units:
<BLOCKQUOTE>
<I>x</I> scale factor = <I>x</I> viewport extent / <I>x</I> window extent<BR>
<I>y</I> scale factor = <I>y</I> viewport extent / <I>y</I> window extent<BR>
device <I>x</I> = logical <I>x</I> &#215; <I>x</I> scale factor + <I>x</I> origin offset<BR>
device <I>y</I> = logical <I>y</I> &#215; <I>y</I> scale factor + <I>y</I> origin offset<BR>
</BLOCKQUOTE>
<P>

<P>Suppose the window is 448 pixels wide (<I>rectClient.right</I>). The right edge of the ellipse's client rectangle is 500 logical units from the origin. The <I>x</I> scale factor is <SUP>448</SUP>/<SUB>1000</SUB>, and the <I>x</I> origin offset is <SUP>448</SUP>/<SUB>2</SUB> device units. If you use the 
formulas shown on the previous page, the right edge of the ellipse's client 
rectangle comes out to 448 device units, the right edge of the window. The 
<I>x</I> scale factor is expressed as a ratio (viewport extent/window extent) because Windows device coordinates are integers, not floating-point values. The extent values are meaningless by themselves.
<P>If you substitute <I>MM_ISOTROPIC</I> for <I>MM_ANISOTROPIC</I> in the preceding example, the &quot;ellipse&quot; is always a circle, as shown in Figure 4-4. It expands to fit the smallest dimension of the window rectangle.
<P><A HREF="javascript:fullSize('F04OG04x.htm')"> <img src="F04OG04.JPG" width=404 height=222 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 4-4.</B> <I>A centered ellipse drawn in the </I>MM_ISOTROPIC<I> mapping mode.</I>
<!-- /caption -->
<A NAME="71"><H2>Coordinate Conversion</H2></A><P>Once you set the mapping mode (plus the origin) of a device context, you can use logical coordinate parameters for most <I>CDC</I> member functions. If you get the mouse cursor coordinates from a Windows mouse message (the <I>point</I> parameter in <I>OnLButtonDown</I>), for example, you're dealing with device coordinates. Many other MFC functions, particularly the member functions of class <I>CRect</I>, work correctly only with device coordinates.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The <I>CRect</I> arithmetic functions use the underlying Win32 <I>RECT </I>arithmetic functions, which assume that <I>right </I>is greater than <I>left </I>and <I>bottom </I>is greater than <I>top</I>. A rectangle (0, 0, 1000, -1000) in <I>MM_HIMETRIC</I> coordinates, for example, has <I>bottom </I>less than <I>top </I>and cannot be processed by functions such as 
<I>CRect::PtInRect</I> unless your program first calls <I>CRect::NormalizeRect</I>, which changes the rectangle's data members to (0, 
-1000, 1000, 0).
</BLOCKQUOTE>
</DIV>
<P>Furthermore, you're likely to need a third set of coordinates that we will call <U>physical</U> <U>coordinates</U>. Why do you need another set? Suppose you're using the <I>MM_LOENGLISH</I> mapping mode in which a logical unit is 0.01 inch, but an inch on the screen represents a foot (12 inches) in the real world. Now suppose the user works in inches and decimal fractions. A measurement of 26.75 inches translates to 223 logical units, which must be ultimately translated to device coordinates. You will want to store the physical coordinates as either floating-point numbers or scaled long integers to avoid rounding-off errors.
<P>For the physical-to-logical translation you're on your own, but the Windows GDI takes care of the logical-to-device translation for you. The <I>CDC</I> functions <I>LPtoDP</I> and <I>DPtoLP</I> translate between the two systems, assuming the device context mapping mode and associated parameters have already been set. Your job is to decide when to use each system. Here are a few rules of thumb:
<UL>
<P><LI>Assume that the <I>CDC</I> member functions take logical coordinate parameters.
<P><LI>Assume that the <I>CWnd</I> member functions take device coordinate parameters.
<P><LI>Do all hit-test operations in device coordinates. Define regions in device coordinates. Functions such as <I>CRect::PtInRect</I> work best with device coordinates.
<P><LI>Store long-term values in logical or physical coordinates. If you store a point in device coordinates and the user scrolls through a window, that point is no longer valid.<P>
</UL>
<P>Suppose you need to know whether the mouse cursor is inside a rectangle when the user presses the left mouse button. The code is shown here.
<P>
<PRE>// m_rect is CRect data member of the derived view class with MM_LOENGLISH
//  logical coordinates

void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    CRect rect = m_rect; // rect is a temporary copy of m_rect.
    CClientDC dc(this);  // This is how we get a device context
                         //  for SetMapMode and LPtoDP
                         //  -- more in next chapter
    dc.SetMapMode(MM_LOENGLISH);
    dc.LPtoDP(rect);     // rect is now in device coordinates
    if (rect.PtInRect(point)) {
        TRACE(&quot;Mouse cursor is inside the rectangle.\n&quot;);
    }
}
</PRE>
<P>Notice the use of the <I>TRACE</I> macro (covered in <A HREF="ch03a.htm">Chapter 3</A>).
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
As you'll soon see, it's better to set the mapping mode in the virtual <I>CView </I>function <I>OnPrepareDC </I>instead of in the <I>OnDraw </I>function.
</BLOCKQUOTE></DIV>
<P>
<A NAME="72"><H2>The EX04B Example&#151;Converting to the <I>MM_HIMETRIC</I> Mapping Mode</H2></A><P>EX04B is EX04A converted to <I>MM_HIMETRIC</I> coordinates. The EX04B project on the companion CD-ROM uses new class names and filenames, but the instructions here take you through modifying the EX04A code. Like EX04A, EX04B performs a hit-test so that the ellipse changes color only when you click inside the bounding rectangle.
<OL>
<B><LI>Use ClassWizard to override the virtual <I>OnPrepareDC </I>function.</B>  
ClassWizard can override virtual functions for selected MFC base classes, including <I>CView</I>. It generates the correct function prototype in the 
class's header file and a skeleton function in the CPP file. Select the class 
name <I>CEx04aView</I> in the Object IDs list, and then double-click on the 
<I>OnPrepareDC</I> function in the Messages list. Edit the function as shown here:
<P>
<PRE>void CEx04aView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo) 
{
    <B>pDC-&gt;SetMapMode(MM_HIMETRIC);</B>
    CView::OnPrepareDC(pDC, pInfo);
}
</PRE>
<P>The application framework calls the virtual <I>OnPrepareDC</I> function just before it calls <I>OnDraw</I>.<P>
<B><LI>Edit the view class constructor.</B> You must change the coordinate values for the ellipse rectangle. That rectangle is now 4-by-4 centimeters instead of 200-by-200 pixels. Note that the <I>y</I> value must be negative; 
otherwise, the ellipse will be drawn on the &quot;virtual screen&quot; right 
above your monitor! Change the values as shown here:<P>
<PRE>CEx04aView::CEx04aView() : m_rectEllipse(0, 0, <B>4000, -4000</B>)
{
    m_nColor = GRAY_BRUSH;
}
</PRE><P>
<B><LI>Edit the <I>OnLButtonDown</I> function.</B> This function must now convert the ellipse rectangle to device coordinates in order to do the hit-test. Change the function as shown in the following code:
<P>
<PRE>void CEx04aView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    <B>CClientDC dc(this);
    OnPrepareDC(&amp;dc);
    CRect rectDevice = m_rectEllipse;
    dc.LPtoDP(rectDevice);</B>
    if (<B>rectDevice</B>.PtInRect(point)) {
        if (m_nColor == GRAY_BRUSH) {
            m_nColor = WHITE_BRUSH;
        }
        else {
            m_nColor = GRAY_BRUSH;
        }
        InvalidateRect(<B>rectDevice</B>);
    }
}
</PRE>
<B><LI>Build and run the EX04B program.</B> The output should look similar to the output from EX04A, except that the ellipse size will be different. If you try using Print Preview again, the ellipse should appear much larger than it did in EX04A.
</OL>
</BODY>
</HTML>



