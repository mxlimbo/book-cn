<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX28A Example -- An MFC In-Place-Activated Mini-Server</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="641"><H1><B>The EX28A Example&#151;An MFC In-Place-Activated Mini-Server</B></H1></A>
<P>You don't need much OLE theory to build an MFC mini-server. This example is a good place to start, though, because you'll get an idea of how containers and components interact. This component isn't too sophisticated. It simply draws some text and graphics in a window. The text is stored in the 
document, and there's a dialog for updating it.

<P>Here are the steps for creating the program from scratch:

<ol>
<P><LI><B>Run AppWizard to create the EX28A project in the \vcpp32\ex28a directory.</B> Select Single Document interface. Click the Mini-Server option in the AppWizard Step 3 dialog shown here.

<P><A HREF="javascript:fullSize('g28og01x.htm')"> <img src="g28og01.jpg" width=404 height=325 border=0 ALT = "Click to view at full size."> </A>

<P><LI><B>Examine the generated files.</B> You've got the familiar application, document, main frame, and view files, but you've got two new files too.


<p>
<table cellpadding=5 width="95%">
<tr><td valign="top"><b>Header</b></td>
<td valign="top"><b>Implementation</b></td>
<td valign="top"><b>Class</b></td>
<td valign="top"><b>MFC Base Class</b></td></tr>
<tr><td valign="top">SrvrItem.h</td>
<td valign="top">SrvrItem.cpp</td>
<td valign="top"><I>CEx28aSrvrItem</I></td>
<td valign="top"><I>COleServerItem</I></td></tr>
<tr><td valign="top">IpFrame.h</td>
<td valign="top">IpFrame.cpp</td>
<td valign="top"><I>CInPlaceFrame</I></td>
<td valign="top"><I>COleIPFrameWnd</I></td></tr>
</table>


<P><LI><B>Add a text member to the document class.</B> Add the following public data member in the class declaration in ex28aDoc.h:

<P><pre><B>
CString m_strText;
</B></pre>

<P>Set the string's initial value to <I>Initial default text</I> in the document's <I>OnNewDocument</I> member function.

<P><LI><B>Add a dialog to modify the text.</B> Insert a new dialog template with an edit control, and then use ClassWizard to generate a <I>CTextDialog</I> class derived from <I>CDialog</I>. Don't forget to include the dialog class header in ex28aDoc.cpp. Also, use ClassWizard to add a <I>CString</I> member variable named <I>m_strText</I> for the edit control.

<P><LI><B>Add a new menu command in both the embedded and in-place menus.</B> Add a Modify menu command in both the <I>IDR_SRVR_EMBEDDED</I> and <I>IDR_SRVR_INPLACE</I> menus. To insert this menu command on the <I>IDR_SRVR_EMBEDDED</I> menu, use the resource editor to add an EX28A-EMBED menu item on the top level, and then add a Modify option on the submenu for this item. Next add an EX28A-INPLACE 
menu item on the top level of the <I>IDR_SRVR_INPLACE</I> menu and add a Modify option on the EX28A-INPLACE submenu.

<P>To associate both Modify options with one <I>OnModify</I> function, use <I>ID_MODIFY</I> as the ID for the Modify option of both the <I>IDR_SRVR_EMBEDDED</I> and <I>IDR_SRVR_INPLACE</I> menus. Then use 
ClassWizard to map both Modify options to the <I>OnModify</I> function in the document class. Code the Modify command handler as shown here:

<P><pre>
void CEx28aDoc::OnModify() 
{
<B>    CTextDialog dlg;
    dlg.m_strText = m_strText;
    if (dlg.DoModal() == IDOK) {
        m_strText = dlg.m_strText;
        UpdateAllViews(NULL); // Trigger CEx28aView::OnDraw
        UpdateAllItems(NULL); // Trigger CEx28aSrvrItem::OnDraw
        SetModifiedFlag();
    }</B>
}
</pre>

<P><LI><B>Override the view's <I>OnPrepareDC</I> function.</B> Use ClassWizard to generate the function, and then replace any existing code with the following line:

<P><pre><B>
pDC-&gt;SetMapMode(MM_HIMETRIC);
</b></pre>

<P><LI><B>Edit the view's <I>OnDraw</I> function.</B> The following code in ex28aView.cpp draws a 2-cm circle centered in the client rectangle, with the text wordwrapped in the window:

<P><pre>
void CEx28aView::OnDraw(CDC* pDC)
{
    CEx28aDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
<B>    CFont font;
    font.CreateFont(-500, 0, 0, 0, 400, FALSE, FALSE, 0,
                    ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    DEFAULT_PITCH | FF_SWISS, &quot;Arial&quot;);
    CFont* pFont = pDC-&gt;SelectObject(&amp;font);
    CRect rectClient;
    GetClientRect(rectClient);
    CSize sizeClient = rectClient.Size();
    pDC-&gt;DPtoHIMETRIC(&amp;sizeClient);
    CRect rectEllipse(sizeClient.cx / 2 - 1000,
                     -sizeClient.cy / 2 + 1000,
                      sizeClient.cx / 2 + 1000,
                     -sizeClient.cy / 2 - 1000);
    pDC-&gt;Ellipse(rectEllipse);
    pDC-&gt;TextOut(0, 0, pDoc-&gt;m_strText);
    pDC-&gt;SelectObject(pFont);</B>
}
</pre>

<P><LI><B>Edit the server item's <I>OnDraw</I> function.</B> The following code in the SrvrItem.cpp file tries to draw the same circle drawn in the view's <I>OnDraw</I> function. You'll learn what a 
<U>server</U> <U>item</U> is shortly.

<P><pre>
BOOL CEx28aSrvrItem::OnDraw(CDC* pDC, CSize&amp; rSize)
{
    // Remove this if you use rSize
    UNREFERENCED_PARAMETER(rSize);

    CEx28aDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: set mapping mode and extent
    //  (The extent is usually the same as the size returned from 
    //  OnGetExtent)
    pDC-&gt;SetMapMode(MM_ANISOTROPIC);
    pDC-&gt;SetWindowOrg(0,0);
    pDC-&gt;SetWindowExt(3000, <B>-</B>3000);

<B>    CFont font;
    font.CreateFont(-500, 0, 0, 0, 400, FALSE, FALSE, 0,
                    ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                    CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    DEFAULT_PITCH | FF_SWISS, &quot;Arial&quot;);
    CFont* pFont = pDC-&gt;SelectObject(&amp;font);
    CRect rectEllipse(CRect(500, -500, 2500, -2500));
    pDC-&gt;Ellipse(rectEllipse);
    pDC-&gt;TextOut(0, 0, pDoc-&gt;m_strText);
    pDC-&gt;SelectObject(pFont);</B>

    return TRUE;
}
</pre>

<P><LI><B>Edit the document's <I>Serialize </I>function.</B> The framework takes care of loading and saving the document's data from and to an OLE stream named <I>Contents</I> that is attached to the object's main storage. You simply write normal serialization code, as shown here:

<P><pre>
void CEx28aDoc::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
<B>        ar &lt;&lt; m_strText;</B>
    }
    else
    {
<B>        ar &gt;&gt; m_strText;</B>
    }
}
</pre>

<P>There is also a <I>CEx28aSrvrItem::Serialize</I> function that delegates to the document <I>Serialize</I> function.

<P><LI><B>Build and register the EX28A application.</B> You must run the application directly once to update the Registry.

<P><LI><B>Test the EX28A application.</B> You need a container program that supports in-place activation. Use Microsoft Excel 97 or a later version if you have it, or build the project in the MFC DRAWCLI sample. Choose the container's Insert Object menu item. If this option does not appear on 
the Insert menu, it might appear on the Edit menu instead. Then select Ex28a Document from the list.
</ol>

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
You debug an embedded component the same way you debug an Automation EXE component. See the sidebar, 
&quot;<A HREF="ch25n.htm#100">Debugging an EXE Component Program</A>&quot;, for more information.</blockquote></div>

<P>When you first insert the EX28A object, you'll see a hatched border, which indicates that the object is in-place active. The bounding rectangle is 3-by-3-cm square, with a 2-cm circle in the center, as illustrated here.

<P><img src="g28og02.gif" width=121 height=121 border="0">

<P>If you click elsewhere in the container's window, the object becomes inactive, and it's shown like this.

<P><IMG SRC="G28og03.gif" WIDTH=113 HEIGHT=113 ALIGN="BOTTOM" BORDER=0 ALT="">

<P>In the first case, you saw the output of the <U>view's</U> <I>OnDraw</I> function; in the second case, you saw the output of the <U>server</U> <U>item's</U> <I>OnDraw</I> function. The circles are the same, but the text is formatted differently because the server (component) item code is drawing on a metafile device context.

<P>If you use the resize handles to extend the height of the object (click once on the object to see the resize handles; don't double-click), you'll stretch the circle and the font will get bigger, as shown below in the figure on the left. If you reactivate the object by double-clicking on it, it's reformatted as shown in the figure on the right.

<P><img src="g28og04.gif" width=117 height=183 border="0">
<img src="g28og05.gif" width=121 height=190 border="0">

<P>Click elsewhere in the container's window, single-click on the object, and then choose Ex28a Object from the bottom of the Edit menu. Choose Open from the submenu. This starts the component program in embedded mode rather than in in-place mode, as shown here.

<P><A HREF="javascript:fullSize('g28og06x.htm')"> <img src="g28og06.jpg" width=404 height=307 border=0 ALT = "Click to view at full size."> </A>

<P>Notice that the component's <I>IDR_SRVR_EMBEDDED</I> menu is visible.

<A NAME="642"><H2><B>An MDI Embedded Component?</B></H2></A>
<P>The EX28A example is an SDI mini-server. Each time a controller creates an EX28A object, a new EX28A process is started. You might expect an MDI mini-server process to support multiple component objects, each with its own document, but this is not the case. When you ask AppWizard to generate an MDI mini-server, it generates an SDI program, as in EX28A. It's theoretically possible to have a single process support multiple embedded objects in different windows, but you can't easily create such a program with the MFC library.

<A NAME="643"><H2><B>In-Place Component Sizing Strategy</B></H2></A>
<P>If you look at the EX28A output, you'll observe that the metafile image does not always match the image in the in-place frame window. We had hoped to create another example in which the two images matched. We were unsuccessful, however, when we tried to use the Microsoft Office 97 applications as containers. Each one did something a little different and unpredictable. A complicating factor is the containers' different zooming abilities.

<P>When AppWizard generates a component program, it gives you an overridden <I>OnGetExtent</I> function in your server item class. This function returns a hard-coded size of (3000, 3000). You can certainly change this value to suit your needs, but be careful if you change it dynamically. We tried maintaining our own document data member for the component's extent, but that messed us up when the container's zoom factor changed. We thought containers would make more use of another component item virtual function, <I>OnSetExtent</I>, but they don't.

<P>You'll be safest if you simply make your component extents fixed and assume that the container will do the right thing. Keep in mind that when the container application prints its document, it prints the component metafiles. The metafiles are more important than the in-place views.


<P>If you control both container and component programs, however, you have more flexibility. You can build up a modular document processing system with its own sizing protocol. You can even use other OLE interfaces.

</BODY>
</HTML>



