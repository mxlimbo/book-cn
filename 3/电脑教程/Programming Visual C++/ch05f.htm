<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX05A Example</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="109"><H1>The EX05A Example</H1></A><P>This example sets up a view window with the logical twips mapping mode. A text string is displayed in 10 point sizes with the Arial TrueType font. Here are the steps for building the application:<P>
<OL>
<B><LI>Run AppWizard to generate the EX05A project.</B>
Start by choosing New from the File menu, and then select MFC AppWizard (exe) on the Project tab. Select Single Document and deselect Printing And Print 
Preview; accept all the other default settings. The options and the default class names are shown in the following illustration.<P>

<P><img src="G05OG01x.gif" width=413 height=418 border=0 ><P>
<OL START="2">
<B><LI>Use ClassWizard to override the <I>OnPrepareDC</I> function in the 
<I>CEx05aView</I> class.</B> Edit the code in ex05aView.cpp as follows:<P>
<PRE>void CEx05aView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    <B>pDC-&gt;SetMapMode(MM_ANISOTROPIC);
    pDC-&gt;SetWindowExt(1440, 1440);
    pDC-&gt;SetViewportExt(pDC-&gt;GetDeviceCaps(LOGPIXELSX),
                        -pDC-&gt;GetDeviceCaps(LOGPIXELSY));</B>
}
</PRE><P>
<B><LI>Add a private <I>ShowFont</I> helper function to the view class.</B> Add the prototype shown below in ex05aView.h:
<P>
<PRE><B>private:
    void ShowFont(CDC* pDC, int&amp; nPos, int nPoints);</B></PRE>
<P>Then add the function itself in ex05aView.cpp:<P>
<PRE><B>void CEx05aView::ShowFont(CDC* pDC, int&amp; nPos, int nPoints)
{
    TEXTMETRIC tm;
    CFont      fontText;
    CString    strText;
    CSize      sizeText;

    fontText.CreateFont(-nPoints * 20, 0, 0, 0, 400, FALSE, FALSE, 0,
                        ANSI_CHARSET, OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                        DEFAULT_PITCH | FF_SWISS, &quot;Arial&quot;);
    CFont* pOldFont = (CFont*) pDC-&gt;SelectObject(&amp;fontText);
    pDC-&gt;GetTextMetrics(&amp;tm);
    TRACE(&quot;points = %d, tmHeight = %d, tmInternalLeading = %d,&quot;
          &quot; tmExternalLeading = %d\n&quot;, nPoints, tm.tmHeight,
          tm.tmInternalLeading, tm.tmExternalLeading);
    strText.Format(&quot;This is %d-point Arial&quot;, nPoints);
    sizeText = pDC-&gt;GetTextExtent(strText);
    TRACE(&quot;string width = %d, string height = %d\n&quot;, sizeText.cx,
          sizeText.cy);
    pDC-&gt;TextOut(0, nPos, strText);
    pDC-&gt;SelectObject(pOldFont);
    nPos -= tm.tmHeight + tm.tmExternalLeading;
}
</B></PRE><P>
<B><LI>Edit the <I>OnDraw</I> function in ex05aView.cpp.</B> AppWizard always generates a skeleton <I>OnDraw</I> function for your view class. Find the 
function, and replace the code with the following:<P>
<PRE>void CEx05aView::OnDraw(CDC* pDC)
{
    <B>int nPosition = 0;

    for (int i = 6; i &lt;= 24; i += 2) {
        ShowFont(pDC, nPosition, i);
    }
    TRACE(&quot;LOGPIXELSX = %d, LOGPIXELSY = %d\n&quot;,
          pDC-&gt;GetDeviceCaps(LOGPIXELSX),
          pDC-&gt;GetDeviceCaps(LOGPIXELSY)); 
    TRACE(&quot;HORZSIZE = %d, VERTSIZE = %d\n&quot;,
          pDC-&gt;GetDeviceCaps(HORZSIZE),
          pDC-&gt;GetDeviceCaps(VERTSIZE)); 
    TRACE(&quot;HORZRES = %d, VERTRES = %d\n&quot;,
          pDC-&gt;GetDeviceCaps(HORZRES),
          pDC-&gt;GetDeviceCaps(VERTRES));</B>
}
</PRE><P>
<B><LI>Build and run the EX05A program.</B> You must run the program from the debugger if you want to see the output from the TRACE statements. You can choose Go from the Start Debug submenu of the Build menu in Visual C++, or click the following button on the Build toolbar.<P>

<P><IMG SRC="G05OG02.GIF" width=24 height=23 BORDER=0><P>

<P>The resulting output (assuming the use of a standard VGA card) looks like the screen shown here.

<P><A HREF="javascript:fullSize('G05OG03x.htm')"> <img src="G05OG03.JPG" width=404 height=288 border=0 ALT = "Click to view at full size."> </A><P>

<P>Notice that the output string sizes don't quite correspond to the point sizes. This discrepancy results from the font engine's conversion of logical 
units to pixels. The program's trace output, partially shown below, shows the printout of font metrics. (The numbers depend on your display 
driver and your video driver.)<P>
<PRE>points = 6, tmHeight = 150, tmInternalLeading = 30, tmExternalLeading = 4
string width = 990, string height = 150
points = 8, tmHeight = 210, tmInternalLeading = 45, tmExternalLeading = 5
string width = 1380, string height = 210
points = 10, tmHeight = 240, tmInternalLeading = 45, tmExternalLeading = 6
string width = 1770, string height = 240
points = 12, tmHeight = 270, tmInternalLeading = 30, tmExternalLeading = 8
string width = 2130, string height = 270
</PRE><P>
</OL>

<A NAME="110"><H2>The EX05A Program Elements</H2></A><P>Following is a discussion of the important elements in the EX05A example.
<A NAME="111"><H3>Setting the Mapping Mode in the <I>OnPrepareDC</I> Function</H3></A><P>The application framework calls <I>OnPrepareDC</I> prior to calling <I>OnDraw</I>, so the <I>OnPrepareDC</I> function is the logical place to prepare the device context. If you had other message handlers that needed the correct mapping mode, those functions would have contained calls to 
<I>OnPrepareDC</I>.
<A NAME="112"><H3>The <I>ShowFont</I> Private Member Function</H3></A><P><I>ShowFont</I> contains code that is executed 10 times in a loop. With C, you would have made this a global function, but with C++ it's better to make it a private class member function, sometimes known as a 
<U>helper</U> <U>function</U>.
<P>This function creates the font, selects it into the device context, prints 
a string to the window, and then deselects the font. If you choose to include 
debug information in the program, <I>ShowFont</I> also displays useful font metrics information, including the actual width of the string.
<A NAME="113"><H3>Calling <I>CFont::CreateFont</I></H3></A><P>This call includes lots of parameters, but the important ones are the first two&#151;the font height and width. A width value of 0 means that the aspect ratio of the selected font will be set to a value specified by the font designer. If you put 
a nonzero value here, as you'll see in the next example, you can change the 
font's aspect ratio.
<P>
<DIV CLASS=tip>
<BLOCKQUOTE>
<IMG SRC="tip.jpg" width=123 height=18 BORDER=0><P>
If you want your font to be a specific point size, the <I>CreateFont</I> font height parameter (the first parameter) must be <U>negative</U>. If you're using the <I>MM_TWIPS</I> mapping mode for a printer, for example, a height parameter of -240 ensures a true 12-point font, with <I>tmHeight</I> - 
<I>tmInternalLeading</I> = 240. A +240 height parameter gives you a smaller font, with <I>tmHeight</I> = 240.
</BLOCKQUOTE></DIV>
<P>
The last <I>CreateFont</I> parameter specifies the font name, in this case the Arial TrueType font. If you had used <I>NULL</I> for this parameter, the 
<I>FF_SWISS</I> specification (which indicates a proportional font without serifs) would have caused Windows to choose the best matching font, which, depending on the specified size, might have been the System font or the Arial TrueType font. The font name takes precedence. If you had specified 
<I>FF_ROMAN</I> (which indicates a proportional font with serifs) with Arial, for example, you would have gotten Arial.
</BODY>
</HTML>



