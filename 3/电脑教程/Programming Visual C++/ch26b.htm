<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The IDataObject Interface</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="554"><H1><B>The <I>IDataObject</I> Interface</B></H1></A>
<P>The <I>IDataObject</I> interface is used for clipboard transfers and drag-and-drop operations, but it's also used in compound documents, ActiveX Controls, and custom OLE features. In his book <I>Inside OLE, </I>2d ed. (Microsoft Press, 1995) Kraig Brockschmidt says, &quot;Think of objects as little piles of stuff.&quot; The <I>IDataObject</I> interface helps you move those piles around, no matter what kind of stuff they contain.

<P>If you were programming at the Win32 level, you would write C++ code that supported the <I>IDataObject</I> interface. Your program would then construct <U>data</U> <U>objects</U> of this class, and you would manipulate those objects with the <I>IDataObject</I> member functions. In this chapter you'll see how to accomplish the same results by using MFC's implementation of <I>IDataObject</I>. Let's start by taking a quick look at why the OLE clipboard is an improvement on the regular Windows clipboard.

<A NAME="555"><H2><B>How <I>IDataObject</I> Improves on Standard Clipboard Support</B></H2></A>
<P>There has never been much MFC support for the Windows Clipboard. If you've written programs for the clipboard already, you've used Win32 clipboard functions such as <I>OpenClipboard</I>, 
<I>CloseClipboard</I>, <I>GetClipboardData</I>, and <I>SetClipboardData</I>. One program copies a single data element of a specified format to the clipboard, and another program selects the data by format code and pastes it. Standard clipboard formats include global memory (specified by an 
<I>HGLOBAL</I> variable) and various GDI objects, such as bitmaps and metafiles (specified by their handles). Global memory can contain text as well as custom formats.

<P>The <I>IDataObject</I> interface picks up where the Windows Clipboard leaves off. To make a long story short, you transfer a single <I>IDataObject</I> pointer to or from the clipboard instead of transferring a series of discrete formats. The underlying data object can contain a whole array of formats. Those formats can carry information about target devices, such as printer characteristics, and they can specify the data's <U>aspect</U> or view. The standard aspect is content. Other 
aspects include an icon for the data and a thumbnail picture.

<P>Note that the <I>IDataObject</I> interface specifies the <U>storage</U> <U>medium</U> of a data object format. Conventional clipboard transfer relies exclusively on global memory. The <I>IDataObject</I> interface permits the transmission of a disk filename or a structured storage pointer instead. Thus, if you want to transfer a very large block of data that's already in a disk file, you don't have to waste time copying it to and from a memory block.

<P>In case you were wondering, <I>IDataObject</I> pointers are compatible with programs that use existing clipboard transfer methods. The format codes are the same. Windows takes care of the conversion to and from the data object. Of course, if an OLE-aware program puts an <I>IStorage</I> pointer in a data object and puts the object on the clipboard, older, non-OLE-aware programs are 
unable to read that format.

</BODY>
</HTML>



