<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Visual C++ and DHTML</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="986"><H1>Visual C++ and DHTML</H1></A><P>Visual C++ 6.0 supports DHTML through both MFC and ATL. Both 
MFC and ATL give you complete access to the DHTML object model. 
Unfortunately, access to the object model from languages like 
C++ is done through OLE Automation 
(<I>IDispatch</I>) and in many cases isn't as cut-and-dried as some of 
the scripts we looked at earlier.
<P>The DHTML object model is exposed to C++ developers through a 
set of COM objects with the prefix IHTML (<I>IHTMLDocument, 
IHTMLWindow, IHTMLElement, IHTMLBodyElement</I>, and so on). In 
C++, once you obtain the document interface, you can use any of the 
<I>IHTMLDocument2</I> interface methods to obtain or to modify the document's properties.
<P>You can access the <I>all</I> collection by calling the 
<I>IHTMLDocument2::get_all</I> method. This method returns an 
<I>IHTMLElementCollection</I> collection interface that contains all the elements in the document. You can then iterate 
through the collection using the 
<I>IHTMLElementCollection::item</I> method (similar to 
the parentheses in the script above). The 
<I>IHTMLElementCollection::item</I> method supplies you with an 
<I>IDispatch</I> pointer that you can call 
<I>QueryInterface</I> on, requesting the 
<I>IID_IHTMLElement</I> interface. This call to 
<I>QueryInterface</I> will give you an 
<I>IHTMLElement</I> interface pointer that you can use to get or 
set information for the HTML element.
<P>Most elements also provide a specific interface for working with 
that particular element type. These element-specific interface names take the 
format of <I>IHTMLXXXXElement</I>, where XXXX is the name of the element 
(<I>IHTMLBodyElement, </I>for example). You must call 
<I>QueryInterface</I> on the 
<I>IHTMLElement</I> object to request the element-specific interface you need. This might 
sound confusing (because it can be!). But don't worry&#151;the MFC and ATL 
sections in this chapter contain plenty of samples that demonstrate how it all ties 
together. You'll be writing DHTML code in no time.
<A NAME="987"><H2>MFC and DHTML</H2></A><P>MFC's support for DHTML starts with a new 
<I>CView</I> derivative, <I>CHtmlView.</I> <I>CHtmlView 
</I>allows you to embed an HTML view inside frame windows or 
splitter windows, where with some DHTML work it can act as a dynamic 
form. Example EX37A demonstrates how to use the new 
<I>CHtmlView</I> class in a vanilla MDI application.
<P>Follow these steps to create the EX37A example:<P>
<OL>
<B><LI>Run AppWizard and create 
\vcpp32\ex37a\ex37a</B>. Choose New from Visual C++'s File menu. Then click the Projects tab, and select MFC AppWizard (exe). Accept all defaults, except in Step 6 choose CHtmlView 
as the Base Class, as shown here.<P>

<P><A HREF="javascript:fullSize('g37og01x.htm')"> <img src="g37og01.jpg" width=404 height=325 border=0 ALT = "Click to view at full size."> </A><P>

<B><LI>Edit the URL to be loaded.</B> In the 
<I>CEx37aView::OnInitialUpdate</I> function, you will see this line:
<P><PRE>Navigate2(_T(&quot;http://www.microsoft.com/visualc/&quot;),NULL,NULL);</PRE>
<P>You can edit this line to have the application load a local page or a 
URL other than the Visual C++ page.
<P><B><LI>Compile and run.</B> Figure 37-3 shows the application running with 
the default Web page.

<P><A HREF="javascript:fullSize('f37og03x.htm')"> <img src="f37og03.jpg" width=404 height=278 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 37-3.</B> <I>The EX37A example.</I>
<!-- /caption -->
<P>Now let's create a sample that really shows how to use DHTML with 
MFC. EX37B creates a <I>CHtmlView</I> object and a 
<I>CListView</I> object separated by a splitter. The example then uses DHTML to enumerate the HTML elements in the <I>CHtmlView</I> object and displays the results in the 
<I>CListView </I>object. The end result will be a DHTML explorer that you can use to view the DHTML 
object model of any HTML file.
<P>Here are the steps to create EX37B:<P>

<B><LI>Run AppWizard and create 
\vcpp32\ex37b\ex37b.</B> Choose New from Visual C++'s File menu. Then click the Projects tab, and select 
MFC AppWizard (exe). Accept all the defaults but three: select Single 
Document, select Windows Explorer in Step 5, and select 
<I>CHtmlView</I> as the Base Class in Step 6. The options that you should see after finishing 
the wizard are shown in the graphic below.<P>

<P><img src="g37og02x.gif" width=416 height=424 border=0><P>

<B><LI>Change the <I>CLeftView</I> to be a 
<I>CListView</I> derivative.</B> By default, AppWizard makes the 
<I>CLeftView</I> of the splitter window a 
<I>CTreeView</I> derivative. Open the LeftView.h 
file, and do a global search for <I>CTreeView</I> 
and replace it with <I>CListView</I>. Open LeftView.cpp and do the same find and 
replace (Hint: Use Edit/Replace/Replace All.)
<P><B><LI>Edit the URL to be loaded.</B> In the 
<I>CEx37bView::OnInitialUpdate</I> function, change the URL to 
res://ie4tour.dll/welcome.htm.
<P><B><LI>Add a <I>DoDHTMLExplore</I> function to 
<I>CMainFrame</I>.</B> First add the fol-lowing declaration to the MainFrm.h file:
<P><PRE>    virtual void DoDHTMLExplore(void);</PRE>
<P>Now add the implementation for 
<I>DoHTMLExplore</I> to MainFrm.cpp.
<P><PRE>void CMainFrame::DoDHTMLExplore(void)
{

    CLeftView *pListView = 
        (CLeftView *)m_wndSplitter.GetPane(0,0);

    CEx37bView * pDHTMLView = 
        (CEx37bView *)m_wndSplitter.GetPane(0,1);

    //Clear the listview 
    pListView-&gt;GetListCtrl().DeleteAllItems();
    IDispatch* pDisp = pDHTMLView-&gt;GetHtmlDocument();
    
    if (pDisp != NULL )
    {
        IHTMLDocument2* pHTMLDocument2;
        HRESULT hr;

        hr = pDisp-&gt;QueryInterface( IID_IHTMLDocument2,
                    (void**)&amp;pHTMLDocument2 );
        if (hr == S_OK)
        {
            IHTMLElementCollection* pColl = NULL;

            hr = pHTMLDocument2-&gt;get_all( &amp;pColl );
            if (hr == S_OK &amp;&amp; pColl != NULL)
            {
                LONG celem;
                hr = pColl-&gt;get_length( &amp;celem );

                if ( hr == S_OK )
                {
                    for ( int i=0; i&lt; celem; i++ )
                    {
                        VARIANT varIndex;
                        varIndex.vt = VT_UINT;
                        varIndex.lVal = i;
                        VARIANT var2;
                        VariantInit( &amp;var2 );
                        IDispatch* pDisp; 

                        hr = pColl-&gt;item( varIndex, var2, &amp;pDisp );
                        if ( hr == S_OK )
                        {
                            IHTMLElement* pElem;

                            hr = pDisp-&gt;QueryInterface(
                                IID_IHTMLElement,
                                (void **)&amp;pElem);
                            if ( hr == S_OK )
                            {
                                BSTR bstr;
                                hr = pElem-&gt;get_tagName(&amp;bstr);
                                CString strTag = bstr;
                                IHTMLImgElement* pImgElem;

                                //Is it an image element?
                                hr = pDisp-&gt;QueryInterface(
                                    IID_IHTMLImgElement, 
                                    (void **)&amp;pImgElem );
                                if ( hr == S_OK )
                                {
                                    pImgElem-&gt;get_href(&amp;bstr);
                                    strTag += &quot; - &quot;;
                                    strTag += bstr;
                                    pImgElem-&gt;Release();
                                }
                                else
                                {
                                    IHTMLAnchorElement* pAnchElem;

                                    //Is it an anchor?
                                    hr = pDisp-&gt;QueryInterface(
                                        IID_IHTMLAnchorElement, 
                                        (void **)&amp;pAnchElem );
                                    if ( hr == S_OK )
                                    {
                                        pAnchElem-&gt;get_href(&amp;bstr);
                                        strTag += &quot; - &quot;;
                                        strTag += bstr;
                                        pAnchElem-&gt;Release();
                                    }
                                }//end of else

                                pListView-&gt;GetListCtrl().InsertItem(
                                    pListView-&gt;GetListCtrl()
                                    .GetItemCount(), strTag);
                                pElem-&gt;Release();
                            }
                            pDisp-&gt;Release();
                        }
                    }
                }
                pColl-&gt;Release();
            }
            pHTMLDocument2-&gt;Release();
        }
        pDisp-&gt;Release();
    }
}</PRE>
<P>Here are the steps that this function takes to &quot;explore&quot; the 
HTML document using DHTMLs:
<UL>
<LI>First <I>DoHTMLExplore</I> gets pointers to the 
<I>CListView</I> and <I>CHtmlView</I> views in the splitter window.<P>
<LI>Then it makes a call to 
<I>GetHtmlDocument</I> to get an <I>IDispatch</I> 
pointer to the DHTML <I>document</I> object.<P>
<LI>Next <I>DoHTMLExplore</I> gets the 
<I>IHTMLDocument2</I> interface.<P>
<LI>With the <I>IHTMLDocument2</I> interface, 
<I>DoHTMLExplore</I> retrieves the <I>all</I> collection and iterates through it. In each iteration, 
<I>DoHTMLExplore</I> checks the element type.If the element is an image or 
an anchor, <I>DoHTMLExplore</I> retrieves additional information such 
as the link for the image. The <I>all</I> collection loop then places the 
textual description of the HTML element in the 
<I>CListView</I> object.<P>
</UL>
<P><B><LI>Make sure that Mainfrm.cpp includes 
mshtml.h.</B> Add the following line to the top of Mainfrm.cpp so that the 
<I>DoHTMLExplore</I> code will compile.
<P><PRE>#include &lt;mshtml.h&gt;</PRE>
<P><B><LI>Add a call to 
<I>DoHTMLExplore</I>.</B> For this example, we will change 
the <I>CEx37bApp::OnAppAbout</I> function to call the 
<I>DoDHTMLExplore</I> function in the ex37b.cpp file. Replace the existing code with the 
following boldface code:
<P><PRE>void CEx37bApp::OnAppAbout()
{
<B>    CMainFrame * pFrame = (CMainFrame*)AfxGetMainWnd();
    pFrame-&gt;DoDHTMLExplore();</B>

}</PRE>
<P><B><LI>Customize the list view.</B> In the 
<I>CLeftView::PreCreateWindow</I> function (LeftView.cpp), add this line:      
<P><PRE>cs.style |= LVS_LIST;</PRE>
<P><B><LI>Compile and run.</B> Compile and run the sample. Press the &quot;?&quot; 
toolbar item, or choose Help/About to invoke the explore function.
<P>Figure 37-4 shows the EX37B example in action.

<P><A HREF="javascript:fullSize('F37OG04x.htm')"> <img src="F37OG04.JPG" width=404 height=282 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 37-4.</B> <I>The EX37B example in action.</I>
<!-- /caption -->
</OL>
<P>Now that you've seen how to use DHTML and MFC, let's look at 
how ATL implements DHMTL support.
<A NAME="988"><H2>ATL and DHTML</H2></A><P>ATL's support for DHTML comes in the form of an HTML object that 
can be embedded in any ATL ActiveX control. EX37C creates an ATL control 
that illustrates DHTML support.
<P>To create the example, follow these steps:
<OL>
<P><B><LI>Run the ATL COM AppWizard and create 
\vcpp32\ex37c\ex37c.</B> Choose New from Visual C++'s File menu. Then click the Projects 
tab, and select ATL COM AppWizard. Choose Executable as the server type.
<P><B><LI>Insert an HTML control.</B> In ClassView, right-click on the ex37c 
classes item and select New ATL Object. Select Controls and HTML Control 
as shown in the graphic below.<P>

<P><img src="G37OG03x.GIF" width=415 height=258 border=0><P>

<B><LI>Click Next and fill in the C++ Short Name as shown here.</B><P>


<P><img src="G37OG04x.GIF" width=421 height=279 border=0> 
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
If you look at the <I>IDHTMLUI</I> object, you will see this 
stock implementation of the <I>OnClick</I> handler:
<P><PRE>    STDMETHOD(OnClick)(IDispatch* pdispBody, VARIANT varColor)
    {
        CComQIPtr&lt;IHTMLBodyElement&gt; spBody(pdispBody);
        if (spBody != NULL)
            spBody-&gt;put_bgColor(varColor);
        return S_OK;
    }</PRE>
<P>The default <I>OnClick</I> handler uses 
<I>QueryInterface</I> on the <I>IDispatch</I> pointer to get the 
<I>IHTMLBodyElement</I> object. The handler then 
calls the <I>put_bgColor</I> method to change the background color.
</BLOCKQUOTE></DIV>
<P>

<B><LI>Compile, load, and run the control to see the ATL DHTML code in 
action.</B> After you build the project, select ActiveX Control Test Container 
from the Tools menu. In the test container, select Insert New Control from 
the Edit menu and choose CDHTML Class from the list box. Figure 
37-5 shows the resulting ActiveX control that uses DHTML to change the 
background when the user clicks the button.

<P> <img src="f37og05x.gif" width=429 height=413 border=0> <P>
<!-- caption -->
<B>Figure 37-5.</B> <I>EX37C ActiveX control.</I>
<!-- /caption -->
</OL>
<A NAME="989"><H2>For More Information&#133;</H2></A><P>We hope this introduction to DHTML has you thinking of some ways to 
use this exciting new technology in your Visual 
C++ applications. The possibilities are endless: completely dynamic applications, applications that update from the Internet, client/server ActiveX controls, and many more.
<P>If you would like to learn more about DHTML, we suggest the 
following resources:
<UL>
<LI><I>Inside Dynamic HTML</I> by Scott Isaacs (Microsoft Press, 1997)<P>
<LI><I>Dynamic HTML in Action</I> by William J. Pardi and Eric M. 
Schurman (Microsoft Press, 1998)<P>
<LI><I>The Internet SDK (an excellent resource on DHTML and 
other Microsoft technologies)<P></I>
<LI><I><A HREF="http://www.microsoft.com" TARGET="_BLANK">www.microsoft.com</A></I> (several areas discuss DHTML)<P>
</UL>
<P>
</BODY>
</HTML>



