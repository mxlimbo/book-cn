<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Setting the Color for the Dialog Background and for Controls</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="144"><H1>Setting the Color for the Dialog Background and for Controls</H1></A>
<P>You can change the background color of individual dialogs or specific 
controls in a dialog, but you have to do some extra work. The parent dialog is sent a WM_CTLCOLOR message for each control immediately before the control is displayed. A WM<B><I>_</I></B>CTLCOLOR message is also sent on behalf of the dialog itself. If you map this message in your derived dialog class, you can set the foreground and background text colors and select a brush for the control or dialog nontext area.
<P>Following is a sample <I>OnCtlColor</I> function that sets all edit control 
backgrounds to yellow and the dialog background to red. The <I>m<B>_</B>hYellowBrush</I> and <I>m<B>_</B>hRedBrush</I> variables are data members of type <I>HBRUSH</I>, initialized in the dialog's <I>OnInitDialog</I> function. The <I>nCtlColor</I> parameter indicates the type of control, and the <I>pWnd</I> parameter identifies the specific control. If you wanted to set the color for an individual edit control, you would convert <I>pWnd</I> to a child window ID and test it.
<P>
<PRE>HBRUSH CMyDialog::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
    if (nCtlColor == CTLCOLOR_EDIT) {
        pDC-&gt;SetBkColor(RGB(255, 255, 0));  // yellow
        return m_hYellowBrush;
    }
    if (nCtlColor == CTLCOLOR_DLG) {
        pDC-&gt;SetBkColor(RGB(255, 0, 0));    // red
        return m_hRedBrush;
    }
    return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}
</PRE><P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The dialog does not post the WM_CTLCOLOR message in the message queue; instead, it calls the Win32 <I>SendMessage</I> function to send the message immediately. Thus the message handler can return a parameter, in this case a handle to a brush. This is not an MFC <I>CBrush</I> object but rather a Win32 <I>HBRUSH</I>. You can create the brush by calling the Win32 functions 
<I>CreateSolidBrush</I>, <I>CreateHatchBrush</I>, and so forth.
</BLOCKQUOTE></DIV>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B>
<P>Actually, Win32 no longer has a WM_CTLCOLOR message. It was replaced by control-specific messages such as WM_CTLCOLORBTN, WM_CTLCOLORDLG, and so on. MFC and ClassWizard process these messages invisibly, so your programs look as though they're mapping the old 16-bit WM_CTLCOLOR messages. This trick makes debugging more complex, but it makes portable code easier to write. Another option would be to use the <I>ON_MESSAGE</I> macro to map the real Win32 messages.
<P>If your dialog class (or other MFC window class) doesn't map the WM_CTLCOLOR message, the framework <U>reflects</U> the message back to the control. When you study window subclassing in <A HREF="ch16a.htm">Chapter 16</A>, you'll learn how to write your own control window classes that can process these reflected messages.
</BLOCKQUOTE></DIV>
<P>
</BODY>
</HTML>



