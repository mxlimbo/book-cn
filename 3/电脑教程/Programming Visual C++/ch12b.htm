<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Windows Message Processing</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="237"><H1>Windows Message Processing</H1></A>
<P>To understand threads, you must first understand how 32-bit Windows processes messages. The best starting point is a single-threaded program that shows the importance of the message translation and dispatch process. You'll improve that program by adding a second thread, which you'll control with a global variable and a simple message. Then you'll experiment with events and critical sections. For heavy-duty multithreading elements such as mutexes and semaphores, however, you'll need to refer to another book, such as Jeffrey Richter's <I>Advanced Windows, </I>3d Ed. (Microsoft Press, 1997).
<A NAME="238"><H2>How a Single-Threaded Program Processes Messages</H2></A>
<P>All the programs so far in this book have been <U>single-threaded</U>, which means that your code has only one path of execution. With ClassWizard's help, you've written handler functions for various Windows messages and you've written <I>OnDraw</I> code that is called in response to the WM_PAINT message. It might seem as though Windows magically calls your handler when the message 
floats in, but it doesn't work that way. Deep inside the MFC code (which is linked to your program) are instructions that look something like this:
<P><PRE>MSG message;
while (::GetMessage(&amp;message, NULL, 0, 0)) {
    ::TranslateMessage(&amp;message);
    ::DispatchMessage(&amp;message);
}
</PRE><P>Windows determines which messages belong to your program, and the 
<I>GetMessage</I> function returns when a message needs to be processed. If no 
messages are posted, your program is suspended and other programs can run. When 
a message eventually arrives, your program &quot;wakes up.&quot; The <I>TranslateMessage</I> function translates WM_KEYDOWN messages into WM_CHAR 
messages containing ASCII characters, and the <I>DispatchMessage</I> function passes control (via the window class) to the MFC message pump, which calls your function via the message map. When your handler is finished, it returns to the MFC code, which eventually causes <I>DispatchMessage</I> to return.
<A NAME="239"><H2>Yielding Control</H2></A>
<P>What would happen if one of your handler functions was a pig and chewed up 10 seconds of CPU time? Back in the 16-bit days, that would have hung up the whole computer for the duration. Only cursor tracking and a few other interrupt-based tasks would have run. With Win32, multitasking got a whole lot better. Other applications can run because of preemptive multitasking&#151;Windows simply interrupts your pig function when it needs to. However, even in Win32, your program would be locked out for 10 seconds. It couldn't process any messages because <I>DispatchMessage</I> doesn't return until the pig returns.
<P>There is a way around this problem, however, which works with both Win16 and Win32. You simply train your pig function to be polite and yield control once in a while by inserting the following instructions inside the pig's main loop:
<P><PRE>MSG message;
if (::PeekMessage(&amp;message, NULL, 0, 0, PM_REMOVE)) {
    ::TranslateMessage(&amp;message);
    ::DispatchMessage(&amp;message);
}
</PRE><P>The <I>PeekMessage</I> function works like <I>GetMessage</I>, except that it returns immediately even if no message has arrived for your program. In that case, the pig keeps on chewing. If there <U>is</U> a message, however, the pig pauses, the handler is called, and the pig starts up again after the handler exits.
<A NAME="240"><H2>Timers</H2></A><P>A Windows timer is a useful programming element that sometimes makes multithreaded programming unnecessary. If you need to read a communication buffer, for example, you can set up a timer to retrieve the accumulated characters every 100 milliseconds. You can also use a timer to control animation because the timer is independent of CPU clock speed.
<P>Timers are easy to use. You simply call the <I>CWnd</I> member function <I>SetTimer</I> with an interval parameter, and then you provide, with the help of ClassWizard, a message handler function for the resulting WM_TIMER messages. Once you start the timer with a specified interval in milliseconds, WM_TIMER messages will be sent continuously to your window until you call <I>CWnd::KillTimer</I> or until the timer's window is destroyed. If you want to, you can use multiple timers, each identified by an integer. Because Windows isn't a real-time operating system, the interval between timer events becomes imprecise if you specify an interval much less than 100 milliseconds.
<P>Like any other Windows messages, timer messages can be blocked by other handler functions in your program. Fortunately, timer messages don't stack up. Windows won't put a timer message in the queue if a message for that timer is already present.
<A NAME="241"><H2>The EX12A Program</H2></A><P>We're going to write a single-threaded program that contains a CPU-intensive computation loop. We want to let the program process messages after the user starts the computation; otherwise, the user couldn't cancel the job. Also, we'd like to display the percent-complete status by using a progress indicator control, as shown in Figure 12-1. The EX12A program allows message processing by yielding control in the compute loop. A timer handler updates the progress control based on compute parameters. The WM_TIMER messages could not be processed if the compute process didn't yield control.
<P><IMG SRC="F12OG01.GIF" width=306 height=123 BORDER=0><P>
<!-- caption -->
<B>Figure 12-1.</B> <I>The Compute dialog box.</I>
<!-- /caption -->
<P>Here are the steps for building the EX12A application:<P>
<OL>
<B><LI>Run AppWizard to generate \vcpp32\ex12a\ex12a.</B> Accept all the default settings but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown here.

<P><img src="G12OG01x.gif" width=414 height=423 border=0 ><P>

<B><LI>Use the dialog editor to create the dialog resource <I>IDD_COMPUTE.</I></B> Use the resource shown here as a guide.

<P><IMG SRC="G12OG02.GIF" width=318 height=134 BORDER=0>

<P>Keep the default control ID for the Cancel button, but use <I>IDC_START</I> for the Start button. For the progress indicator, accept the default ID <I>IDC_PROGRESS1</I>.
<P><B><LI>Use ClassWizard to create the <I>CComputeDlg</I> class.</B> ClassWizard connects the new class to the <I>IDD_COMPUTE</I> resource you just created.
<P>After the class is generated, add a WM_TIMER message handler function. Also add BN_CLICKED message handlers for <I>IDC_START</I> and <I>IDCANCEL</I>. Accept the default names <I>OnStart</I> and <I>OnCancel</I>.
<P><B><LI>Add three data members to the <I>CComputeDlg</I> class.</B> Edit the file ComputeDlg.h. Add the following private data members:
<P><PRE><B>int m_nTimer;
int m_nCount;
enum { nMaxCount = 10000 };</B>
</PRE>
<P>The <I>m_nCount</I> data member of class <I>CComputeDlg </I>is incremented during the compute process. It serves as a percent complete measurement when divided by the &quot;constant&quot; <I>nMaxCount</I>.
<P><B><LI>Add initialization code to the <I>CComputeDlg</I> constructor in the ComputeDlg.cpp file.</B> Add the following line to the constructor to ensure that the Cancel button will work if the compute process has not been started:
<P><PRE><B>m_nCount = 0;</B></PRE>
<P>Be sure to add the line outside the 
<I>//{{AFX_DATA_INIT</I> comments generated by ClassWizard.
<P><B><LI>Code the <I>OnStart</I> function in ComputeDlg.cpp.</B> This code is executed when the user clicks the Start button. Add the following boldface code:
<P><PRE>void CComputeDlg::OnStart() 
{
<B>    MSG message;

    m_nTimer = SetTimer(1, 100, NULL); // 1/10 second
    ASSERT(m_nTimer != 0);
    GetDlgItem(IDC_START)-&gt;EnableWindow(FALSE);
    volatile int nTemp;
    for (m_nCount = 0; m_nCount &lt; nMaxCount; m_nCount++) {
        for (nTemp = 0; nTemp &lt; 10000; nTemp++) {
            // uses up CPU cycles
        }
        if (::PeekMessage(&amp;message, NULL, 0, 0, PM_REMOVE)) {
            ::TranslateMessage(&amp;message);
            ::DispatchMessage(&amp;message);
        }
    }
    CDialog::OnOK();</B>
}
</PRE><P>The main <I>for</I> loop is controlled by the value of <I>m_nCount</I>. At the end of each pass through the outer loop, <I>PeekMessage</I> allows other messages, including WM_TIMER, to be processed. The <I>EnableWindow(FALSE)</I> call disables the Start button during the computation. If we didn't take this precaution, the <I>OnStart</I> function could be reentered.
<P><B><LI>Code the <I>OnTimer</I> function in ComputeDlg.cpp.</B> When the timer fires, the progress indicator's position is set according to the value of <I>m_nCount</I>. Add the following boldface code:
<P><PRE>void CComputeDlg::OnTimer(UINT nIDEvent)
{
<B>    CProgressCtrl* pBar = (CProgressCtrl*) GetDlgItem(IDC_PROGRESS1);
    pBar-&gt;SetPos(m_nCount * 100 / nMaxCount);</B>
}
</PRE>
<P><B><LI>Update the <I>OnCancel</I> function in ComputeDlg.cpp.</B> When the user clicks the Cancel button during computation, we don't destroy the dialog; instead, we set <I>m_nCount</I> to its maximum value, which causes <I>OnStart</I> to exit the dialog. If the computation hasn't started, it's okay 
to exit directly. Add the following boldface code:
<P><PRE>void CControlDlg::OnCancel()
{
<B>    TRACE(&quot;entering CComputeDlg::OnCancel\n&quot;);
    if (m_nCount == 0) {      // prior to Start button
        CDialog::OnCancel();
    }
    else {                    // computation in progress
        m_nCount = nMaxCount; // Force exit from OnStart
    }</B>
}
</PRE>
<P><B><LI>Edit the <I>CEx12aView</I> class in ex12aView.cpp.</B> First edit the virtual <I>OnDraw</I> function to display a message, as shown here:
<P><PRE>void CEx12aView::OnDraw(CDC* pDC)
{
<B>    pDC-&gt;TextOut(0, 0, &quot;Press the left mouse button here.&quot;);</B>
}
<P></PRE>Then use ClassWizard to add the <I>OnLButtonDown</I> function to handle WM_LBUTTONDOWN messages, and add the following boldface code:
<P><PRE>void CEx12aView::OnLButtonDown(UINT nFlags, CPoint point)
{
<B>    CComputeDlg dlg;
    dlg.DoModal();</B>
}
</PRE><P>This code displays the modal dialog whenever the user presses the 
left mouse button while the mouse cursor is in the view window.
<P>While you're in ex12aView.cpp, add the following <I>#include</I> statement:
<P><PRE><B>#include &quot;ComputeDlg.h&quot;</B></PRE>
<P><LI><B>Build and run the application.</B> Press the left mouse button while the mouse cursor is inside the view window to display the dialog. Click the Start button, and then click Cancel. The progress indicator should show the status of the computation.
</OL>
</BODY>
</HTML>



