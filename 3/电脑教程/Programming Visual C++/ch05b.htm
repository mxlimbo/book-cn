<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The Device Context Classes</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="87"><H1>The Device Context Classes</H1></A><P>In <A HREF="ch03a.htm">Chapter 3</A> and <A HREF="ch04a.htm">Chapter 4</A>, the view class's 
<I>OnDraw</I> member function was passed a pointer to a device context object. 
<I>OnDraw</I> selected a brush and then drew an ellipse. The Microsoft Windows 
<U>device</U> <U>context</U> is the key GDI element 
that represents a physical device. Each C++ device context object has an 
associated Windows device context, identified by a 32-bit handle of type HDC.
<P>Microsoft Foundation Class (MFC) Library version 6.0 provides a 
number of device context classes. The base class 
<I>CDC</I> has all the member functions (including some virtual functions) that you'll need for drawing. Except for the oddball <I>CMetaFileDC</I> class, derived classes are distinct only in their 
constructors and destructors. If you (or the application framework) construct an 
object of a derived device context class, you can pass a 
<I>CDC</I> pointer to a function such as <I>OnDraw</I>. For the display, the usual derived classes are 
<I>CClientDC</I> and <I>CWindowDC</I>. For other devices, such as printers or memory buffers, 
you construct objects of the base class <I>CDC</I>.
<P>The &quot;virtualness&quot; of the <I>CDC</I> class is an important feature of the 
application framework. In <A HREF="ch19a.htm">Chapter 19</A>, you'll see how easy it is to write code 
that works with both the printer and the display. A statement in 
<I>OnDraw</I> such as<P>
<PRE>pDC-&gt;TextOut(0, 0, &quot;Hello&quot;);
</PRE>
<P>sends text to the display, the printer, or the Print Preview window, 
depending on the class of the object referenced by the 
<I>CView::OnDraw</I> function's <I>pDC </I>parameter.
<P>For display and printer device context objects, the application 
framework attaches the handle to the object. For other device contexts, such as the 
memory device context that you'll see in <A HREF="ch11a.htm">Chapter 11</A>, you must call a member 
function after construction in order to attach the handle.
<A NAME="88"><H2>The Display Context Classes <I>CClientDC</I> and <I>CWindowDC</I></H2></A>
<P>Recall that a window's client area excludes the border, the caption bar, and 
the menu bar. If you create a <I>CClientDC</I> object, you have a device context that 
is mapped only to this client area&#151;you can't draw outside it. The point (0, 
0) usually refers to the upper-left corner of the client area. As you'll see later, 
an MFC <I>CView</I> object corresponds to a 
<U>child</U> <U>window</U> that is contained inside 
a separate frame window, often along with a toolbar, a status bar, and scroll 
bars. The client area of the view, then, does not include these other windows. If 
the window contains a docked toolbar along the top, for example, (0, 0) refers 
to the point immediately <U>under</U> the left edge of the toolbar.
<P>If you construct an object of class 
<I>CWindowDC</I>, the point (0, 0) is at the upper-left corner of the nonclient area of the window. With this whole-window device context, you can draw in the window's border, in the caption area, 
and so forth. Don't forget that the view window doesn't have a nonclient area, 
so <I>CWindowDC</I> is more applicable to frame windows than it is to view windows.
<A NAME="89"><H2>Constructing and Destroying <I>CDC</I> Objects</H2></A>
<P>After you construct a <I>CDC</I> object, it is important to destroy it promptly 
when you're done with it. Microsoft Windows limits the number of available 
device contexts, and if you fail to release a Windows device context object, a 
small amount of memory is lost until your program exits. Most frequently, 
you'll construct a device context object inside a message handler function such 
as <I>OnLButtonDown</I>. The easiest way to ensure that the device context object 
is destroyed (and that the underlying Windows device context is released) is 
to construct the object on the stack in the following way:<P>
<PRE>void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    CRect rect;

    CClientDC dc(this);  // constructs dc on the stack
    dc.GetClipBox(rect); // retrieves the clipping rectangle
} // dc automatically released
</PRE>
<P>Notice that the <I>CClientDC</I> constructor takes a window pointer as a 
parameter. The destructor for the <I>CClientDC</I> object is called when the 
function returns. You can also get a device context pointer by using the 
<I>CWnd::GetDC</I> member function, as shown in the following code. You must be careful here 
to call the <I>ReleaseDC</I> function to release the device context.<P>
<PRE>void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    CRect rect;

    CDC* pDC = GetDC();    // a pointer to an internal dc
    pDC-&gt;GetClipBox(rect); // retrieves the clipping rectangle
    ReleaseDC(pDC);        // Don't forget this
}
</PRE>
<P>
<DIV CLASS=warning>
<BLOCKQUOTE>
<IMG SRC="warning.jpg" width=123 height=18 BORDER=0><P>
You must not destroy the <I>CDC</I> object passed by 
the pointer to <I>OnDraw</I>. The application framework handles the 
destruction for you.
</BLOCKQUOTE></DIV>
<P>
<A NAME="90"><H2>The State of the Device Context</H2></A>
<P>You already know that a device context is required for drawing. When you 
use a <I>CDC</I> object to draw an ellipse, for example, what you see on the screen 
(or on the printer's hard copy) depends on the current &quot;state&quot; of the device 
context. This state includes the following:
<UL>
<LI>Attached GDI drawing objects such as pens, brushes, and fonts
<P><LI>The mapping mode that determines the scale of items when they 
are drawn (You've already experimented with the mapping mode 
in <A HREF="ch04a.htm">Chapter 4</A>.)
<P><LI>Various details such as text alignment parameters and polygon filling mode
<P></UL>
<P>You have already seen, for example, that choosing a gray brush prior 
to drawing an ellipse results in the ellipse having a gray interior. When you 
create a device context object, it has certain default characteristics, such as a black 
pen for shape boundaries. All other state characteristics are assigned through 
<I>CDC </I>class member functions. GDI objects are selected into the device context 
by means of the overloaded <I>SelectObject</I> functions. A device context can, for 
example, have one pen, one brush, or one font selected at any given time.
<A NAME="91"><H2>The <I>CPaintDC</I> Class</H2></A><P>You'll need the <I>CPaintDC</I> class only if you override your view's 
<I>OnPaint</I> function. The default <I>OnPaint</I> calls 
<I>OnDraw</I> with a properly set up device context, but sometimes you'll need display-specific drawing code. The <I>CPaintDC</I> class is special because its constructor and destructor do housekeeping 
unique to drawing to the display. Once you have a 
<I>CDC</I> pointer, however, you can use it as you would any other device context pointer.
<P>Here's a sample <I>OnPaint</I> function that creates a 
<I>CPaintDC</I> object:<P>
<PRE>void CMyView::OnPaint()
{
    CPaintDC dc(this);
    OnPrepareDC(&amp;dc); // explained later
    dc.TextOut(0, 0, &quot;for the display, not the printer&quot;);
    OnDraw(&amp;dc);      // stuff that's common to display and printer
}
</PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B><P>
<P>The <I>CPaintDC</I> constructor calls 
<I>BeginPaint</I> for you, and the destructor calls 
<I>EndPaint</I>. If you construct your device context on the stack, 
the <I>EndPaint</I> call is completely automatic.
</BLOCKQUOTE></DIV>
<P>
</BODY>
</HTML>



