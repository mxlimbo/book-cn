<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX06B Example</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="155"><H1>The EX06B Example</H1></A>
<P>I won't try to contrive a business-oriented example that uses all the 
custom controls. I'll just slap the controls in a modal dialog and trust that you'll see what's going on. The steps are shown below. After step 3, the instructions are oriented to the individual controls rather than to the Visual C++ components you'll be using.<P>
<OL>
<B><LI>Run AppWizard to generate the EX06B project.</B>  Choose New from Visual C++'s File menu, and then select Microsoft AppWizard (exe) from the Projects page. Accept all the defaults but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown here.<P>

<P><img src="G06OG18x.Gif" width=413 height=418 border=0>  </A>

<P><B><LI>Create a new dialog resource with ID <I>IDD_DIALOG1</I>.</B>  Place the controls as shown back in Figure 6-2.
<P>You can select the controls from the control palette. The following table lists the control types and their IDs.
<P>Don't worry about the other properties now&#151;you'll set those in the following steps. (Some controls might look different than they do in Figure 6-2 until you set their properties.) Set the tab order as shown next.<P>

<P><A HREF="javascript:fullSize('G06OG19x.htm')"> <img src="G06OG19.JPG" width=404 height=209 border=0 ALT = "Click to view at full size."> </A><P>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Tab Sequence</B> </TD><TD VALIGN="TOP"><B>Control Type</B> </TD><TD VALIGN="TOP"><B>Child Window ID</B> </TD></TR>
<TR><TD VALIGN="TOP">  1</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">  2</TD><TD VALIGN="TOP">Progress</TD><TD VALIGN="TOP"><I>IDC_PROGRESS1</I></TD></TR>
<TR><TD VALIGN="TOP">  3</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">  4</TD><TD VALIGN="TOP">Trackbar (Slider)</TD><TD VALIGN="TOP"><I>IDC_TRACKBAR1</I></TD></TR>
<TR><TD VALIGN="TOP">  5</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC_TRACK1</I></TD></TR>
<TR><TD VALIGN="TOP">  6</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">  7</TD><TD VALIGN="TOP">Trackbar (Slider)</TD><TD VALIGN="TOP"><I>IDC_TRACKBAR2</I></TD></TR>
<TR><TD VALIGN="TOP">  8</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC_TRACK2</I></TD></TR>
<TR><TD VALIGN="TOP">  9</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD VALIGN="TOP">Edit</TD><TD VALIGN="TOP"><I>IDC_BUDDY_SPIN1</I></TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD VALIGN="TOP">Spin</TD><TD VALIGN="TOP"><I>IDC_SPIN1</I></TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD VALIGN="TOP">List control</TD><TD VALIGN="TOP"><I>IDC_LISTVIEW1</I></TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC_LISTVIEW1</I></TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD VALIGN="TOP">Tree control</TD><TD VALIGN="TOP"><I>IDC_TREEVIEW1</I></TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC_TREEVIEW1</I></TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD VALIGN="TOP">Pushbutton</TD><TD VALIGN="TOP"><I>IDOK</I></TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD VALIGN="TOP">Pushbutton</TD><TD VALIGN="TOP"><I>IDCANCEL</I></TD></TR>
</TABLE>


<P><B><LI>Use ClassWizard to create a new class, <I>CEx06bDialog</I>, derived from 
<I>CDialog</I>.</B>  ClassWizard will automatically prompt you to create this 
class because it knows that the <I>IDD_DIALOG1</I> resource exists without an 
associated C++ class. Map the WM_INITDIALOG message, the WM_HSCROLL message, and the WM_VSCROLL message.

<P><B><LI>Program the progress control.</B>  Because ClassWizard won't generate a data member for this control, you must do it yourself. Add a public integer data member named <I>m_nProgress</I> in the <I>CEx06bDialog</I> class header, and set it to 0 in the constructor. Also, add the following code in the <I>OnInitDialog</I> member function:

<P><PRE><B>CProgressCtrl* pProg = 
    (CProgressCtrl*) GetDlgItem(IDC_PROGRESS1);
pProg-&gt;SetRange(0, 100);
pProg-&gt;SetPos(m_nProgress);
</B> </PRE>

<P><B><LI>Program the &quot;continuous&quot; trackbar control.</B>  Add a public integer data member named <I>m_nTrackbar1</I> to the <I>CEx06bDialog</I> header, and set it to 0 in the constructor. Next add the following code in the 
<I>OnInitDialog</I> member function to set the trackbar's range, to initialize its position from the data member, and to set the neighboring static control to the tracker's current value.

<P><PRE><B>CString strText1;
CSliderCtrl* pSlide1 = 
    (CSliderCtrl*) GetDlgItem(IDC_TRACKBAR1);
pSlide1-&gt;SetRange(0, 100);
pSlide1-&gt;SetPos(m_nTrackbar1);
strText1.Format(&quot;%d&quot;, pSlide1-&gt;GetPos());
SetDlgItemText(IDC_STATIC_TRACK1, strText1);</B> 
</PRE>

<P>To keep the static control updated, you need to map the WM_HSCROLL message that the trackbar sends to the dialog. Here is the code for the handler:

<P><PRE>void CEx06bDialog::OnHScroll(UINT nSBCode, UINT nPos,
                             CScrollBar* pScrollBar)
{
    <B>CSliderCtrl* pSlide = (CSliderCtrl*) pScrollBar;
    CString strText;
    strText.Format(&quot;%d&quot;, pSlide-&gt;GetPos());
    SetDlgItemText(IDC_STATIC_TRACK1, strText);</B> 
}
</PRE>

<P>Finally, you need to update the trackbar's <I>m_nTrackbar1</I> data member when the user clicks OK. Your natural instinct would be to put this code in the <I>OnOK</I> button handler. You would have a problem, however, if a data exchange validation error occurred involving any other control in the dialog. Your handler would set <I>m_nTrackbar1</I> even though the user might choose to cancel the dialog. To avoid this problem, add your code in the <I>DoDataExchange</I> function as shown below. If you do your own validation and detect a problem, call the <I>CDataExchange::Fail</I> function, which alerts the user with a message box.

<P><PRE><B>if (pDX-&gt;m_bSaveAndValidate) {
    TRACE(&quot;updating trackbar data members\n&quot;);
    CSliderCtrl* pSlide1 =
        (CSliderCtrl*) GetDlgItem(IDC_TRACKBAR1);
    m_nTrackbar1 = pSlide1-&gt;GetPos();

}
</B> </PRE>

<P><B><LI>Program the &quot;discrete&quot; trackbar control.</B>  Add a public integer data member named <I>m_nTrackbar2</I> to the <I>CEx06bDialog</I> header, and set it to 0 in the constructor. This data member is a zero-based index into the <I>dValue</I>, the array of numbers (4.0, 5.6, 8.0, 11.0, and 16.0) that the trackbar can represent. Define <I>dValue</I> as a private static double array member variable in ex06bDialog.h, and add to ex06bDialog.cpp the 
following line:

<P><PRE><B>double CEx06bDialog::dValue[5] = {4.0, 5.6, 8.0, 11.0, 16.0};</B> 
</PRE>

<P>Next add code in the <I>OnInitDialog</I> member function to set the trackbar's range and initial position.

<P><PRE><B>CString strText2;
CSliderCtrl* pSlide2 = 
    (CSliderCtrl*) GetDlgItem(IDC_TRACKBAR2);
pSlide2-&gt;SetRange(0, 4);
pSlide2-&gt;SetPos(m_nTrackbar2);
strText2.Format(&quot;%3.1f&quot;, dValue[pSlide2-&gt;GetPos()]);
SetDlgItemText(IDC_STATIC_TRACK2, strText2);</B> 
</PRE>

<P>If you had only one trackbar, the WM_HSCROLL handler in step 5 would work. But because you have two trackbars that send WM_HSCROLL messages, the handler must differentiate. Here is the new code:<P>
<PRE>void CEx06bDialog::OnHScroll(UINT nSBCode, UINT nPos,
                             CScrollBar* pScrollBar)
{
    CSliderCtrl* pSlide = (CSliderCtrl*) pScrollBar;
    CString strText;

    <B>// Two trackbars are sending
    //  HSCROLL messages (different processing)
    switch(pScrollBar-&gt;GetDlgCtrlID()) {
    case IDC_TRACKBAR1:</B> 
        strText.Format(&quot;%d&quot;, pSlide-&gt;GetPos());
        SetDlgItemText(IDC_STATIC_TRACK1, strText);
        <B>break;
    case IDC_TRACKBAR2:
        strText.Format(&quot;%3.1f&quot;, dValue[pSlide-&gt;GetPos()]);
        SetDlgItemText(IDC_STATIC_TRACK2, strText);
        break;
    }</B> 
}
</PRE>

<P>This trackbar needs tick marks, so you must check the control's Tick Marks and Auto Ticks properties back in the dialog editor. With Auto Ticks set, the trackbar will place a tick at every increment. The same data exchange considerations applied to the previous trackbar apply to this trackbar. Add the following code in the dialog class <I>DoDataExchange</I> member function inside the block for the <I>if</I> statement you added in the previous step:

<P><PRE><B>CSliderCtrl* pSlide2 =
    (CSliderCtrl*) GetDlgItem(IDC_TRACKBAR2);
m_nTrackbar2 = pSlide2-&gt;GetPos();</B> 
</PRE> 

<P>Use the dialog editor to set the Point property of both trackbars to Bottom/Right. Select Right for the Align Text property of both the <I>IDC_STATIC_TRACK1</I> and <I>IDC_STATIC_TRACK2</I> static controls.

<P><B><LI>Program the spin button control.</B> The spin control depends on its buddy edit control, located immediately before it in the tab order. Use ClassWizard to add a double-precision data member called <I>m_dSpin</I> for the <I>IDC_BUDDY_SPIN1</I> edit control. We're using a <I>double</I> instead of an <I>int</I> because the <I>int</I> would require almost no programming, and that would be too easy. We want the edit control range to be 0.0 to 10.0, but the spin control itself needs an integer range. Add the following code to <I>OnInitDialog</I> to set the spin control range to 0 to 100 and to set its 
initial value to <I>m_dSpin * 10.0</I>:

<P><PRE><B>CSpinButtonCtrl* pSpin =
    (CSpinButtonCtrl*) GetDlgItem(IDC_SPIN1);
pSpin-&gt;SetRange(0, 100);
pSpin-&gt;SetPos((int) (m_dSpin * 10.0));</B> 
</PRE><P>
To display the current value in the buddy edit control, you need to map the WM_VSCROLL message that the spin control sends to the dialog. Here's the code:

<P><PRE>void CEx06bDialog::OnVScroll(UINT nSBCode, UINT nPos, 
                             CScrollBar* pScrollBar) 
{
    <B>if (nSBCode == SB_ENDSCROLL) {
        return; // Reject spurious messages
    }
    // Process scroll messages from IDC_SPIN1 only
    if (pScrollBar-&gt;GetDlgCtrlID() == IDC_SPIN1) {
        CString strValue;
        strValue.Format(&quot;%3.1f&quot;, (double) nPos / 10.0);
        ((CSpinButtonCtrl*) pScrollBar)-&gt;GetBuddy()
                                       -&gt;SetWindowText(strValue);
    }</B> 
}
</PRE>

<P>There's no need for you to add code in <I>OnOK</I> or in <I>DoDataExchange</I> because the dialog data exchange code processes the contents of the edit control. In the dialog editor, select the spin control's Auto Buddy property and the buddy's Read-only property.

<P><B><LI>Set up an image list.</B>  Both the list control and the tree control need an image list, and the image list needs icons.

<P>First use the graphics editor to add icons to the project's RC file. 
On the companion CD-ROM, these icons are circles with black outlines 
and different-colored interiors. Use fancier icons if you have them. You 
can import an icon by choosing Resource from the Insert menu and 
then clicking the Import button. For this example, the icon resource IDs are 
as follows.<P>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Resource ID</B> </TD><TD VALIGN="TOP"><B>Icon File</B> </TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_BLACK</I></TD><TD VALIGN="TOP">Icon1</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_BLUE</I></TD><TD VALIGN="TOP">Icon3</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_CYAN</I></TD><TD VALIGN="TOP">Icon5</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_GREEN</I></TD><TD VALIGN="TOP">Icon7</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_PURPLE</I></TD><TD VALIGN="TOP">Icon6</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_RED</I></TD><TD VALIGN="TOP">Icon2</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_WHITE</I></TD><TD VALIGN="TOP">Icon0</TD></TR>
<TR><TD VALIGN="TOP"><I>IDI_YELLOW</I></TD><TD VALIGN="TOP">Icon4</TD></TR>
</TABLE>
<P>

Next add a private <I>CImageList</I> data member called <I>m_imageList</I> 
in the <I>CEx06bDialog</I> class header, and then add the following code 
to <I>OnInitDialog</I>:

<P><PRE><B>HICON hIcon[8];
int n;
m_imageList.Create(16, 16, 0, 8, 8); // 32, 32 for large icons
hIcon[0] = AfxGetApp()-&gt;LoadIcon(IDI_WHITE);
hIcon[1] = AfxGetApp()-&gt;LoadIcon(IDI_BLACK);
hIcon[2] = AfxGetApp()-&gt;LoadIcon(IDI_RED);
hIcon[3] = AfxGetApp()-&gt;LoadIcon(IDI_BLUE);
hIcon[4] = AfxGetApp()-&gt;LoadIcon(IDI_YELLOW);
hIcon[5] = AfxGetApp()-&gt;LoadIcon(IDI_CYAN);
hIcon[6] = AfxGetApp()-&gt;LoadIcon(IDI_PURPLE);
hIcon[7] = AfxGetApp()-&gt;LoadIcon(IDI_GREEN);
for (n = 0; n &lt; 8; n++) {
    m_imageList.Add(hIcon[n]);
}
</B> </PRE>

<P>

<DIV CLASS=note>
<BLOCKQUOTE>
<B>About Icons</B> 

<P>You probably know that a bitmap is an array of bits that represent 
pixels on the display. (You'll learn more about bitmaps in <A HREF="ch11a.htm">Chapter
11</A>.) In Windows, an icon is a &quot;bundle&quot; of bitmaps. First of all, an icon has different bitmaps for different sizes. Typically, small icons are 
16-by-16 pixels and large icons are 32-by-32 pixels. Within each size are 
two separate bitmaps: one 4-bit-per-pixel bitmap for the color image 
and one monochrome (1-bit-per-pixel) bitmap for the &quot;mask.&quot; If a 
mask bit is 0, the corresponding image pixel represents an opaque color. 
If the mask bit is 1, an image color of black (0) means that the pixel 
is transparent and an image color of white (0xF) means that the background color is inverted at the pixel location. Windows 95 and Windows NT seem to process inverted colors a little differently than Windows 3.x does&#151;the inverted pixels show up transparent against the desktop, black against a Windows Explorer window background, and white against list and tree control backgrounds. Don't ask me why.

<P>Small icons were new with Windows 95. They're used in the task bar, in Windows Explorer, and in your list and tree controls, if you want them there. If an icon doesn't have a 16-by-16-pixel bitmap, Windows manufactures a small icon out of the 32-by-32-pixel bitmap, but it won't be as neat as one you draw yourself.

<P>The graphics editor lets you create and edit icons. Look at the color palette shown here.

<P><IMG SRC="G06OG20.GIF" width=341 height=138 BORDER=0>

<P>The top square in the upper-left portion shows you the main color for brushes, shape interiors, and so on, and the square under it shows the border color for shape outlines. You select a main color by left-clicking on a color, and you select a border color by right-clicking on a color. Now look at the top center portion of the color palette. You click on the upper &quot;monitor&quot; to paint transparent pixels, which are drawn in dark cyan. You click on the lower monitor to paint inverted pixels, which are drawn in red.
</BLOCKQUOTE></DIV>


<P><B><LI>Program the list control.</B> In the dialog editor, set the list control's style attributes as shown in the next illustration.<P>

<P><IMG SRC="G06OG21.GIF" width=403 height=162 BORDER=0>

<P>Make sure the Border style on the More Styles page is set. Next add the following code to <I>OnInitDialog</I>:
<P>
<PRE><B>static char* color[] = {&quot;white&quot;, &quot;black&quot;, &quot;red&quot;,
                        &quot;blue&quot;, &quot;yellow&quot;, &quot;cyan&quot;,
                        &quot;purple&quot;, &quot;green&quot;};
CListCtrl* pList = 
    (CListCtrl*) GetDlgItem(IDC_LISTVIEW1);
pList-&gt;SetImageList(&amp;m_imageList, LVSIL_SMALL); 
for (n = 0; n &lt; 8; n++) {
    pList-&gt;InsertItem(n, color[n], n); 
}
pList-&gt;SetBkColor(RGB(0, 255, 255)); // UGLY!
pList-&gt;SetTextBkColor(RGB(0, 255, 255));</B> 
</PRE><P>
As the last two lines illustrate, you don't use the WM_CTLCOLOR message with common controls; you just call a function to set the background color. As you'll see when you run the program, however, the icons' inverse-color pixels look shabby.

<P>If you use ClassWizard to map the list control's LVN_ITEMCHANGED notification message, you'll be able to track the user's selection of items. The code in the following handler displays the selected item's text in a static control:
<P>
<PRE>void CEx06bDialog::OnItemchangedListview1(NMHDR* pNMHDR,
                                          LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    <B>CListCtrl* pList =
        (CListCtrl*) GetDlgItem(IDC_LISTVIEW1);
    int nSelected = pNMListView-&gt;iItem;
    if (nSelected &gt;= 0) {
        CString strItem = pList-&gt;GetItemText(nSelected, 0);
        SetDlgItemText(IDC_STATIC_LISTVIEW1, strItem);
    }</B> 
    *pResult = 0;
}
</PRE>
<P>The <I>NM_LISTVIEW</I> structure has a data member called <I>iItem</I> that contains the index of the selected item.

<P><B><LI>Program the tree control.</B>  In the dialog editor, set the tree 
control's style attributes as shown here.<P>

<P><IMG SRC="G06OG22.GIF" width=403 height=162 BORDER=0><P>

<P>Next, add the following lines to <I>OnInitDialog</I>:

<P><PRE><B>CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREEVIEW1);
pTree-&gt;SetImageList(&amp;m_imageList, TVSIL_NORMAL);
// tree structure common values
TV_INSERTSTRUCT tvinsert;
tvinsert.hParent = NULL;
tvinsert.hInsertAfter = TVI_LAST;
tvinsert.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE |
                     TVIF_TEXT;
tvinsert.item.hItem = NULL; 
tvinsert.item.state = 0;
tvinsert.item.stateMask = 0;
tvinsert.item.cchTextMax = 6;
tvinsert.item.iSelectedImage = 1;
tvinsert.item.cChildren = 0;
tvinsert.item.lParam = 0;
// top level
tvinsert.item.pszText = &quot;Homer&quot;;
tvinsert.item.iImage = 2;
HTREEITEM hDad = pTree-&gt;InsertItem(&amp;tvinsert);
tvinsert.item.pszText = &quot;Marge&quot;;
HTREEITEM hMom = pTree-&gt;InsertItem(&amp;tvinsert);
// second level     
tvinsert.hParent = hDad;
tvinsert.item.pszText = &quot;Bart&quot;;
tvinsert.item.iImage = 3;
pTree-&gt;InsertItem(&amp;tvinsert);
tvinsert.item.pszText = &quot;Lisa&quot;;
pTree-&gt;InsertItem(&amp;tvinsert);
// second level
tvinsert.hParent = hMom;
tvinsert.item.pszText = &quot;Bart&quot;;
tvinsert.item.iImage = 4;
pTree-&gt;InsertItem(&amp;tvinsert);
tvinsert.item.pszText = &quot;Lisa&quot;;
pTree-&gt;InsertItem(&amp;tvinsert);
tvinsert.item.pszText = &quot;Dilbert&quot;;
HTREEITEM hOther = pTree-&gt;InsertItem(&amp;tvinsert);
// third level
tvinsert.hParent = hOther;
tvinsert.item.pszText = &quot;Dogbert&quot;;
tvinsert.item.iImage = 7;
pTree-&gt;InsertItem(&amp;tvinsert);
tvinsert.item.pszText = &quot;Ratbert&quot;;
pTree-&gt;InsertItem(&amp;tvinsert);</B> 
</PRE><P>As you can see, this code sets TV_INSERTSTRUCT text and 
image indexes and calls <I>InsertItem</I> to add nodes to the tree.
<P>Finally, use ClassWizard to map the TVN_SELCHANGED 
notification for the tree control. Here is the handler code to display the 
selected text in a static control:<P>
<PRE>void CEx06bDialog::OnSelchangedTreeview1(NMHDR* pNMHDR,
                                         LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    <B>CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREEVIEW1);
    HTREEITEM hSelected = pNMTreeView-&gt;itemNew.hItem;
    if (hSelected != NULL) {
        char text[31];
        TV_ITEM item;
        item.mask = TVIF_HANDLE | TVIF_TEXT;
        item.hItem = hSelected;
        item.pszText = text;
        item.cchTextMax = 30;
        VERIFY(pTree-&gt;GetItem(&amp;item));
        SetDlgItemText(IDC_STATIC_TREEVIEW1, text);
    }</B> 
    *pResult = 0;
}
</PRE>
<P>The <I>NM_TREEVIEW</I> structure has a data member called <I>itemNew</I> that contains information about the selected node; <I>itemNew.hItem</I> is the handle of that node. The <I>GetItem</I> function retrieves the node's data, 
storing the text using a pointer supplied in the <I>TV_ITEM</I> structure. The <I>mask</I> variable tells Windows that the <I>hItem</I> handle is valid going in and that text output is desired.

<P><B><LI>Add code to the virtual <I>OnDraw</I> function in file ex06bView.cpp.</B>  
The following boldface code replaces the previous code:
<P>
<PRE>void CEx06bView::OnDraw(CDC* pDC)
{
    <B>pDC-&gt;TextOut(0, 0, &quot;Press the left mouse button here.&quot;);</B> 
}
</PRE>

<P><B><LI>Use ClassWizard to add the <I>OnLButtonDown</I> member function.</B>  
Edit the AppWizard-generated code as follows:

<P><PRE>void CEx06bView::OnLButtonDown(UINT nFlags, CPoint point)
{
    <B>CEx06bDialog dlg;

    dlg.m_nTrackbar1 = 20;
    dlg.m_nTrackbar2 = 2; // index for 8.0
    dlg.m_nProgress = 70; // write-only
    dlg.m_dSpin = 3.2;

    dlg.DoModal();</B> 
}
</PRE>
<P>Add a statement to include ex06bDialog.h in file ex06bView.cpp.

<P><B><LI>Compile and run the program.</B>  Experiment with the controls to see how they work. We haven't added code to make the progress indicator functional; we'll cover that in <A HREF="ch12a.htm">Chapter 12</A>.
</OL>

<A NAME="156"><H2>Other Windows Common Controls</H2></A><P>You've seen most of the common controls that appear on the dialog editor control palette. We've skipped the animation control because this book doesn't cover multimedia, and we've skipped the hot key control because it isn't very interesting. The tab control <U>is</U> interesting, but you seldom use it inside another dialog. <A HREF="ch13a.htm">Chapter 13</A> shows you how to construct a tabbed dialog, sometimes known as a property sheet. In <A HREF="ch13a.htm">Chapter 13</A>, you'll also see an application that is built around the <I>CRichEditView</I> class, which incorporates the Windows rich edit control.
</BODY>
</HTML>



