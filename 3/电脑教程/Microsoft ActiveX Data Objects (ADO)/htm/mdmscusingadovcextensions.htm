<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=GB_2312-80">
<title>使用 ADO VC++ Extensions</title>
<style>@import url(/stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<h2><a name="mdmscusingadovcextensions"></a>使用 ADO VC++ Extensions</h2>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:请参阅">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mdmscUsingADOVCExtensions_C">
</object></p>
<p>
<b>定义绑定条目</b></p>
<p>
ADO VC++ Extensions 可将 <b>Recordset </b>对象的字段映射到 C/C++ 变量，对字段与变量之间映射关系的定义称为“绑定条目”。预处理宏用来定义数值、定长和变长变量的绑定条目。</p>
<p>
将 <b>BEGIN_ADO_BINDING </b>和 <b>END_ADO_BINDING </b>宏之间的绑定条目用括号括起。不要在绑定条目结尾使用逗号或分号，这些定界符仅限在宏中使用。</p>
<p>
为每个将被转换为 C/C++ 变量的字段指定一个绑定条目。使用适当的 <b>ADO_FIXED_LENGTH_BINDING_ENTRY</b>、<b>ADO_NUMERIC_BINDING_ENTRY </b>或 <b>ADO_VARIABLE_LENGTH_BINDING_ENTRY</b> 宏。</p>
<p>
在宏的参数中，用序数指定将被提出的 <b>Recordset </b>字段 ― 0 标识第一字段，1 标识第二字段，依此类推。</p>
<p>
使用数据类型声明 C/C++ 变量。如果变量为数值，也可指定精度和范围。如果变量为变长变量（如字符串），则必须以字节指定变量的最大尺寸。如果需要，<b>Recordset </b>字段值可被强制为该数据类型。</p>
<p>
指定临时的工作缓冲区，用来将字段值从 VARIANT 转换为 C/C++ 变量。缓冲区应至少与此 C/C++ 变量一样大。</p>
<p>
将布尔型修改参数设置为 TRUE 使 ADO 可更新绑定的字段，如只检查字段而不将其更改，可设置为 FALSE。VC++ Extensions 不保留有关字段的状态信息，因此必须指定 ADO 是否更改字段值（例如，由数据源保留的自动增值字段的值）。因此该字段的修改参数应设置为 FALSE。</p>
<p>
状态参数可告诉您从 <b>Recordset</b> 字段到 C 或 C++ 变量的转换是否成功以及变量的内容是否有效。该参数的两个最重要的值是 <b>adFldOK</b> （意味着转换成功）和 <b>adFldNull</b> （意味着字段是 NULL―无值可供转换）。</p>
<p>
首先检测该参数以决定 C 或 C++ 变量是否有效。例如，如果字段具有有效的行内容，状态将会是 <b>adFldOK</b>；如果移动到另一个字段为 NULL 的行，状态则将是 <b>adFldNull</b>。然而，C 或 C++ 变量的内容将不被更改 ― 该变量将仍然包含上一行的字段值。</p>
<p>
<b>将 Recordset 绑定到变量</b></p>
<p>
在应用程序中，调用 <b>BindToRecordset </b>接口方法可使 <b>Recordset </b>字段关联（或绑定）到 C/C++ 变量，无论何时更改 <b>Recordset </b>对象的当前行，C/C++ 变量都将自动更新。</p>
<p class=label>
<b>头文件</b></p>
<p>
要使用 VC++ Extensions，请在应用程序中包含如下文件： 
<ul type=disc>
<li>
#include &lt;icrsint.h&gt;</li>
</ul>
<p class=label>
<b>接口方法</b></p>
<p>
<b>IADORecordBinding</b> 接口具有使 <b>Recordset</b> 字段与 C/C++ 变量关联、添加新行和执行更新的方法。所有这三个方法都可使指针指向由 <b>CADORecordBinding</b> 派生的类，该 <b>CADORecordBinding</b> 定义每个字段和变量之间的绑定。</p>
<p>
接口方法是：
<ul type=disc>
<li>
<b>BindToRecordset</b>(<i>&amp;binding</i>)</li>
</ul>
<p>
调用该方法可使变量与字段相关联。 
<ul type=disc>
<li>
<b>AddNew</b>(&amp;<i>binding</i>)</li>
</ul>
<p>
调用该方法可间接调用 ADO <b>AddNew </b>方法。 
<ul type=disc>
<li>
<b>Update</b>(&amp;<i>binding</i>)</li>
</ul>
<p>
调用该方法可间接调用 ADO <b>Update</b> 方法。</p>
<p class=label>
<b>预处理宏 </b>
<ul type=disc>
<li>
BEGIN_ADO_BINDING(<i>cls</i>)<br><br></li>
<li>
ADO_FIXED_LENGTH_BINDING_ENTRY(<i>Ordinal</i>, <i>DataType</i>, <i>Buffer</i>, <i>Status</i>, <i>Modify</i>)<br><br></li>
<li>
ADO_NUMERIC_BINDING_ENTRY(<i>Ordinal</i>, <i>DataType</i>, <i>Buffer</i>, <i>Precision</i>, <i>Scale</i>, <br>
<i>Status</i>, <i>Modify</i>)<br><br></li>
<li>
ADO_VARIABLE_LENGTH_BINDING_ENTRY(<i>Ordinal</i>, <i>DataType</i>, <i>Buffer</i>, <i>Size</i>, <br>
<i>Status</i>, <i>Modify</i>)<br><br></li>
<li>
END_ADO_BINDING() </li>
</ul>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=23%><b>参数</b></td>
<td class=label width=77%><b>说明</b></td>
</tr>
<tr valign=top>
<td width=23%><i>cls</i></td>
<td width=77%>类，定义绑定条目，缓冲区，和 <b>Recordset </b>对象。</td>
</tr>
<tr valign=top>
<td width=23%><i>Ordinal</i></td>
<td width=77%>按顺序的字段号码，0 标识第一字段，1 标识第二字段，依此类推。</td>
</tr>
<tr valign=top>
<td width=23%><i>DataType</i></td>
<td width=77%>储存已转换字段的变量的数据类型。</td>
</tr>
<tr valign=top>
<td width=23%><i>Buffer</i></td>
<td width=77%>缓冲区，用于将字段转换为变量。</td>
</tr>
<tr valign=top>
<td width=23%><i>Status</i></td>
<td width=77%>指示字段转换是否成功。</td>
</tr>
<tr valign=top>
<td width=23%><i>Modify</i></td>
<td width=77%>布尔标志；如果为 TRUE，则表明 ADO 可以更新关联的字段。</td>
</tr>
<tr valign=top>
<td width=23%><i>Precision</i></td>
<td width=77%>在数值变量中可被表现出的数字位数。</td>
</tr>
<tr valign=top>
<td width=23%><i>Scale</i></td>
<td width=77%>位于数值变量中的小数点后的位数。</td>
</tr>
<tr valign=top>
<td width=23%><i>Size</i></td>
<td width=77%>变长变量所需的字节数，诸如：字符串。</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>状态参数值</b></td>
<td class=label width=62%><b>说明</b></td>
</tr>
<tr valign=top>
<td width=38%><b>adFldOK</b></td>
<td width=62%>返回非 NULL 字段值。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldBadAccessor</b></td>
<td width=62%>绑定无效。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldCantConvertValue</b></td>
<td width=62%>由于符号不匹配和数据溢出以外的原因，值不能转换。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldNull</b></td>
<td width=62%>返回 NULL。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldTruncated</b></td>
<td width=62%>变长数据或数值型数字被截短。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldSignMismatch</b></td>
<td width=62%>值有符号，而变量数据类型无符号。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldDataOverFlow</b></td>
<td width=62%>值大于在变量数据类型中的存储大小。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldCantCreate</b></td>
<td width=62%>已打开未知列类型和字段。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldUnavailable</b></td>
<td width=62%>无法确定字段值 ― 例如在无默认值的新建、未指定的字段中。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldPermissionDenied</b></td>
<td width=62%>更新时，不允许写入数据。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldIntegrityViolation</b></td>
<td width=62%>更新时，字段值将破坏列的完整性。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldSchemaViolation</b></td>
<td width=62%>更新时，字段值将破坏列模式。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldBadStatus</b></td>
<td width=62%>更新时，无效的状态参数。</td>
</tr>
<tr valign=top>
<td width=38%><b>adFldDefault</b></td>
<td width=62%>更新时，使用了默认值。</td>
</tr>
</table><br>
</BODY>
</HTML>
