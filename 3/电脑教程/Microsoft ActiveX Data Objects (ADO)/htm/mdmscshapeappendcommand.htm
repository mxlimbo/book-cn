<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=GB_2312-80">
<title>Shape Append 命令</title>
<style>@import url(/stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<h2><a name="mdmscshapeappendcommand"></a>Shape Append 命令</h2>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:请参阅">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mdmscShapeAppendCommand_C">
</object></p>
<p>
Shape APPEND 命令将子 <b>Recordset </b>分配给父 <b>Recordset </b>中 <b>Field </b>对象的 <b>Value </b>属性。 </p>
<p class=label>
<b>语法</b></p>
<p>
SHAPE <b>{</b><i>parent-command</i><b>}</b> [[AS] <i>parent-alias</i>]</p>
<p>
APPEND <b>({</b><i>child-command</i><b>}</b> [AS] <i>child-alias</i></p>
<p>
RELATE <i>parent-column</i> TO <i>child-column</i><b>...)</b> [[AS] <i>chapter-alias</i>] <b>...</b></p>
<p class=label>
<b>组成说明</b></p>
<p>
该命令的组成部分为：</p>
<p>
<i>parent-command</i>, <i>child-command</i>&nbsp;&nbsp;&nbsp;如下之一。
<ul type=disc>
<li>
在尖括号（“<b>{}</b>”）中的查询命令，返回 <b>Recordset</b> 对象。命令发布给基本数据提供者，其语法取决于该提供者的要求。虽然 ADO 并不要求使用任何指定的查询语言，但通常是使用结构化查询语言 (SQL)。圆括号（“<b>()</b>”）是必需的关键字，它们将子集列追加到引用由查询命令返回的 <b>Recordset</b> 的父。<br><br></li>
<li>
以前成形的 <b>Recordset</b> 的名称。<br><br></li>
<li>
另一个 Shape 命令。<br><br></li>
<li>
TABLE 关键字，后跟表的名称。</li>
</ul>
<p>
<i>parent-column</i>&nbsp;&nbsp;&nbsp;由 <i>parent-command </i>返回的 <b>Recordset</b> 中的列。</p>
<p>
<i>child-column</i>&nbsp;&nbsp;&nbsp;由 <i>child-command</i> 返回的 <b>Recordset</b> 中的列。</p>
<p>
<b>...</b>&nbsp;&nbsp;&nbsp;“<i>parent-column </i><b>TO</b> <i>child-column</i>”子句实际上是列表，并用逗号将每个定义关系分隔开<i>。</i></p>
<p>
<i>chapter-alias</i>&nbsp;&nbsp;&nbsp;别名，对追加到父的列的引用。</p>
<p>
<i>parent-alias</i>&nbsp;&nbsp;&nbsp;别名，对父 <b>Recordset </b>的引用。</p>
<p>
<i>child-alias</i>&nbsp;&nbsp;&nbsp;别名，对子 <b>Recordset </b>的引用。</p>
<p>
<b>...</b>&nbsp;&nbsp;&nbsp;在 APPEND 关键字后面的子句实际上是列表（每个子句使用逗号分隔），定义被追加到父的另一个列。</p>
<p class=label>
<b>操作</b></p>
<p>
发出 <i>parent-command</i> 并返回父 <b>Recordset</b>。然后发出 <i>child-command</i> 并返回子 <b>Recordset</b>。</p>
<p>
例如，<i>parent-command</i> 可以从客户表返回公司的客户 <b>Recordset</b>，而 <i>child-command</i> 从定货表返回所有客户的定单 <b>Recordset</b>。</p>
<p>
一般，父和子 <b>Recordset</b> 对象必须各自拥有用于关联父和子的列。列在 <b>RELATE</b> 子句中命名，<i>parent-column</i> 在先，<i>child-column</i> 在后。在各自的 <b>Recordset </b>中，列可以有不同名称，但必须引用相同信息以便指定有意义的关系。例如，<b><i>Customers</i></b> 和 <b><i>Orders</i></b> <b>Recordsets</b> 可以同时拥有 <b><i>customerID</i></b> 字段。</p>
<p>
数据构形将子集列追加到父 <b>Recordset</b>。子集列中的值是对子 <b>Recordset </b>中列的引用，子 <b>Recordset </b>满足 <b>RELATE</b> 子句。即在给定父行中的 <i>parent-column</i> 与在子集子的所有行中的 <i>child-column </i>具有相同的值。</p>
<p>
当您访问在子集列中的引用时，ADO 将自动检索由引用表示的 <b>Recordset</b>。注意尽管已经检索了全部子 <b>Recordset</b>，但子集（<i>chapter</i>）仅表示行的子集。</p>
<p>
如果追加的列没有 <i>chapter-alias</i>，则会自动生成其名称。列的 <b>Field</b> 对象将被追加到 <b>Recordset</b> 对象的 <b>Fields</b> 集合，其数据类型将是 <b>adChapter</b>。</p>
<p>
有关定位分级 <b>Recordset </b>的详细信息，请参阅<a href="mdmscaccessingrowsinhierarchicalrecordset.htm">访问分级 Recordset 中的行</a>。</p>
<p class=label>
<b>参数化命令</b></p>
<p>
如果您正在处理大的子 <b>Recordset</b>（尤其是比父 <b>Recordset </b>大），却只需要访问部分子子集，那么，使用参数化命令会更有效。</p>
<p>
<i>non-parameterized command</i>（非参数化命令）同时检索整个父和子 <b>Recordsets</b>，并将子集列追加到父，然后为每个父行指定相关子子集的引用。</p>
<p>
<i>parameterized command</i>（参数化命令）检索整个父 <b>Recordset</b>，但在访问子集列时仅检索子集 <b>Recordset</b>。这种检索策略的差别可以有益的性能好处。</p>
<p>
例如，可以指定如下：</p>
<pre>"SHAPE {SELECT * FROM customer} 
APPEND ({SELECT * FROM orders WHERE cust_id = ?} 
RELATE cust_id TO PARAMETER 0)"
</pre>
<p>
父和子表通常拥有列名 <i>cust_id</i>。<i>child-command</i> 有占位符（即“？”），受 <b>RELATE</b> 子句引用（即“...PARAMETER 0”）。关系在于显性标识的 <b>customer</b> 表 <i>parent-column（即</i> <b>cust_id</b>）和隐性标识的 <b>orders</b> 表 <i>child-column</i>（即 <b>cust_id</b>）之间，由占位符和“PARAMETER 0”指定。</p>
<p class=indent>
<B><b>注意&nbsp;&nbsp;&nbsp;</b></B>PARAMETER 子句仅属于 Shape 命令语法。与 ADO <b>Parameter</b> 属性和 <b>Parameters</b> 集合均无关联。</p>
<p>
在执行 Shape 命令时，发生如下情形：
<ol>
<li>
执行 <i>parent-command</i>，并返回 <b>customer</b> 表的父 <b>Recordset</b>。<br><br></li>
<li>
子集列被追加到父 <b>Recordset</b>。<br><br></li>
<li>
在访问父行的子集列时，<b>customer.cust_id</b> 列的值将替换 <b>orders.cust_id </b>的占位符，并执行 <i>child-command</i>。<br><br></li>
<li>
<b>orders</b> 表（在此，<b>orders.cust_id</b> 列的值与 <b>customer.cust_id</b> 列的值相匹配）的所有行被检索。<br><br></li>
<li>
对检索到的子行（即子 <b>Recordset</b> 的 <i>chapter</i>）的引用被放置在父 <b>Recordset</b> 当前行的子集列。<br><br></li>
<li>
当访问另一个行的子集列时，重复步骤 3-5。</li>
</ol>
<p class=label>
<b>插入 Shape <i>COMPUTE</i> 命令</b></p>
<p>
现在将参数化 Shape 命令的参数化命令嵌入任意嵌套数量的形状 <i>COMPUTE</i> 命令中是有效的。例如：</p>
<pre>SHAPE {select au_lname, state from authors} APPEND 
((SHAPE 
(SHAPE 
{select * from authors where state = ?} rs 
COMPUTE rs, ANY(rs.state) state, ANY(rs.au_lname) au_lname 
BY au_id) rs2 
COMPUTE rs2, ANY(rs2.state) BY au_lname) 
RELATE state TO PARAMETER 0)</pre>
</BODY>
</HTML>
