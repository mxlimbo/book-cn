<HTML>
<HEAD>
<TITLE>Microsoft Data Access Components (MDAC)</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09c.htm", "ch09e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="466"><H1>Microsoft Data Access Components (MDAC)</H1></A>

<p>After completing application design, developers should have access
to conceptual design documents that contain a sufficient model of
needed data objects. Additionally, the project team will presumably
have defined several specific data and data connectivity requirements.
With these requirements, the team should 
be able to approximate how these objects will be grouped into
components. As developers attempt to implement these components, they
should keep the following key design points regarding data objects in
mind:</p>

<ul>
<p><li> Accuracy, completeness, and consistency of data rely on the data
objects that own such data.</li></p>

<p><li> Data objects should operate correctly whether or not the
objects' callers are transactional.</li></p>

<p><li> Developers should carefully consider how their data objects are
to be used, and also consider the expense of data access before
retaining state across method calls. This point is particularly
important, as data objects can not retain state across transaction
boundaries.</li></p>

<p><li> The fewer network round-trips required to use a data object, the
better&#8212;data objects should thus be network-friendly. Additionally,
typically the fewer round-trips the better the application
performance.</li></p>
</ul>



<p>Every data store provides a native access method. Each database
vendor provides a vendor-specific API to ease database access. As
mentioned, non-DBMS data can be accessed through data-specific APIs,
such as the Windows NT 
Directory Service API or MAPI, for accessing mail data, or via file
system 
APIs. By using the native access method for each data store, developers
can use each store's full power. However, such technique requires
developers to learn how to use each access method. Furthermore,
developers must understand the API functions and their most efficient
uses, and also learn how to use diagnostic and configuration tools
associated with data stores. The project team should be aware that
costs of training developers on all data access APIs used within an
organization can be high.</p>

<p>Distributed application developers face two fundamental technical
challenges related to data access. First, developers rarely have the
opportunity to start from the beginning, regarding data access. Most
applications need to access existing data, which can be stored in a
variety of formats. For instance, some of this information could be
stored in DBMSs; other data could be stored in less structured forms.
Many DBMSs are on the market, including mainframe databases such as
Information Management Systems (IMS) and DB2, 
server databases such as Oracle and SQL Server, and desktop databases
such as Microsoft Access and Paradox. It is possible for multiple DBMSs
to be in use with a single application. Non-DBMS data can be stored in
text files, indexed sequential access method (ISAM) files,
spreadsheets, e-mail messages, or any application-specific file.
Somehow, distributed application developers must integrate such
disparate data sources into a unified view for application users.</p>

<p>A second challenge related to data access is that distributed
applications naturally involve accessing remote data sources. In most
cases, users implementing applications to examine data are working on
different computers than the computers on which data is stored.
Therefore, it's important that efficient mechanisms for accessing
remote data are in place, to minimize network traffic generated by
applications. This point becomes increasingly critical as applications
scale to reach thousands or millions of users, many connected to
computers through relatively expensive network bandwidth over wide area
network (WAN) connections or throughput constrained modem
connections.</p>

<p>MDAC components are:</p>

<ul>
<p><li> <b>ADO</b> Application-level programming interface to data.</li></p>

<p><li> <b>Remote Data Service (RDS)</b> Client-side caching engine;
formerly known as Advanced Data Connector (ADC).</li></p>

<p><li> <b>Microsoft OLE DB provider for ODBC</b> Access provider for ODBC
databases, via OLE DB.</li></p>

<p><li> <b>ODBC driver manager</b> The DLL that implements the ODBC API
and directs calls to the appropriate ODBC drivers.</li></p>

<p><li> <b>ODBC drivers</b> Database drivers for SQL Server, Access, and
Oracle.</li></p>
</ul>



<A NAME="467"><H2>Open Database Connectivity (ODBC)</H2></A>

<p>Instead of using native data access methods, developers can choose
to use a generic, vendor-neutral API such as the Microsoft ODBC
interface. ODBC is a C programming language interface for accessing
data in a DBMS using SQL. An ODBC driver manager provides the
programming interface and run-time components developers need to locate
DBMS-specific drivers. The DBMS vendor typically supplies ODBC drivers.
These drivers translate generic calls from the ODBC driver manager into
calls to the native data access method.</p>

<p>The primary advantage of using ODBC is that developers need to learn
only one API to access a wide range of DBMSs. Applications can access
data from multiple DBMSs simultaneously. In fact, application
developers do not need to target a specific DBMS&#8212;the exact DBMS to
be used can be decided upon application deployment.</p>

<p>Unfortunately, there are several drawbacks to the ODBC approach.
First, an ODBC driver must be present for every data store developers
want to access. These drivers must support SQL queries, even if the
database does not use SQL for its native query language. Second, the
ODBC API treats all data in the form of relational tables. Both
constraints can cause problems for unstructured and non-relational data
stores. Finally, the ODBC API is a standard, controlled by a committee.
In other words, regardless of the underlying DBMS's capabilities,
the ODBC driver can expose only functionality that is part of the
standard. Modifying the API is a complex process. The committee must
agree to the proposed change, specify how ODBC drivers should implement
the proposed function(s), and specify how applications or the driver
manager can detect whether a given driver supports the new
specification. Drivers must be updated, and applications must ensure
that new drivers are installed or that applications are written
carefully against older drivers.</p>

<p>In practice, ODBC is a widely used mechanism for database access and
an appropriate solution for applications that work only with
traditional relational databases. Most major DBMS vendors support ODBC.
However, as applications move beyond relational DBMSs (RDBMS), a more
comprehensive solution is needed.</p>

<A NAME="468"><H2>OLE DB</H2></A>

<p>OLE DB specifies a set of COM interfaces for data management. These
interfaces are defined so that data providers can implement different
support levels, based on underlying data store capabilities. Because
OLE DB is COM-based, it can easily be extended; resulting extensions
are implemented as new interfaces. Clients can use the standard COM <b>
QueryInterface</b>  method to determine whether specific features are
supported either on a particular computer, or by a particular data
store. This capability improves upon function-based APIs defined by
ODBC.</p>

<p>Figure 9.3 shows the high-level OLE DB architecture, which consists
of three major elements: data consumers, service components, and data
providers.</p>

<P><A HREF="javascript:fullSize('f09ar03x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f09ar03.jpg" WIDTH=404 HEIGHT=477 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 9.3</b> <i> OLE DB architecture</i><!-- /caption --></P>

<p><i>Data consumers</i> are COM components that access data using OLE
DB providers. OLE DB service providers are COM components that
encapsulate a specialized data management function, such as query
processing, cursor management, or transaction management. OLE DB is
designed so that these service components can be implemented
independently from data providers, which are in turn delivered as
stand-alone products and plugged in as needed. For example, sim-ple
data providers may provide a way only to retrieve&#8212;but not query,
sort, or filter&#8212;all information from its data source.</p>

<p>A <i>service component</i> may implement SQL query processing for
any data provider. If a consumer wanted to perform a SQL query on data
from a simple data provider, the service component could then execute
the query.</p>

<p>OLE DB <i>data providers</i> are COM components responsible for
providing information from data stores to the outside world. With the
use of this procedure, all data is exposed in the form of virtual
tables, or rowsets. Internally, providers will make calls to an
underlying data store using its native data access method or a generic
API, such as ODBC.</p>

<p>The OLE DB object model consists of seven core components, shown in
Figure 9.4. These objects are implemented by data providers or service
components and used by data consumers.</p>

<P><A HREF="javascript:fullSize('f09ar04x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f09ar04.jpg" WIDTH=404 HEIGHT=246 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 9.4</b> <i> OLE DB object model</i><!-- /caption --></P>

<p>In the OLE DB object model, an <b>Enumerator</b>  object locates a
data source. Data consumers that aren't accustomed to a specific
data source use an <b>Enumerator</b>  object to retrieve a list of names
of available data sources and subordinate <b>Enumerator</b>  objects.
For example, in a file system, each file could correspond to a data
source and each subdirectory could correspond to a subordinate <b>
Enumerator</b>  object. The data consumer searches the list of names for
a data source to use, moving through the subordinate <b>Enumerator</b> 
objects as necessary. Once a data source is selected by name, a <b>Data
Source</b>  object can be created.</p>

<p>A <b>Data Source</b>  object knows how to connect to a data store
type, such as a file or a DBMS. Each OLE DB provider implements a <b>
Data Source</b>  component class with a unique CLSID. A data consumer
can either create a specific Data Source directly, by calling <b>
CoCreateInstance</b>, using the Data Source's CLSID, or it can use
an <b>Enumerator</b>  object to search for a data source to use.
Although each <b>Data Source</b>  class has a unique CLSID, all classes
are required to expose a certain set of OLE DB interfaces. This
requirement is important, as a consumer can standardize the use of any
available data source. Data consumers specify the name of the data
source to which they want to connect, as well as provide any
authentication information, through the <b>Data Source</b>  object. Once
a <b>Data Source</b>  object is created, it can reveal the underlying
data provider's capabilities.</p>

<p>Developers create <b>Session</b>  objects using a <b>Data Source</b> 
object. A <b>Session</b>  represents a particular connection to a data
source. A <b>Session</b>  object's primary function is to define
transaction boundaries. <b>Session</b>  objects are also responsible for
creating <b>Command</b>  and <b>Rowset</b>  objects, which are the
primary objects for which to access data through OLE DB. A <b>Data
Source</b>  object can be associated with multiple <b>Session</b> 
objects.</p>

<p>If an OLE DB provider supports queries, it must implement <b>
Command</b>  objects. <b>Command</b>  objects are generated by <b>
Session</b>  objects, and are responsible for preparing and executing
text commands. Multiple <b>Command</b>  objects can be associated with a
single <b>Session</b>  object. Developers should keep in mind that OLE
DB doesn't distinguish among command languages used; <b>Command</b> 
objects must simply understand commands and translate them into calls
to the underlying data provider when the commands are executed.</p>

<p>Commands that return data create <b>Rowset</b>  objects. <b>
Rowset</b>  objects can also be created directly by <b>Session</b> 
objects. A <b>Rowset</b>  simply represents tabular data. <b>Rowsets</b> 
are used extensively by OLE DB. All <b>Rowsets</b>  are required to
implement a core set of OLE DB interfaces. These interfaces allow
consumers to sequentially traverse the rows in the <b>Rowset</b>, get
information about <b>Rowset</b>  columns, bind <b>Rowset</b>  columns to
data variables, and get information about the <b>Rowset</b>  as a whole.
Implementing additional OLE DB interfaces supports additional features,
such as updating the <b>Rowset</b>  object or accessing specific rows
directly.</p>

<p>The OLE DB object model also includes an <b>Error</b>  object. Any
other OLE DB object can create error objects. They contain rich error
information that can not be conveyed through the simple HRESULT
returned by COM methods. OLE DB <b>Error</b>  objects build on a
standard error-handling mechanism, <b>IErrorInfo</b>, defined by
Automation. OLE DB extends this error-handling mechanism to permit
multiple error records that a single call returns, and also to permit
providers to return provider-specific error messages.</p>

<p>The OLE DB object model provides a powerful, flexible mechanism for
consumers to access any data type uniformly. OLE DB defines a rich,
component-based model that lets data providers implement as much
functionality as the providers are able to support, including
sequential access, simple rowsets, and full DBMS functionality. This
model gives developers the option of writing generic data access
components that use only the most basic functionality. Using this
model, developers may also write components (optimized for a specific
DBMS) that use a single programming model.</p>

<A NAME="469"><H2>ActiveX Data Objects (ADO)</H2></A>

<p>The OLE DB object model exposes functionality through COM interfaces
that are not Automation compatible, which means that OLE DB cannot be
used directly from many programming languages and tools, such as
Microsoft Active Server Pages. Thus, UDA also defines the
application-level programming interface ADO. All ADO interfaces are
dual interfaces, so any COM-aware programming language or tool can use
them. ADO is the recommended way to access data stores in multi-service
layer applications, also commonly referred to as Microsoft Windows DNA
applications.</p>

<A NAME="470"><H3>ADO Object Model</H3></A>

<p>The ADO object model is shown in Figure 9.5. ADO is built on top of
OLE DB, so developers will see many similarities to the OLE DB object
model. ADO was also designed to be familiar to developers who have used
earlier Microsoft data access object models such as DAO and RDO. Unlike
DAO and RDO, the ADO object model is not hierarchical. Except for <b>
Error</b>  and <b>Field</b>  objects, all objects can be created
independently, making it easy to reuse objects in different contexts.
Creating objects independently also allows for several ways to
accomplish a particular programming task.</p>

<P><A HREF="javascript:fullSize('f09ar05x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f09ar05.jpg" WIDTH=404 HEIGHT=215 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 9.5</b> <i> ADO object model</i><!-- /caption --></P>

<p><div class="note"><blockquote><b>NOTE</b><hr> Microsoft has introduced several object models
for data access over the years. DAO consists of Automation objects for
accessing the Microsoft Jet database engine used by Access as well as
ISAM and ODBC databases. RDO consists of Automation objects for
accessing relational ODBC data sources. These technologies are
supported &quot;in-the-box&quot; by Visual Basic 5.0. However, while
these technologies will continue to be supported, future development
efforts should focus on ADO.</blockquote></div>
</p>

<p>The <b>Connection</b>  object represents a unique session to a data
store. The <b>Connection</b>  object is essentially a combination of the
<b>Data Source</b>  and <b>Session</b>  objects in OLE DB. <b>
Connection</b>  objects expose an <b>Execute</b>  method that lets
developers perform simple tasks with a minimal amount of effort.
Alternatively, <b>Connection</b>  objects can be attached to <b>
Command</b>  and <b>Recordset</b>  objects, which also offer methods to
access data from the data store.</p>

<p><b>Command</b>  objects in ADO are equivalent to OLE DB <b>
Command</b>  objects&#8212;both provide a means to prepare and execute
parameterized commands against the data source. Preparing a command
lets developers save a processed form of the command that can be
executed quickly. A <b>Command</b>  object has a <b>Parameters</b> 
collection, which contains one or more <b>Parameter</b>  objects, each
representing a command-specific parameter. ADO <b>Command</b>  objects
are available only when the underlying OLE DB provider implements OLE
DB <b>Command</b>  objects.</p>

<p><b>Recordset</b>  objects are the basis of ADO. Like OLE DB <b>
Rowset</b>  objects, they represent tabular data from a data source. <b>
Connection</b>  and <b>Command</b>  methods that return data from the
data store return read-only <b>Recordset</b>  objects that can be
accessed sequentially. More flexible <b>Recordset</b>  objects can be
created directly by programmers, connected to <b>Connection</b>  and
(optionally) <b>Command</b>  objects, and populated by calling various
<b>Recordset</b>  methods. <b>Recordset</b>  objects support a variety of
options for controlling the amount of data retrieved from a data source
at a given time. Other available options control the type and duration
of locks placed on the underlying data source, and also specify when
updates are applied to the data store.</p>

<p>Although <b>Recordset</b>  object refers to the overall construct of
a set of rows and columns. At a granular level, a <b>Recordset</b> 
refers to a set of columns associated with a specific row, which is
also the current row. Individual columns of the <b>Recordset</b>  are
accessed through its <b>Fields</b>  collection, with one <b>Field</b> 
object for every column. Associated with every <b>Recordset</b>  object
is a cursor. In database terms, a cursor is the software that returns
rows of data to an application. The cursor in a <b>Recordset</b>  object
indicates the current position in the <b>Recordset</b>  and determines
what row will be returned next. ADO supports several cursor types,
ranging from simple forward-only cursors, to cursors that let
developers move to any row, to cursors that let developers view changes
made by other users as developers move through the <b>Recordset</b> 
object.</p>

<A NAME="471"><H3>Programming with ADO</H3></A>

<p>The ADO object model contains the seven objects listed in Table
9.6.</p>

<p><b>Table 9.6</b> <i>Objects contained in the ADO object model</i></p>
<p><table cellpadding=5 width="95%"><tr>
<th>Object</th><th>Description</th>
</tr><tr>
<td valign="top"><b>Connection</b></td> <td valign="top"> Manages a connection to a data source.</td>
</tr><tr>
<td valign="top"><b>Command</b></td> <td valign="top"> Defines a specific command to execute against a data source.</td>
</tr><tr>
<td valign="top"><b>Recordset</b></td> <td valign="top"> Represents a set of records from a data source or the results of an executed command.</td>
</tr><tr>
<td valign="top"><b>Field</b></td>  <td valign="top">Represents a column of data with a common data type. A
<b>Recordset</b>  object has a <b>Fields</b>  collection, with one <b>
Field</b>  object per column in the <b>Recordset</b>.</td>
</tr><tr>
<td valign="top"><b>Parameter</b></td>  <td valign="top">Represents a parameter associated with a <b>
Command</b>  object based on a parameterized query or stored procedure.
A <b>Command</b>  object has a <b>Parameters</b>  collection, with one
<b>Parameter</b>  object per command parameter.</td>
</tr><tr>
<td valign="top"><b>Property</b></td>  <td valign="top">Represents a dynamic characteristic of an ADO object
defined by the OLE DB provider. <b>Connection</b>, <b>Command</b>, <b>
Recordset</b>, and <b>Field</b>  objects have <b>Properties</b> 
collections, with one <b>Property</b>  object per dynamically defined
characteristic.</td>
</tr><tr>
<td valign="top"><b>Error</b></td>  <td valign="top">Contains details about data access errors for a single
operation. A <b>Connection</b>  object has an <b>Errors</b>  collection,
with one <b>Error</b>  object per OLE DB provider error.</td>
</tr></table></p>

<A NAME="472"><H3>Connections</H3></A>

<p>Developers use a <b>Connection</b>  object to set up a connection
with a data source. When the object is used with an ODBC data source,
developers establish a connection by passing either a data source name
(DSN), user ID, and password or a DSN filename to the <b>Connection</b> 
object's <b>Open</b>  method.</p>

<p>Data objects should generally access data sources using a fixed
identity, rather than using the client's identity. This technique
greatly simplifies administration and makes it possible to efficiently
pool database connections across multiple client requests. If
developers need to restrict access to a database, they can restrict
access to business objects with which clients interact, or to the data
objects themselves.</p>

<p>The most straightforward and flexible way to specify parameters for
the <b>Connection</b>  object's <b>Open</b>  method is to include a
DSN filename in development source code and then specify the data
source, user ID, and password in the DSN file. This technique lets a
system administrator modify the data source or account access
information without requiring source code changes to components.</p>

<p>The <b>Connection</b>  object specifies the type of database access
desired by the developer. Developers would use the <b>Mode</b>  property
to indicate a read-only, write-only, or read/write connection, and also
the type of sharing to be permitted so the team's database will be
protected. Developers must set the <b>Mode</b>  property before opening
a connection.</p>

<p>Typically, developers open a connection immediately before accessing
the database, then subsequently close this connection as soon as
possible, rather than retain a connection for an object's lifetime.
This approach is acceptable despite the expense of creating database
connections, because the ODBC 3.0 driver manager contains exceptional
connection pooling services. For each connection request, the driver
manager first examines the pool for an acceptable unused connection. If
it finds a connection, the driver manager returns it; otherwise, the
manager creates a new connection. If the connection remains idle for a
specified period (by default, 60 seconds), the connections driver
manager disconnects it from the database and removes it from the pool.
Currently, only free memory and the number of database connections
available limit the ODBC connection pool size. The only alternative for
controlling the pool size is to set the ODBC pooling time-out value
based on an estimated connection rate.</p>

<p>The driver manager does not reuse a connection that was established
using a different user identity. Developers thus should connect to
databases using a fixed identity within their data objects. If
developers use the client's identity, every unique client will
require a unique database connection, eliminating a key scalability
benefit of three-service layer architecture and Microsoft Transaction
Server (MTS). Developers also can not reuse connections across process
boundaries. As we discussed in <A HREF="ch08a.htm">Chapter 8</A>, components that access the
same data sources should run within the same process so that
connections can be reused.</p>

<p>If developers examine <b>Connection</b>  object methods in the ADO
documentation, the <b>BeginTrans</b>, <b>CommitTrans</b>, and <b>
RollbackTrans</b>  methods, related to transaction processing, will
occur. Components running in the MTS environment should never use these
three methods. Instead, developers should let MTS manage transactions
through <b>ObjectContext</b>  and use the <b>ObjectContext</b>, <b>
SetComplete</b>, and <b>SetAbort</b>  methods to elicit the transaction
outcome.</p>

<A NAME="473"><H3>Accessing Data</H3></A>

<p>Using ADO, data can be accessed using three elements: the <b>
Connection Execute</b> method as well as the <b>Command</b> and <b>
Recordset</b> objects. Developers can use the <b>Connection Execute</b> 
method to execute a specified command against a data source. When used
with an ODBC data source, commands can be SQL statements or
nonparameterized stored procedures. Any results are returned as a
Recordset object with a read-only, forward-only cursor. We'll
discuss cursors in more detail in the &quot;Recordset Objects&quot;
section below.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> Stored procedures can provide a great
performance boost, especially for complex data access operations.
However, developers should use stored procedures only for data access.
Business logic should be implemented in business objects.</blockquote></div>
</p>

<p>Developers can use <b>Command</b>  objects to execute parameterized
stored procedures and commands or to save a compiled version of a
command that will be executed multiple times. Developers also establish
a connection to a data source by setting the <b>Command
ActiveConnection</b>  property. Developers should specify such a command
using the <b>CommandText</b>  property, and execute this command using
the <b>Execute</b>  method. Any results are returned as a Recordset with
a read-only, forward-only cursor. If developers have a parameterized
command, they should specify such parameters in the <b>Command</b> 
object's <b>Parameters</b>  collection. To compile a command for
speedy reuse, developers set the <b>Prepared</b>  property.</p>

<p>Finally, developers can manipulate data directly using <b>
Recordset</b>  objects. Creating a <b>Recordset</b>  object and using its
methods directly is the most flexible way to manipulate data.</p>

<A NAME="474"><H3>Recordset Objects</H3></A>

<p>When developers use ADO, they will almost always manipulate data
exclusively through <b>Recordset</b>  objects. Developers get either a
<b>Recordset</b>  as the return value from a <b>Connection</b>  or <b>
Command Execute</b>  call, or developers create their own
Recordsets.</p>

<p>A <b>Recordset</b>  object comprises a set of rows and columns. As
mentioned, at any given time, a <b>Recordset</b>  refers to the set of
columns associated with the current specific row. The <b>
Recordset</b> 's individual columns can be accessed through the <b>
Fields</b>  collection. Developers move through the rows of a <b>
Recordset</b>  by using the object's associated cursor.</p>

<p><b>Recordset</b>  objects are tremendously useful for three-service
layer applications. State on a server should not be shared across
method calls; rather, server states should connect to a database,
retrieve data, disconnect, and return all data to the caller.
Disconnected <b>Recordset</b>  objects can accomplish such a process
through ADO.</p>

<A NAME="475"><H3>Recordset Locking</H3></A>

<p><b>Recordset</b>  objects also support a variety of lock types.
Whenever records in a <b>Recordset</b>  are being updated, a lock must
be put on those records. The following <b>LockType</b>  property values
specify what types of locks are placed on records during editing:</p>

<ul>
<p><li> <b>adLockOptimistic</b>  Optimistic locking applies locks record
by record, but only when the <b>Update</b>  method is called.</li></p>

<p><li> <b>adLockPessimistic</b>  Pessimistic locking applies locks record
by record, at the time the record is read.</li></p>

<p><li> <b>adLockBatchOptimistic</b>  Batch optimistic locking applies
locks to the entire <b>Recordset</b>  object<b>,</b>  but only when the
<b>UpdateBatch</b>  method is called.</li></p>

<p><li> <b>adLockReadOnly</b>  Read-only locking is the default. When this
lock type is specified, developers cannot update data in the <b>
Recordset</b>  object.</li></p>
</ul>



<p><div class="note"><blockquote><b>NOTE</b><hr> The <b>Recordset</b>  object provides a set of
methods for moving through its rows. The <b>MoveNext</b>  and <b>
MovePrevious</b>  methods move forward and backward through the
Recordset, one record at a time. Developers can use the <b>BOF</b>  and
<b>EOF</b>  properties to detect when they have reached the beginning or
end of a <b>Recordset</b>  object. For a <b>Recordset</b>  object that
supports dynamic positioning, <b>MoveFirst</b>  and <b>MoveLast</b>  are
available. For a <b>Recordset</b>  object that supports bookmarks,
developers can use the <b>Bookmark</b>  property to return a unique
identifier for a current record in the <b>Recordset</b>  object. At a
later time, developers can set the <b>Bookmark</b>  property to return
to that particular record. <b>Recordset</b>  objects also provide
methods to move to specific records by ordinal number.</blockquote></div>
</p>

<p>The most common way to populate a <b>Recordset</b>  object that
developers create is to attach it to a <b>Connection</b>  object using
the <b>ActiveConnection</b>  property, then by calling the <b>Recordset
Open</b>  method. Developers can also populate a <b>Recordset</b>  object
programmatically, if the data does not derive from an OLE DB data
source.</p>

<A NAME="476"><H3>ADO Cursor Types</H3></A>

<p>ADO supports the following four cursor types:</p>

<ul>
<p><li> <b>Dynamic cursor</b>  Enables developers to view additions,
changes, and deletions made by other users. All types of movement
through the <b>Recordset</b>  object that don't rely on bookmarks
are permitted. Bookmarks are supported if the OLE DB provider supports
them.</li></p>

<p><li> <b>Keyset cursor</b>  Similar to a dynamic cursor, except that
developers can't see records added by other users and developers
can't access records deleted by other users. Keyset cursors always
support bookmarks.</li></p>

<p><li> <b>Static cursor</b>  Provides a static copy for a set of records.
Developers cannot see additions, changes, or deletions made by other
users. Static cursors always support bookmarks, and thus permit any
type of movement through the <b>Recordset</b>  object.</li></p>

<p><li> <b>Forward-only cursor</b>  Similar to a static cursor, but allows
developers only to scroll forward through the <b>Recordset</b> 
object.</li></p>
</ul>



<p>The <b>Recordset</b>  object features available to developers depend
on the cursor type specified when the <b>Recordset</b>  object is
opened.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> Not every OLE DB provider supports every cursor
type. When developers use the OLE DB provider for ODBC, the cursor
types available to developers depend on types supported by the
underlying ODBC driver for a database. The SQL Server ODBC driver
supports all four cursor types.</blockquote></div>
</p>

<A NAME="477"><H3>Disconnected Recordset</H3></A>

<p>Disconnected <b>Recordset</b>  objects use optimistic locking;
developers can manipulate these objects on the client using a
client-side cursor library. (In this context, &quot;client&quot; refers
to either the presentation or business layer.) Disconnected batch
updates are supported through the <b>UpdateBatch</b>  method. Using the
<b>UpdateBatch</b>  method requires extreme care, because another client
may risk updating several records while these records are being
modified on a different client. When the batch update is applied,
developers will receive errors for the conflicting updates. In this
case, developers need to define, as part of their 
component interfaces, how partial updates will be handled&#8212;will
they generate transaction failures, or will the client need to handle
the error?</p>

<p>To create a disconnected <b>Recordset</b>  object, before opening the
connection, developers should set the <b>CursorLocation</b>  property on
either the <b>Connection</b> or the <b>Recordset</b>  object to <b>
adUseClient</b>. The developers should then retrieve the data and
release the <b>ActiveConnection</b>. If developers want to allow the
client to modify the information, they should create the <b>
Recordset</b> object using batch optimistic locking
(<b>adLockBatchOptimistic</b>) and either a static
(<b>adOpenStatic</b>) or a keyset (<b>adOpenKeyset</b>) cursor.</p>

<A NAME="478"><H3>Recordset Fields</H3></A>

<p>As mentioned, columns of the current row in a <b>Recordset</b> 
object are accessed using the <b>Fields</b> collection. Developers can
access a field by its name or by a numeric index. When developers use
an ODBC data source, the field name corresponds to its name in a SQL
SELECT statement. The numeric index is thereby determined by the
field's position in the SQL SELECT statement. Once developers have
a <b>Field</b>  object, they can get or set information about this
object using its properties. The most commonly used property is <b>
Value</b>, which can be used to retrieve or set the field's data
value.</p>

<p>Two special methods on the <b>Field</b>  object&#8212;<b>GetChunk</b> 
and <b>AppendChunk</b>&#8212;are available to handle long binary or
character data. Developers can use <b>GetChunk</b>  to retrieve a data
portion and <b>AppendChunk</b>  to write a data portion. Developers can
determine whether they need to use these methods by examining the <b>
Field</b>  object's <b>Attributes</b>  property.</p>

<A NAME="479"><H3>Handling Errors</H3></A>

<p>Any ADO operation can generate errors, so it's important to
handle those errors within method calls. Such error handling consists
of two steps performed by ADO: returning error codes for each method
call, then supporting the standard COM error reporting mechanism, <b>
IErrorInfo</b>. Specific OLE DB provider errors, such as native
database error codes or ODBC error codes, are stored in the <b>
Errors</b>  collection associated with a <b>Connection</b>  object. One
ADO call can generate multiple errors in the <b>Errors</b>  collection.
It is recommended that developers walk through the <b>Errors</b> 
collection to retrieve substantial error information about database
failures.</p>

<p>ADO clears the <b>ErrorInfo</b>  object before it makes a call that
could potentially generate errors. However, the <b>Errors</b> 
collection is cleared and repopulated only when the OLE DB provider
generates a new error, or when the <b>Clear</b>  method is called. Some
methods and properties can generate warning messages in the <b>
Errors</b>  collection without halting program execution. Before calling
these methods or properties, developers should clear the <b>Errors</b> 
collection so that they can read the <b>Count</b>  property to determine
whether any warnings were generated. <b>Methods</b>  that can generate
warnings include <b>Recordset</b>  <b>Resync</b>, <b>UpdateBatch</b>,
and <b>CancelBatch</b>. The <b>Recordset Filter</b>  property can also
generate warnings.</p>

<A NAME="480"><H2>Remote Data Service (RDS)</H2></A>

<p>Although ADO recordsets offer access to only one row of data at a
time, recordsets do not necessarily access the underlying data store
every time the cursor moves. Internally, a <b>Recordset</b>  can cache
multiple rows of data. This caching capability is an important part of
building scalable distributed applications.</p>

<p>We'll consider a scenario in which thousands of users access an
online store over the Internet. The catalog of items for sale is most
likely maintained in a database. If each user maintains a unique
connection to the database for the entire time the user browses the
store, the number of database connections available on the database
server strictly limits the number of simultaneous shoppers. On the
other hand, if database connections are used only while blocks of data
are read from the database, a single connection can support many users.
In addition, if a large block of data can be sent back to each
user's computer, the user can browse a catalog with fewer database
server accesses. The latter scenario not only can reduce network
traffic; it could also make the online store more responsive for the
user.</p>

<p>The MDAC technologies that help make this scenario a reality are ADO
disconnected <b>Recordset</b>  objects and RDS. The RDS architecture is
shown in Figure 9.6.</p>

<P><A HREF="javascript:fullSize('f09ar06x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f09ar06.jpg" WIDTH=404 HEIGHT=269 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 9.6</b> <i> RDS architecture</i><!-- /caption --></P>

<p>A disconnected <b>Recordset</b>  object has simply been dissociated
from its <b>Connection</b>  object. Disconnected <b>Recordset</b> 
objects do not retain locks on the under-lying data store. Instead, all
data for all rows is cached within the <b>Recordset</b>  object. If a
<b>Recordset</b>  is modified and the changes are saved back to the data
store, OLE DB checks each modified row for conflicting updates in the
data store. In other words, OLE DB checks whether the row has been
modified since the <b>Recordset</b>  object was cached. If so, a
conflict is reported to the application so that the application can
handle the conflict properly.</p>

<p>RDS provides a client-side cursor engine for disconnected
recordsets. It also provides a very efficient service for marshaling
recordsets between computers, over either the Internet or an intranet.
This means that a server application can generate a set of data and
copy it to a client application, which can browse the data as if it
were connected to the actual data store. RDS also provides a way to
bind <b>Recordset</b>  objects to data-bound controls, which can greatly
simplify writing this type of client application.</p>

<p>RDS provides three components to help developers write applications:
<b>RDS.DataControl</b>, <b>RDSServer.DataFactory</b>, and <b>
RDS.DataSpace</b>. 
An <b>RDS.DataControl</b>  object is used to bind data-bound ActiveX
controls 
to <b>Recordset</b>  objects. Client applications use <b>
RDS.DataControl</b>  to browse or modify a Recordset. <b>
RDSServer.DataFactory</b>  is essentially a generic business object for
communicating with data sources. It contains no business rules or other
application-specific logic.</p>

<p>The <b>Recordset</b>  object itself is obtained in one of two ways.
First, the 
<b>Recordset</b>  object can be created implicitly by <b>
RDS.DataControl</b>. Properties 
of <b>RDS.DataControl</b>  are set that identify the data server and
query to be used. When the <b>Refresh</b>  method is called, an <b>
RDSServer.DataFactory</b>  object is 
used behind the scenes to create the <b>Recordset</b>  object. Second,
custom business objects that return disconnected recordsets can be
defined. <b>RDS.DataSpace</b>  objects are used to create client-side
proxies to these business objects. The 
client-side proxy does whatever is necessary to communicate with the
business object. Once the proxy has been created, the application can
call whatever method returns a <b>Recordset</b>  object; it then sets
the <b>Recordset</b>  property of <b>RDS.DataControl</b>.</p>

<p>This book exclusively endorses the second method. Middle-service
business 
objects will use data objects to create ADO disconnected recordsets.
These <b>Recordset</b>  objects will be passed back to the presentation
layer using RDS. 
Presentation-layer client applications will use RDS to bind the <b>
Recordset</b>  
objects to data-bound controls.</p>

<p>In intranet scenarios, DCOM can be used to transfer <b>
Recordsets</b>  between client and server computers. In Internet
scenarios, however, HTTP will normally be used. In this case, RDS
provides services to manage the HTTP communication. An Internet Server
API (ISAPI) extension, Advanced Data ISAPI (ADISAPI), is installed on
the Web server. ADISAPI does the work required to handle requests for
Recordsets from client-side business object proxies. It creates
server-side objects, calls the methods required to generate the <b>
Recordset</b>  objects, and converts the data to an efficient form for
transmission back to the client. ADISAPI and the business object
proxies handle all details of actually transmitting the data via
HTTP.</p>

</BODY>
</HTML>


