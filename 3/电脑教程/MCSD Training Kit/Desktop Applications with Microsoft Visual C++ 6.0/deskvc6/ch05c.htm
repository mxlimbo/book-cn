<HTML>
<HEAD>
<TITLE>Lesson 2: Displaying and Printing Application Data</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05b.htm", "ch05d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="194"><H1>Lesson 2: Displaying and Printing Application Data</H1></A>

<p>In <a href="ch03e.htm#133">Lesson 4</a> of Chapter 3, you learned how a class derived from the MFC <b>CView</b>
class is used to render an image of your application data. You learned how MFC provides
a <b>CDC</b> class, which encapsulates a device context and a set of drawing functions
that operate upon the device context, to render output on a device. You also learned
how the framework passes a <b>CDC</b>-derived device context object, which corresponds
to the current output device, to the <b>CView::OnDraw()</b> function. In this way, the
<b>OnDraw()</b> function provides a centralized location for your application drawing
code. The same code is used whether the output target is an application window, a print
preview window, or a page on a printing device.</p>

<p>In this lesson, you will learn more about how to use classes derived from <b>CView</b>
and <b>CDC</b>. You will also learn about MFC's drawing tool classes, which you use
to send your application's data to the screen or to a printing device.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe how to set up a logical coordinate system to make your application output appear correctly on any device that conforms to the Windows Graphical Device Interface (GDI).</li></p>
<p><li> Describe the Windows coordinate mapping modes and explain how they are used.</li></p>
<p><li> Describe how to implement scrolling for an MFC application.</li></p>
<p><li> Describe how to use the MFC drawing tool classes to draw in a device context.</li></p>
<p><li> Understand the printing and print preview processes, and how you can implement custom printing functions.</li></p>
</ul>
<b>Estimated lesson time: 40 minutes</b>
</blockquote></div>
</p>


<p>Before you proceed with this lesson, you will need to modify the application drawing
function so that it displays the application data rather than &quot;Hello
World!&quot;</p>

<p><li> <b>To modify the OnDraw() function</b></li></p>

<ol>
<p><li> Locate the implementation of the <b>CMyAppView::OnDraw()</b> function. Replace the current implementation with the following code:</li></P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppView::OnDraw(CDC* pDC)
{
     CMyAppDoc* pDoc = GetDocument();
     ASSERT_VALID(pDoc);

     CFont aFont;
     aFont.CreateFont(16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
          FF_ROMAN, 0);

     CFont * pOldFont = pDC-&gt;SelectObject(&amp;aFont);

     CSize TextSize = pDC-&gt;GetTextExtent(pDoc-&gt;m_string);
     int nLinePos = 10;

     for(int i = 0; i &lt; pDoc-&gt;m_nLines; i++)
     {
          pDC-&gt;TextOut(10, nLinePos, pDoc-&gt;m_string);
          nLinePos += TextSize.cy;
     }

     pDC-&gt;SelectObject(pOldFont);
}</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application.</li></p>
<p><li> On the <b>Edit</b> menu, click <b>Data</b>.</li></p>
<p><li> In the <b>Edit Document Data</b> dialog box, type a string 60 characters long into the <b>Line text</b> edit control, and the number <b>20</b> into the <b>Number of lines</b> edit control.</li></p>
<p><li> Click <b>OK</b> to close the dialog box. The line of text that you entered should appear 20 times, as shown in Figure 5.5.</li></p>

<p>
<A HREF="javascript:fullSize('f05DA05x.htm')"> <img src="images/f05DA05.jpg" width=404 height=291 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 5.5</b> <i>MyApp application test output</i><!-- /caption -->
</p>
</ol>

<A NAME="195"><H2>Understanding Coordinate Mapping</H2></A>

<p>Graphical devices render their output across a two-dimensional coordinate system.
Screen output is mapped to a pixel grid; printers work with a two-dimensional
array of dots on the printed page. The GDI drawing functions that are used by Windows
applications specify their output in a similar manner. GDI drawing is measured and
scaled in abstract units of measure known as <i>logical units</i>.</p>

<p>For example, the following line from our <b>OnDraw()</b> function initializes a font
object for outputting text into the device context. The font will be created with a
height of 16 logical units.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
aFont.CreateFont(16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FF_ROMAN, 0));
</pre>
</td></tr>
</table>
</p>

<p>The following code moves to the point in the application drawing space with the
coordinates (100,200), and draws a horizontal line 200 logical units long to the point
(300,200).</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
pDC-&gt;MoveTo(100, 200);
pDC-&gt;LineTo(300, 200);</pre>
</td></tr>
</table>
</p>

<p>Logical units have no intrinsic value. It is up to you to specify the actual value,
in terms of units of measure on the device, of a logical unit. To provide a standard
interface to the many different types of screens, printers, and other output devices
that an application might encounter, the GDI implements a coordinate mapping system.
You can specify a <i>mapping mode</i>, which determines how the logical units of the
application drawing space are to be mapped to the drawing space of the hardware device
(specified in <i>device units</i>). The GDI ensures that the mapping will produce
consistent output on whatever hardware device is attached.</p>

<p>The GDI defines a set of eight mapping modes that specify the ratio between logical
coordinates and device coordinates. The default mapping mode is identified by the value
MM_TEXT. This maps a logical unit to a single pixel on the device, regardless of the
device resolution. This can cause problems with printed output, as illustrated by the
following exercise.</p>

<p><li> <b>To view the effects of the default MM_TEXT mapping mode</b></li></p>

<ol>
<p><li> Run the MyApp application.</li></p>

<p><li> On the <b>Data</b> menu, click <b>Edit</b>, and type a string of about 60
characters to be displayed 20 times.</li></p>

<p><li> If you have a printer installed, click <b>Print</b> on the <b>File</b> menu to
print the application data. If you don't have a printer installed, click <b>Print
Preview</b> on the <b>File</b> menu to view the data as it would appear on a printed
page.</li></p>
</ol>

<p>Notice how the printer output appears extremely small. This is due to the difference
in resolution between the screen and printer. The drawing functions are scaling their
output in terms of the resolution of the target device. So a character that is 16
pixels high is about 0.21 inches tall on an 800 x 600 monitor. On a 600 x 600 
dots per inch printer, it is only about 0.026 inches tall.</p>

<p>MM_TEXT is one of six <i>fixed</i> mapping modes, which establish predefined
mappings between logical units and device units. Other fixed mapping modes map logical
units to units of measure on the device. MM_LOENGLISH for example, specifies that a
logical unit will correspond to 0.01 inches on the output device. The fixed mapping
modes are shown in Table 5.2.</p>

<p><b>Table 5.2</b> <i>Fixed Mapping Modes</i></p>

<table cellpadding="5" border="0" width="95%">
<tr><th>Mapping mode</th><th>One unit maps to</th></tr>
<tr><td valign="top">MM_TEXT</td><td valign="top">1 device pixel</td></tr>
<tr><td valign="top">MM_LOENGLISH</td><td valign="top">0.01 inch</td></tr>
<tr><td valign="top">MM_HIENGLISH</td><td valign="top">0.001 inch</td></tr>
<tr><td valign="top">MM_LOMETRIC</td><td valign="top">0.1 millimeter</td></tr>
<tr><td valign="top">MM_HIMETRIC</td><td valign="top">0.01 millimeter</td></tr>
<tr><td valign="top">MM_TWIPS</td><td valign="top">1/1440 inch</td></tr>
</table>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
There is no true physical measurement for displays in Windows
because a display driver has no knowledge of the actual physical size of the target
monitor. Thus the inches and millimeters in the preceding table are really logical
values based on the physical size of an idealized monitor. Printer measurements, on the
other hand, are physically accurate.</blockquote></div>
</p>

<p>In addition to the fixed mapping modes, you can use one of the unconstrained mapping
modes MM_ISOTROPIC or MM_ANISOTROPIC. These modes do not set up a predefined mapping
and so require you to specify the ratio between logical units and device units. When
the MM_ISOTROPIC mode is set, the GDI will continually adjust the mapping to ensure
that one logical unit maps to the same physical distance in both <i>x</i> and <i>y</i>
directions. The MM_ANISOTROPIC mode allows the <i>x</i> and <i>y</i> coordinates to be
adjusted independently.</p>

<p>To specify the ratio between logical units and device units, you must describe two
rectangles that specify the relative dimensions of the logical space (the <i>
window</i>) and the device space (the <i>viewport</i>). Window dimensions are specified
in logical units using the <b>CDC::SetWindowExt()</b> function. Viewport extents are
set using <b>CDC::SetViewportExt()</b> and are specified in device units. Information
about the current device dimensions can be obtained by using the <b>
CDC::GetDeviceCaps()</b> function.</p>

<p>The following code sets up a mapping mode similar to MM_LOENGLISH:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
pDC-&gt;SetMapMode(MM_ANISOTROPIC);
pDC-&gt;SetViewPortExt(pDC-&gt;GetDeviceCaps(LOGPIXELSX),
     pDC-&gt;GetDeviceCaps(LOGPIXELSY);
pDC-&gt;SetWindowExt(100, -100);</pre>
</td></tr>
</table>
</p>

<p>The <i>LOGPIXELSX</i> and <i>LOGPIXELSXY</i> parameters to the <b>
GetDeviceCaps()</b> function return the number of pixels per logical inch along the
width and height of the display. The code specifies that a 1 x 1-inch square on the
device is to correspond to a square in the application drawing space that is 100 x 100 logical
units. Or to put it another way, one logical unit will correspond to 0.01 inch on the
output device.</p>

<p>Note that the <i>y</i> parameter of the <b>SetWindowExt()</b> function has a
negative value. By default, device coordinates follow the Windows convention that the
origin is located in the upper left corner of the window and <i>y</i> values increase
downward. By specifying an inverse ratio between the window and the viewport <i>y</i> values,
you can allow your drawing functions to describe output using the traditional
mathematical coordinate system, with <i>y</i> values that increase upward. Be aware
that because the origin of the onscreen display window (the position <i>(0, 0)</i>) is
set by default to the top left corner of the window, your drawing will not be visible
if you use <i>y</i> coordinates that increase upward. You will be drawing in the space
above the top of the visible window. Either invert the values of your <i>y</i> coordinates
or use the <b>CDC::SetViewportOrg()</b> function to offset the device window origin to
a point that corresponds to the bottom left corner of your logical window.</p>

<p>The fixed mapping modes follow the mathematical convention that <i>x</i> coordinates
increase in value toward the right and that <i>y</i> coordinates increase as they go
up. The MM_TEXT mapping mode follows the Windows convention that <i>y</i> coordinate
values increase as they go down.</p>

<p>After you have set up a suitable mapping mode for your view, you simply use the GDI
drawing functions to render output using logical coordinates. The conversion between
logical coordinates and physical (device) coordinates is handled for you. At times, you
will need to convert coordinates yourself using the <b>CDC</b> methods <b>LPtoDP()</b>
and <b>DPtoLP()</b> because certain types of information are supplied to you only in
device coordinates. For example, the location of a mouse-click is supplied as a
parameter to the <b>CView::OnLButtonDown()</b> handler function as a pair of physical
coordinates. You would have to convert the coordinates if you needed to determine
whether the location of the mouse click corresponded to a significant region of your
logical drawing space.</p>

<A NAME="196"><H2>Scrolling Views</H2></A>

<p>When drawing your application output in logical space, you are limited only by the
size of the coordinate range. Drawing coordinates in a Windows 95 or 98 application
must lie within the range _32,768 through 32,767. Using the MM_LOENGLISH mapping mode,
this range maps to nearly 3000 square feet of physical drawing space&#8212;considerably
larger than any output device that you are likely to encounter.</p>

<p>Windows that are not able to display all of the application output in a single frame
should implement scroll bars. Scroll bars should be implemented
wherever the user can resize the window, and they should appear at the point where the
window frame starts to clip the output in the client area.</p>

<p>Fortunately, MFC makes it easy to add scrolling to your document/view application.
You will recall from <a href="ch02b.htm#65">Lesson 1</a> of Chapter 2 that the view class for the MyApp
application was derived from the <b>CScrollView</b> class. You can implement scrolling
yourself in any view class by using the <b>CWnd</b> scrolling functions and handling
the WM_VSCROLL and WM_HSCROLL messages, but <b>CScrollView</b> makes it easy for you to
implement scrolling by:</p>

<ul>
<p><li> Managing window and viewport sizes and mapping modes.</li></p>
<p><li> Scrolling automatically in response to scroll-bar messages.</li></p>
</ul>

<p>The following exercise introduces the scrolling capabilities offered by <b>CScrollView</b>.</p>

<p><li> <b>To view the default scrolling behavior of the MyApp application</b></li></p>

<ol>
<p><li> Run the MyApp application.</li></p>
<p><li> On the <b>Data</b> menu, click <b>Edit,</b> and then type a string of about 60 characters to be displayed 20 times.</li></p>
<p><li> Resize the window so that it resembles Figure 5.6.</li></p>

<p>
<img src="images/F05DA06.JPG" width=168 height=187 border="0">
</p><p>
<!-- caption --><b>Figure 5.6</b> <i>Testing the MyApp scrolling capabilities</i><!-- /caption -->
</p>
</ol>

<p>Notice that although scrolling is invoked automatically, it doesn't behave quite
as it should. In Figure 5.6, you can see that the right side of the data lines is out
of the view and that a horizontal scroll bar has not appeared. You would expect the
scroll bars to appear as soon as the frame edges clip the data displayed in the window.
Also notice that when you shrink the window further so that a horizontal scroll bar
appears, you cannot scroll across to see an entire data line.</p>

<p>The reason for this behavior is that it is your responsibility to specify a logical
size and a mapping mode for a scrolling view. When an AppWizard application is created
with a view derived from <b>CScrollView</b>, the AppWizard adds the following code to
the overloaded <b>CView::OnInitialUpdate()</b> method:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CSize sizeTotal;
// TODO: calculate the total size of this view
sizeTotal.cx = sizeTotal.cy = 100;
SetScrollSizes(MM_TEXT, sizeTotal);</pre>
</td></tr>
</table>
</p>

<p>The <b>CScrollView::SetScrollSizes()</b> function is used to specify the logical
size and a mapping mode for the scrolling view. The default <b>OnInitialUpdate()</b>
method will set up the view window with dimensions of 100 x 100 logical units. Under
the MM_TEXT mapping mode, this corresponds to an onscreen viewport that is 100 x 100
pixels&#8212;about a square inch on an 800 x 600 monitor. The <b>SetScrollSizes()</b>
function has additional parameters that specify the <i>line size</i> and the <i>page
size.</i> The line size is the horizontal and vertical distance to scroll in each
direction when the user clicks on a scroll arrow. The page size is the distance to
scroll when the user clicks in the scroll bar, but not on a scroll arrow. These last
two parameters have default values that are calculated to be in proportion to the total
size of the window.</p>

<p>When the MyApp application window is large enough, you can see all the text. If the
window is resized so that the view becomes smaller than the size set in the <b>
SetScrollSizes()</b> function, the scroll bars are displayed. The scroll bar scale and
positions are also calculated on the basis of the size of the scrolling view. This is
why, when you were experimenting with the default scrolling behavior of the MyApp
application, it was impossible to scroll to see data that lay outside the 100 x 100
logical window area.</p>

<p>To set up a simple scrolling view for a document/view application, you need to
decide how large a logical drawing space is required to render your document data. Then
determine a suitable mapping mode to scale your drawing to an output device, and set
the values with a call to <b>SetScrollSizes()</b> in the view class's <b>
OnInitialUpdate()</b> function. The following code snippet illustrates how you might
set up a view of 8.5 x 11 inches:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
sizeTotal.cx = 850;
sizeTotal.cy = 1100;
SetScrollSizes(MM_LOENGLISH, sizeTotal);</pre>
</td></tr>
</table>
</p>

<p>This approach is appropriate if you can determine a fixed size for your document
data. However, consider an application such as a word processing application, which
does not place a constraint on the length of a document. As the user adds lines of
text, you will be required to resize the logical window and to recalculate the scale of
the scroll bars. In such a case, you will need to call the <b>SetScrollSizes()</b>
function frequently as the size of the document data changes.</p>

<p>In the following exercise, you will use the <b>SetScrollSizes()</b> function to adjust
the CMyAppView view so that the scroll bars will appear as the displayed data is
obscured by the window frame. The <b>SetScrollSizes()</b> function will be called from
within the drawing function so that the scroll sizes will be adjusted according to the
size of the string that is displayed. The function will also set the mapping mode to
MM_LOENGLISH so that the output will appear consistently on the screen and the
printer.</p>

<p><li> <b>To set the scroll sizes for the MyApp application</b></li></p>

<ol>
<p><li> In ClassView, expand the <b>CMyAppView</b> class icon.</li></p>
<p><li> Double click the <b>OnDraw()</b> icon to edit the method.</li></p>
<p><li> Beneath the following line,</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CSize TextSize = pDC-&gt;GetTextExtent(pDoc-&gt;m_string);</pre>
</td></tr>
</table>
</p>

<p>add these lines:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CSize scrollArea =  
     CSize(TextSize.cx, TextSize.cy * pDoc-&gt;m_nLines);

// Allow a margin
scrollArea += CSize(20, 20);

SetScrollSizes(MM_LOENGLISH, scrollArea);</pre>
</td></tr>
</table>
</p>
</ol>

<p>The scroll sizes are set relative to the size of the data that will be displayed and
are specified by the length of the string and the number of lines that are to be
displayed.</p>

<p>When the MM_TEXT mapping mode is used, the <i>y</i> coordinate values increase
downward and the other fixed mapping modes follow the mathematical convention, with <i>
y</i> values that increase upward. As you have changed the mapping mode from the
default MM_TEXT to MM_LOENGLISH, you will need to invert the <i>y</i> coordinates in
your display code so that their values decrease as you proceed down the page.</p>

<p><li> <b>To invert the <i> y</i> coordinates in your display code</b></li></p>

<ol>
<p><li> Locate the following lines of code in the <b>OnDraw()</b> function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
int nPos = 10;

for(int i = 0; i &lt; pDoc-&gt;m_nLines; i++)
{
     pDC-&gt;TextOut(10, nPos, pDoc-&gt;m_string);
     nPos += TextSize.cy;
}
</pre>
</td></tr>
</table>
</p>

<p><li> Change the initial value of <b>nPos</b> to <b>_10</b>.</li></p>

<p><li> Change the operator that increments <b>nPos</b> in the loop to <b>_ =</b>. The
entire function should now look as follows:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMyAppView::OnDraw(CDC* pDC)
{
     CMyAppDoc* pDoc = GetDocument();
     ASSERT_VALID(pDoc);

     CFont aFont;
     aFont.CreateFont(16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
          FF_ROMAN, 0);

     CFont * pOldFont = pDC-&gt;SelectObject(&amp;aFont);

     CSize TextSize = pDC-&gt;GetTextExtent(pDoc-&gt;m_string);

     CSize scrollArea =  
          CSize(TextSize.cx, TextSize.cy * pDoc-&gt;m_nLines);

     // Allow a margin
     scrollArea += CSize(20, 20);

     SetScrollSizes(MM_LOENGLISH, scrollArea);

     int nPos = -10;

     for(int i = 0; i &lt; pDoc-&gt;m_nLines; i++)
     {
          pDC-&gt;TextOut(10, nPos, pDoc-&gt;m_string);
          nPos -= TextSize.cy;
     }

     pDC-&gt;SelectObject(pOldFont);
}
</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application.</li></p>

<p><li> On the <b>Data</b> menu, click <b>Edit</b> and make 20 long lines of text appear.</li></p>

<p><li> Resize the application window and check that the scroll bars appear as the view
area becomes smaller than the data display. Try changing the size of the string and the
number of lines that are displayed, and notice how the scroll bars automatically scale
to fit the size of the data display.</li></p>

<p><li> Print the document, or use Print Preview to check that the printed output is a
reasonable size.</li></p>
</ol>

<A NAME="197"><H2>Drawing in a Device Context</H2></A>

<p>The framework passes to your <b>OnDraw()</b> function a pointer to a device context
object, which represents the client area of your application window. The <b>CDC</b>
class, the base class for all MFC device context objects, provides a number of
functions that enable you to draw lines, shapes, and fill areas; output text; and
manipulate bitmap patterns. You have met a few of these functions, such as <b>
LineTo()</b>, <b>Rectangle()</b><i>,</i> and <b>TextOut()</b><i>,</i> in the examples
throughout this chapter.</p>

<p>The drawing functions work together with the MFC drawing tool classes, which include
<b>CPen</b> (for drawing lines), <b>CBrush</b> (for filling areas), <b>CFont</b>, and
<b>Cbitmap</b><i>,</i> among others. A drawing tool of each type is <i>selected
into</i> the device context for use with the drawing functions. Thus the <b>
CDC::Rectangle()</b> function will draw a rectangle in the device context using the
current <b>CPen</b> and fill it using the current <b>CBrush</b>.</p>

<p>The recommended procedure for using the drawing tool graphic objects is as follows:</p>

<ol>
<p><li> Use a two-stage creation process to create a graphic object. First declare the
object and then initialize it with the type-specific create function, such as <b>
CPen::CreatePen()</b>.</li></p>

<p><li> Using the <b>CDC::SelectObject()</b> function, select the object into the
current device context. The <b>SelectObject()</b> function is overloaded in several
ways to correspond to the different types of graphic objects that can be selected.</li></p>

<p><li> The <b>SelectObject()</b> function returns a pointer to the graphic object that
was originally selected. Create a pointer of the appropriate type to save this pointer
value.</li></p>

<p><li> When done with the current graphic object, use the saved pointer to select the
old graphic object back into the device context to restore its state. You should leave
the device context just as you found it.</li></p>
</ol>

<p>The <b>OnDraw()</b> function that you implemented for the MyApp application provides
a good example of the procedure. The following lines declare and create a new font and
select it into the current device context:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CFont aFont;
aFont.CreateFont(16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, FF_ROMAN, 0);
CFont * pOldFont = pDC-&gt;SelectObject(&amp;aFont);
</pre>
</td></tr>
</table>
</p>

<p>The <i>aFont</i> font is used in subsequent calls to the <b>CDC::TextOut()</b>
function to display text in the device context. When the function has finished with the
font, it discards the <b>aFont</b> object and uses the following line of code to
restore the object stored in the <b>pOldFont</b> pointer:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>pDC-&gt;SelectObject(pOldFont);</pre>
</td></tr>
</table>
</p>

<p>
<div class="tip"><blockquote><b>TIP</b><hr>
Rather than saving and restoring each individual object in the
device context, you can use the <b>CDC</b> methods <b>SaveDC()</b> and <b>
RestoreDC()</b> to save and restore the entire device context.</blockquote></div>
</p>

<p>In this courseware, we will only describe how to implement a passive display of
application data. A fair amount of work needs to go into developing views that support
features such as object selection, cut, copy, and paste, the manipulation of on-screen
objects by the user, drawing with the mouse, and so forth. The DRAWCLI sample
application that is provided with Visual C++ gives a good example of how to implement
many of these features.</p>

<A NAME="198"><H2>Printing Process</H2></A>

<p>In <a href="ch03e.htm#133">Lesson 4</a> of Chapter 3, you learned that the process of rendering an image of your
application data on a printed page is simple because the same <b>OnDraw()</b> function
is used for both screen and printer output. The functions <b>CView::OnPrint()</b> and
<b>CWnd::OnPaint()</b> both call the <b>OnDraw()</b> function to render output.</p>

<p>When printing, the framework will perform the following tasks:</p>

<ul>
<p><li> Display the <b>Print</b> dialog box.</li></p>

<p><li> Create a device context object for the printer.</li></p>

<p><li> Call the <b>CDC::StartDoc()</b> function to notify the printer 
that all subsequent pages should be spooled under the same job until a 
<b>CDC::EndDoc()</b> call occurs. This ensures that documents longer than 
one page will not be interspersed with other jobs.</li></p>

<p><li> Repeatedly call the <b>CDC::StartPage()</b> and <b>CDC::EndPage()</b> functions
to inform the printer driver of the beginning and end of each page.</li></p>

<p><li> Call overridable functions in the view at the appropriate times.</li></p>
</ul>

<p>Several of the functions, including those for implementing pagination for the
printed document, allocating GDI resources for printing, and sending escape codes to
change the printer mode before printing a given page, can be overridden. You can use
these functions to customize the printing process. Table 5.3 lists the printing
functions that can be overridden (all members of the <b>CView</b> class).</p>

<p><b>Table 5.3</b> <i>Printing Functions That Can Be Overridden</i></p>

<table cellpadding="5" border="0" width="95%">
<tr><th>Name</th><th>Function</th></tr>
<tr><td valign="top" nowrap>OnPreparePrinting()</td><td valign="top">Allows you to modify a <B>CPRINTIINFO</B> structure to insert values into the <B>Print</B> dialog box&#8212;commonly used to set the length of the document. Passes the <B>CPRINTIINFO</B> structure to the <B>CView::DoPreparePrinting()</B> method, which displays the dialog box and creates the printer device context object.</td></tr>
<tr><td valign="top" nowrap>OnBeginPrinting()</td><td valign="top">Allows you to allocate fonts or other GDI resources used for printed output.</td></tr>
<tr><td valign="top" nowrap>OnPrepareDC()</td><td valign="top">Allows you to adjust attributes of the device context for a given page. If the length of the document hasn't been specified, a check for the end of the document is performed.</td></tr>
<tr><td valign="top" nowrap>OnPrint()</td><td valign="top">Allows you to print a given page. By default, this function simply calls <B>OnDraw()</B> to render the output, although you can override <B>OnPrint()</B> to provide printed output that is significantly different to the screen display.</td></tr>
<tr><td valign="top" nowrap>OnEndPrinting()</td><td valign="top">Allows you to disconnect GDI resources.</td></tr>
</table>

<p>Figure 5.7 illustrates the full printing cycle and shows the order in which these
functions are called.

<p>
<img src="images/F05DA07.JPG" width=254 height=471 border="0">
</p><p>
<!-- caption --><b>Figure 5.7</b> <i>The MFC printing cycle</i><!-- /caption -->
</p>

<p>The <b>Print</b> dialog box in the MyApp application currently allows you to select
a range of pages to print. This feature should be made unavailable for an application
that allows you to print only one page of data. In the following exercise, you will add
code to the <b>CMyAppView::OnPreparePrinting()</b> function to set the maximum number
of document printer pages to 1. This has the effect of making the page range selection
feature in the <b>Print</b> dialog box unavailable.</p>

<p><li> <b>To set the maximum number of printer pages</b></li></p>

<ol>
<p><li> Run the MyApp application. On the <b>File</b> menu, click <b>Print</b> to verify that the page range feature is available.</li></p>
<p><li> In ClassView, expand the <b>CMyAppView</b> class icon.</li></p>
<p><li> Double-click the <b>OnPreparePrinting()</b> icon to edit the method.</li></p>
<p><li> To the body of the function, before the return statement, add the following line:</li></p>
<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>pInfo-&gt;SetMaxPage(1);</pre>
</td></tr>
</table>
</p>
<p><li> Build and run the MyApp application. Click <b>Print</b> on the <b>File</b> menu to verify that the page range feature has been made unavailable.</li></p>
</ol>

<A NAME="199"><H2>Print Preview</H2></A>

<p>When the user selects the <b>Print Preview</b> command from the <b>File</b> menu,
the framework creates a <b>CPreviewDC</b> object. Whenever your application performs an
operation that sets a characteristic of the printer device context, the framework also
performs a similar operation on the preview device context. For example, if your
application selects a font for printing, the framework selects a font for screen
display that simulates the printer font. Whenever your application sends output to the
printer, the framework sends the output to the screen.</p>

<p>Print Preview differs from printing in the order that the pages of a document are
drawn. During printing, the framework loops until a certain range of pages has been
rendered. During Print Preview, one or two pages are displayed and then the application
waits. No further pages are displayed until the user clicks <b>Next Page</b> or <b>
Previous Page</b>. During Print Preview, the application must also respond to WM_PAINT
messages, just as it does during ordinary screen display.</p>

<p>The <b>OnPreparePrinting()</b> function is called when preview mode is invoked, just
as it is when beginning a print job. The <b>CPRINTINFO</b> structure passed to the
function contains several members whose values you can set to adjust certain
characteristics of the print preview operation. For example, you can set the <b>
m_nNumPreviewPages</b> member to specify whether you want to preview the document in
one-page or two-page mode.</p>

<A NAME="200"><H3>Modifying Print Preview</H3></A>

<p>You can rather easily modify the behavior and appearance of print preview in a
number of ways. Some of the modifications you can make include those listed on the next
page.</p>

<ul>
<p><li> Causing the print preview window to display a scroll bar for easy access to any page of the document.</li></p>
<p><li> Causing print preview to maintain the user's position in the document by beginning its display on the current page.</li></p>
<p><li> Causing different initialization to be performed for print preview and printing.</li></p>
</ul>


<A NAME="201"><H2>Lesson Summary</H2></A>

<p>The Windows GDI provides a layer of abstraction between applications and the many
different types of output devices upon which an application can display output. The
graphical output of applications is measured and scaled in logical units. The GDI
implements a coordinate mapping system, which determines how the logical units of the
application output are to be mapped to the drawing space of the hardware device. This
ensures consistent application output on whatever hardware device is attached.</p>

<p>The GDI defines a set of eight mapping modes that specify the ratio between logical
coordinates and device coordinates. You can choose one of the six fixed mapping modes
that establish predefined mappings between logical units and units of measure on the
device, or one of the two unconstrained mapping modes that allow you to specify the
ratio between logical units and device units.</p>

<p>Scroll bars should be implemented for a window whenever the window is not able to
display all of the application output in a single frame. MFC makes it easy to add
scrolling to your document/view application by allowing you to derive your application
view class from the MFC class <b>CScrollView</b>. It is your responsibility to specify
a size and a mapping mode for a scrolling view so that the framework knows when and how
to implement scrolling capabilities.</p>

<p>MFC provides a number of drawing tool classes, which are used in conjunction with
the GDI drawing functions to render application output in a device context. Generally,
you create and configure drawing tool objects to suit the needs of your application.
You select these objects into the device context using the <b>CDC::SelectObject()</b>
function, which returns a pointer to the previously selected object. You should always
use this pointer to restore the object at the end of your drawing function to preserve
the original state of the device context.</p>

<p>When printing a document, the framework calls a sequence of functions. All the
functions are virtual member functions of the <b>CView</b> class. You can override
these functions to customize the printing process. The most common task is to implement
pagination for the printed document. Other tasks include the allocation of any GDI
resources needed for printing, and sending escape codes to change the printer mode
before printing a given page. You can also use some of these functions to perform
customizations that are specific to the display of application data in a print preview
window.</p>

</BODY>
</HTML>







