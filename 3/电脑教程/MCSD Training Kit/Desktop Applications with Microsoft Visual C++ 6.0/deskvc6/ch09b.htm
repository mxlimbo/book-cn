<HTML>
<HEAD>
<TITLE>Lesson 1: Creating COM Components with ATL</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09a.htm", "ch09c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="357"><H1>Lesson 1: Creating COM Components with ATL</H1></A>

<p>ATL is a set of templated C++ classes with which you can easily create efficient COM
components. It has special support for key COM features including the <b>IUnknown</b>
and <b>IDispatch</b> interfaces, and dual interfaces. ATL can also be used to create
ActiveX controls. ATL code can also be used to create single-threaded,
apartment-threaded, or free-threaded objects.</p>

<p>In addition to ATL, Microsoft Visual Studio supplies wizards that simplify the
process of using ATL as the basis of your development framework.</p>

<p>This lesson shows you how to create simple COM components using ATL.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>
<p><li>Describe how to use the ATL COM AppWizard to create a COM server to host COM
objects.</li></p>

<p><li>Describe how to use the ATL Object Wizard to create a COM object.</li></p>

<p><li>Describe how to create and implement a property for an ATL COM object.</li></p>

<p><li>Describe how to create and implement a method for an ATL COM object.</li></p>
</ul>

<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>

<A NAME="358"><H2>Using ATL</H2></A>

<p>A significant amount of boilerplate code can be used when creating COM objects. With
ATL, Visual Studio provides an easily tailored approach to generating and implementing
COM objects. A number of ATL wizards generate boilerplate code, leaving you free to
concentrate on the component-specific methods that perform the real work of your COM
object.</p>

<p>The code generated by the ATL wizards is based around the core set of templated
classes and macros that form ATL. The use of templates (as opposed to the kind of deep
inheritance structure used by MFC) enables ATL to produce fast, lightweight code that
is suitable for developing components and controls.</p>

<p>A COM object is created using ATL by the following process:</p>

<ol>
<p><li>Create an ATL COM project using the ATL COM AppWizard. The type of project you
create will determine the type of server (in-process or out-of-process) that will host
your COM objects.</li></p>

<p><li>Insert a new ATL object using the ATL Object Wizard.</li></p>

<p><li>Add methods to your object using the Add Method to Interface Wizard.</li></p>

<p><li>Add properties to your object using the Add Property to Interface Wizard.</li></p>

<p><li>Provide the implementation of your object's methods.</li></p>
</ol>

<p>In this lesson, you will follow these steps to construct a simple ATL-based COM
object that provides encryption services. This COM object, called <b>Encoder</b>,
supports a single interface named <b>IEncoder</b>. This interface exposes a single
method, named <b>EncodeString()</b>, which returns an encoded version of a single
string through the use of a simple encryption algorithm that increases or decreases the
value of each character by a specified number. This number is specified as a
configurable property named <b>Key</b>.</p>

<A NAME="359"><H2>Creating an ATL COM Project</H2></A>

<p>In this exercise, you will use the ATL COM AppWizard to create an ATL COM project
for your COM server.</p>

<p><li><b>To create the EncodeServer project</b></li></p>

<ol>
<p><li>On the <b>File</b> menu, click <b>New</b>, and then click the <b>Projects</b>
tab.</li></p>

<p><li>The project category options are listed in the window on the left side of the
dialog box. Click <b>ATL COM AppWizard</b>.</li></p>

<p><li>In the <b>Project name</b> box, type <b>EncodeServer</b>. Click <b>OK</b>.</li></p>

<p><li>In the <b>ATL COM AppWizard</b> dialog box, ensure that <b>Dynamic Link Library (DLL)</b> is selected as shown in Figure 9.1, and then click <b>Finish</b>.</li></p>


<p>
<A HREF="javascript:fullSize('F09DA02x.htm')"> <img src="images/F09DA02.JPG" width=404 height=325 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9.1</b> <i>The <b>ATL COM AppWizard</b> dialog box configured to create a DLL</i><!-- /caption -->
</p>

<p>If you choose to create a DLL to host your COM components, you are indicating that
you want to create an in-process COM server. If you select the <b>Executable (EXE)</b>
option, you will create a server that can be an out-of-
process server or a remote server, depending on how it is implemented. These terms are
defined in <a href="ch08c.htm#320">Lesson 2</a> of Chapter 8. The <b>Service</b> option allows you to create a 
<i>Windows NT service&#8212;</i>a program that runs in the background when Windows
NT starts up.</p>

<p><li>The <b>New Project Information</b> dialog box describes the files generated for
your COM project, as shown in Figure 9.2. Click <b>OK</b> to continue.</li></p>


<p>
<A HREF="javascript:fullSize('f09DA03x.htm')"> <img src="images/f09DA03.jpg" width=404 height=413 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9.2</b> <i>The <b>New Project Information</b> dialog box</i><!-- /caption -->
</p>
</ol>

<p>You have now created the DLL host environment for an in-process COM server, as well
as all the code necessary to register your COM object in the system registry. This type
of COM object is known as a <i>self-registering</i> component.</p>

<A NAME="360"><H2>Inserting a New COM Component</H2></A>

<p>Now that you have the hosting environment defined and configured, you can add an
actual COM object. You use the ATL Object Wizard to perform this task.</p>

<p><li><b>To add the Encoder COM component</b></li></p>

<ol>
<p><li>On the <b>Insert</b> menu, click <b>New ATL Object</b>.</li></p>

<p><li>In the <b>Category</b> list, click <b>Objects</b>.</li></p>

<p><li>In the <b>Objects</b> box, click the <b>Simple Object</b> icon shown in Figure
9.3, and then click <b>Next</b>.</li></p>

<p>
<A HREF="javascript:fullSize('f09DA04x.htm')"> <img src="images/f09DA04.jpg" width=404 height=251 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9.3</b> <i>The <b>ATL Object Wizard</b> dialog box</i><!-- /caption -->
</p>

<p><li>In the <b>ATL Object Wizard Properties</b> dialog box, click the <b>Names</b>
tab.</li></p>

<p><li>In the <b>Short Name</b> box, type the name of your server class&#8212;<b>Encoder</b>. All remaining fields will update automatically based on the contents of the <b>Short Name</b> box, as shown in Figure 9.4.</li></p>

<p>
<A HREF="javascript:fullSize('f09DA05x.htm')"> <img src="images/f09DA05.jpg" width=404 height=268 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9.4</b> <i>The <b>ATL Object Wizard Properties</b> dialog box</i><!-- /caption -->
</p>

<p>The left pane of this dialog box indicates that the wizard will create a C++ class
named <b>CEncoder</b> (defined in the Encoder.h and the Encoder.cpp files). You will
add code to this class to provide the implementation of your COM component. The pane on
the right indicates that the name of the component will be <b>Encoder</b>, and that it
will expose the default interface <b>IEncoder</b>. Note also the ProgID 
<b>EncodeServer.Encoder</b>. This is the name you can use to retrieve the object's
GUID using the <b>CLSIDFromProgID()</b> function.</p>

<p><li>In the <b>ATL Object Wizard Properties</b> dialog box, click the 
<b>Attributes</b> tab. Set the following attributes as shown in Figure 9.5:</li></p>

<ul>
<p><li>Under <b>Threading Model</b>, select <b>Single</b>.</li></p>

<p><li>Under <b>Interface</b>, select <b>Custom</b>.</li></p>

<p><li>Under <b>Aggregation</b>, select <b>No</b>.</li></p>


<p>
<A HREF="javascript:fullSize('f09DA06x.htm')"> <img src="images/f09DA06.jpg" width=404 height=268 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9.5</b> <i>The <b>Attributes</b> tab of the <b>ATL Object Wizard Properties</b> dialog box</i><!-- /caption -->
</p>
</ul>

<p>ATL follows the recommended practice of implementing dispatch interfaces as dual
interfaces. By selecting a custom interface, you are choosing <i>not</i> to implement a
dispatch interface for your COM component. Only clients that are capable of attaching
directly to the component's vtable will be able to call the interface methods.</p>

<p><li>Ensure that all check boxes are cleared, and then click <b>OK</b> to add the
Encoder object.</li></p>

<p>In ClassView you will see that you have inserted the <b>CEncoder</b> component class
and the <b>IEncoder</b> interface, as shown in Figure 9.6.</p>

<p>
<img src="images/f09DA07.jpg" width=249 height=321>
</p><p>
<!-- caption --><b>Figure 9.6</b> <i>ClassView displaying the <b>CEncoder</b> class and <b>IEncoder</b> interface</i><!-- /caption -->
</p>
</ol>

<p>With the <b>CEncoder</b> component class, you acquire a templated version of a class
factory, which will be used to create your COM component when it is instantiated. You
also inherit default implementations for the <b>IUnknown</b> methods 
<b>QueryInterface()</b>, <b>AddRef()</b>, and <b>Release()</b>, which manage client access
to interface pointers and control the lifetime of your COM object.</p>

<A NAME="361"><H2>Adding Methods to the Component Interface</H2></A>

<p>After you have the host environment, a class factory, and the <b>IUnknown</b>
methods added to your COM component, you insert component-specific methods. A client
can execute these methods to use the services of your COM object. When adding a method
to your component, you use the Add Method to Interface Wizard.</p>

<p><li><b>To add the EncodeString() method</b></li></p>

<ol>
<p><li>In ClassView, right-click the <b>IEncoder</b> interface.</li></p>

<p><li>On the shortcut menu, click <b>Add Method</b>. The <b>Add Method to
Interface</b> dialog box appears.</li></p>

<p><li>In the <b>Return Type</b> box, select <b>HRESULT</b>.</li></p>

<p><li>In the <b>Method Name</b> box, type <b>EncodeString</b>.</li></p>

<p><li>Insert the following code into the <b>Parameters</b> box.</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[in] const BSTR instring, [out, retval] BSTR * outstring</pre>
</td></tr>
</table>
</p>

<p>In the <b>Implementation</b> box, the Add Method to Interface Wizard shows a
complete MIDL listing of the method signature based upon the data you
entered, as shown in Figure 9.7.</p>
</ol>

<p>
<img src="images/f09DA08.jpg" width=366 height=257>
</p><p>
<!-- caption --><b>Figure 9.7</b> <i>The <b>Add Method to Interface</b> dialog box</i><!-- /caption -->
</p>

<p>When you specify parameters using the Add Method to Interface Wizard, you must
provide the parameter list in the format used by the Interface Definition Language
(IDL). This format requires that you use attributes to indicate the
direction of data transfer. By indicating the direction [<b>in</b>], you establish that
the first parameter passes data into the method. The [in] parameter is passed by
value.</p>

<p>The <b>EncodeString()</b> function will take the [in] parameter and create an
encoded string using a simple encryption algorithm. A pointer to the encoded string
will be passed to the client as the [out] parameter.</p>

<p>Note the use of the Automation string data type BSTR. Using Automation-compatible 
data types for your interface method parameters means that languages such as
Microsoft Visual Basic or Microsoft Visual J++ will be able to use the services
provided by your component.</p>

<p>Most COM interface methods return an HRESULT&#8212;a COM-specific 32-bit value that
indicates a success or failure condition. HRESULTS are explained in detail in <a href="ch13c.htm#480">Lesson 2</a>
of Chapter 13. Some client languages (Visual Basic, for example) are not capable of
using the HRESULT data type directly. The [<b>retval</b>] attribute indicates the
parameter that is used as a return value in such a case. The Visual Basic run-time
error-handling system will process the HRESULT returned by the function, but as far as
the Visual Basic code is concerned, the return value of the <b>EncodeString()</b>
function is the value referred to by the [retval] parameter. Thus the following piece
of Visual Basic code will cause the encrypted form of &quot;Hello&quot; to be displayed
in a message box:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Dim comobj As Encoder

Set comobj = New Encoder

MsgBox comobj.EncodeString(&quot;Hello&quot;)</pre>
</td></tr>
</table>
</p>

<p>Click <b>OK</b> to add the <b>EncodeString()</b> method. The Add Method to Interface
Wizard places an entry in your project's IDL file based on the descriptive
information you entered. The wizard also adds a C++ method to the <b>CEncoder</b>
component class.</p>

<A NAME="362"><H2>Adding Properties to the Component Interface</H2></A>

<p>Properties are public data members of a COM object. Languages that support COM
properties can get and set the value of an object property in much the same way that
you set member variables of a C++ class. For example, the following piece of Visual
Basic code displays the current value of the <b>Key</b> property in a message box, and
assigns it a new value of 3:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Dim comobj As Encoder

Set comobj = New Encoder

MsgBox comobj.Key

comobj.Key = 3</pre>
</td></tr>
</table>
</p>

<p>Because a COM interface is essentially a table of pointers to functions, C++
implements COM properties as a pair of functions&#8212;one to set the value of the
function and another to get the value. The Add Property to Interface Wizard
automatically creates <b>Get</b> and <b>Put</b> methods for each property you
define, although you can choose not to implement a <b>Put</b> method and thus 
create a read-only property.</p>

<p><li><b>To add the Key property</b></li></p>

<ol>
<p><li>In ClassView, right-click the <b>IEncoder</b> interface.</li></p>

<p><li>On the shortcut menu, click <b>Add Property</b>.</li></p>

<p><li>In the <b>Return Type</b> box, select <b>HRESULT</b>, and in the <b>Property
Type</b> box, select <b>short</b>.</li></p>

<p><li>In the <b>Property Name</b> box, type <b>Key</b>. Note the MIDL signatures of
the <b>get_Key</b> and <b>put_Key()</b> functions that appear in the <b>
Implementation</b> box.</li></p>

<p><li>Click <b>OK</b> to create the functions that implement the property.</li></p>
</ol>

<p>In the class that implements your COM object, you must define a member variable to
hold the data. You must also provide implementations of the <b>Get</b> and <b>Put</b>
methods to pass data to and from this member variable.</p>

<p><li><b>To implement the Key property</b></li></p>

<ol>
<p><li>Add a <b>short</b> protected member variable named <b>m_Key</b> to the 
<b>CEncoder</b> class.</li></p>

<p><li>Add the following line to the constructor <b>CEncoder::CEncoder()</b> to
initialize the m_Key variable to a default value:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_Key = 1;</pre>
</td></tr>
</table>
</p>

<p><li>In ClassView, expand the <b>IEncoder</b> interface under the <b>CEncoder</b>
class item to locate the <b>get_Key()</b> and <b>put_Key()</b> functions. Implement
these functions as shown in the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>STDMETHODIMP CEncoder::get_Key(short *pVal)
{
     *pVal = m_Key;

     return S_OK;
}

STDMETHODIMP CEncoder::put_Key(short newVal)
{
     newVal = newVal &gt; 5 ? 5 : newVal;
     newVal = newVal &lt; -5 ? -5 : newVal;
     m_Key = newVal;

     return S_OK;
}</pre>
</td></tr>
</table>
</p>
</ol>

<p>Note the simple bounds-checking code incorporated into the <b>put_Key()</b>
function.</p>

<A NAME="363"><H2>Implementing Component Methods</H2></A>

<p>Now that you have implemented the <b>Key</b> property, you can add code to implement
the <b>EncodeString()</b> method.</p>

<p><li><b>To implement the EncodeString() method</b></li></p>

<ol>
<p><li>On the <b>View</b> menu, click <b>Workspace</b>, and then click the 
<b>ClassView</b> tab.</li></p>

<p><li>Click the plus sign next to <b>CEncoder</b> to expand the contents of this
class.</li></p>

<p><li>Click the plus sign next to <b>IEncoder</b>, within the <b>CEncoder</b> class,
to expand the contents of this interface as shown in Figure 9.8.</li></p>

<p>
<img src="images/f09DA08.jpg" width=366 height=257 border=0 ALT="Click to view at full size.">
</p><p>
<!-- caption --><b>Figure 9.8</b> <i>ClassView displaying the methods of the <b>IEncoder</b> interface</i><!-- /caption -->
</p>

<p><li>Double-click the <b>EncodeString()</b> method underneath the <b>IEncoder</b>
interface, which is subordinate to the <b>CEncoder</b> class. This opens an edit window
into the body of the <b>EncodeString()</b> implementation function within the
Encoder.cpp file.</li></p>

<p><li>Add code to the body of the <b>EncodeString()</b> function so that it appears
as follows:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>STDMETHODIMP CEncoder::EncodeString(const BSTR instring, BSTR *outstring)
{
     BSTR tempstring = ::SysAllocString(instring);
     wcscpy(tempstring, instring);

     for(UINT i = 0; i &lt; ::SysStringLen(tempstring); i++)
          tempstring[i] += m_Key;

     *outstring = ::SysAllocString(tempstring);

     ::SysFreeString(tempstring);

     return S_OK;
}</pre>
</td></tr>
</table>
</p>
</ol>

<p>It may help you to understand the function above if you know a little more about
BSTRs. A BSTR is essentially a pointer to a wide-character string (<i>*wchar_t</i>).
You can see how the code just shown uses a BSTR as a parameter to the <b>wscpy()</b>
standard library function. However, a BSTR is more than just an array of 
characters&#8212;it is prefixed with a 4-byte integer that indicates the number of bytes
that the string contains. This means that you <i>must</i> allocate space for a BSTR
using the Win32 function <b>SysAllocString()</b>. The example above 
allocates a BSTR from an existing BSTR. Alternatively, you can allocate a BSTR from a
<i>wchar_t</i> array as shown here:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>wchar_t wszPeas[] = L&quot;Visualize Whirled Peas&quot;;
BSTR bstrPeas = ::SysAllocString(wszPeas);</pre>
</td></tr>
</table>
</p>

<p>When you have finished with a BSTR, deallocate it using <b>SysFreeString()</b>. Note
that the BSTR <i>outstring</i> in our example is not deallocated because it needs to be
passed back to the client. In COM, it is the client's responsibility to free
resources allocated by a server at a client's request.</p>

<p>You will also notice that the <b>EncodeString()</b> function makes use of the 
<b>SysStringLen()</b> function to discover the length (in characters) of the BSTR.</p>

<p>You can now build your EncodeServer project. If compilation and linking are successful,
Visual Studio takes the additional step of registering your <b>Encoder</b> object on
the local computer so that client applications will be able to use the services of the
<b>Encoder</b> object. In <A HREF="ch11a.htm">Chapter 11</A>, you will develop a client program that does just
that.</p>

<A NAME="364"><H2>Lesson Summary</H2></A>

<p>When you want to create COM objects, the simplest approach is to employ ATL. This
framework provides several wizards to aid you, including the ATL COM AppWizard, the ATL
Object Wizard, the Add Method to Interface Wizard, and the Add Property to Interface
Wizard. These wizards let you harness ATL to
generate all the COM-specific boilerplate code necessary to implement a COM object.
Your focus can thus be on the implementation of the interface properties and methods
exposed by your COM object. The net result is higher productivity.</p>

</BODY>
</HTML>







