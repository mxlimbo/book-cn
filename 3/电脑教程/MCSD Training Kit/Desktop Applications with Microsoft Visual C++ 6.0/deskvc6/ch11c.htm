<HTML>
<HEAD>
<TITLE>Lesson 2: Creating ActiveX Controls with ATL</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11b.htm", "ch11d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="418"><H1>Lesson 2: Creating ActiveX Controls with ATL</H1></A>

<p>In this lesson, you will re-implement the OneArmedBandit ActiveX control using ATL. By doing this, you will be able to compare the differences between MFC
and ATL control development techniques and assess which technology is most suited to
your needs.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe how to develop ActiveX controls using ATL.</li></p>

<p><li> Describe how to add properties and methods to your control.</li></p>

<p><li> Describe how to implement a control property page and make properties persistent.</li></p>

<p><li> Describe how to use ATL's implementation of the COM connection point
architecture to add events to your control.</li></p>
</ul>
<b>Estimated lesson time: 50 minutes</b>
</blockquote></div>
</p>

<A NAME="419"><H2>Adding Controls to an ATL COM Project</H2></A>

<p>As with any ATL COM development, you start by creating an ATL project and then add
individual COM objects using the ATL Object Wizard. In the following exercises, you
will create a DLL project to host your control, and then you'll add your ATL
ActiveX control.</p>

<p><li> <b>To create the OneArmedBanditATL project</b></li></p>

<ol>
<p><li> On the <b>File</b> menu, click <b>New</b>. On the <b>Projects</b> tab, click <b>
ATL COM AppWizard</b>.</li></p>

<p><li> In the <b>Project name</b> box, type <b>OneArmedBanditATL</b> and click <b>
OK</b>.</li></p>

<p><li> In the <b>ATL COM AppWizard</b> dialog box, ensure that <b>Dynamic Link Library (DLL</b>) is selected and click <b>Finish</b>.</li></p>

<p><li> Review the <b>New Project Information</b> dialog box and click <b>OK</b>.</li></p>
</ol>

<p><li> <b>To add the ATLBandit ActiveX control</b></li></p>

<ol>
<p><li> On the <b>Insert</b> menu, click <b>New ATL Object</b>.</li></p>

<p><li> In the <b>Category</b> list, click <b>Controls</b>. The <b>ATL Object Wizard</b>
should appear as shown in Figure 11.5.</li></p>

<p>
<A HREF="javascript:fullSize('f11DA05x.htm')"> <img src="images/f11DA05.jpg" width=404 height=251 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 11.5</b> <i>ATL Object Wizard control options</i><!-- /caption -->
</p>

<p>The ATL Object Wizard displays a number of different types of controls that you can
create, including:</p>

	<ul>
	<p><li> <b>Full controls</b> Controls that can be embedded in any container that complies
	with ActiveX guidelines.</li></p>
	
	<p><li> <b>Lite controls</b> Controls that can be embedded in Internet Explorer, but that
	do not support interfaces required by many other containers.</li></p>
	
	<p><li> <b>Composite controls</b> Controls such as dialog boxes that are capable of
	containing other ActiveX controls.</li></p>
	
	<p><li> <b>HTML controls</b> Controls that use an embedded Web-browser control to display
	an HTML page. You'll learn more about these in <A HREF="ch12a.htm">Chapter 12</A>.</li></p>
	</ul>

<p><li> In the <b>Objects</b> list, click <b>Full Control</b>. Click <b>Next</b>.</li></p>

<p><li> Click the <b>Names</b> tab. In the <b>Short Name</b> box, type <b>
ATLBandit</b>.</li></p>

<p><li> On the <b>Attributes</b> tab, select the <b>Support Connection Points</b>
option.</li></p>

<p><li> On the <b>Stock Properties</b> tab, use the <b>&gt;</b> button to move the <b>
Background Color</b> and the <b>Foreground Color</b> stock properties from the <b>Not
Supported</b> list to the <b>Supported</b> list, as shown in Figure 11.6.</li></p>

<p>
<A HREF="javascript:fullSize('f11DA06x.htm')"> <img src="images/f11DA06.jpg" width=404 height=268 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 11.6</b> <i>Selecting stock properties in the ATL Object Wizard</i><!-- /caption -->
</p>

<p><li> Click <b>OK</b> to add the <b>ATLBandit</b> ActiveX control to the project.</li></p>
</ol>

<p>In ClassView, you see that the wizard has added the <b>IATLBandit</b> interface and
the <b>CATLBandit</b> implementation class. The <b>CATLBandit</b> class is derived from
the ATL <b>CComControl</b> class (as well as many others). Open the ATLBandit.h file
and locate the COM map structure. You see that the <b>CATLBandit</b> class supports the
many interfaces that are required by ActiveX control containers.</p>

<p>Directly beneath the COM map, you will see this property map structure:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_PROP_MAP(CATLBandit)
     PROP_DATA_ENTRY(&quot;_cx&quot;, m_sizeExtent.cx, VT_UI4)
     PROP_DATA_ENTRY(&quot;_cy&quot;, m_sizeExtent.cy, VT_UI4)
     PROP_ENTRY(&quot;BackColor&quot;, DISPID_BACKCOLOR, CLSID_StockColorPage)
     PROP_ENTRY(&quot;ForeColor&quot;, DISPID_FORECOLOR, CLSID_StockColorPage)
     // Example entries
     // PROP_ENTRY(&quot;Property Description&quot;, dispid, clsid)
     // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()</pre>
</td></tr>
</table>
</p>

<p>ATL creates the property map structure to make implementing property persistence
easy. You can see in the code just shown that entries for the stock properties,
including the dimensions of the control, have already been added to the property map.
Note that the <b>PROP_ENTRY</b> macros allow you to associate
a property page with a property, and that the color stock property page has
already been specified for your <b>ForeColor</b> and <b>BackColor</b>
properties.</p>

<A NAME="420"><H2>Adding Properties</H2></A>

<p>You will now add the <b>NumberOfSymbols</b> custom property to the control
class.</p>

<p><li> <b>To add the NumberOfSymbols property</b></li></p>

<ol>
<p><li> In ClassView, right-click the <b>IATLBandit</b> interface item. Click <b>
Add Property</b>.</li></p>

<p><li> In the <b>Add Property To Interface</b> dialog box, select <b>short</b> for the
property type. In the <b>Property Name</b> box, enter <b>NumberOfSymbols</b>.</li></p>

<p><li> Click <b>OK</b> to create the functions that implement the property.</li></p>
</ol>

<p>Remember that when you are working with ATL, you must define a member variable to
hold the data and provide implementations of the <b>Get</b> and <b>Put</b> functions so
that you can pass data to and from this member variable.</p>

<p><li> <b>To implement the NumberOfSymbols property</b></li></p>

<ol>
<p><li> Add a protected member variable named <b>m_numberOfSymbols</b> of type <b>
short</b> to the <b>CATLBandit</b> class.</li></p>

<p><li> In ClassView, expand the <b>IATLBandit</b> interface under the <b>CATLBandit</b>
class item to locate the <b>get_NumberOfSymbols()</b> and <b>put_NumberOfSymbols()</b>
functions. Implement these functions as shown in the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>STDMETHODIMP CATLBandit::get_NumberOfSymbols(short *pVal)
{
     *pVal = m_numberOfSymbols;

     return S_OK;
}

STDMETHODIMP CATLBandit::put_NumberOfSymbols(short newVal)
{
     newVal = newVal &lt; 3 ? 3 : newVal;
     newVal = newVal &gt; 7 ? 7 : newVal;

     m_numberOfSymbols = newVal;
     SetDirty(TRUE);

     return S_OK;
}</pre>
</td></tr>
</table>
</p>
</ol>

<p>You should note that the <b>put_ NumberOfSymbols()</b> function ensures that the <b>
NumberOfSymbols</b> property is set to a valid value. Note also the call to the <b>
SetDirty()</b> function. This function should be called when the value of a persistent
property is changed, so that the container can ask the user whether to save or abandon
changes to the control's state. You will implement persistence for the <b>
NumberOfSymbols</b> property after you have added a property page that allows access to
the property value.</p>

<A NAME="421"><H2>Adding Events</H2></A>

<p>You will now implement the <b>Click</b> and <b>Jackpot</b> events for your control.
To help you understand how COM events are implemented, open the project IDL file,
OneArmedBanditATL.idl, and look at the type library definition, which is shown below.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[
     uuid(39623002-6FAA-11D3-935D-0080C7FA0C3E),
     version(1.0),
     helpstring(&quot;OneArmedBanditATL 1.0 Type Library&quot;)
]
library ONEARMEDBANDITATLLib
{
     importlib(&quot;stdole32.tlb&quot;);
     importlib(&quot;stdole2.tlb&quot;);

     [
          uuid(39623010-6FAA-11D3-935D-0080C7FA0C3E),
          helpstring(&quot;_IATLBanditEvents Interface&quot;)
     ]
     dispinterface _IATLBanditEvents
     {
          properties:
          methods:
     };

     [
          uuid(3962300F-6FAA-11D3-935D-0080C7FA0C3E),
          helpstring(&quot;ATLBandit Class&quot;)
     ]
     coclass ATLBandit
     {
          [default] interface IATLBandit;
          [default, source] dispinterface _IATLBanditEvents;
     };
};</pre>
</td></tr>
</table>
</p>

<p>The definition of the ONEARMEDBANDITATLLib type library contains the definition of a
dispatch interface named <b>_IATLBanditEvents</b>. This interface
is declared inside the <b>ATLBandit</b> coclass block&#8212;indicating that the
ATLBandit control exposes the <b>_IATLBanditEvents</b> interface. Notice, however, that
the in-terface is declared with the <b><i>[source]</i></b> IDL
attribute, which indicates that the <b>_IATLBanditEvents</b> interface is a source of
events. This kind of interface is known as a <i>connection point</i>. COM objects that
expose connection points implement the <b>IConnectionPointContainer</b> interface,
which manages the connection of source interfaces to a corresponding client object
known as a <i>sink</i>. A sink object implements methods defined by the source object.
Through the connection point mechanism, a pointer to the sink object's interface is
passed to the source object. This pointer provides the source with access to the
sink's implementation of its methods. To fire an event, the source object calls the
corresponding method on the sink interface.</p>

<p>The first stage of defining an event is to add a method to the source interface to
represent the event.</p>

<p><li> <b>To add the Click() and Jackpot() event methods</b></li></p>

<ol>
<p><li> In ClassView, right-click the <b>_IATLBanditEvents</b> interface item. Click <b>
Add Method</b> on the shortcut menu.</li></p>

<p><li> Select <b>void</b> as the return type. Enter <b>Click</b> as the method
name.</li></p>

<p><li> Repeat the process to create a <b>void</b> method with the name <b>
Jackpot</b>.</li></p>
</ol>

<p>After you have added the event methods to the source interface, you use an ATL
Wizard to implement a connection point. ATL uses information from the type library to
achieve this implementation, which means that the type library must first be
compiled.</p>

<p><li> <b>To compile the type library</b></li></p>

<ol>
<p><li> Switch to FileView and locate the OneArmedBanditATL.idl file.</li></p>

<p><li> Right-click <b>OneArmedBanditATL.idl</b> and then click <b>Compile
OneArmedBanditATL.idl</b>.</li></p>

<p><li> When the compile is completed, switch back to ClassView.</li></p>
</ol>

<p>Now you can use the ATL Wizard to implement the connection point.</p>

<p><li> <b>To implement a connection point for the ATLBandit control</b></li></p>

<ol>
<p><li> Right-click the <b>CATLBandit</b> class item and then click <b>Implement
Connection Point</b>. The Implement Connection Point Wizard displays as shown in Figure
11.7.</li></p>

<p>
<A HREF="javascript:fullSize('f11DA07x.htm')"> <img src="images/f11DA07.jpg" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 11.7</b> <i>The Implement Connection Point Wizard</i><!-- /caption -->
</p>

<p><li> In the Implement Connection Point Wizard, select the <b>_IATLBanditEvents</b>
checkbox and click <b>OK</b>.</li></p>
</ol>

<p>The wizard creates a <i>proxy class</i> (nothing to do with the proxy objects used
in marshaling), which contains proxy functions that implement the event methods you
added to your event interface. If you look in ClassView, you will see that
the <b>CProxy_IATLBanditEvents</b> class has been added to your project, and that it
provides the functions <b>Fire_Click()</b> and <b>Fire_Jackpot()</b> that you use to
fire control events. ATL alters the definition of the <b>CATLBandit</b> class so that
it derives from the <b>CProxy_IATLBanditEvents class</b>, making the <b>
Fire_Click()</b> and <b>Fire_Jackpot()</b> methods accessible as members of your
control class.</p>

<p>The Implement Connection Point Wizard also creates the following connection point map
within your class.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_CONNECTION_POINT_MAP(CATLBandit)
     CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
     CONNECTION_POINT_ENTRY(DIID__IATLBanditEvents)
END_CONNECTION_POINT_MAP()</pre>
</td></tr>
</table>
</p>

<p>Make sure that the connection point map appears exactly as just shown&#8212;ATL
sometimes fails to implement this map correctly, causing compilation errors.</p>

<p>You are now in a position to use the event proxy functions to fire events from your
control. To demonstrate this, you will implement a handler function that fires a <b>
Click()</b> event when you click inside the control.</p>

<p><li> <b>To implement the OnLButtonDown() handler function</b></li></p>

<ol>
<p><li> In ClassView, right-click the <b>CATLBandit</b> class item. On the shortcut
menu, click <b>Add Windows Message Handler</b>.</li></p>

<p><li> In the <b>New Windows messages/events</b> list, click <b>
WM_LBUTTONDOWN</b>.</li></p>

<p><li> Click <b>Add and Edit</b> to add the <b>OnLButtonDown()</b> function and jump
to the implementation code, which is declared inline in the <b>CATLBandit</b> class
definition. Note that ATL maintains its own kind of message map, which is located just
below the connection point map.</li></p>

<p><li> Replace the //TODO comment inside the <b>OnLButtonDown()</b> function
implementation with the following single line of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Fire_Click();</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="422"><H2>Adding Methods</H2></A>

<p>You will now add the <b>Play()</b> method to the control interface and provide the
code to implement the method.</p>

<p><li> <b>To add the Play() method</b></li></p>

<ol>
<p><li> In ClassView, right-click the <b>IATLBandit</b> interface. Click <b>Add
Method</b> on the shortcut menu.</li></p>

<p><li> In the <b>Add Method to Interface</b> dialog box, type <b>Play</b> in the <b>
Method Name</b> box.</li></p>

<p><li> Click <b>OK</b> to create the method.</li></p>
</ol>

<p><li> <b>To implement the Play() method</b></li></p>

<ol>
<p><li> As you did with the MFC OneArmedBandit control in <a href="ch11b.htm#404">Lesson 1</a>, add the
following protected member variable to the <b>CATLBandit</b> class:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>TCHAR m_symbols[3];</pre>
</td></tr>
</table>
</p>

<p>To the CATLBandit constructor, add the following line to initialize the string:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>_tcscpy(m_symbols, _T(&quot;JJJ&quot;));</pre>
</td></tr>
</table>
</p>

<p><li> In ClassView, expand the <b>IATLBandit</b> interface beneath the <b>
CATLBandit</b> class item.</li></p>

<p><li> Double-click the <b>Play()</b> method underneath the <b>IATLBandit</b> interface
item to edit the <b>CATLBandit::Play()</b> implementation function.</li></p>

<p><li> Add code to the body of the <b>CATLBandit::Play()</b> function so that it appears as follows:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH11_03.cpp, installed from the companion CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>STDMETHODIMP CATLBandit::Play()
{
     srand((unsigned)time(NULL));

     _tcscpy(m_symbols, _T(&quot;JJJ&quot;));

     for(int i = 0; i &lt; 3; i++)
          m_symbols[i] += UINT(rand() % m_numberOfSymbols);

     // repaint control
     m_spInPlaceSite-&gt;InvalidateRect(NULL, TRUE);

     if(m_symbols[0] == m_symbols[1] &amp;&amp;
          m_symbols[1] == m_symbols[2])
          Fire_Jackpot();

     return S_OK;
}</pre>
</td></tr>
</table>
</p>

<p><li> To the top of the ATLBandit.cpp file, add the following line:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &lt;time.h&gt;</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="423"><H2>Creating Property Pages</H2></A>

<p>You will now implement the <b>Symbols</b> property page, which will enable users to
set the value of the <b>NumberOfSymbols</b> custom property. ATL sets up each page of a
control's property sheet as a separate object, implemented by a class derived from
<b>IPropertyPage</b>. In the following exercise, you will insert a new property page
class into your project.</p>

<p><li> <b>To add the Symbols property page</b></li></p>

<ol>
<p><li> On the <b>Insert</b> menu, click <b>New ATL Object</b>. In the <b>Category</b>
list, click <b>Controls</b>.</li></p>

<p><li> In the <b>Objects</b> list, click <b>Property Page</b>. Click <b>Next</b>.</li></p>

<p><li> Click the <b>Names</b> tab. In the <b>Short Name</b> box, type <b>
BanditPP</b>.</li></p>

<p><li> On the <b>Strings</b> tab, type <b>Symbols</b> in the <b>Title</b> box. Delete
the text in the other two boxes.</li></p>

<p><li> Click <b>OK</b> to add the property page. A dialog template for the page opens
in the dialog editor.</li></p>

<p><li> Create the dialog template just as you did for the MFC control (refer back to
Figure 11.4). Add a static text control and a numeric edit control with the ID <b>
IDC_NUMSYMBOLS</b>.</li></p>
</ol>

<p>If you switch back to ClassView, you will see that the <b>CBanditPP</b> class has
been added to the project. The ATL Object Wizard has provided an implementation of the
<b>IPropertyPageImpl::Apply()</b> function for this class. <b>Apply()</b> is
executed when the user of the property page clicks the <b>OK</b> or <b>Apply</b>
button.  You will add code to provide an implementation of this function.</p>

<p><li> <b>To implement the CBanditPP::Apply() function</b></li></p>

<p>Locate the <b>CBanditPP::Apply()</b> function in the BanditPP.h file. Replace
the example code with the following implementation:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>STDMETHOD(Apply)(void)
{
     CComQIPtr&lt;IATLBandit&gt; pIBandit(m_ppUnk[0]);

     pIBandit-&gt;put_NumberOfSymbols(GetDlgItemInt(IDC_NUMSYMBOLS));

     m_bDirty = FALSE;
     return S_OK;
}</pre>
</td></tr>
</table>
</p>

<p>This function sets the control's <b>NumberOfProperties</b> property with the
integer value retrieved from the edit control. Notice the use of the ATL smart pointer
class <b>CComQIPtr</b> to retrieve an <b>IATLBandit</b> pointer. The member variable
m_ppUnk is an array of <b>IUnknown</b> pointers to the objects associated with the
property page.</p>

<p>The <b>Apply()</b> function stores the value in the edit control to the persistent <b>
IATLBandit::NumberOfSymbols</b> property. You will also need to create a
function to initialize the edit control with the property value. This function is
essentially the <b>Apply()</b> function in reverse.</p>

<p><li> <b>To implement the CBanditPP::OnInitDialog() function</b></li></p>

<ol>
<p><li> In ClassWizard, right-click the <b>CBanditPP</b> class item. Click <b>Add
Windows Message Handler</b> on the shortcut menu.</li></p>

<p><li> In the <b>New Windows messages/events</b> list, click the <b>WM_INITDIALOG</b>
message.</li></p>

<p><li> Click <b>Add and Edit</b> to add the <b>OnInitDialog()</b> function and jump to
the implementation code.</li></p>

<p><li> Implement the function as shown in the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, 
     BOOL&amp; bHandled)
{
     CComQIPtr&lt;IATLBandit&gt; pIBandit(m_ppUnk[0]);

     short i = 0;
     pIBandit-&gt;get_NumberOfSymbols(&amp;i);
     SetDlgItemInt(IDC_NUMSYMBOLS, i);
     return 0;
}</pre>
</td></tr>
</table>
</p>

<p>At this point, you should also add a notification function to indicate that the
property page has been modified. This function should handle the <b>EN_CHANGE</b> event
that fires when the user changes the value in the edit control.</p>
</ol>

<p><li> <b>To implement the CBanditPP::OnChangeNumsymbols() function</b></li></p>

<ol>
<p><li> In ClassWizard, right-click the <b>CBanditPP</b> class item. Click <b>Add
Windows Message Handler</b> on the shortcut menu.</li></p>

<p><li> In the <b>Class or object to handle</b> list, click the <b>
IDC_NUMSYMBOLS</b> object.</li></p>

<p><li> In the <b>New Windows messages/events</b> list, click the <b>EN_CHANGE</b>
event.</li></p>

<p><li> Click <b>Add and Edit</b> and then click <b>OK</b> to add the <b>
OnChangeNumsymbols()</b> function and jump to the implementation code.</li></p>

<p><li> Replace the //TODO comment with the following line of code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SetDirty(TRUE);</pre>
</td></tr>
</table>
</p>
</ol>
<p>Now that you have fully implemented the property page, you can add an entry
to the control class property map to make the <b>NumberOfSymbols</b> property
persistent.</p>

<p><li> <b>To make the NumberOfSymbols property persistent</b></li></p>

<ol>
<p><li> Locate the property map in the ATLBandit.h file.</li></p>

<p><li> Add a new entry for the <b>NumberOfSymbols</b> property so that the property map
appears as follows:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_PROP_MAP(CATLBandit)
     PROP_DATA_ENTRY(&quot;_cx&quot;, m_sizeExtent.cx, VT_UI4)
     PROP_DATA_ENTRY(&quot;_cy&quot;, m_sizeExtent.cy, VT_UI4)
     PROP_ENTRY(&quot;NumberOfSymbols&quot;, 1, CLSID_BanditPP)
     PROP_ENTRY(&quot;BackColor&quot;, DISPID_BACKCOLOR, CLSID_StockColorPage)
     PROP_ENTRY(&quot;ForeColor&quot;, DISPID_FORECOLOR, CLSID_StockColorPage)
END_PROP_MAP()</pre>
</td></tr>
</table>
</p>
</ol>

<p>The second parameter to the <b>PROP_ENTRY</b> macro is the <i>DISPID</i>, which
can be found in the IDL file. The <b>CLSID_BanditPP</b> constant is defined in the
OneArmedBanditATL_i.c file.</p>

<A NAME="424"><H2>Drawing the Control</H2></A>

<p>All that remains is to implement the drawing code. Like the MFC <b>COleControl</b>
class, the <b>CComControl</b> class provides an <b>OnDraw()</b> function to contain all
the drawing code. The <b>CComControl::OnDraw()</b> function receives a reference to an
<b>ATL_DRAWINFO</b> structure that contains, among other things, a handle to a device
context and a pointer to a <b>RECT</b> structure that denotes the bounding rectangle of
the control. The device context is an <b>HDC</b>, the raw Windows data type that is
wrapped by the MFC class <b>CDC</b>. This means that you have to use the GDI API
functions to render your control. The GDI functions are similar to their <b>CDC</b>
counterparts, the main difference being that they receive the <b>HDC</b> as the first
argument. If you compare the implementation of <b>CATLBandit::OnDraw()</b> with the <b>
COneArmedBanditCtrl::OnDraw()</b> function in the previous lesson, you will get a
pretty good idea of how it all works.</p>

<p><li> <b>To implement the CATLBandit::OnDraw() function</b></li></p>

<p>Replace the function in ATLBandit.h with the following version:</p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH11_04.cpp, installed from the companion CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HRESULT OnDraw(ATL_DRAWINFO&amp; di)
{
     const RECT&amp; rc = *reinterpret_cast&lt;const RECT*&gt;(di.prcBounds);
     HDC dc = di.hdcDraw;

     COLORREF colorBack, colorFore;
     OleTranslateColor(m_clrForeColor, NULL, &amp;colorFore);
     OleTranslateColor(m_clrBackColor, NULL, &amp;colorBack);

     // Get dimensions of control
     float ctrlWidth = float(rc.right - rc.left);
     float ctrlHeight = float(rc.bottom - rc.top);

     // Set up DC
     HBRUSH brush = CreateSolidBrush(colorBack);
     HBRUSH oldBrush = static_cast&lt;HBRUSH&gt;(SelectObject(dc, brush));

     HPEN pen = CreatePen(PS_SOLID, 3, colorFore);
     HPEN oldPen = static_cast&lt;HPEN&gt;(SelectObject(dc, pen));

     HFONT SymbolFont = CreateFont(long(ctrlHeight / 1.1),
          long(ctrlWidth/6), 0, 0, 0, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0,
          0,&quot;WingDings&quot;);

     HFONT oldFont = static_cast&lt;HFONT&gt;(SelectObject(dc, SymbolFont));

     // Draw bounding rectangle
     Rectangle(dc, rc.left, rc.top, rc.right, rc.bottom);
     SetBkMode(dc, TRANSPARENT);

     // Draw text
     SetTextColor(dc, colorFore);
     RECT rect;
     CopyRect(&amp;rect, &amp;rc);

     TCHAR strDisplay[5];
     _stprintf(strDisplay, &quot;%c %c %c&quot;, 
          m_symbols[0], m_symbols[1], m_symbols[2]);

     DrawText(dc, strDisplay, 5, &amp;rect, DT_SINGLELINE | DT_CENTER | 
          DT_VCENTER );

     // Draw vertical bars
     long onethird = long(ctrlWidth / 3);
     POINT ptTop = { rc.left, rc.top };
     POINT ptBtm = { rc.left, rc.bottom };

     ptTop.x += onethird; ptBtm.x += onethird;
     MoveToEx(dc, ptTop.x, ptTop.y, NULL);
     LineTo(dc, ptBtm.x, ptBtm.y);

     ptTop.x += onethird; ptBtm.x += onethird;
     MoveToEx(dc, ptTop.x, ptTop.y, NULL);
     LineTo(dc, ptBtm.x, ptBtm.y);

     // Restore device context
     SelectObject(dc, oldFont);
     SelectObject(dc, oldPen);
     SelectObject(dc, oldBrush);

     DeleteObject(brush);
     DeleteObject(pen);
     DeleteObject(SymbolFont);

     return S_OK;
}</pre>
</td></tr>
</table>
</p>


<p>You can now build the <b>ATLBandit</b> control. Load the control into the ActiveX
Control Test Container to test the control display, the property pages, the property
persistence, the <b>Play()</b> method, and the <b>Click</b> and <b>Jackpot</b>
events.</p>

<A NAME="425"><H2>MFC or ATL?</H2></A>

<p>By now you should have a good idea of the differences between MFC and ATL ActiveX
control development. MFC makes it very easy to develop controls, shielding you from
most of the complexities of COM programming. Although developing controls with ATL
involves more work, as your COM expertise develops you might come to appreciate the
greater degree of control that ATL
affords.</p>

<p>ActiveX controls written in ATL are smaller than their MFC counterparts, and
if written properly will perform better. A self-contained (MinDependency)
build of the ATLBandit project results in a control that is 100 KB in size. The
OneArmedBandit.ocx, when statically linked to the MFC libraries, is about
264 KB. When the component is dynamically linked to the MFC libraries, its size drops
to about 36 KB, making MFC an attractive proposition when developing for target
platforms where you can expect the MFC DLLs to be installed.</p>

<A NAME="426"><H2>Lesson Summary</H2></A>

<p>ATL can be used to create small, high-performance ActiveX controls that are suitable
for use in any ActiveX control container. In ATL, ActiveX controls are implemented by a
class that inherits from the <b>CComControl</b> class. ActiveX controls also implement
the many COM interfaces that are required by ActiveX control containers. ATL control
classes implement a property map structure to implement property persistence, a message
map to handle Windows messages, and COM connection points to implement ActiveX events.
You can insert a property page COM object into your project to implement a property
page for your control. You draw your control using GDI API functions inside the <b>
CComControl::OnDraw()</b> function.</p>

</BODY>
</HTML>







