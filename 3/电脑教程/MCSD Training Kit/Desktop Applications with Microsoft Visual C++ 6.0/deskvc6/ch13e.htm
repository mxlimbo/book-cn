<HTML>
<HEAD>
<TITLE>Lesson 4: Using the Integrated Debugger</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13d.htm", "ch13f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="492"><H1>Lesson 4: Using the Integrated Debugger</H1></A>

<p>Armed with the general overview of debugging provided in <a href="ch13d.htm#487">Lesson 3</a>, you are now ready
to use the Visual C++ debugger. As you will see, the debugger greatly facilitates the
debugging process and can help you find nearly any bug you are likely to encounter in
Windows software development.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Use the Visual C++ integrated debugger and understand the extensive information
presented in the debugger windows.</li></p>
<p><li> Monitor a running program and set breakpoints to interrupt the program.</li></p>
<p><li> Single-step through a program.</li></p>
<p><li> Use the debugger's <b>Edit and Continue</b> feature to correct code on the
fly while debugging.</li></p>
<p><li> Debug COM-based programs and components.</li></p>
<p><li> Use the Test Container utility to monitor ActiveX controls.</li></p>
</ul>
<b>Estimated lesson time: 40 minutes</b>
</blockquote></div>
</p>


<A NAME="493"><H2>Breakpoints</H2></A>

<p>The debugger does not interrupt the program being debugged. Rather, the program
interrupts itself when it locates a marker set in the text editor. The marker is called
a <i>breakpoint</i>. As the program executes, the debugger sleeps. It regains control
when the executing program triggers a breakpoint.</p>

<p>The debugger recognizes two different types of breakpoints, one based on location in
the code, and the other based on program data. A <i>location breakpoint</i> is a marker
attached to a particular instruction in your source code, similar to using a bookmark
in the Visual C++ text editor. A <i>data breakpoint</i> depends on data instead of
code. Use a data breakpoint to suspend execution of your program when the value of a
variable changes. A data breakpoint can be useful if you suspect a variable is being
incorrectly altered in your program, but you aren't sure in which location. The
data breakpoint triggers the debugger to interrupt execution when the variable changes
or becomes a certain value (for example, when a pointer is reassigned or when the
variable <i>x</i> exceeds a value of 500).</p>

<A NAME="494"><H2>Setting Breakpoints</H2></A>

<p>The text editor is the best place to begin debugging. Location breakpoints are by
far the most commonly used breakpoints, and are easy to set in the Visual C++ debugger.
You simply need to have a general idea of where you think your program is going
wrong.</p>

<p><li> <b>To set a location breakpoint</b></li></p>

<ol>
<p><li> Open the program's source files and locate the line where you want to
interupt the execution of the program.</li></p>

<p><li> Click anywhere on the line to place the insertion point there, then press F9 to
set a location breakpoint. The editor marks the line by placing a small red dot in the
selection margin to the left of the line.</li></p>

<p><li> To remove a location breakpoint, press F9 again to toggle the breakpoint
off.</li></p>

<p><li>You can also set or remove a location breakpoint by right-clicking the line. On the shortcut menu that appears (shown in Figure 13.4), select the <b>Insert/Remove Breakpoint</b> command to set or clear a breakpoint.</li></p>
</ol>

<p>
<img src="images/F13DA04.JPG" width=202 height=334 border=0>
</p><p>
<!-- caption --><b>Figure 13.4</b> <i>The <b>Insert/Remove Breakpoint</b> command</i><!-- /caption -->
</p>

<p>Though less convenient, you can also set a location breakpoint through the <b>
Breakpoints</b> dialog box. This dialog box provides the only means for setting data
breakpoints and two other variations, called <i>conditional breakpoints</i> and <i>
message breakpoints</i>. Conditional breakpoints trigger as soon as a variable is set to a specified value. Message breakpoints trigger as soon as a specified message is received by a window.</p>

<A NAME="495"><H2>Breakpoints Dialog Box</H2></A>

<p>To invoke the <b>Breakpoints</b> dialog box shown in Figure 13.5, press CTRL+B or
click the <b>Breakpoints</b> command on the <b>Edit</b> menu. The three tabs in the
dialog box let you set location, data, conditional, and message breakpoints.</p>


<p>
<img src="images/F13DA05.JPG" width=402 height=335 border=0>
</p><p>
<!-- caption --><b>Figure 13.5</b> <i>The <b>Breakpoints</b> dialog box</i><!-- /caption -->
</p>

<A NAME="496"><H3>Location Breakpoints</H3></A>

<p>The <b>Breakpoints</b> dialog box provides several enhancements for location
breakpoints that often prove useful. For instance, you can type the name of a function
in the <b>Break At</b> text box to set a location breakpoint at the first line of the
function, or type the name of a label to set a breakpoint at the labeled line. The text
in the <b>Break At</b> control is case-sensitive, so it must match the function name or
label exactly. A C++ function name must include the class name and scope resolution
operator. Thus, the entry <b>OnInitDialog()</b> does not specify a valid breakpoint location, but <b>CDemoDlg::OnInitDialog()</b> does.</p>

<A NAME="497"><H3>Data Breakpoints</H3></A>

<p>The <b>Breakpoints</b> dialog box provides the only means for setting a data
break-point. On the <b>Data</b> tab in the <b>Breakpoints</b> dialog box, enter the
name of the variable or the expression you want the debugger to monitor. Type an
ex-pression in the form of a standard C/C++ conditional expression, such as the
following:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>i == 100 or nCount &gt; 25</pre>
</td></tr>
</table>
</p>

<p>The debugger can monitor a range of variables identified by a pointer, such as an
array or structure name, provided you dereference the pointer in the expression.</p>

<p><li> <b>To set a data breakpoint for an array or structure</b></li></p>

<ol>
<p><li> In the <b>Breakpoints</b> dialog box, click the <b>Data</b> tab.</li></p>

<p><li> For an array, type the array name followed by <b>[0]</b> to dereference the
pointer&#8212;<b>iArray[0]</b>, for example.</li></p>

<p><li> To monitor more than just the first element of the array, set the number of elements to monitor in the text box labeled <b>Enter the number of elements in an
array or structure</b>. Notice that this is the number of elements, not the number of
bytes.</li></p>

<p><li>To set a data breakpoint for a structure, precede the pointer variable
with the asterisk dereference operator, as in <b>pStruct</b>.</li></p>

</ol>

<p>Similarly, to monitor a string of character bytes that the variable pString points
to, type <b>*pString</b> in the <b>Enter The Expression</b> text box. In the <b>Enter
the number of elements</b> text box, type the number of bytes that you want the
debugger to monitor. Typing <b>pString</b> without the asterisk dereference operator
will result in the breakpoint being triggered only if pString is changed to point
somewhere else. In this case, the debugger monitors pString itself, not the contents of
the string to which it points.</p>

<p>Your program's execution speed can slow significantly if you set more than four
data breakpoints, or if any of the data breakpoints are set on a variable residing on
the stack.</p>

<A NAME="498"><H3>Conditional Breakpoints</H3></A>

<p>The debugger responds to a conditional breakpoint only if a specified condition is
TRUE when control reaches the marked instruction. Each time an instruction marked as a
conditional breakpoint executes, the debugger evaluates the expression and suspends
program flow only if the expression does not evaluate to zero.</p>

<p><li> <b>To set a conditional breakpoint</b></li></p>

<ol>
<p><li>In the <b>Breakpoints</b> dialog box, click the <b>Location</b> tab.</li></p>

<p><li>Specify the source code instruction at which to set the breakpoint.</li></p>

<p><li>Click the <b>Condition</b> button (shown in Figure 13.5) to display the <b>
Breakpoint Condition</b> dialog box.</li></p>

<p><li>In the <b>Enter the expression to be evaluated</b> text box, type the
breakpoint condition in the form of a C/C++ conditional expression.</li></p>
</ol>

<A NAME="499"><H3>Message Breakpoints</H3></A>

<p>A message breakpoint attaches to a window procedure. Execution breaks when the window procedure receives a specified message, such as WM_SIZE or WM_COMMAND. Message breakpoints are not always useful in C++ programs that use MFC, since window procedures usually lie buried inside the MFC framework. To trap a specific message in an MFC program, set a location breakpoint for the function that handles the message, which is identified in the
class's message map.</p>

<A NAME="500"><H2>Running the Debugger</H2></A>

<p>Once you have created a debug build and have established where and under what
conditions you want your program to stop, you are ready to execute your program.</p>

<p><li><b>To start the debugger</b></li></p>

<ol>
<p><li>On the <b>Build</b> menu, click <b>Start Debug</b>. You will be presented with
four choices: <b>Go</b>, <b>Step Into</b>, <b>Run to Cursor</b>, and <b>Attach to
Process</b>.</li></p>

<p><li>When you have set at least one breakpoint in the source code, click <b>Go</b>.
The debugger runs the program, suspending execution when the flow of execution in your
program reaches a location breakpoint or triggers a data breakpoint.</li></p>

<p><li>Click <b>Step Into</b> to start program execution, and stop at the first
command.</li></p>

<p><li>Click the <b>Run to Cursor</b> command to run the program and break at the
source line containing the insertion point. If no source file is open in the text
editor, the <b>Run to Cursor</b> command is unavailable. Otherwise, it allows you to
quickly jump into a program without setting a breakpoint.</li></p>

<p><li>Click the <b>Attach to Process</b> command to launch the debugger and
attach it to a program that is currently executing.</li></p>
</ol>

<p>The debugger provides shortcut keys for the first three subcommands of <b>Start
Debug</b>, so you don't have to pull down the <b>Build</b> menu to begin
debugging. The shortcut keys are F5 for <b>Go</b>, F11 for <b>Step Into</b>, and CTRL+F10 for <b>Run to Cursor</b>.</p>

<A NAME="501"><H2>Debugger Windows</H2></A>

<p>When the program you are debugging stops at a breakpoint, the debugger updates its
windows with information about the program's current state. The most important
debugger window is the source window, which shows the source code where the program
stopped. A small yellow arrow, the <i>instruction pointer,</i> appears in the selection
margin to the left of the interrupted instruction. The instruction pointer identifies
the instruction that has not yet executed, but is next in line to do so when the
program resumes execution.</p>

<p>When control is returned to the debugger, the <b>Debug</b> toolbar appears on the
screen. The six buttons identified in Figure 13.6 as debugger windows act as toggles
that expose or hide dockable windows containing information about the current state of
the program. Table 13.4 describes the type of information displayed in the debugger
windows.</p>

<p>
<A HREF="javascript:fullSize('F13DA06x.htm')"> <img src="images/F13DA06.JPG" width=404 height=92 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.6</b> <i>Debugger windows buttons</i><!-- /caption -->
</p>

<p><b>Table 13.4</b> <i>Information Displayed by the Debugger Windows Buttons</i></p>

<table cellpadding=5 width="95%">
<tr><th>Window</th> <th>Information displayed</th></tr>

<tr><td valign="top">Watch</td> <td valign="top">Current values of variables and expressions tracked by the debugger</td></tr>

<tr><td valign="top">Variables</td> <td valign="top">Current values of variables accessed at or near the break location</td></tr>

<tr><td valign="top">Registers</td> <td valign="top">Current contents of the CPU registers</td></tr>

<tr><td valign="top">Memory</td> <td valign="top">Memory contents at a specified address</td></tr>

<tr><td valign="top">Call Stack</td> <td valign="top">List of called functions that have not yet returned</td></tr>

<tr><td valign="top">Disassembly</td> <td valign="top">Assembly language translation of the compiled code that supplements the source window on the screen</td></tr>
</table>

<A NAME="502"><H3>Variables Window and Watch Window</H3></A>

<p>The Variables window displays information about variables relevant to the location
where the program flow has been suspended. Variables referenced by the instruction that
last executed, and usually one or two previous instructions, appear in the Variables
window. You can change the value of a variable by double-clicking it in the Variables
window and typing a new value.</p>

<p>The Watch window shows the current values of specified variables no matter where
they are referenced in the program. To add a variable to the Watch window, double-click
the dotted new-entry box in the window and type the variable name. The QuickWatch tool
shown in Figure 13.6 lets you query for a current value without adding the variable to
the Watch window. If the variable name appears on the screen, the debugger offers a
more convenient way to query for its current value. Simply position the mouse pointer
over the variable name in the Source window to see a ToolTip showing the current
value.</p>

<A NAME="503"><H3>Memory Window and Registers Window</H3></A>

<p>The Memory window shows the contents of memory at a given address. The Memory window
is useful for examining buffers that might not appear in the Variables window.
Determine the value of the buffer pointer by locating it in the Variables or Watch window, then type or paste the address into the text box in the Memory window and press ENTER.</p>

<p>The Registers window shows the state of the processor's registers as they
existed when the program was suspended. The Registers window is generally used only
when the Disassembly window is active, showing the code in assembly language.</p>

<A NAME="504"><H3>Call Stack Window</H3></A>

<p>The Call Stack window shows the route the program has taken to reach the point you
are examining. It answers the question, &quot;How did I get here?&quot;</p>

<p>A <i>call stack</i> is a list of nested functions, each of which have been called
and none of which have yet returned. The list begins with the current function that
contains the point of interruption, and continues in reverse order toward the oldest
parent function. MFC programs often wind through many nested functions hidden in the
framework, so the call stack for these programs can be lengthy.</p>

<A NAME="505"><H2>Stepping Through Code</H2></A>

<p>The <b>Debug</b> toolbar holds a group of four buttons (shown in Figure 13.7) that
allow you to step through a suspended program. You can recognize the Step tools by the
arrows and curly braces on them. In the order shown, the buttons activate the <b>Step
Into</b>, <b>Step Over</b>, <b>Step Out</b>, and <b>Run To Cursor</b> commands.
We've already discussed the <b>Run To Cursor</b> command; this section covers the
<b>Step Into</b>, <b>Step Over</b>, and <b>Step Out</b> commands.</p>

<p>
<A HREF="javascript:fullSize('F13DA07x.htm')"> <img src="images/F13DA07.JPG" width=404 height=121 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.7</b> <i>The <b>Debug</b> toolbar Step tools</i><!-- /caption -->
</p>

<p>The <b>Step Into</b> and <b>Step Over</b> commands (or their respective shortcut
keys F11 and F10) let you single-step through the program. When you select <b>Step
Into</b> or <b>Step Over</b>, the debugger allows the program to resume execution, but for
only one instruction. After the instruction finishes, the debugger again suspends
execution. If the Disassembly view is available, the <b>Step</b> tools act on
individual assembly instructions instead of the high-level C/C++ instructions. If
applied to an instruction that calls a function, <b>Step Over</b> halts at the
instruction following the call, whereas <b>Step Into</b> halts at the first instruction
of the function called. For instructions that do not call a function, <b>Step Into</b>
and <b>Step Over</b> have the same effect.</p>

<p>The <b>Step Out</b> command is useful for leaving a function. The command executes
the rest of the current function, then stops at the next statement following the
function call. In other words, when applied to a function call, the <b>Step Into</b>
and <b>Step Out</b> commands together have the same effect as <b>Step Over</b>.</p>

<A NAME="506"><H2>Edit and Continue</H2></A>

<p>Through its <b>Edit and Continue</b> feature, Visual C++ lets you permanently fix
many problems directly in the debugger's source window, without having to exit the
debugger and recompile. When you continue running the program after editing the source,
Visual C++ first compiles the revised code and replaces the affected module with the
corrected version.</p>

<p><b>Edit and Continue</b> has certain limitations; this feature does not recognize
source changes that are impossible, impractical, or unsafe to compile while debugging,
such as:</p>

<ul>
<p><li>Alterations to exception handler blocks.</li></p>

<p><li>Wholesale deletions of functions.</li></p>

<p><li>Changes to class and function definitions.</li></p>

<p><li>Changes to static functions.</li></p>

<p><li>Changes to resource data in the project's resource (.rc) file.</li></p>
</ul>


<p>Attempting to resume execution through <b>Edit and Continue</b> after making any of
these changes causes the debugger to display an error message in the status bar that
explains the problem. You have the option of continuing to debug using the original
code, or closing the debugger and recompiling the revised code normally.</p>

<A NAME="507"><H2>Debugging COM Components</H2></A>

<p>The Visual C++ debugger easily handles in-process COM components such as ActiveX
controls, though such components require a container application to run them. If you
have written the component's container as another project, it does not matter where
you begin debugging, whether in the container's project or in the component's
project. The debugger crosses the boundary between projects transparently as execution
flow moves from client to server and back again.</p>

<p>To begin debugging in the component's project, first specify the container
application in which you want to embed the component. On the <b>Debug</b> tab of the
<b>Project Settings</b> dialog box, type the container's path and file name in the
text box labeled <b>Executable For Debug Session</b>. You can also browse for the
container by clicking the arrow next to the text box. This action displays a small menu
of choices, one of which is <b>ActiveX Control Test Container</b>.</p>

<A NAME="508"><H3>ActiveX Control Test Container</H3></A>

<p>The Test Container utility shown in Figure 13.8 is a general-purpose container
utility for ActiveX controls. Visual C++ provides the Test Container so that you can
debug and test ActiveX controls without having to write a corresponding container for
them.</p>

<p>
<A HREF="javascript:fullSize('F13DA08x.htm')"> <img src="images/F13DA08.JPG" width=404 height=256 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.8</b> <i>The ActiveX Control Test Container</i><!-- /caption -->
</p>

<p>The first step is to set breakpoints in your project's source files. If you
have chosen the Test Container as the host for your component during debugging, the debugger launches the utility automatically, as it would any other container.
When a breakpoint in the method triggers, focus returns to the Visual C++ debugger,
ready for you to single-step through your source code.</p>

<p>You can also execute the Test Container without the debugger, as the next practice
exercise demonstrates.</p>

<A NAME="509"><H3>Executing ActiveX Controls in the Test Container</H3></A>

<p>In this practice exercise, you will launch the Test Container utility manually,
without starting the debugger. You will learn how to open an ActiveX control in the
Test Container and program it through its methods and properties.</p>

<p><li><b>To start the Test Container</b></li></p>

<ol>
<p><li>On the <b>Tools</b> menu, click <b>ActiveX Control Test Container</b>.</li></p>

<p><li>When the Test Container appears, click <b>New Control</b> on the toolbar, which
displays a list of registered ActiveX controls.</li></p>

<p><li>If you have built your own ActiveX control and it has been properly registered,
locate it in the list. Otherwise, double-click any control in the list to activate it,
such as the <b>Calendar</b> control that comes with Internet Explorer.</li></p>

<p><li>Once the control appears in the Test Container window, click the <b>Invoke
Methods</b> tool to display the <b>Invoke Methods</b> dialog box.</li></p>

<p><li>Click the <b>Method Name</b> box to expose a list of methods that the control
exports. If you have activated the <b>Calendar</b> control or a similar object, select
the <b>BackColor (PropPut)</b> property method in the list. Methods identified as <b>
PropPut</b> write a control property; <b>PropGet</b> methods read a property.</li></p>

<p><li>Enter the new property value in the <b>Parameter Value</b> box. To set a
color, enter the decimal equivalent of an RGB value, such as <b>255</b> for bright
red.</li></p>

<p><li>Click the <b>Invoke</b> button to call the method with the new value. If the
property affects the control's appearance (as does the <b>BackColor</b> property),
you should see the control change accordingly.</li></p>

<p><li>Press DELETE to delete the selected control, then close the Test
Container.</li></p>
</ol>

<A NAME="510"><H3>Debugging Out-of-Process COM Servers</H3></A>

<p>Many out-of-process COM servers can run as stand-alone programs, and thus do not
technically require an executing container. However, as a server's methods and
events execute only when activated by a client, you should specify a path to the client
instead of the server on the <b>Debug</b> tab of the <b>Project Settings</b> dialog
box. Set breakpoints in the server's source code as you want them, then launch the
debugger to automatically start the client application. When both the client and server
are active, switch to the client and invoke the commands necessary to activate the
server's functions that contain the breakpoints. As with an in-process server, the
Visual C++ debugger becomes active when execution reaches a breakpoint. You can then
examine the server's code.</p>

<A NAME="511"><H2>Lesson Summary</H2></A>

<p>This lesson presented the Visual C++ debugger, an invaluable tool for locating the
causes of errors in a program. You learned how to set both location and data
breakpoints through the <b>Breakpoints</b> dialog box, how to launch the debugger, and
how to single-step through code when the debugged program halts at a breakpoint. The
lesson also described the debugger's <b>Edit and Continue</b> feature, which allows
you to correct source code without having to exit the debugger and recompile.</p>

<p>A typical debugging session begins in the text editor. You can set breakpoints in
the project source code, at those sections of your program that you want to interrupt,
before you start the debugger. The debugger in turn automatically starts your program
and gains control when a breakpoint is triggered. The debugger displays six dockable
windows:</p>

<ul>
<p><li><b>Watch</b> displays the values of selected data.</li></p>

<p><li><b>Variables</b> displays information pertaining to the current instruction.</li></p>

<p><li><b>Call Stack</b> contains a list of nested function calls.</li></p>

<p><li><b>Registers</b> displays the current contents of the CPU registers.</li></p>

<p><li><b>Memory</b> displays any area of accessible memory.</li></p>

<p><li><b>Disassembly</b> translates source code into equivalent assembly
instructions.</li></p>
</ul>


<p>In-process ActiveX controls are DLLs and therefore are debugged with the same ease
as normal DLLs. Visual C++ also provides the Test Container utility, which serves as a
general-purpose container application for running ActiveX controls. The Test Container
enables you to debug and test your ActiveX control without having to develop a separate
container for it.</p>

</BODY>
</HTML>







