<HTML>
<HEAD>
<TITLE>Lesson 2: Serialization of Application Data</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06b.htm", "ch06d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="245"><H1>Lesson 2: Serialization of Application Data</H1></A>

<p>Implementing persistence presents special problems in development of object-oriented
applications. A development team must consider how to preserve the structure and
relationships of application objects when storing and retrieving persistent data. This
consideration can be troublesome, since data in a file is typically stored as an
unstructured binary stream. To address this problem, the MFC application framework
implements <i>serialization</i>, which enables you to preserve your application
data's object structure when saving it to, and restoring it from, a persistent
archive.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>


<ul>
<p><li> Understand how the MFC application framework implements serialization.</li></p>

<p><li> Use the overloaded <b>&lt;&lt;</b> and <b>&gt;&gt;</b> operators to serialize
built-in types and MFC types to an archive.</li></p>

<p><li> Make a class serializable.</li></p>

<p><li> Serialize an MFC collection.</li></p>
</ul>


<b>Estimated lesson time: 50 minutes</b>
</blockquote></div>
</p>


<A NAME="246"><H2>MFC Support for Serialization</H2></A>

<p>MFC provides built-in support for serialization through the <b>CObject</b> class.
All classes that implement serialization must derive from <b>CObject</b> and must also
provide an overload of the <b>CObject::Serialize()</b> function. The <b>Serialize()</b>
function's task is to archive selected data members of the class, and save them to
or restore them from an object of the MFC class <b>CArchive</b>.</p>

<p>A <b>CArchive</b> object acts as an intermediary between the object to be serialized
and the storage medium. Also, a <b>CArchive</b> object is always associated with a <b>
CFile</b> object. The <b>CFile</b> object usually represents a disk file, but it can
also represent a memory file. For example, you could associate a <b>CArchive</b> object
with a <b>CSharedFile</b> object to serialize data to and from the Windows Clipboard.
Additionally, a <b>CArchive</b> object provides a type-safe buffering mechanism for
reading and writing serializable objects to and from a <b>CFile</b> object.</p>

<p>A given <b>CArchive</b> object is used either to store data or to load data, but
never both. The life of a <b>CArchive</b> object is limited to one pass, through either
writing objects <i>to</i> a file or reading objects <i>from</i> a file. Separately
created <b>CArchive</b> objects are required to serialize data to a file, and also to
restore data back from a file. The status of a <b>CArchive</b> object, whether used for
storing or loading, can be determined by querying the Boolean return value of the <b>
CArchive::IsStoring()</b> function.</p>

<p>The <b>CArchive</b> class defines both the insertion operator (<b>&lt;&lt;</b>) and
the extraction operator (<b>&gt;&gt;</b>). These operators are used in a manner similar
to the insertion and extraction operators defined for the standard C++ stream classes,
as illustrated by the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if (ar.IsStoring())
{
     ar &lt;&lt; m_string;     
}
else
{
     ar &gt;&gt; m_string;     
}</pre>
</td></tr>
</table>
</p>

<p>You can use the insertion and extraction operators to store data to, and retrieve
data from, a <b>CArchive</b> object. Table 6.2 lists the data types and objects that
can be used with the insertion and extraction operators.</p>

<p><b>Table 6.2</b>  <i>Data Types and Objects Used with Insertion and Extraction Operators</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<td valign="top">CObject*</td><td valign="top"> SIZE and CSize </td><td valign="top">float</td>
</tr>

<tr>
<td valign="top">WORD </td><td valign="top">CString </td><td valign="top">POINT and CPoint</td>
</tr>
<tr>
<td valign="top">DWORD </td><td valign="top">BYTE</td> <td valign="top">RECT and CRect</td>
</tr>

<tr>
<td valign="top">double </td><td valign="top">LONG</td> <td valign="top">CTime and CTimeSpan</td>
</tr>

<tr>
<td valign="top">int </td><td valign="top">COleCurrency</td><td valign="top">COleVariant</td>
</tr>

<tr>
<td valign="top">COleDateTime</td> <td valign="top">COleDateTimeSpan</td><td valign="top"></td>
</tr>
</table>
</p>


<A NAME="247"><H3>Serialization Process</H3></A>

<p>In <a href="ch03e.htm#133">Lesson 4</a> of Chapter 3, you learned that the application data is stored in the
application's document object. Application data is serialized to a document file on
disk, then restored from the document file into the document object. A document file
type is associated with an application by specifying a filename extension in the <b>
Advanced Options</b> dialog box, in Step 4 of the AppWizard (see <a href="ch02b.htm#65">Lesson 1</a> of Chapter
2).</p>

<p>The document object begins application data serialization in response to file
commands selected by the user. A <b>CArchive</b> object of the appropriate type
(according to whether data is to be saved to or restored from the archive) is created
by the framework, and passed as a parameter to the document object's <b>
Serialize()</b> function.</p>

<p>The AppWizard creates a stub <b>Serialize()</b> function for your document class.
You must add code to this function to store or retrieve persistent data members to or
from the archive. You can store and retrieve simple data members using the <b>
&lt;&lt;</b> and <b>&gt;&gt;</b> operators. If the document object contains more
complex objects that implement their own serialization code, you must call the <b>
Serialize()</b> function for those objects, and forward a reference to the current
archive.</p>

<p>As an example, consider an application TestApp that maintains a document class with
three data members, as shown by the following code sample:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Class CtestAppDoc
{
     CString m_string;
     DWORD m_dwVar;
     MyObj m_obj;
}</pre>
</td></tr>
</table>
</p>

<p>Assume that the <b>MyObj</b> class is a serializable class.</p>

<p>The following code illustrates a <b>Serialize()</b> function that might be written for
the <b>TestApp</b> document class:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CTestAppDoc::Serialize(CArchive&amp; ar)
{
     if (ar.IsStoring())
     {
          ar &lt;&lt; m_string;
          ar &lt;&lt; m_dwVar;
     }
     else
     {
          ar &gt;&gt; m_string;
          ar &gt;&gt; m_dwVar;
     }
     m_obj.Serialize(ar);
}</pre>
</td></tr>
</table>
</p>

<p>Note how the <b>MyObj::Serialize()</b> function is called outside of the conditional
branching code, as it contains its own branch condition to determine whether data is
being stored or retrieved. Figure 6.1 illustrates how you can apply this technique to
serialize objects recursively.</p>
<p>
<A HREF="javascript:fullSize('f06DA01x.htm')"> <img src="images/f06DA01.jpg" width=404 height=271 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 6.1</b> <i>Serializing contained objects</i><!-- /caption -->
</p>

<p>As long as your serialization routines are kept consistent, complex object structures
can be saved to disk and restored to an application. You need to ensure that the
storing and restoring branches of your <b>Serialize()</b> functions match&#8212;in other
words, that they store and restore the same objects in the same order.</p>

<p>The serialization routines handle proper reconstruction of an object structure when
this structure is restored from a disk file. Serialization accomplishes this by writing
information about the object's type as well as its state (data member values) into
the disk file. When an object is restored, this information is used to determine what
type of object needs to be created to receive the data. The serialization routine
automatically performs the object creation. However, to ensure that this action works
properly, you must provide a default constructor (one with no arguments) for your
serializable class.</p>

<p>In the following practice exercise, you will learn the steps required to implement
simple serialization of application data.</p>

<A NAME="248"><H2>Serializing Application Data</H2></A>

<p>In <a href="ch05b.htm#182">Lesson 1</a> of Chapter 5 you added two member variables, CMyAppDoc::m_nLines and
CMyAppDoc::m_string, as application data for the MyApp application. You will now add
code to this project to serialize these data items to a document file.</p>

<p><li><b> To serialize the MyApp application data</b></li></p>

<ol>

<p><li> Locate the <b>Serialize()</b> function created by the AppWizard for your
document class <b>CMyApp</b>. The generated code for the <b>Serialize()</b> function is
shown in the following code example:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyApp::Serialize(CArchive&amp; ar)
{
     if (ar.IsStoring())
     {
          // TODO: add storing code here
     }
     else
     {
          // TODO: add loading code here
     }
}</pre>
</td></tr>
</table>
</p>


<p><li> Replace the //TODO comments with code to store and restore the document data
members. The completed code should look as follows:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppDoc::Serialize(CArchive&amp; ar)
{
     if (ar.IsStoring())
     {
          ar &lt;&lt; m_nLines;
          ar &lt;&lt; m_string;
     }
     else
     {
          ar &gt;&gt; m_nLines;
          ar &gt;&gt; m_string;
     }
}</pre>
</td></tr>
</table>
</p>


<p><li> Locate the <b>CMyAppDoc::OnDataEdit()</b> function. At the end of the function,
directly beneath the call to <b>UpdateAllViews()</b>, add the following line:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SetModifiedFlag();</pre>
</td></tr>
</table>
</p>

<p>Thus, the entire function looks as follows:</p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppDoc::OnDataEdit()
{
     CEditDataDialog aDlg;

     aDlg.m_nLines = m_nLines;
     aDlg.m_strLineText = m_string;

     if(aDlg.DoModal())
     {
          m_nLines = aDlg.m_nLines;
          m_string = aDlg.m_strLineText;

          UpdateAllViews(NULL);
          SetModifiedFlag();
     }
}</pre>
</td></tr>
</table>

</p>

<p>The <b>CDocument::SetModifiedFlag()</b> function is called to notify the
application framework that the application data has been modified. This function
causes the framework to prompt the user to save changes before closing a
document.</p>


<p><li> Use ClassWizard to overload the <b>CDocument::DeleteContents()</b> function for
the <b>CMyAppDoc</b> class. Replace the comment code in the generated code with the
following lines:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_nLines = 0;
m_string = &quot;&quot;;</pre>
</td></tr>
</table>
</p>

<p>Thus, the entire function looks as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppDoc::DeleteContents()
{
     m_nLines = 0;
     m_string = &quot;&quot;;

     CDocument::DeleteContents();
}</pre>
</td></tr>
</table>
</p>
</ol>

<p>Unlike multiple-document interface (MDI) applications, which create a new document
object each time a new document is created or an existing document file is opened,
single-document interface (SDI) applications create only one document object, which is
reused each time a document is created or opened. The <b>DeleteContents()</b> function
clears the application data held in the document object before the object is reused.
When developing an SDI application, you must implement a <b>DeleteContents()</b>
function that sets all document object data members to zero or null values. Otherwise,
you will find data from previous editing sessions in your current document.</p>

<p><li><b>To test MyApp serialization</b></li></p>

<ol>

<p><li> Build and run the MyApp application.</li></p>

<p><li> Using the <b>Edit</b> option on the <b>Data</b> menu, type a string to display,
and also type the number of times you want it displayed. Click <b>OK</b> to close the
<b>Edit Document Data</b> dialog box.</li></p>

<p><li> On the <b>File</b> menu, choose <b>New</b>. A message box appears, prompting
you to save changes to your untitled MyApp document before opening the new document. This dialog box appears 
because your code called the <b>
SetModifiedFlag()</b> function after you modified the application data.</li></p>

<p><li> Click <b>Yes</b>. Use the <b>Save As</b> dialog box to save your document as <b>
MyFile.mya</b> in the current directory.</li></p>

<p><li> Another untitled document now appears on your screen. The <b>
DeleteContents()</b> function that you provided has cleared the data from your
MyFile.mya document.</li></p>

<p><li> Open the MyFile.mya file by choosing <b>Open</b> from the <b>File</b> menu, or
by selecting <b>MyFile.mya</b> from the <b>Most Recently Used</b> list on the <b>
File</b> menu.</li></p>

<p><li> Your application data is now restored and displayed as it originally was, both
in the application window and in the <b>Edit Document Data</b> dialog box's edit
controls.</li></p>
</ol>

<A NAME="249"><H2>Making a Serializable Class</H2></A>

<p>You have already seen how a document object can contain objects that implement their
own serialization code. To create a serializable class, perform the following
steps:</p>

<ol>
<p><li> Derive the class from <b>CObject</b> or a class derived from <b>
CObject</b>.</li></p>

<p><li> Provide a default constructor (one with no arguments) for your class.</li></p>

<p><li> Add the MFC macro <b>DECLARE_SERIAL</b> to the class declaration in the header
file. <b>DECLARE_SERIAL</b>, and its partner <b>IMPLEMENT_SERIAL</b>, provide MFC
run-time class information for your class. These macros also provide a global extraction operator (<b>&gt;&gt;</b>), which uses the
run-time class information to restore objects of your class from an archive. <b>
DECLARE_SERIAL</b> takes the name of your class as a parameter.</li></p>


<p>The following code illustrates a serializable class
declaration:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>// MyClass.h
class CMyClass : public CObject  
{
     DECLARE_SERIAL(CMyClass)

public:
     CMyClass() {;}  // Default constructor

     virtual void Serialize(CArchive&amp; ar);

};</pre>
</td></tr>
</table>
</p>


<p><li> Add the <b>IMPLEMENT_SERIAL</b> macro to your class implementation (.cpp) file.
The <b>IMPLEMENT_SERIAL</b> macro takes three parameters: the name of the class being
serialized, the name of its parent class, and a schema number, as shown here:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IMPLEMENT_SERIAL(CMyClass, CObject, 1)</pre>
</td></tr>
</table>
</p>

<p>The schema number allows you to implement a versioning system for your
document files. You will likely change your application documents' object structure
between releases. These changes will most likely cause errors for a user that tries to
use a new version of your application to open a document created with an older
version.</p>

<p>You can assign a different schema number to an object's <b>IMPLEMENT_ SERIAL</b>
macro for each release that changes the object's structure. This
action allows you to add code that detects discrepancies between application and
document versions, and takes appropriate actions, such as displaying an error message
or running a document format conversion routine.</p>


<p><li> Provide an override of the <b>CObject::Serialize()</b> function for your
class.</li></p>
</ol>

<A NAME="250"><H2>Serializing MFC Collection Classes</H2></A>

<p>MFC's templated collection classes <b>CArray</b>, <b>CList</b> and <b>CMap</b>,
implement their own versions of the <b>Serialize()</b> function that serialize all of
the elements in the collection.</p>

<p>Suppose your document class contains a collection of integer values as shown in the
following code sample:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CList&lt;int, int &amp;&gt; m_intList;</pre>
</td></tr>
</table>
</p>

<p>This collection can be serialized by adding the following line to the document's
<b>Serialize()</b> function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_intList.Serialize(ar);</pre>
</td></tr>
</table>
</p>

<p>This line of code is all that is required to serialize a collection of simple types.
<b>CList::Serialize()</b> calls the global helper function template <b>
SerializeElements()</b>, which has the following signature:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>template&lt;class <i>TYPE</i>&gt; void AFXAPI SerializeElements(CArchive&amp; <i>ar</i>, <i>TYPE</i>* <i>pElements</i>, int <i>nCount</i>);</pre>
</td></tr>
</table>
</p>

<p>The compiler generates an appropriate instantiation of this template for the
collection class element type. The <b>SerializeElements()</b> function's default
behavior is to perform a bitwise copy of the data contained in the collection
(referenced by the pointer <b>pElements</b>) to or from the archive.</p>

<p>This default behavior is fine for simple objects, but is problematic for more
complicated object structures. Suppose that your document class contains the member as
shown in the following example code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CList&lt;CMyClass, CMyClass &amp;&gt; m_objList;</pre>
</td></tr>
</table>
</p>

<p><b>CMyClass</b> would be defined as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>class CmyClass
{
     DECLARE_SERIAL(CMyClass)

public:
     CMyClass() {;}
     int m_int;
     DWORD m_dw;
     CString m_string;
     virtual void Serialize(CArchive&amp; ar);
}</pre>
</td></tr>
</table>
</p>

<p>Attempting to serialize the m_objList collection by adding the following line to the
document object's <b>Serialize()</b> function will cause errors:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_objList.Serialize(ar);</pre>
</td></tr>
</table>
</p>

<p>Such errors will result because the <b>CMyClass</b> objects contain <b>CStrings</b>;
which are complex objects that use custom memory allocation and reference-counting
techniques.</p>

<p>The default <b>SerializeElements()</b> function generated for the m_objlist collection
will attempt to read or write a bitwise copy of the collection elements to or from the
archive, therefore bypassing the custom serialization routines built in the
<b>&lt;&lt;</b> and <b>&gt;&gt;</b> operators defined for the <b>CString</b> class.</p>

<p>In this case, you must write your own version of the <b>SerializeElements()</b>
function. Assuming that <b>CMyClass</b> has been properly constructed as a serializable
class, the corresponding <b>SerializeElements()</b> function might look as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>template &lt;&gt; void AFXAPI SerializeElements &lt;CMyClass&gt;
     (CArchive&amp; ar, CMyClass * pNewMC, int nCount)
{
     for (int i = 0; i &lt; nCount; i++, pNewMC++)
     {
          // Serialize each CMyClass object
          pNewMC-&gt;Serialize(ar);
     }
}</pre>
</td></tr>
</table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You do not have to provide your own version of <b>
SerializeElements()</b> for a simple collection of <b>CString</b> objects, as MFC
provides one as part of the <b>CArchive</b> source code.</blockquote></div>
</p>

<A NAME="251"><H2>Lesson Summary</H2></A>

<p>The MFC application framework implements a technology called serialization that
enables you to preserve your application data's object structure when saving it to,
and restoring it from, a persistent archive. All classes that implement serialization
must be derived from the <b>CObject</b> class, and additionally must overload the <b>
CObject::Serialize()</b> function.</p>

<p>The <b>Serialize()</b> function stores and retrieves persistent data members to and
from a <b>CArchive</b> class object. This object acts as an intermediary between the
object to be serialized and the storage medium, which is usually a disk file
encapsulated as a <b>CFile</b> class object. In addition, a <b>CArchive</b> object
provides a type-safe buffering mechanism for writing and reading serializable objects
to or from a <b>CFile</b> object. Separate <b>CArchive</b> objects must be used for
storing and retrieving data. Once the archive object has been created, its role
(determined by whether the <b>CArchive::IsStoring()</b> function returns TRUE or FALSE)
cannot be changed.</p>

<p>The document object begins application data serialization in response to user
commands to load or save files. A <b>CArchive</b> object is created by the framework,
and passed as a parameter to the document object's <b>Serialize()</b> function.</p>

<p>The AppWizard creates a stub <b>Serialize()</b> function for your document class. You
must add code to this function to store or retrieve persistent data members to, or
from, the archive. The <b>CArchive</b> class defines the <b>&lt;&lt;</b> insertion
operator and the <b>&gt;&gt;</b> extraction operator, which can be used to store or
retrieve various C++ and MFC data types. If an object contains other serializable
objects, you call the
<b>Serialize()</b> function for these objects. To make a class serializable, you
must:</p>

<ul>
<p><li> Derive the class from <b>CObject</b>.</li></p>

<p><li> Provide a default constructor for your class.</li></p>

<p><li> Add the <b>DECLARE_SERIAL</b> macro to the class declaration and the <b>
IMPLEMENT_SERIAL</b> macro to your class implementation file.</li></p>

<p><li> Provide an override of the <b>CObject::Serialize()</b> function for your
class.</li></p>
</ul>


<p>To serialize an instance of an MFC collection template class, simply call the
collection object's serialize function. It is important to be aware that the
collection template classes implement serialization by calling the instantiation of the
<b>SerializeElements()</b> function template that is generated for the element type of
the collection class. The default behavior of the <b>SerializeElements()</b> function
is to perform a bitwise copy of the data contained in the collection to or from the
archive. If this behavior is not appropriate for the element type of your collection,
you should provide your own implementation of the <b>SerializeElements()</b> function
template.</p>

</BODY>
</HTML>







