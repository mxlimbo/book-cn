<HTML>
<HEAD>
<TITLE>Lesson 1: Creating ActiveX Controls with MFC</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11a.htm", "ch11c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="404"><H1>Lesson 1: Creating ActiveX Controls with MFC</H1></A>

<p>MFC simplifies the process of creating an ActiveX control. Using the MFC ActiveX
ControlWizard, you can easily create a fully featured ActiveX control. In this lesson,
you will use MFC to create an ActiveX control that implements a dispatch interface,
fires events, and provides a property page that can be used to get and set persistent
properties.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>


<ul>
<p><li> Describe how to use the MFC ActiveX ControlWizard to create an ActiveX
control.</li></p>

<p><li> Describe how to use ClassWizard to add properties, methods, and events to your
control.</li></p>

<p><li> Describe how to implement a control property page.</li></p>

<p><li> Describe how to make properties persistent.</li></p>

<p><li> Describe how to use the ActiveX Control Test Container to test your control.</li></p>
</ul>


<b>Estimated lesson time: 50 minutes</b>
</blockquote></div>
</p>


<A NAME="405"><H2>Creating an MFC ActiveX Control Project</H2></A>

<p>In this lesson, you will develop the OneArmedBandit ActiveX control, a software
version of a Las Vegas-style slot machine. The control provides the single method <b>
Play()</b>, which causes a random combination of symbols to appear in the control's
three &quot;reels.&quot; When the control displays three identical symbols, the <b>
Jackpot</b> event is fired. When the user clicks inside the control, the <b>Click</b>
event is fired. Figure 11.1 shows the OneArmedBandit control inside
the ActiveX Control Test Container.</p>

<p>The OneArmedBandit control provides a property page that allows a user to set the
values of the <b>ForeColor</b> and <b>BackColor</b> properties, and to set the custom
control-specific <b>NumberOfSymbols</b> property. This property is used to set the
number of possible symbols that the control can display, and thus increase or
decrease the odds of winning the jackpot. All three of the control properties are
persistent.</p>

<p>
<A HREF="javascript:fullSize('f11DA01x.htm')"> <img src="images/f11DA01.jpg" width=404 height=291 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 11.1</b> <i>The OneArmedBandit ActiveX control</i><!-- /caption -->
</p>

<p>As with all MFC development, the first stage in creating an ActiveX control is
to create a development project. In the following exercise, you will create the
OneArmedBandit project.</p>

<p><li> <b>To create the OneArmedBandit project</b></li></p>

<ol>
<p><li> On the <b>File</b> menu, click <b>New,</b> and then click the <b>Projects</b>
tab.</li></p>

<p><li> Click <b>MFC ActiveX ControlWizard</b>. In the <b>Project</b> <b>name</b> box,
type <b>OneArmedBandit</b> and click <b>OK</b>.</li></p>

<p><li> Step 1 of the ControlWizard appears. Review the options and click <b>Next</b> to
accept the default settings.</li></p>

<p><li> In Step 2 of the ControlWizard, clear the <b>Has an &quot;About&quot; box</b>
option. Click <b>Finish</b>.</li></p>

<p><li> The <b>New Project Information</b> dialog box appears as shown in Figure 11.2.</li></p>

<p>
<A HREF="javascript:fullSize('f11DA02x.htm')"> <img src="images/f11DA02.jpg" width=404 height=413 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 11.2</b> <i>Creating the OneArmedBandit project</i><!-- /caption -->
</p>

<p>There are a couple of interesting things to note about the information displayed in
this dialog box. First, the DLL is created with an .ocx extension. The use of the .ocx
extension is not required for ActiveX controls; it is simply a convention left over
from the days when ActiveX controls were called OLE controls. OLE controls replaced the
older Visual Basic Extension (VBX) controls. Second, the type library source code is in
a file named OneArmedBandit.odl. This file contains Object Description Language (ODL)
code. ODL was the predecessor to Interface Definition Language (IDL), and it is very
similar to IDL in syntax. The Microsoft IDL (MIDL) compiler is capable of compiling ODL
code.</p>

<p><li> Click <b>OK</b> to create the OneArmedBandit project. Expand the ClassView items
to view the classes created for your project, as shown in Figure 11.3.</li></p>
</ol>

<p>The ActiveX ControlWizard creates classes to implement the control's DLL server,
the control itself, and the control's property page. The <b>COneArmedBanditCtrl</b>
control class is derived from the MFC class <b>COleControl</b>. This powerful class
inherits all the functionality of the <b>CWnd</b> and <b>CCmdTarget</b> classes and
provides a large number of member functions related to the operation of an ActiveX
control. Using these functions, you can get and set a control's stock properties,
retrieve ambient properties from the container, fire stock events, implement property
persistence, and perform a number of operations related to siting and displaying a
control.</p>

<p>
<A HREF="javascript:fullSize('f11DA03x.htm')"> <img src="images/f11DA03.jpg" width=404 height=321 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 11.3</b> <i>OneArmedBandit project classes</i><!-- /caption -->
</p>

<A NAME="406"><H2>Defining the Control Interface</H2></A>

<p>The ControlWizard also defines two dispatch interfaces for your control: <b>
_DOneArmedBandit</b> and <b>_DOneArmedBanditEvents</b>. You add methods
and properties to the first of these and events to the second. Although you can make
these additions by right-clicking the interface items and choosing the
appropriate command from the shortcut menu, the preferred method is to use
ClassWizard.</p>

<A NAME="407"><H3>Adding Properties</H3></A>

<p>In the following exercises, you will be adding the stock <b>ForeColor</b> and <b>
BackColor</b> properties and the custom <b>NumberOfSymbols</b> property to the <b>
COneArmedBanditCtrl</b> class.</p>

<p><li> <b>To add properties to an ActiveX control</b></li></p>

<ol>
<p><li> Press CTRL+W to open ClassWizard. Select the <b>Automation</b> tab.</li></p>

<p><li> Click <b>Add Property</b> to display the <b>Add Property</b> dialog box.</li></p>

<p><li> Expand the <b>External name</b> drop-down list to display a list of stock
properties supported by the <b>COleControl</b> class. From this list, select <b>
BackColor</b>.</li></p>

<p><li> Note that the <b>Stock</b> radio button in the <b>Implementation</b> group is
selected automatically. The dialog box also indicates that the <b>GetBackColor()</b> and <b>
SetBackColor()</b> functions will be created. Click <b>OK</b> to implement the <b>
BackColor</b> stock property and create the <b>Get</b> and <b>Set</b> functions.</li></p>

<p><li> Repeat the process to create the <b>ForeColor</b> stock property.</li></p>

<p><li> To create the custom property, open the <b>Add Property</b> dialog box and
type the name <b>NumberOfSymbols</b> into the <b>External name</b> list. Note that
ClassWizard will create the m_numberOfSymbols member variable to store the property
value, and that it will also create a notification function <b>OnNumberOf
SymbolsChanged()</b> that is called when the property is changed.</li></p>

<p><li> From the <b>Type</b> drop-down list, select <b>short</b>, and then click <b>
OK</b> to create the custom property.</li></p>

<p><li> Click <b>OK</b> to finish creating the properties.</li></p>
</ol>

<p>In ClassView, you will be able see the new properties listed underneath the <b>
_DOneArmedBandit</b> interface item. Notice also that the member variable and the
notification function have been added to the <b>COneArmedBanditCtrl</b> class.
Double-click the <b>OnNumberOfSymbolsChanged()</b> function to view the source code in
the OneArmedBanditCtl.cpp file. The default version of the function simply calls the
<b>COleControl::SetModifiedFlag()</b> function.</p>

<p>Toward the top of the OneArmedBanditCtl.cpp file, you will find this code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_DISPATCH_MAP(COneArmedBanditCtrl, COleControl)
     //{{AFX_DISPATCH_MAP(COneArmedBanditCtrl)
     DISP_PROPERTY_NOTIFY(COneArmedBanditCtrl, &quot;NumberOfSymbols&quot;, 
          m_numberOfSymbols, OnNumberOfSymbolsChanged, VT_I2)
     DISP_STOCKPROP_BACKCOLOR()
     DISP_STOCKPROP_FORECOLOR()
     //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()</pre>
</td></tr>
</table>
</p>

<p>This code, along with the corresponding <b>DECLARE_DISPATCH_MAP</b> macro in the
header file, implements an MFC <i>dispatch map</i> for the class. The dispatch map is
very similar to the message map you learned about in <A HREF="ch03a.htm">Chapter 3</A>, but instead of mapping
Windows messages to class handler functions, the dispatch map maps Automation client
requests to your control class's implementation of the properties and methods. For
example, when a Visual Basic client requests the <b>NumberOfSymbols</b> property with
the following code, the control uses the dispatch map (specifically the <b>
DISP_PROPERTY_NOTIFY</b> macro) to retrieve
the value contained in the m_numberOfSymbols variable and pass it back to the
client:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Dim myobj As OneArmedBandit
Set myobj = New OneArmedBandit
MsgBox myobj.NumberOfSymbols</pre>
</td></tr>
</table>
</p>

<p>As you can see from the dispatch map code, stock properties are supported with their
own specific macros.</p>

<A NAME="408"><H3>Property Persistence</H3></A>

<p>MFC makes it easy to make control properties persistent. The <b>COleControl::
DoPropExchange()</b> function serializes the control properties to and from a
storage medium&#8212;usually the control's container. The ActiveX ControlWizard
overloads the <b>DoPropExchange()</b> function for your control class. The framework
passes this function a pointer to a <b>CPropExchange</b> object, which encapsulates the
context of the property exchange, including its direction. The over- loaded version of
<b>DoPropExchange()</b> calls the base class version to serialize
the stock properties implemented by the control. It is your responsibility to add code
to serialize any custom properties you want to make persistent.</p>

<p>MFC provides a number of functions that allow you to serialize properties of
different types. The names of these functions begin with the prefix <i>PX_</i>. To
serialize your <b>NumberOfSymbols</b> property, replace the //TODO comment in your
control class's <b>DoPropExchange(</b>) function with a call to the <b>
PX_Short()</b> function, as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void COneArmedBanditCtrl::DoPropExchange(CPropExchange* pPX)
{
     ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
     COleControl::DoPropExchange(pPX);

     PX_Short(pPX, &quot;NumberOfSymbols&quot;, m_numberOfSymbols, 3);

}</pre>
</td></tr>
</table>
</p>

<p>The fourth argument to the <b>PX_Short()</b> function specifies a default value
for
the property that is used if the function is unable to retrieve a value from storage
medium. The example code above ensures that the <b>NumberOfSymbols</b> property of a
new control instance will be initialized with a default value of 3.</p>

<A NAME="409"><H3>Adding Methods</H3></A>

<p>As well as providing access to control properties, the dispatch map also maps client
method calls to class member function implementations. You use ClassWizard to add a
method.</p>

<p><li> <b>To add a method to an ActiveX control</b></li></p>

<ol>
<p><li> In ClassWizard, click the <b>Automation</b> tab and click <b>Add Method</b> to
display the <b>Add Method</b> dialog box.</li></p>

<p><li> In the <b>External name</b> list, type <b>Play</b>.</li></p>

<p><li> In the <b>Return type</b> drop-down list, click <b>void</b>.</li></p>

<p><li> Click <b>OK</b>, and then click <b>OK</b> in ClassWizard to create the
method.</li></p>
</ol>

<p>Notice that the <b>Play()</b> function has been added to the <b>
COneArmedBanditCtrl</b> class. If you inspect the dispatch map, you will see that the
following line has been added:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>DISP_FUNCTION(COneArmedBanditCtrl, &quot;Play&quot;, Play, VT_EMPTY, VTS_NONE)</pre>
</td></tr>
</table>
</p>

<A NAME="410"><H3>Adding Events</H3></A>

<p>ClassWizard also automates the process of defining events fired by the control. In
the following exercise, you will implement the <b>Click</b> stock event and the <b>
Jackpot</b> custom event.</p>

<p><li> <b>To define an ActiveX control event</b></li></p>

<ol>
<p><li> In ClassWizard, click the <b>ActiveX Events</b> tab. Click <b>Add Event</b> to
display the <b>Add Event</b> dialog box.</li></p>

<p><li> From the <b>External name</b> drop-down list, choose the <b>Click</b> stock
event. Click <b>OK</b> to add the event.</li></p>

<p><li> Click <b>Add Event</b> once again. In the <b>Add Event</b> dialog box, type <b>
Jackpot</b> into the <b>External name</b> list. Click <b>OK</b>.</li></p>

<p><li> In ClassWizard, click <b>OK</b> to finish creating events.</li></p>
</ol>

<p>In ClassView, notice that the <b>FireJackpot()</b> function has been added to the
<b>COneArmedBanditCtrl</b> class. You can use this function from within your code to
fire the <b>Jackpot</b> event. ClassWizard has also added entries to the class's
<i>event map</i>. The event map is a structure very similar to the dispatch map that is
used to implement ActiveX control events. The following is the event map implementation
for the <b>COneArmedBanditCtrl</b> class:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_EVENT_MAP(COneArmedBanditCtrl, COleControl)
     //{{AFX_EVENT_MAP(COneArmedBanditCtrl)
     EVENT_CUSTOM(&quot;Jackpot&quot;, FireJackpot, VTS_NONE)
     EVENT_STOCK_CLICK()
     //}}AFX_EVENT_MAP
END_EVENT_MAP()</pre>
</td></tr>
</table>
</p>

<A NAME="411"><H2>Creating Property Pages</H2></A>

<p>Now that you have implemented your ActiveX control's interface, you can add
property pages to allow users of the control to get and set its properties. The
framework uses the <b>PROPPAGEID</b> series of macros to specify an array of property
page IDs for your control's property sheet. The default code generated by the
ActiveX ControlWizard for the OneArmedBandit project can be found in the
OneArmedBandit.cpp file, and is as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_PROPPAGEIDS(COneArmedBanditCtrl, 1)
     PROPPAGEID(COneArmedBanditPropPage::guid)
END_PROPPAGEIDS(COneArmedBanditCtrl)</pre>
</td></tr>
</table>
</p>

<p>Note that this structure, unlike the dispatch and event maps, is not maintained by
ClassWizard. You have to maintain the code yourself.</p>

<A NAME="412"><H3>Custom Property Pages</H3></A>

<p>In the code that is shown above, the single <b>PROPPAGEID</b> entry in the table
refers to the default property page that is created for your control. The ActiveX
ControlWizard creates a dialog template resource and a dialog class (based on the <b>
COlePropertyPage</b> class) that you can edit and compile to create a property page
that allows access to your control's custom properties.</p>

<p>In the following exercises, you will create a property page that allows a user to
set the <b>NumberOfSymbols</b> custom property.</p>

<p><li> <b>To implement the custom property page</b></li></p>

<ol>
<p><li> In ResourceView, expand the Dialog folder. Double-click <b>IDD_PROPPAGE_ONEARMEDBANDIT</b> to edit the dialog template resource.</li></p>

<p><li> Delete the //TODO static text. Add a static text control and an edit control so
that the dialog template appears as shown in Figure 11.4.</li></p>

<p>
<img src="images/f11DA04.jpg" width=375 height=101>
</p><p>
<!-- caption --><b>Figure 11.4</b> <i>Implementing the custom property page</i><!-- /caption -->
</p>

<p>Give the edit control the ID <b>IDC_NUMSYMBOLS</b>. On the <b>Styles</b> tab of the
<b>Edit Properties</b> dialog box, select the <b>Number</b> check box.</p>

<p><li> Press CTRL+W to open ClassWizard. Select the <b>Member Variables</b> tab.</li></p>

<p><li> Click <b>Add Variable</b> to add a Value category member variable named <b>
m_numsymbols</b>. The variable type should be <b>short</b>. In the <b>Optional property
name</b> box, type <b>NumberOfSymbols</b> and then click <b>OK</b>.</li></p>

<p><li> Specify the range validation by entering a minimum value of <b>3</b> and a
maximum value of <b>7</b>. Click <b>OK</b>.</li></p>
</ol>

<p>Look at the <b>DoDataExchange()</b> function of the <b>COneArmedBanditPropPage</b>
class. Notice that in addition to the DDX and DDV functions, ClassWizard has added the
following line:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>DDP_Text(pDX, IDC_NUMSYMBOLS, m_numsymbols, _T(&quot;NumberOfSymbols&quot;));</pre>
</td></tr>
</table>
</p>

<p>This is one of a number of functions with the <i>DDP_</i> prefix that is
provided by MFC to transfer data between an ActiveX Control property page and the
control properties. Note that the dispatch name of the control property is
used, so you do not have to provide an additional code link between the <b>
COneArmedBanditPropPage</b> class and the <b>COneArmedBanditCtrl</b> class.</p>

<A NAME="413"><H3>Stock Property Pages</H3></A>

<p>Because you have added the <b>ForeColor</b> and <b>BackColor</b> properties to your
control, you will need to implement a property page to allow the user to set them. MFC
provides three stock property pages for use with ActiveX controls: <b>CLSID_
CColorPropPage</b>, <b>CLSID_CFontPropPage</b>, and <b>CLSID_CPicturePropPage</b>.
These pages display a user interface for stock color, font, and picture properties,
respectively. To add a stock property page, add another <b>PROPPAGEID</b> macro to the
code in the OneArmedBandit.cpp file, as shown here:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_PROPPAGEIDS(COneArmedBanditCtrl, 2)
     PROPPAGEID(COneArmedBanditPropPage::guid)
     PROPPAGEID(CLSID_CColorPropPage)
END_PROPPAGEIDS(COneArmedBanditCtrl)</pre>
</td></tr>
</table>
</p>

<p>Note that the second argument to the <b>BEGIN_PROPPAGEIDS</b> macro must be altered
to match the number of property pages specified for the ActiveX control.</p>

<A NAME="414"><H2>OnDraw() Function</H2></A>

<p>Controls created with the MFC ActiveX ControlWizard are user-interface controls.
This means that much of the control-specific implementation that you
provide is drawing code. As with an MFC document/view application, all the drawing
code for a control is placed within a single function named <b>OnDraw()</b>. The
following is the default implementation generated by the ControlWizard:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void COneArmedBanditCtrl::OnDraw(
     CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)
{
     // TODO: Replace the following code with your own drawing code.
     pdc-&gt;FillRect(rcBounds,
     CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
     pdc-&gt;Ellipse(rcBounds);

}</pre>
</td></tr>
</table>
</p>

<p>The <b>COleControl::OnDraw()</b> function receives a pointer to an MFC device
context object, and a rectangle that represents the control's on-screen area,
specified in logical units. You should avoid using fixed values in your drawing code,
and you should scale all drawing output to the dimensions of the bounding rectangle. In
this way, you ensure that the entire control is always visible and that
its internal proportions are always maintained. The <b>OnDraw()</b> function also
receives a rectangle that represents the invalidated area of the control and can be
used to optimize your drawing code.</p>

<p><li> <b>To implement the COneArmedBanditCtrl::OnDraw() function</b></li></p>

<p>Replace the code in your project with the following code:</p>
<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>
<p>(This code can be found in CH11_01.cpp, installed from the companion CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void COneArmedBanditCtrl::OnDraw(
     CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)
{
     // Get colors of stock properties
     COLORREF colorBack = TranslateColor(GetBackColor());
     COLORREF colorFore = TranslateColor(GetForeColor());

     // Get dimensions of control
     float ctrlWidth = float(rcBounds.Width());
     float ctrlHeight = float(rcBounds.Height());

     // Setup DC
     CBrush brush(colorBack);
     CBrush * pOldBrush = pdc-&gt;SelectObject(&amp;brush);

     CPen pen(PS_SOLID, 3, colorFore);
     CPen *pOldPen = pdc-&gt;SelectObject(&amp;pen);

     CFont SymbolFont;
     CFont *pOldFont;

     if(SymbolFont.
          CreateFont(long(ctrlHeight / 1.1), long(ctrlWidth/6),
          0, 0, 0, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0,
          0,&quot;WingDings&quot;));

          pOldFont = pdc-&gt;SelectObject(&amp;SymbolFont);
     else
          pOldFont = SelectStockFont(pdc);

     // Draw bounding rectangle
     pdc-&gt;Rectangle(rcBounds);
     pdc-&gt;SetBkMode(TRANSPARENT);

     // Draw text
     pdc-&gt;SetTextColor(colorFore);
     RECT rect;
     ::CopyRect(&amp;rect, rcBounds);
     CString strDisplay;
     strDisplay.Format(&quot;%c %c %c&quot;,
          m_symbols[0], m_symbols[1], m_symbols[2]);

     pdc-&gt;DrawText(strDisplay, &amp;rect, DT_SINGLELINE | DT_CENTER
          | DT_VCENTER );

     // Draw vertical bars
     long onethird = long(ctrlWidth / 3);
     CPoint ptTop(rcBounds.TopLeft());
     CPoint ptBtm(rcBounds.left, rcBounds.bottom);

     ptTop.x += onethird; ptBtm.x += onethird;
     pdc-&gt;MoveTo(ptTop);
     pdc-&gt;LineTo(ptBtm);

     ptTop.x += onethird; ptBtm.x += onethird;
     pdc-&gt;MoveTo(ptTop);
     pdc-&gt;LineTo(ptBtm);

     // Restore device context
     pdc-&gt;SelectObject(pOldFont);
     pdc-&gt;SelectObject(pOldPen);
     pdc-&gt;SelectObject(pOldBrush);
}</pre>
</td></tr>
</table>
</p>

<p>This function simulates the slot machine window by displaying three characters from
the Wingdings symbol font, as shown in Figure 11.1. The characters themselves are
contained in the fixed-length string <b>m_symbols</b>, which is a member variable of
the <b>COneArmedBanditCtrl</b> class. You will need to add this member before your code
will compile.</p>

<p><li> <b>To implement the COneArmedBanditCtrl::m_symbols string</b></li></p>

<ol>
<p><li> In ClassWizard, right-click the <b>COneArmedBanditCtrl</b> class. Click <b>Add
Member Variable</b>. Create the following protected member variable:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>TCHAR m_symbols[3];</pre>
</td></tr>
</table>
</p>

<p><li> Locate the <b>COneArmedBanditCtrl</b> constructor and add the following line to
initalize the string:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>_tcscpy(m_symbols, _T(&quot;JJJ&quot;));</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="415"><H2>Implementing the Control Method</H2></A>

<p>All that remains is to implement the <b>Play()</b> method that simulates the
spinning of the slot machine reels, displaying a random symbol in each window. You
created a stub for the <b>Play()</b> implementation function when you added the method
to the interface. Now you need to add code to randomly alter each of the characters in
the <b>COneArmedBanditCtrl::m_symbols</b> string.</p>

<p><li> <b>To implement the COneArmedBanditCtrl::Play() function</b></li></p>

<ol>
<p><li> Locate the <b>Play()</b> function stub and then replace the stub with the code
that follows:</li></p>
<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>
<p>(This code can be found in CH11_02.cpp, installed from the companion CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void COneArmedBanditCtrl::Play()
{
     srand((unsigned)time(NULL));

     _tcscpy(m_symbols, _T(&quot;JJJ&quot;));

     for(int i = 0; i &lt; 3; i++)
          m_symbols[i] += UINT(rand() % m_numberOfSymbols);

     InvalidateControl(); // repaints control

     if(m_symbols[0] == m_symbols[1] &amp;&amp;
          m_symbols[1] == m_symbols[2])
          FireJackpot();

}</pre>
</td></tr>
</table>
</p>

<p>The use of the modulus operator (<b>%</b>) ensures that each character in the
m_symbols string is incremented by a random number between zero and <i>
m_numberOfSymbols</i>. When all three characters are the same, the <b>Jackpot</b>
custom event is fired.</p>

<p><li> Press F7 to build the OneArmedBandit ActiveX control. The compiler and linker
create a DLL with an .ocx extension in your output directory. If the build is
successful, the control is registered on your computer.</li></p>
</ol>

<A NAME="416"><H2>Testing the Control</H2></A>

<p>The ActiveX Control Test Container is a useful tool provided by Visual Studio that
allows you to run and test any ActiveX control registered on your computer. In the
following exercises, you will learn how to use the ActiveX Control Test Container to
test the property pages, the events, and the <b>Play()</b> method of the OneArmedBandit
ActiveX control.</p>

<p><li> <b>To test the OneArmedBandit ActiveX control</b></li></p>

<ol>
<p><li> On the <b>Tools</b> menu in Visual C++, click <b>ActiveX Control Test
Container</b>. On the Test Container's <b>Edit</b> menu, click <b>Insert New
Control</b>.</li></p>

<p><li> In the <b>Insert Control</b> dialog box, click <b>OneArmedBandit Control</b> and
then click <b>OK</b>.</li></p>

<p><li> Using the resize handles around the edge of the control, make the control a
suitable size.</li></p>

<p><li> On the <b>Edit</b> menu, simply click <b>Properties</b>. On the <b>General</b>
tab of the <b>OneArmedBandit</b> <b>Control Properties</b> dialog box, change the <b>
Number of symbols</b> property to <b>5</b>.</li></p>

<p><li> Click the <b>Colors</b> tab and choose <b>BackColor</b> and <b>ForeColor</b>
values for the control.</li></p>

<p><li> Click <b>OK</b>, and then check that the control displays the correct
colors.</li></p>

<p><li> Click inside the control area and verify that the <b>Click</b> event is notified
in the lower half of the Test Container window.</li></p>

<p><li> On the <b>Control</b> menu, click <b>Invoke Methods</b>. If necessary, move the
<b>Invoke Methods</b> dialog box so that you can see the entire control and the output
in the lower half of the Test Container window.</li></p>

<p><li> With <b>Play (Method)</b> selected in the <b>Method Name</b> drop-down list,
click <b>Invoke</b> to play the one-armed bandit game. Keep playing until you get three
symbols that are the same. When this happens, you should see the <b>Jackpot</b> event
notified in the lower half of the Test Container window.</li></p>
</ol>

<p><li> <b>To test property persistence</b></li></p>

<ol>
<p><li> Close the ActiveX Control Test Container. When prompted, save the session as <b>
oab.tcs</b>.</li></p>

<p><li> Re-open the ActiveX Control Test Container. On the <b>File</b> menu, simply
click <b>oab.tcs</b> from the recently used file list. The OneArmedBandit control
should display with the size and colors saved from the previous session. (The <b>
COleControl</b> class implements the serialization of the control dimensions, without
requiring any coding on your part).</li></p>

<p><li> Click the control border to select the control. View the control properties to
check that the <b>NumberOfSymbols</b> property is still set to <b>5</b>.</li></p>

<p><li> Close the ActiveX Control Test Container.</li></p>
</ol>

<A NAME="417"><H2>Lesson Summary</H2></A>

<p>In this lesson, you have seen just how easy it is to develop ActiveX controls
using MFC. The ActiveX ControlWizard creates a set of classes that implement
a DLL, a control and a property page. The ControlWizard defines dispatch
interfaces for your control's properties, methods, and events. You use
ClassWizard to design these interfaces. An MFC ActiveX control is based on the <b>
COleControl</b> class, which provides many member functions that allow you to
implement stock properties and events, retrieve ambient properties from the container,
implement property persistence, and connect a control's properties to a property
page. Apart from the implementations of the custom methods, most of the code that you
need to write for your control is drawing code, placed within the control's <b>
OnDraw()</b> function.</p>

</BODY>
</HTML>







