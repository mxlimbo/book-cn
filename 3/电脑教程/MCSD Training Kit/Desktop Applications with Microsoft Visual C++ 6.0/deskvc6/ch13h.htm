<HTML>
<HEAD>
<TITLE>Lesson 7: Testing Your Application</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13g.htm", "ch13i.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="523"><H1>Lesson 7: Testing Your Application</H1></A>

<p>Application testing ensures that your application actually performs as specified.
When your application is viewed as nearly complete and reasonably stable, debugging and
testing should begin in earnest&#8212;testing to detect errors, and debugging to fix
them. This lesson examines some of the techniques of testing.</p>

<p>As much as possible, testing should be conducted under widely different scenarios that
mimic real-life conditions under which an application might have to function. For
example, a program designed to run under Microsoft Windows 95 and Microsoft Windows NT
should be tested under both operating systems. Whereas developers try to create code
that can't be broken, testers concentrate on breaking the code&#8212;that is,
finding the weak points. Developers who must wear both hats should bring equal zeal to
both tasks.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Understand terminology pertaining to testing.</li></p>
<p><li> Design an effective test plan.</li></p>
<p><li> Employ common techniques for testing your application.</li></p>
</ul>
<b>Estimated lesson time: 15 minutes</b>
</blockquote></div>
</p>


<A NAME="524"><H2>Glossary of Testing Terms</H2></A>

<p>Like any rigorous field, testing has a unique lexicon. This section defines some of
the terms that pertain to testing, making subsequent discussions in the lesson more
meaningful. The glossary is arranged by level, starting with the simplest type of
testing and proceeding to more involved testing practices.</p>

<ul>
<p><li> <b>Unit testing</b> verifies a discrete piece of code, such as a loop, a block, a
subroutine, or an event. In formal terms, a unit test applies to the smallest piece of
code for which a practical test can be conducted.</li></p>

<p><li> <b>Integration testing</b> is the next highest level of testing, and is concerned
with confirming that no problems arise from combining units of code into more complex
processes. For example, two functions might test successfully as units, but the effects
of providing one function with the output of the other should also be considered.
Threads must be subjected to stringent integration testing to ensure that they perform
as expected when running simultaneously.</li></p>

<p><li> <b>System testing</b> is concerned with the full build of an application. At this
level, the emphasis is less on bug hunting and more on checking that the application
and its environment interact with each other correctly. The level of testing that would
be conducted at this phase would be more systemwide&#8212;features such as correct
initialization from the registry, performance, unexpected termination of resources,
logon failures, and error recovery.</li></p>

<p><li> <b>Stress testing</b> verifies how an application behaves under adverse conditions
such as low memory, high network traffic, or insufficient disk space.</li></p>

<p><li> <b>Regression testing</b> is the repetition of previous tests after changes have
been made to the source code. The purpose of regression testing is to verify that
expected bug fixes were successful, that the application still works as expected, and
that new bugs have not been introduced by the code revisions.</li></p>

<p><li> <b>Beta testing</b> is when a developer distributes a pre-release version of an
application to a selected group of users. The users are generally chosen for their
familiarity with past versions of a product, their willingness to use the new version
under a wide variety of conditions, and a demonstrated ability to communicate what they
like and dislike about a product.</li></p>

<p><li> <b>User acceptance testing</b> is when a tested version of the specified
deliverable is made available to a selected number of users who have already received
training in the use of the system. The users chosen to perform the tests are expected
to give the system the kind of usage that it will receive in real life.</li></p>
</ul>


<A NAME="525"><H2>Developing a Test Plan</H2></A>

<p>A <i>test plan</i> is a written version of the entire test suite for an application.
A properly created test plan completely describes all of the testing that needs to be
done, and identifies what constitutes the success of any particular test. Test plans
should be written to provide directions to someone other than the author on how to test
an application. The primary criterion for a successful test plan is whether a different
tester can pick up the plan halfway through the project and continue testing.</p>

<p>Custom applications can be effectively tested through three methods:</p>

<ul>
<p><li> In-house testing by the developers and the testing/quality assurance (QA)
group</li></p>

<p><li> Beta testing by selected users</li></p>

<p><li> User acceptance testing by selected users</li></p>
</ul>


<A NAME="526"><H3>Elements of a Test Plan</H3></A>

<p>A test plan provides a formal basis from which to develop repeatable regression
tests. As applications evolve, or as new builds are created during the debug cycle, it
is essential that the existing stability of the application as a whole has not been
damaged. A test plan also provides a basis from which the test strategy can be
inspected and discussed by all interested parties.</p>

<p>A good test plan starts with a description of the application and the functionality
to be tested, and is followed by a brief discussion of the test objectives. The plan
should include the following elements:</p>

<ul>
<p><li> The objectives of the test exercise.</li></p>

<p><li> A description of how the tests should be performed, explaining the various
degrees of reliance that should be made on key testing components such as test scripts,
manual checklists, and user involvement.</li></p>

<p><li> A description of the environment in which the tests should occur, including the
operating system and, if relevant, its version number. For example, the original
release of Windows 95 has slightly different characteristics than the same operating
system with Service Pack 1 installed. A test plan might need to consider these
differences.</li></p>

<p><li> A listing of the test data that must be made available for the tests to be
valid.</li></p>

<p><li> A discussion of any restrictions placed on the test team that might affect the reliability of the test results. For example, if you are testing a system
designed for hundreds of users accessing a large central database, it can be impossible for a small organization to simulate this volume of usage.</li></p>

<p><li> A declaration of the relative orders of importance placed on different criteria&#8212;for example, your concern for robustness compared to that of performance.</li></p>

<p><li> A list of features that should not be tested, with a commentary explaining your
reasons.</li></p>

<p><li> An intended test schedule that identifies milestones. This should tie into the
overall project plan.</li></p>
</ul>


<A NAME="527"><H3>Test Scenarios</H3></A>

<p>After designing a test plan, the next step is to list each test scenario, using the
same breakdown of functionality as presented in the design specification. Each scenario
should include:</p>

<ul>
<p><li> A reference to the item to be tested.</li></p>

<p><li> The expected results.</li></p>

<p><li> Commentary that describes how the test results confirm that the item being tested
is functioning as expected.</li></p>
</ul>


<A NAME="528"><H2>Lesson Summary</H2></A>

<p>This lesson defined some of the common terminology pertaining to software testing,
and described how to write an effective test plan. A test plan incorporates detailed
information about an intended program of testing procedures including:</p>

<ul>
<p><li> Unit testing for small sections of code.</li></p>

<p><li> Integration testing to verify how code sections operate together.</li></p>

<p><li> System testing to verify the overall stability of the entire program.</li></p>

<p><li> Stress testing to determine how the program reacts to conditions of limited
system resources.</li></p>

<p><li> Regression testing to ensure that a revision to the code does not introduce
further errors.</li></p>

<p><li> Beta testing to gather user input.</li></p>

<p><li> User acceptance testing to reflect real-life usage.</li></p>
</ul>


<p>Small development teams of less than four or five people usually have to serve as
both programmers and testers. In larger organizations with more personnel, developers
and testers often form two distinct teams. Even in this case, pro-grammers can benefit
from the information in this lesson, because the entire development process runs more smoothly when both teams understand each other's work.</p>

</BODY>
</HTML>







