<HTML>
<HEAD>
<TITLE>Lesson 3: Using Multiple Threads</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05c.htm", "ch05e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="202"><H1>Lesson 3: Using Multiple Threads</H1></A>

<p>In <a href="ch04b.htm#162">Lesson 2</a> of Chapter 4, you learned that a <i>process</i> is an instance of an
executing program. A <i>thread</i> is a path of execution within a process and is the
smallest piece of code that can be scheduled to run on the processor. A thread runs in
the address space of the process and uses resources allocated to the process. All
processes have at least one thread of execution, known as the <i>primary thread</i>.
You can create additional <i>secondary</i> <i>threads</i> to take advantage of the
multitasking capabilities of Windows 32-bit operating systems.</p>

<p>In this lesson, you will learn how to enhance the capabilities and the performance
of your application by creating secondary threads of execution using MFC classes and
global functions.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe when to use multithreaded programming techniques.</li></p>
<p><li> Describe the two different types of thread that you can implement using MFC.</li></p>
<p><li> Describe the role of the MFC class <b>CWinThread</b> in the implementation of secondary threads.</li></p>
<p><li> Describe how to create and terminate secondary threads in an MFC application.</li></p>
<p><li> Describe how to use the MFC synchronization classes to control thread access to shared data and resources.</li></p>
</ul>
<b>Estimated lesson time: 60 minutes</b>
</blockquote></div>
</p>


<A NAME="203"><H2>Multithreaded Applications</H2></A>

<p>You can use multiple threads in your application wherever an improvement in
performance can be gained by running separate tasks concurrently. As an example,
consider a word processing application that automatically backs up the current document
every five minutes. The user's input to the document, via the main application
window, is handled by the primary thread. The application code can create a separate
secondary thread that is responsible for scheduling and performing the automatic
backups. Creating a secondary thread prevents the backing up of lengthy documents from
interfering with the responsiveness of the application's user interface.</p>

<p>Situations where using multiple threads can deliver performance benefits to your
application include:</p>

<ul>
<p><li> <b>Scheduled (timer-driven) activities</b> The thread that runs the automatic
backup feature in the word processor example is blocked for five-minute intervals
between backups. Thread schedules can be set with millisecond precision in Win32
applications.</li></p>

<p><li> <b>Event-driven activities</b> The threads can be triggered by signals from other
threads. An example is a monitoring system, in which an error-logging thread is
inactive until one of the other threads alerts it to an error condition.</li></p>

<p><li> <b>Distributed activities</b> When data must be collected from (or distributed to)
several computers, it makes sense to create a thread for each request so that these
tasks can proceed in parallel, in their own time frame.</li></p>

<p><li> <b>Prioritized activities</b> Win32 threads can be assigned <i>priorities</i> to
determine the proportionate amount of execution time that is assigned to a thread by
the thread scheduler. To improve a program's responsiveness, it is sometimes useful
to divide its work into a high-priority thread for the user interface and a
low-priority thread for background work.</li></p>
</ul>


<A NAME="204"><H2>Multithreading with MFC: CWinThread Class</H2></A>

<p>All threads in MFC applications are represented by <b>CWinThread</b> objects. This
includes the primary thread of your application, which is implemented as a class
derived from <b>CWinApp</b>. <b>CWinApp</b> is directly derived from <b>
CWinThread</b>.</p>

<p>Although the Win32 API provides the <b>_beginthreadex</b> function, which allows you
to launch threads at a low level, you should always use the <b>CWinThread</b> class to
create threads that use MFC functionality. This is because the <b>CWinThread</b> class
uses thread-local storage to manage information specific to the context of the thread
in the MFC environment. You can declare <b>CWinThread</b> objects directly, but in many
cases, you will allow the global MFC function <b>AfxBeginThread()</b> to create a <b>
CWinThread</b> object for you.</p>

<p>The <b>CWinThread::CreateThread()</b> function is used to launch the new thread. The
<b>CWinThread</b> class also provides the functions <b>SuspendThread()</b> and <b>
ResumeThread()</b> to allow you to suspend and resume the execution of a thread.</p>

<A NAME="205"><H3>Worker Threads and User Interface Threads</H3></A>

<p>MFC distinguishes between two types of threads: <i>worker</i> threads and <i>user
interface</i> threads. This distinction is made solely by MFC; the Win32 API does not
distinguish between threads.</p>

<p>Worker threads are commonly used to complete background tasks that do not require
user input. Examples could include database backup functions or functions that monitor
the current state of a network connection.</p>

<p>User interface threads are able to handle user input, and they implement a message
loop to respond to events and messages generated by user interaction with the
application. The best example of a user interface thread is the application primary
thread represented by your application's <b>CWinApp</b>-derived class. Secondary
user interface threads can be used to provide a means to interact with an application
without degrading the performance of other application features. For example, consider
an application that allows anesthetists to monitor the condition of a patient undergoing 
surgery. A user interface thread could be used to allow the anesthetists to enter details 
of the drugs that they have administered without interrupting the threads that handle the 
monitoring of a patient's vital signs.</p>

<p>You create secondary threads in an MFC application by calling the global function
<b>AfxBeginThread()</b>. There are two overloaded versions of <b>AfxBeginThread()</b>,
one for creating worker threads, and one for creating user interface threads. The
following sections demonstrate how these two versions are used.</p>

<A NAME="206"><H3>Creating Worker Threads</H3></A>

<p>Creating a worker thread is simply a matter of implementing a controlling function
that performs the task your thread is to perform, and passing the address of the
controlling function to the appropriate version of the <b>AfxBeginThread()</b>
function.</p>

<p>The controlling function should have the following syntax:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>UINT MyControllingFunction(LPVOID pParam);</pre>
</td></tr>
</table>
</p>

<p>The parameter is a single 32-bit value. The parameter can be used in a number of
ways, or it can be ignored. It can pass a simple value to the function or a pointer to
a structure containing multiple parameters. If the parameter refers to a structure, the
structure can be used not only to pass data from the caller to the thread, but also to
pass data back from the thread to the caller.</p>

<p>The worker-thread version of <b>AfxBeginThread()</b> is declared as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CWinThread* AfxBeginThread(AFX_THREADPROC pfnThreadProc,
     LPVOID pParam,
     int nPriority = THREAD_PRIORITY_NORMAL,
     UINT nStackSize = 0,
     DWORD dwCreateFlags = 0,
     LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);</pre>
</td></tr>
</table>
</p>

<p>The first two parameters are the address of the controlling function and the address
of the parameter that is to be passed to it. The remaining parameters (which all have
default values) allow you to specify the thread priority, its stack size, whether it is
to be created in a suspended state, and whether it is to run immediately. The final
parameter allows you to specify the security attributes for the thread&#8212;the default
value NULL means that the thread will inherit the attributes of the calling thread.</p>

<p><b>AfxBeginThread()</b> creates a new <b>CWinThread</b> object, calls its <b>
CreateThread()</b> function to start executing the thread, and returns a pointer to the
thread. Checks are made throughout the procedure to make sure all objects are
deallocated properly should any part of the creation fail. To end the thread, you call
the global function <b>AfxEndThread()</b> from within the thread or simply return from
the controlling function of the worker thread. The return value of the controlling
function is commonly used to indicate the reason for termination. Traditionally, the
exit code is 0 if the function was successful. Nonzero values are used to indicate
specific types of errors.</p>

<A NAME="207"><H2>Creating a Worker Thread</H2></A>

<p>The following exercises illustrate how to create a worker thread for the MyApp
application. You will create a simple timer function that displays a message box when
the system time reaches the timer setting. The user will set the timer using a dialog
box. After the timer has been set, a worker thread will monitor the system clock once
every second. After the timer time has been reached, the thread will display the
message box and terminate.</p>

<p>You will create the <b>CTimer</b> class to encapsulate the timer. This class will
contain a protected MFC <b>CTime</b> variable to store the timer time. It will also
contain a public <b>CWinThread</b> pointer, which will be used to determine whether the
<b>CTimer</b> object is currently referenced by an active thread.</p>

<p><li> <b>To create the CTimer class</b></li></p>

<ol>
<p><li> Open the CMyApp project. Then in FileView, double-click the <b>MainFrm.cpp</b> file icon.</li></p>
<p><li> To the top of the file, beneath the #include statements, add the following code:</li></p>
<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
class Ctimer
{
protected:
     CTime m_time;

public:
     CWinThread * m_thread;

     CTimer() {Reset();}

     CTime GetTime() {return m_time;}
     void  SetTime(CTime time) {m_time = time;}

     void  Reset() {
          m_time = CTime::GetCurrentTime();
          m_thread = NULL;
     }
};
</pre>
</td></tr>
</table>
</p>

<p>The <b>GetCurrentTime()</b> function is a static member function of the <b>CTime</b>
class that returns the current system time in <b>CTime</b> format.</p>

<p><li> Directly beneath the class declaration, add the following line to declare a global <b>CTimer</b> object:</li></P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CTimer g_timer;</pre>
</td></tr>
</table>
</p>
</ol>

<p>You will now implement a controlling function for the worker thread. This
function will compare the system time to the timer time at one-second intervals. After
the timer time is reached, the function will display a message box and
reset the timer.</p>

<p><li> <b>To add the DoTimer() function</b></li></p>

<ol>
<p><li> In the MainFrm.cpp file, directly beneath the class declaration, add the following function definition:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
UINT DoTimer(LPVOID pparam)
{
     CTime currenttime = CTime::GetCurrentTime();

     while(currenttime &lt; g_timer.GetTime())
     {
          Sleep(1000);
          currenttime = CTime::GetCurrentTime();
     }

     AfxMessageBox(&quot;Time's up!&quot;);

     g_timer.Reset();

     return 0;
}
</pre>
</td></tr>
</table>
</p>

<p>The <b>Sleep()</b> function causes the thread on which the function is called to be suspended for the specified number of milliseconds.</p>

<p><li> Your next step is to implement the dialog box that is used to set the timer time. Use the dialog editor to create a dialog box like the one shown in Figure 5.8.</li></p>

<p>
<img src="images/f05DA08.jpg" width=285 height=179>
</p><p>
<!-- caption --><b>Figure 5.8</b> <i>The <b>Timer</b> dialog box</i><!-- /caption -->
</p>

<p>The dialog box as a whole should have the ID <b>IDD_TIMER</b>. The control that looks
similar to a combo box is a <b>Date Time Picker</b> control, which is available on the
control toolbar. This control should be given the ID <b>IDC_DTPSETTIME</b> and should
be set to display the time only.</p>
</ol>

<p><li> <b>To set the IDC_DTPSETTIME control to display the time only</b></li></p>

<ol>
<p><li> In the dialog editor, select the <b>IDC_DTPSETTIME</b> control. Press ENTER to edit the control properties.</li></p>
<p><li> Click the <b>Styles</b> tab. In the <b>Format</b> box, click <b>Time</b>.</li></p>
<p><li> Click outside the property sheet to close it.</li></p>
</ol>

<p>You will now create a dialog class for the <b>Timer</b> dialog box.</p>

<p><li> <b>To create the CTimerDialog class</b></li></p>

<ol>
<p><li> With the dialog editor open, press CTRL+W to open ClassWizard. When instructed, create the <b>CTimerDialog</b> class.</li></p>
<p><li> Click the <b>Member Variables</b> tab. Create a Value member variable for the <b>IDC_DTPSETTIME</b> ID. This should be a variable of type CTime and be named <b> m_settime</b>.</li></p>
<p><li> Click <b>OK</b> to close ClassWizard.</li></p>
</ol>

<p>Now all you have to do is add a command and handler function to set the timer time and start the timer thread.</p>

<p><li> <b>To add the Timer option to the View menu and the OnViewTimer() handler function</b></li></p>

<ol>
<p><li> Use the menu editor to create the <b>Timer</b> command on the <b>View</b> menu. Accept the <b>ID_VIEW_TIMER</b> ID that is created by default.</li></p>
<p><li> Use the <b>Message Maps</b> tab on ClassWizard to add a command handler for the <b>ID_VIEW_TIMER</b> object ID to the <b>CMainFrame</b> class. Name the function <b> OnViewTimer()</b>.</li></p>
<p><li> After the handler has been added, click the <b>Edit Code</b> button to locate the <b>CMyAppApp::OnViewTimer()</b> implementation. Add the following code to the body of the function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CTimerDialog aTDlg;

aTDlg.m_time = g_timer.GetTime();

if(aTDlg.DoModal() == IDOK)
{
     g_timer.SetTime(aTDlg.m_time);

     // Only one timer running per instance
     if(!g_timer.m_thread)
          g_timer.m_thread = AfxBeginThread(DoTimer, 0);
}
</pre>
</td></tr>
</table>
</p>

<p><li> To the top of the MainFrm.cpp file, along with the other #include statements, add the following line of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;TimerDialog.h&quot;</pre>
</td></tr>
</table>
</p>


<p><li> Now compile and build the MyApp application. Test the timer operation by choosing the <b>Timer</b> command from the <b>View</b> menu. The <b>Timer</b> dialog box appears with the current time displayed in the Date Time Picker control. Use the control to set the timer time to a minute or two later than the current time. Click <b> Start</b> to close the <b>Timer</b> dialog box and start the timer.</li></p>
</ol>

<p>While waiting for the timer, experiment with the other features of the MyApp
interface. You will notice that their performance is not affected by the independent
worker thread checking the system clock every second.</p>

<p>When the system clock catches up with the time set in the <b>Timer</b> dialog box,
the message box appears and the worker thread terminates.</p>

<A NAME="208"><H3>Creating User Interface Threads</H3></A>

<p>As we stated earlier, all threads in an MFC application are represented by objects 
of the <b>CWinThread</b> class, which are created by the <b>AfxBeginThread()</b> 
function. When you create a worker thread, <b>AfxBeginThread()</b>
creates a generic <b>CWinThread</b> object for you, and assigns the address of your
controller function to the CWinThread::m_pfnThreadProc member variable. To create a
user interface thread, you must derive your own class from <b>CWinThread</b> and pass
run-time information about the class to the user interface version of <b>
AfxBeginThread()</b>.</p>

<p>The following code snippet, taken from the MFC source code, shows how the framework
distinguishes between a worker thread and a user interface thread. The code is taken
from <b>_AfxThreadEntry()</b>, the entry-point function for all MFC threads.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
// First &#8212; check for simple worker thread
DWORD nResult = 0;
if (pThread-&gt;m_pfnThreadProc != NULL)
{
     nResult = (*pThread-&gt;m_pfnThreadProc)(pThread-&gt;m_pThreadParams);
     ASSERT_VALID(pThread);
}
// Else &#8212; check for thread with message loop
else if (!pThread-&gt;InitInstance())
{
     ASSERT_VALID(pThread);
     nResult = pThread-&gt;ExitInstance();
}
else
{
     // Will stop after PostQuitMessage called
     ASSERT_VALID(pThread);
     nResult = pThread-&gt;Run();
}
// Clean up and shut down the thread
threadWnd.Detach();
AfxEndThread(nResult);</pre>
</td></tr>
</table>
</p>

<p>If m_pfnThreadProc points to a controller function, the code knows that it is
dealing with a worker thread. The controller function is called and the thread is
terminated. If m_pfnThreadProc is NULL, the function assumes that it is dealing with a
user interface thread. The thread object's <b>InitInstance()</b> function is called
to perform thread initialization&#8212;to create the main window and other user
interface objects, for example. If <b>InitInstance()</b> returns successfully (i.e., by
returning TRUE), the <b>Run()</b> function is called. <b>CWinThread::Run()</b>
implements a message loop to process messages directed to the thread's main
window.</p>

<p>The <b>InitInstance()</b> and the <b>Run()</b> functions should sound familiar to you.
They are two of the key virtual functions that are inherited by <b>CWinApp</b>, which
was described in <a href="ch03d.htm#119">Lesson 3</a> of Chapter 3, in connection with the MFC implementation of
the Win32 application architecture.</p>

<p>You are obliged to provide an overloaded version of <b>InitInstance()</b> for your
thread class. Very often you will provide class-specific cleanup functions in an
overloaded version of <b>CWinThread::ExitInstance()</b>. Generally, you will use the
base class version of the <b>Run()</b> function.</p>

<p>The following exercise demonstrates the easiest way to create a <b>
CWinThread</b>-derived class.</p>

<p><li> <b>To create the CMyUIThread class</b></li></p>

<ol>
<p><li> From within the CMyApp project, press CTRL+W to open ClassWizard.</li></p>
<p><li> Click the <b>Add Class</b> button and choose <b>New</b> from the drop-down menu. The <b>New Class</b> dialog box appears.</li></p>
<p><li> In the <b>Name</b> box, type <b>CMyUIThread</b>. Choose <b>CWinThread</b> from the <b>Base class</b> drop-down menu.</li></p>
<p><li> Click <b>OK</b> to create the class, and then click <b>OK</b> to close ClassWizard.</li></p>
</ol>

<p>Open the MyUIThread.h and the MyUIThread.cpp files to inspect the source code for
your thread class. Note that ClassWizard has provided stub implementations of the <b>
InitInstance()</b> and <b>ExitInstance()</b> functions, to which you should add your
class-specific implementation code. Note, too, that a message map is implemented for
your thread class. The <b>DECLARE_DYNCREATE</b> and <b>IMPLEMENT_DYNCREATE</b> macros
play an important role here, as they implement the run-time class information for <b>
CObject</b>-derived classes that is required by the user interface thread version of
<b>AfxBeginThread()</b>.</p>

<p>After you have completed the implementation of your thread class, you call the user
interface thread version of <b>AfxBeginThread()</b>, passing your thread class's
run-time class information as a pointer as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>AfxBeginThread(RUNTIME_CLASS(CMyUIThread));</pre>
</td></tr>
</table>
</p>

<p>The <b>RUNTIME_CLASS</b> macro returns a pointer to the <b>CRuntimeClass</b>
structure that maintains run-time type information for all <b>CObject</b>-derived
classes declared with the <b>DECLARE_DYNAMIC, DECLARE_DYNCREATE</b>, or <b>
DECLARE_SERIAL</b> macros. This enables <b>AfxBeginThread()</b> to create a thread
object of the correct type.</p>

<p>The user interface thread version of <b>AfxBeginThread()</b> has the same set of
default parameters as the worker thread version. It also returns a pointer to the
thread object that it creates.</p>

<A NAME="209"><H2>Thread Synchronization</H2></A>

<p>Secondary threads are generally used to implement <i>asynchronous</i> processing. An
asynchronous operation is one that executes independently of other events or actions.
Consider our timer thread, which runs along its own path of execution, checking the
system clock once every second. It does not need to wait upon events in the application
primary thread, and the application can proceed without waiting for the thread to
finish its task.</p>

<p>There are a number of situations where these asynchronous activities will need to
<i>synchronize</i>, or coordinate their operations. As an example, consider a print
scheduler thread that queues print job threads created by different applications. The
print job threads will need to notify the scheduler that they want to join the queue,
and the scheduler will send a message to each print job in the queue when its turn
comes to print.</p>

<p>Another scenario that typically requires thread synchronization is the updating of
global application data. Consider a monitoring application with a sensor thread that
updates a data structure with readings from a sensor device. Another thread is used to
read the structure and display a representation of its state on the screen. Now suppose
that the display thread tries to obtain a reading at the very millisecond that the data
structure is being updated by the sensor thread. The result is likely to be corrupted
data, which could have serious consequences if the application was, for example,
monitoring a nuclear power plant. Thread access to global data needs to be synchronized
to ensure that only one thread can read or modify a thread at any time.</p>

<p>One way to implement thread synchronization is to use a global object to act as an
intermediary between threads. MFC provides a number of synchronization classes, listed
in Table 5.4. These synchronization classes, derived from the base class <b>
CSyncObject</b>, can be used to coordinate asynchronous events of any kind.</p>

<p><b>Table 5.4</b> <i>MFC Synchronization Classes</i></p>

<p><table cellpadding=5 width="95%"><tr>
<th>Name</th><th>Description</th>
</tr><tr>
<td valign="top">CCriticalSection</td> <td valign="top">A synchronization class that allows only one thread from within the
current process to access an object.</td>
</tr><tr>
<td valign="top">CMutex</td> <td valign="top">A synchronization class that allows only one thread from any process to
access an object.</td>
</tr><tr>
<td valign="top">CSemaphore</td> <td valign="top">A synchronization class that allows between one and a specified maximum
number of simultaneous accesses to an object.</td>
</tr><tr>
<td valign="top">CEvent</td> <td valign="top">A synchronization class that notifies an application when an event has
occurred.</td>
</tr></table></p>

<p>The synchronization classes are used in conjunction with the synchronization access
classes <b>CSingleLock</b> and <b>CMultiLock</b> to provide thread-safe access to
global data or shared resources. The recommended way to use these classes is as
follows:</p>

<ul>
<p><li> Wrap global data objects or resource access functions inside a class. Protect the
controlled data and regulate access through the use of public functions.</li></p>

<p><li> Within your class, create a synchronization object of the appropriate type. For
example, you would use a <b>CCriticalSection</b> object to ensure that your global data
is updated by only one thread at a time, or you might include a <b>CEvent</b> object to
signify that a resource was ready to receive data.</li></p>

<p><li> In the member functions that give access to the data or resource, create an
instance of a synchronization access object. Use <b>CSingleLock</b> when you need to
wait on only one object at a time. Use <b>CMultiLock</b> when there are multiple
objects that you could use at a particular time.</li></p>

<p><li> Before the function code attempts to access the protected data, call the <b>
Lock()</b> member function of the synchronization access object. The <b>Lock()</b>
function can be instructed to wait for a specified amount of time (or to wait
indefinitely) for the associated synchronization object to become available. For
example, a <b>CCriticalSection</b> object is available if it successfully manages to
secure exclusive execution access for the current thread. The availability of an event
is set in the program code by calling the <b>CEvent::SetEvent()</b> function.</li></p>

<p><li> After the function has finished accessing the protected data, call the access
object's <b>Unlock()</b> function or allow the object to be destroyed.</li></p>
</ul>


<p>Encapsulating global resources and synchronization code inside a thread-safe class
helps you centralize and control access to the resource and protect against a <i>
deadlock</i> situation. A deadlock is a condition in which two or more threads wait for
one another to release a shared resource before resuming their execution. Deadlock
conditions are notoriously difficult to reproduce or to track down, so you are strongly
advised to analyze your multithreaded application for possible deadlock conditions and
take steps to prevent their occurrence.</p>

<p>The following exercise illustrates the procedure for providing thread-safe access to
global data. You will use a <b>CCriticalSection</b> object and a <b>CSingleLock</b>
object to protect access to the <b>CTime</b> object contained within the <b>CTimer</b>
class that you created in the previous exercise.</p>

<p><li> <b>To implement thread-safe access to the CTimer class data</b></li></p>

<ol>
<p><li> At the top of the MainFrm.cpp file, with the other #include statements, add the
following line:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &lt;afxmt.h&gt;</pre>
</td></tr>
</table>
</p>

<p><li> Add this line of code to the <b>protected</b> section of the <b>CTimer</b> class
definition:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CCriticalSection m_CS;</pre>
</td></tr>
</table>
</p>

<p><li> Remove the inline definitions of the <b>CTimer::GetTime()</b> and <b>
CTimer::SetTime()</b> functions (remember to add semicolons in their place).</li></p>

<p><li> Beneath the <b>CTimer</b> class definition, add the <b>CTimer::GetTime()</b>
function definition as follows:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CTime CTimer::GetTime()
{
     CSingleLock csl(&amp;m_CS);
     csl.Lock();
     CTime time = m_time;
     csl.Unlock();
     return time;
}</pre>
</td></tr>
</table>
</p>

<p><li> Add the following <b>CTimer::SetTime()</b> function definition beneath the lines
of code you added in step 4:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CTimer::SetTime(CTime time)
{
     CSingleLock csl(&amp;m_CS);
     csl.Lock();
     m_time = time;
     csl.Unlock();
}</pre>
</td></tr>
</table>
</p>
</ol>

<p>The calls to <b>CSingleLock::Unlock()</b> in these functions are not strictly
necessary&#8212;we just consider them good programming style.</p>

<p>You can now build and run the application. You will not notice any difference in the
operation of the program, but you can rest assured that the data encapsulated in any
instance of the <b>CTimer</b> class can safely be accessed by any number of
threads.</p>

<A NAME="210"><H2>Lesson Summary</H2></A>

<p>Multiple threads can be used in an application wherever an improvement in
performance might be gained by running separate tasks concurrently. Asynchronous
operations that run in their own time frame, operations scheduled by a timer, and
operations that need to wait on events triggered by other threads are all possible
candidates for implementation as secondary threads in an application process.</p>

<p>All threads that use MFC functionality should be created by an instance of the MFC <b>
CWinThread</b> class. MFC provides the global function <b>AfxBeginThread()</b> to
assist you in the process of creating threads in an MFC application. MFC distinguishes
between two types of threads. Worker threads are commonly used to complete background
tasks that do not require user input. User interface threads are able to handle user
input, and they implement a message loop to respond to events and messages generated by
the user interaction with the application.</p>

<p>To create a worker thread, you implement a controlling function that performs the task
that your thread is to perform, and then pass the function address to the worker-thread
version of <b>AfxBeginThread()</b>. To create a user interface thread, you derive your
own class from <b>CWinThread</b>, provide overloads for key member functions, and pass
run-time information about the class to the user interface thread version of the <b>
AfxBeginThread()</b> function.</p>

<p>Secondary threads are generally used to implement <i>asynchronous</i> processing.
However, there are a number of situations where threads will need to synchronize their
activity. They might need to wait on a signal from another thread, or send signals to
other threads. Thread access to global data needs to be synchronized to ensure that
simultaneous access attempts do not result in data corruption.</p>

<p>MFC provides a number of synchronization classes derived from the base class <b>
CSyncObject</b>, which can be used to coordinate asynchronous thread activity. These
classes are used in conjunction with the synchronization access objects <b>
CSingleLock</b> and <b>CMultiLock</b>.</p>

<p>When controlling thread access to a shared resource, the recommended practice is to
encapsulate the resource inside a class, and to implement synchronization objects as
protected members of the same class. Use the synchronization access objects within the class member functions to ensure that the resources are
accessed in only a thread-safe manner&#8212;so that not more than one thread is
allowed at any given time.</p>

</BODY>
</HTML>







