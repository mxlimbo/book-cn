<HTML>
<HEAD>
<TITLE>Lab 13: Debugging the STUpload Application</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13h.htm", "ch13j.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="529"><H1>Lab 13: Debugging the STUpload Application</H1></A>

<p>In this section, you will use the Visual C++ debugger to investigate the STUpload
application as it runs. The lab exercises implement the debugger's Variables,
Watch, Call Stack, and Disassembly windows, and demonstrate how these windows all
contribute to the debugging effort. You will also set breakpoints at various locations
and examine the effects of data breakpoints.</p>

<p><b>Estimated lesson time: 15 minutes</b></p>


<A NAME="530"><H2>Running STUpload in the Debugger</H2></A>

<p>In this exercise, you will run STUpload in the debugger until the MFC framework
calls the application's <b>CMainFrame::OnCreate()</b> function. This function
executes early in the application's run cycle, before documents and views are
created and before the STUpload window appears on the screen. This process provides the
opportunity to single-step through <b>OnCreate()</b> for an inside view of how an MFC
program begins life.</p>

<p>The first step of the exercise is to build a debug version of the program, which is
necessary to run the debugger. If you have already created a debug version of STUpload
for labs in earlier chapters, skip to the second procedure.</p>

<p><li> <b>To build a debug version</b></li></p>

<ol>
<p><li> Open the STUpload project.</li></p>

<p><li> In the larger of the two text boxes on the <b>Build</b> toolbar, select <b>Win32
Debug</b>. Alternatively, you can click the <b>Set Active Configuration</b> command on
the <b>Build</b> menu and select <b>Win32 Debug</b>.</li></p>

<p><li>Click the <b>Build</b> button on the <b>Build</b> toolbar, or click the
<b>Build</b> command on the <b>Build</b> menu to compile and link the
application.</li></p>
</ol>

<p><li> <b>To stop execution at CMainFrame::OnCreate()</b></li></p>
<ol>
<p><li>On the <b>FileView</b> tab of the Visual C++ Workspace window, expand the list
of source files. Double-click <b>MainFrm.cpp</b> in the list to open the file.</li></p>

<p><li>Scroll down to find the beginning of the <b>OnCreate()</b> function, which looks
like this in the source code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)</pre>
</td></tr>
</table>
</p>


<p><li>Click the function's opening brace to set the insertion point there. This
action identifies the line at which the program should stop.</li></p>


<p><li>Launch the debugger by choosing <b>Start Debug</b> from the <b>Build</b>
menu and clicking the <b>Run to Cursor</b> command.</li></p>

</ol>

<p>The debugger begins first, then automatically runs the STUpload program. When <b>
CMainFrame::OnCreate()</b> gains control, execution halts at the line containing the
insertion point. The instruction has not yet executed, but is next in line to do so
when the program resumes.</p>

<p>Although no C++ code appears associated with the function's opening brace, code
nevertheless exists before the first C++ instruction, as you can see by clicking the
<b>Disassembly</b> tool in the debugger toolbar. The assembly language instructions
that appear in the source window are the function's prologue code, in which a stack frame is created and the class's <b>this</b> pointer is stored as a local variable. Click the <b>Disassembly</b> tool again to restore the normal Source window.</p>

<A NAME="531"><H2>Stepping Through Code</H2></A>

<p>This exercise demonstrates how to single-step through the <b>OnCreate()</b> function
using the <b>Step Into</b>, <b>Step Over</b>, and <b>Step Out</b> tools. The exercise
also shows how to read information in the debugger's Variables and Call Stack
windows while stepping through code.</p>

<p><li> <b>To see the Variables and Call Stack windows</b></li></p>

<ol>
<p><li> If the Variables window does not appear on your screen, click the <b>
Variables</b> tool on the debugger toolbar to expose the window. In its undocked state,
it appears as shown in Figure 13.13.</li></p>

<p>
<A HREF="javascript:fullSize('F13DA13x.htm')"> <img src="images/F13DA13.JPG" width=404 height=146 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.13</b> <i>The Visual C++ debugger's Variables window</i><!-- /caption -->
</p>

<p><li> Click the plus icon adjacent to the lpCreateStruct name in the Variables window
to expand the listing. Because the function's parameter is the only variable on the
current function's stack frame, lpCreateStruct is the only variable listed in the
window. It points to a <b>CREATESTRUCT</b> structure, the various fields of which
appear in the Variables window when the view is expanded. Expanding the view shows
that, for example, the structure's <b>lpszName</b> field contains a pointer to the
application's name.</li></p>

<p><li> Click the debugger's <b>Call Stack</b> tool to expose the Call Stack window
(Figure 13.14). This window shows the course taken to reach the <b>OnCreate()</b>
function, which heads the list. The second function in the call stack list identifies
the function that has called <b>OnCreate()</b>, and to which control will return when
<b>OnCreate()</b> finishes. In this case, the caller is <b>CWnd::OnWndMsg()</b>, part
of the MFC framework.</li></p>

<p>
<A HREF="javascript:fullSize('F13DA14x.htm')"> <img src="images/F13DA14.JPG" width=404 height=97 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.14</b> <i>The Visual C++ debugger's Call Stack window</i><!-- /caption -->
</p>

<p><li>Click the <b>Call Stack</b> tool again to hide the Call Stack
window.</li></p>
</ol>

<p><li><b>To single-step through OnCreate()</b></li></p>

<ol>
<p><li> Click the <b>Step Over</b> tool or press the F10 key to step through the first
two or three instructions of <b>OnCreate()</b>. Each time you invoke the <b>Step
Over</b> command, execution halts at the next instruction as indicated by the yellow
instruction arrow. Notice how the Variables window shows the application's data
changing with each instruction.</li></p>

<p><li> Continue single-stepping until the instruction arrow points to the line that
sets up docking for the application's toolbar:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);</pre>
</td></tr>
</table>
</p>

<p><li>Click the <b>Step Into</b> tool to step into the framework's <b>
CControlBar:: EnableDocking()</b> function. The debugger automatically locates the
func-tion's source file Bardock.cpp and opens it. Execution halts at the
function's first instruction.</li></p>

<p><li>Single-step through <b>CControlBar::EnableDocking()</b> if you want, then click
the debugger's <b>Step Out</b> tool to leave. The rest of the function executes,
and when control returns to <b>CMainFrame::OnCreate()</b>, execution halts at the
instruction following the call to <b>CControlBar::EnableDocking()</b>:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>EnableDocking(CBRS_ALIGN_ANY);</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="532"><H2>Setting Breakpoints</H2></A>

<p>This exercise demonstrates how to set breakpoints in another source file.
Breakpoints are most commonly set before launching the debugger, but as you will see in
this exercise you can set or clear breakpoints at any time, even while the debugger is
active.</p>

<p><li><b>To use a breakpoint to interrupt when importing a file</b></li></p>

<ol>
<p><li> Open the STUploadDoc.cpp source file and scroll down to locate the <b>
CSTUploadDoc::LoadData()</b> function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BOOL CSTUploadDoc::LoadData(CStdioFile &amp;infile)</pre>
</td></tr>
</table>
</p>

<p><li> In the <b>LoadData()</b> function, locate the <b>while</b> loop that reads each
line of a .dat file, as described in <A HREF="ch04a.htm">Chapter 4</A>:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>while(infile.ReadString(strTemp))
     {
       BOOL bValidDate = FALSE;
       CString strFund;
       CString strDate;
       .
       .
       .</pre>
</td></tr>
</table>
</p>

<p><li>Click anywhere on the <b>while</b> instruction to set the insertion point
there.</li></p>

<p><li>Press F9 to set a location breakpoint. A small red dot appears in the selection
margin to indicate the line has been tagged with a breakpoint.</li></p>

<p><li>Click the <b>Go</b> tool on the debugger's toolbar or press the F5 key. The
STUpload application resumes execution, finishing the <b>CMainFrame::OnCreate()</b>
function that had been interrupted. The STUpload main window now appears. At this
point, the STUpload program is active, not the debugger. The debugger does not become
active again until the program encounters a breakpoint.</li></p>

<p><li>On the program's <b>Data</b> menu, click <b>Import</b> and browse for the
Test.dat file in the \Chapter 4\Data folder. When you open the file, control stops at
the breakpoint set in the <b>CSTUploadDoc::LoadData()</b> function.</li></p>

<p><li>Right-click the following line and click either <b>Remove Breakpoint</b> or <b>Disable Breakpoint</b> from the shortcut menu. The first command removes the
breakpoint; the second makes the breakpoint unavailable without removing it.</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>while(infile.ReadString(strTemp))</pre>
</td></tr>
</table>
</p>

<p><li>Single-step through a few instructions, noting in the Variables window
how variables such as StrDate are correctly initialized.</li></p>
</ol>

<p><li><b>To set a data breakpoint</b></li></p>

<ol>
<p><li> On the <b>Edit</b> menu, click <b>Breakpoints</b>, or press CTRL+B to invoke the
<b>Breakpoints</b> dialog box.</li></p>

<p><li> On the <b>Data</b> tab, type <b>bFirstLine</b> in the text box labeled <b>Enter
the expression to be evaluated</b>. This action establishes a data breakpoint that
triggers only when the function's bFirstLine variable changes in value.</li></p>

<p><li> Click <b>OK</b> to close the <b>Breakpoints</b> dialog box.</li></p>

<p><li>Click the <b>Go</b> command again to resume execution.</li></p>
</ol>

<p>You will probably experience a short pause as the <b>while</b> loop continues
because of the drag on execution speed exacted by data breakpoints. The program soon
stops, however, and the debugger displays a message box saying that it has detected a
change in the value of bFirstLine. Clicking the message box's <b>OK</b> button
updates the source window showing the yellow instruction arrow that points to the
instruction following the one that has just cleared the bFirstLine flag.</p>

<p>Setting data breakpoints this way is not very helpful for simple variables like
bFirstLine that change value only once. However, data breakpoints can be invaluable
when tracking down obscure bugs in which a variable is incorrectly altered during
execution, and the location in which the variable was incorrectly altered is
indeterminable.</p>

<p><li> <b>To resume execution and terminate the program</b></li></p>

<ol>
<p><li> Press CTRL+B again to display the <b>Breakpoints</b> dialog box, and click the
<b>Remove All</b> button at the bottom of the dialog box. This action deletes the data
breakpoint attached to bFirstLine, ensuring that the program now runs at normal
speed.</li></p>

<p><li>Click the <b>Go</b> command, or press F5 to continue running the
STUpload program, and terminate the program normally through its <b>Exit</b> command.
When the program stops, so does the debugger.</li></p>
</ol>

</BODY>
</HTML>







