<HTML>
<HEAD>
<TITLE>Lesson 4: Document/View Architecture</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03d.htm", "ch03f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="133"><H1>Lesson 4: Document/View Architecture</H1></A>

<p>The purpose of an application is to perform operations on a set of data. When you
are working on the logical design of your application, you will need to specify how the
application data is going to be structured, and how it is to be presented to users so
that they can interact with it.</p>

<p>The MFC document/view architecture provides a single, consistent way of
co-ordinating application data as well as views of that data. The document/view
architecture is implemented by the classes created when you generate an application
using the AppWizard. This lesson will describe the features of the
document/view architecture and explain how the application framework implements
it.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe the features of the document/view architecture and the benefits they
offer to the application developer.</li></p>

<p><li> Describe how the application framework objects act together to implement the
document/view architecture.</li></p>

<p><li> Describe how the document/view architecture can be used to display a visual
representation of the application data on an output device such as a screen or a
printer.</li></p>
</ul>
<b>Estimated lesson time: 40 minutes</b>
</blockquote></div>
</p>

<A NAME="134"><H2>Documents and Views</H2></A>

<p>In the MFC framework, a document is simply an object that acts as a container for
the application data. A view is a window object, usually associated with the client
area of an onscreen window, through which the user interacts with the data contained in
the document.</p>

<p>This logical separation of application data and its visual representation means that
a document can be associated with a number of different views. For example, when
editing a Microsoft Word document, you can switch between Normal View, Page Layout
View, and Outline View. All of these views draw upon the same data&#8212;they simply
display it differently. Any changes made in one view are reflected in the other
views.</p>

<A NAME="135"><H2>Benefits of the Document/View Architecture</H2></A>

<p>The document/view architecture assists you by simplifying the process of rendering
application data on the screen in a way that enables users to interact with the data.
This functionality can be designed completely from scratch through the overloading of
the view's drawing function, the handling of mouse and keyboard interaction with
the view, and the handling of menu commands. Alternatively, you can elect to use a
predefined view that is based on a control. These capabilities let you develop an
application similar to Windows Explorer by using a Tree View and a List View side by
side in a split window. An Edit View, based on a rich-text edit control, can be used as
the basis of a text-editor.</p>

<p>The document/view architecture also simplifies printing and print previewing by
using the same drawing logic (contained in the view's drawing function) to render
the application's data on the view, on a print preview window, or on a printer.</p>

<p>The document/view architecture provides much of the logic for saving documents to
disk and loading them back into memory. This process of saving and loading documents,
known as <i>serialization</i>, allows you to save and retrieve data in the custom
object format used by your application, as well as in any of the object formats derived
from the MFC <b>CObject</b> class. Serialization of application data is covered in
<A HREF="ch06a.htm">Chapter 6</A>, <i>Persistent Data</i>.</p>

<p>Document/view architecture is important because applications that use documents and
views derive the greatest benefit from the application framework. Although most of the
discussion about Visual C++ and MFC functionality assumes the use of the document/view
architecture, you can use MFC without implementing a document/view architecture. The
benefits associated with document/view architecture also carry with them a potentially
significant performance and size cost.</p>

<p>In some cases, document/view might not be the right choice for your application. For
example, an application that compresses text files might require only a dialog box that
requests file names and displays a progress bar. A main frame window and a view are not
needed, so the document/view architecture would provide little, if any, benefit in this instance. In this case, you could use the dialog-based application framework that the AppWizard provides.</p>

<A NAME="136"><H2>SDI and MDI Applications</H2></A>

<p>As you learned in <A HREF="ch02a.htm">Chapter 2</A>, in addition to generating a dialog-based
application, the MFC AppWizard can generate frameworks for two types of
document/view-based applications: single document interface (SDI) and multiple-document
interface (MDI). SDI applications permit only one document frame window at a time. The
Paint and WordPad applications that come with Windows are examples of SDI applications.
MDI applications allow multiple document windows to be open within the same instance of
an application. In an MDI application, the user can open multiple MDI child windows in
the main window. These child windows are themselves frame windows, each containing a
separate document. Microsoft Word and Microsoft Excel are examples of MDI applications.
The SDI and MDI application types are shown in Figures 3.5 and 3.6.</p>

<p>
<A HREF="javascript:fullSize('f03DA05x.htm')"> <img src="images/f03DA05.jpg" width=404 height=303 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 3.5</b> <i>An SDI application</i><!-- /caption -->
</p>

<p>
<A HREF="javascript:fullSize('F03DA06x.htm')"> <img src="images/F03DA06.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 3.6</b> <i>An MDI application</i><!-- /caption -->
</p>

<A NAME="137"><H2>Objects in the Document/View Architecture</H2></A>

<p>The AppWizard generates the basic framework of an MFC document/view application for
you. As always, you can modify and extend the generated code to obtain the degree of
customization and control that you require.</p>

<p>This framework for documents and views implemented in classes is derived from the
MFC base classes <b>CDocument</b> and <b>CView</b>. The <b>CWinApp</b>, <b>
CFrameWnd</b>, and <b>CDocTemplate</b> classes work in conjunction with <b>
CDocument</b> and <b>CView</b> to ensure that all the pieces of the application fit
together.</p>

<p>Table 3.6 lists the application objects and related MFC base classes in a
document/view-based application and describes the major tasks each object performs.</p>

<p><b>Table 3.6</b> <i>Document/View-Based Application Objects and Related MFC Base Classes</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Object</th>
<th>Derivation and task</th>
</tr>
<tr>
<td valign="top">Document</td>
<td valign="top">Derived from <b>CDocument</b>. Specifies your application's data.</td>
</tr>
<tr>
<td valign="top">View</td>
<td valign="top">Derived from <b>CView</b>. As the user's window to the data, the view class specifies how the user sees your document's data and interacts with it.</td>
</tr>
<tr>
<td valign="top">Frame window</td>
<td valign="top">Derived from <b>CFrameWnd</b>. Views are displayed inside document frame windows. In an
SDI application, the document frame window is also the main frame window for the application.</td>
</tr>
<tr>
<td valign="top">Document template</td>
<td valign="top">Derived from <b>CDocTemplate</b>. A document template orchestrates
the creation of documents, views, and frame windows. A particular document-template class creates and manages all open documents of one type.</td>
</tr>
<tr>
<td valign="top">Application</td>
<td valign="top">Derived from <b>CWinApp</b>. Controls all of the objects in this table
and specifies the application's behavior, such as initialization and cleanup.
</td>
</tr>
</table>
</p>
<p>Document/view application objects cooperatively respond to user actions, bound together
by commands and other messages.</p>

<A NAME="138"><H3>Document Template Objects</H3></A>

<p>Document templates are created and maintained by the application object. One of the
key tasks performed during your application's <b>InitInstance()</b> function is to
construct one or more document templates of the appropriate kind. The following code
shows how this is achieved in an SDI application:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
// From CMyAppApp::InitInstance()
CSingleDocTemplate* pDocTemplate;
pDocTemplate = new CSingleDocTemplate(
     IDR_MAINFRAME,
     RUNTIME_CLASS(CMyAppDoc),
     RUNTIME_CLASS(CMainFrame),       // main SDI frame window
     RUNTIME_CLASS(CMyAppView));
AddDocTemplate(pDocTemplate);</pre>
</td></tr>
</table>
</p>

<p>When a document template object is created, it associates a document class with a
group of resources (such as menus and icons), a frame window, and a view. The template
is added to the application by using the <b>CWinApp::AddDocTemplate()</b> function.</p>

<p>In an SDI application, the user views and manipulates a document through a view
contained inside the main frame window, derived from <b>CFrameWnd</b>.
Figure 3.7 shows the relationship between the document/view objects in a running SDI
application.</p>

<p>
<img src="images/f03DA07.jpg" width=394 height=367>
</p><p>
<!-- caption --><b>Figure 3.7</b> <i>Objects in an SDI application</i><!-- /caption -->
</p>

<p>MDI applications use a <b>CMultiDocTemplate</b> object, which keeps a list of
many open documents of one type. MDI applications use a class derived from <b>
CMDIFrameWnd</b> to implement the application main window. Views are contained within
MDI child windows, implemented by the <b>CMDIChildWnd</b> class. An MDI child window
looks much like a typical frame window, except that it appears inside an MDI frame
window rather than on the desktop. An MDI child window does not have a menu bar of its
own, but instead shares the menu of the MDI frame window. The framework automatically
changes the MDI frame menu to represent the currently active MDI child window.</p>

<p>The construction of an application's <b>CMultiDocTemplate</b> object is
illustrated in the following code snippet.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
// From CMyMDIAppApp::InitInstance()
   CMultiDocTemplate* pDocTemplate;
   pDocTemplate = new CMultiDocTemplate(
       IDR_MYMDIATYPE,
       RUNTIME_CLASS(CMyMDIAppDoc),
       RUNTIME_CLASS(CChildFrame), // custom MDI child frame
       RUNTIME_CLASS(CMyMDIAppView));
   AddDocTemplate(pDocTemplate);</pre>
</td></tr>
</table>
</p>

<A NAME="139"><H3>Document Objects</H3></A>

<p>The document object in an MFC document/view application is implemented
in a class derived from <b>CDocument</b>. This class loads, stores, and manages
the application's data. It will also contain the functions that are used to
access and work with that data. To support the close connection between documents and
views, each document object maintains a list of all the associated views, accessed
through the <b>CDocument::GetFirstViewPosition()</b> and <b>
CDocument::GetNextView()</b> functions.</p>

<p>The <b>CDocument</b> class also provides the <b>UpdateAllViews()</b> member function,
which iterates through all the views associated with a document and notifies each one
that it should redraw itself (by calling the <b>CView::OnUpdate()</b> member
function).</p>

<p>Your application's views should be updated whenever changes are made to the
application data that affect how that data will appear on the screen.</p>

<A NAME="140"><H3>View Objects</H3></A>

<p>The view object physically represents the client area of an application. Logically
it represents a view of the information contained in the document class and allows the
user input through the mouse and keyboard. Whereas a document object can have any
number of views associated with it, a view always belongs to just one document. Views
in your application will be derived from the <b>CView</b> class unless you specify that
the AppWizard should use one of its specialized subclasses. These include <b>
CScrollView</b>, which will provide your view with scrolling functions; and <b>
CListView</b> and <b>CTreeView</b>, which allow you to base the representation of your
data on the list and tree common controls.</p>

<p>The <b>CView</b> class provides a <b>GetDocument()</b> member function, which
supplies a pointer to the associated document object.</p>

<A NAME="141"><H2>Drawing, Printing, and Print Preview Architecture</H2></A>

<p>The final section of this lesson takes a closer look at the <b>CView</b> class and
how it is used to display a visual representation of the application data on an output
device, such as a screen or a printer.</p>

<A NAME="142"><H3>Device Contexts and the GDI</H3></A>

<p>Windows provides a layer of abstraction between applications and output devices,
known as the Graphics Device Interface (GDI). The GDI presents a standard programming
interface to applications, allowing you to write code that is guaranteed to produce
consistent output on all GDI-compatible devices.</p>

<p>The GDI manages a data structure called a <i>device context</i>, which maintains
information about the current drawing attributes of a device. This might include
information such as the color palette, the text font, the width of the pen used to draw
lines, and the brush style used to fill areas. The Windows API provides a number of GDI
functions for drawing lines and shapes, filling areas, and printing text. These
functions render their output to a device context&#8212;they take a handle to a device
context as a parameter.</p>

<p>In MFC, the device context, as well as many general GDI operations, is encapsulated
by the CDC class, which provides creation and initialization functions for
a device context and drawing functions that you can use to render your
application's output. A number of classes that provide for a variety of specific
needs are derived from CDC, including those listed in Table 3.7.</p>

<p><b>Table 3.7</b> <i>CDC Derived Classes</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>CDC Derived Class</th>
<th>Description</th>
</tr>
<tr>
<td valign="top">CPaintDC</td>
<td valign="top">Encapsulates a device context that is prepared for painting an invalid region
of a client window, in response to a WM_PAINT message. The constructor calls <b>
CWnd::BeginPaint()</b>, which creates the device context and prepares the client area
for graphic output. The destructor calls <b>CWnd::EndPaint()</b> to perform clean up
operations.</td>
</tr>
<tr>
<td valign="top">CClientDC</td>
<td valign="top">Encapsulates a device context that represents only the client area of a
window.</td>
</tr>
<tr>
<td valign="top">CWindowDC</td>
<td valign="top">Encapsulates a device context that represents the whole window, including its frame.</td>
</tr>
<tr>
<td valign="top">CMetafileDC</td>
<td valign="top">Encapsulates drawing into a Windows metafile&#8212;a collection of
structures that stores a picture in a device-independent format.</td>
</tr>
</table>
</p>

<A NAME="143"><H3>Drawing in a View</H3></A>

<p>The graphical output of your application's data is handled by the view
object's <b>OnDraw()</b> member function. The <b>CView</b>-derived class that
AppWizard generates for you provides a stub <b>OnDraw()</b> function, to which you must
add code to display a representation of your application data. The stub <b>OnDraw()</b>
function looks like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppView::OnDraw(CDC* pDC)
{
     CMyAppDoc* pDoc = GetDocument();
     ASSERT_VALID(pDoc);
     // TODO: add draw code for native data here
}</pre>
</td></tr>
</table>
</p>

<p>Note that a pointer to a CDC object is passed to the <b>OnDraw()</b> function. This
pointer is used to call the device context drawing functions to render your
application's output. Note, also, that the stub implementation sets up a pointer to
your application's document object. You use this pointer to retrieve the
application data.</p>

<p>The following exercise demonstrates a very simple implementation of the <b>OnDraw()</b>
function.</p>

<p><li> <b>To implement the OnDraw() function</b></li></p>

<ol>
<p><li> Return to the MyApp project you created in the previous lesson.</li></p>

<p><li> In ClassView, right-click the <b>CMyAppDoc</b> class icon.</li></p>

<p><li> On the shortcut menu that appears, click <b>Add Member Variable</b>.</li></p>

<p><li> In the <b>Add Member Variable</b> dialog box, type <b>CString</b> in the <b>
Variable Type</b> box and <b>m_string</b> in the <b>Variable Name</b> box.</li></p>

<p><li> Leave the <b>Access</b> type set as <b>Public</b> and click <b>OK</b> to create
the variable.</li></p>

<p><li> Expand the <b>CMyAppDoc</b> class icon and confirm that the m_string member
variable has been added.</li></p>

<p><li> Locate the <b>CMyAppDoc</b> constructor icon, the member function displayed
beneath the <b>CMyAppDoc</b> class icon with the name <b>CMyAppDoc</b>. Note the key
icon, which indicates a protected class member. Double-click the <b>CMyAppDoc</b>
constructor icon to edit the constructor code.</li></p>

<p><li> Add the following line of code to the body of the constructor:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_string = &quot;Hello World!&quot;;</pre>
</td></tr>
</table>
</p>

<p><li> Expand the <b>CMyAppView</b> class icon. Double-click the <b>OnDraw()</b>
function icon to edit the function code.</li></p>

<p><li> Add the following code to the <b>OnDraw()</b> function in place of the //TODO
comment:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CSize TextSize = pDC-&gt;GetTextExtent(pDoc-&gt;m_string);
CRect rect(10, 10, 10+TextSize.cx, 10+TextSize.cy);
rect.InflateRect(4, 4);

pDC-&gt;Rectangle(&amp;rect);
pDC-&gt;TextOut(10, 10, pDoc-&gt;m_string);</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the program. Check that &quot;Hello World!&quot; is displayed
inside a rectangle in the upper left corner of your application's view.</li></p>
</ol>

<p>You will learn more about displaying application output in <A HREF="ch05a.htm">Chapter 5</A>, <i>
Implementing Application Behaviors</i>. For now, note the following points:</p>

<ul>
<p><li> The device context pointer is used to call the GDI member's functions of the
MFC CDC class to display the application output.</li></p>

<p><li> The document pointer is used to retrieve application data.</li></p>

<p><li> The drawing code is designed so that when the application data changes, it will
always be displayed in a consistent fashion&#8212;the rectangle will always neatly frame
the text. Try assigning a longer string to the <b>CMyAppDoc:: m_string</b> member in
the <b>CMyAppDoc</b> constructor. Recompile and rerun the program to verify that it
displays correctly.</li></p>
</ul>

<A NAME="144"><H3>How OnDraw() is Called by the Framework</H3></A>

<p>When a document's data changes in a way that will affect the visual
representation of the data, the view must be redrawn to reflect the changes. Typically,
this happens when the user makes a change through a view on the document. Any code that
updates the document data should call the document's member <b>UpdateAllViews()</b>
function to notify all views on the same document to update themselves.</p>

<p><b>UpdateAllViews()</b> calls each view's <b>OnUpdate()</b> member function. The
default implementation of <b>OnUpdate()</b> invalidates the view's entire client
area. You can override <b>OnUpdate()</b> to invalidate only those regions of the client
area that map to the modified portions of the document.</p>

<p>When a view becomes invalid, Windows sends it a WM_PAINT message. The view's
default <b>OnPaint()</b> handler function responds to the message by creating a device
context object of class <b>CPaintDC</b> and passing it to the view's <b>
OnDraw()</b> member function. You have already seen how the <b>OnDraw()</b> function
uses this device context object to draw a representation of your data.</p>

<A NAME="145"><H3>Printing and Print Preview</H3></A>

<p>In Windows programming, sending output to the printer is very similar to sending
output to the screen. This is because the GDI is hardware-independent. You can use the
same GDI functions for screen display or for printing simply by
using the appropriate device context. If the CDC object that <b>OnDraw()</b>
receives represents the printer, the output from <b>OnDraw()</b> goes to the
printer.</p>

<p>This explains how MFC applications can perform simple printing without requiring
extra effort on your part. The framework takes care of displaying the <b>Print</b>
dialog box and creating a device context for the printer. When the user chooses the <b>
Print</b> command from the <b>File</b> menu, the view passes this device context to <b>
OnDraw()</b>, which draws the document to the printer.</p>

<p>
<A HREF="javascript:fullSize('f03DA08x.htm')"> <img src="images/f03DA08.jpg" width=404 height=375 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 3.8</b> <i>How <b>OnDraw()</b> is called by the framework</i><!-- /caption -->
</p>

<p>There are, however, some significant differences between printing and screen display.
When you print, you have to divide the document into distinct pages and display them
one at a time, rather than display whatever portion is visible in a window. As a
corollary, you have to be aware of the size of the paper (whether it's letter size,
legal size, or an envelope). You might want to print in different orientations, such as
landscape or portrait. The <b>CView</b> class provides a set of print-related functions
to enable you to implement the logic for the printing routines.</p>

<A NAME="146"><H2>Lesson Summary</H2></A>

<p>The MFC document/view architecture is implemented by the application framework to
provide a single, consistent way of coordinating application data and views of that
data. A document is an object that acts as a container for the application's data.
A view is a window object, usually associated with the client area of an onscreen
window, through which the user interacts with the data contained in the document.</p>

<p>The document/view architecture provides many benefits to the application developer.
The document/view architecture simplifies the display of the application data on the
screen so that users can interact with the data. Printing and print
previewing are also simplified because the same drawing logic is used to render the
application's data on the view window, on a print preview window, or on
a printer. The document/view architecture provides much of the logic for
<i>serialization</i>&#8212;the saving of documents to disk and loading them back into
memory.</p>

<p>The framework classes generated by the MFC AppWizard work together to implement the
document/view architecture. The application object contains at least one document
template object that associates a document class (derived from the MFC class <b>
CDocument</b>) with a group of resources, with a frame window class, and with a view
class (derived from the <b>CView</b> class).</p>

<p>Document/view applications can expose a single document interface (SDI) or a multiple
document interface (MDI). SDI applications permit only one document, displayed within
the application's main frame window, to be open at a time. MDI applications allow
multiple documents, displayed in multiple MDI child windows, to be opened in a single
instance of an application.</p>

<p>Drawing on an output device such as a screen or a printer is handled by the Graphical
Device Interface (GDI). The GDI presents a standard programming interface that allows
you to write device-independent graphical output code. The GDI manages a data structure
called a device context, which maintains information about the current drawing
attributes of a device. GDI drawing functions render their output to a device context.
MFC encapsulates device contexts, and the associated GDI drawing functions, in the <b>
CDC</b> class.</p>

<p>The application's drawing logic is implemented by the view's <b>OnDraw()</b>
function. The <b>OnDraw()</b> function is called by the framework, and is passed a
pointer to a <b>CDC</b> object that represents the current device context. You add code
to the <b>OnDraw()</b> function to display a visual representation of your application
data, which is contained within the application's document object. The same drawing
code is used to render output to your application's view, to a print preview
window, and to the printer.</p>

</BODY>
</HTML>







