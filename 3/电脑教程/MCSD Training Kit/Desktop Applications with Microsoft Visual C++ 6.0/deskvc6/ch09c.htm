<HTML>
<HEAD>
<TITLE>Lesson 2: Understanding ATL COM Component Code</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09b.htm", "ch09d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="365"><H1>Lesson 2: Understanding ATL COM Component Code</H1></A>

<p>In this lesson, you will review aspects of the source code generated by the ATL
wizards for your COM object. You will review specific code segments including the class
declaration, the class body, the global entry-point functions, the registry script
resource, and the interface definition language (IDL) file. After you get familiar with
the code involved with the ATL approach, you learn about some alternative approaches to
developing a COM object.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>
<p><li>Describe the functionality provided for a component by the 
<b>CComObjectRootEx</b> and the <b>CComCoClass</b> templated base classes.</li></p>

<p><li>Describe the global entry-point functions provided for a COM server.</li></p>

<p><li>Describe features of the registry script file created for an ATL project.</li></p>

<p><li>Describe features of the IDL file created for an ATL project.</li></p>

<p><li>Describe some of the alternative approaches to COM component development.</li></p>
</ul>

<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>

<A NAME="366"><H2>Component Class Definition</H2></A>

<p>The definition for your component class appears in the Encoder.h file. This
definition is a standard C++ class specification that uses multiple inheritance.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>class ATL_NO_VTABLE CEncoder :
     public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
     public CComCoClass&lt;CEncoder, &amp;CLSID_Encoder&gt;,
     public Iencoder
{
public:
     CEncoder()
     {
          m_Key = 1;
     }

DECLARE_REGISTRY_RESOURCEID(IDR_ENCODER)
DECLARE_NOT_AGGREGATABLE(CEncoder)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEncoder)
     COM_INTERFACE_ENTRY(IEncoder)
END_COM_MAP()

// IEncoder
public:
     STDMETHOD(get_Key)(/*[out, retval]*/ short *pVal);
     STDMETHOD(put_Key)(/*[in]*/ short newVal);
     STDMETHOD(EncodeString)(/*[in]*/ const BSTR instring, 
     /*[out, retval]*/ BSTR * outstring);
protected:
     short m_Key;
};</pre>
</td></tr>
</table>
</p>

<p>Your class inherits from three base classes: <b>CComObjectRootEx</b>, <b>
CComCoClass</b>, and <b>IEncoder</b>. The first two of these classes are ATL templated
base classes. The remaining class is your interface, which has been declared in the
EncodeServer.h file as an abstract base class. The interface methods you define are
added to the <b>IEncoder</b> class as pure virtual functions. The derived-class
versions of these functions that you provide implement the specific services of your
COM server. In a public section at the end of the class definition, you can see the
declaration of the <b>EncodeString()</b> implementation.</p>

<p>The <b>CComObjectRootEx</b> class provides a default implementation for the <b>
IUnknown</b> interface methods <b>QueryInterface()</b>, <b>AddRef()</b>, and <b>
Release()</b>. When you derive from this class, your client can use <b>
QueryInterface()</b> to acquire an interface pointer to any interface that your COM
object supports. The methods <b>AddRef()</b> and <b>Release()</b> perform reference
counting to hold your COM object in memory while clients are using interface pointers.</p>

<p>Deriving from the <b>CComCoClass</b> base class provides you with a default
implementation of a class factory. The class factory creates an instance of your COM
server. You provide the name of the server class (<b>CEncoder</b>) and a reference to
its GUID (<b>CLSID_Encoder</b>) as arguments to this templated base class. The ATL
wizards use the UUIDGEN.EXE utility to generate all the GUIDs in this project.</p>

<p>Another important element of your class declaration is the COM map. This map contains a
list of the interfaces that your COM object supports. You add an entry to the COM map
by using the macro <b>COM_INTERFACE_ENTRY</b>. Behind the scenes, the framework
maintains a corresponding array of <b>ATL_INTMAP_ENTRY</b> structures that associate
interface GUIDs with functions that retrieve interface pointers. The COM map is used by
the default <b>QueryInterface()</b> method that you inherited from the templated base
class <b>CComObjectRootEx</b>. Whenever
a client application executes <b>QueryInterface()</b>, the default implementation
searches this map for a matching interface GUID. If a match is found, the associated
function returns the corresponding interface pointer.</p>

<A NAME="367"><H2>Component Method Implementation</H2></A>

<p>The Encoder.cpp file contains the body of the <b>EncodeString()</b> method that you
implemented in the previous lesson.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;stdafx.h&quot;
#include &quot;EncodeServer.h&quot;
#include &quot;Encoder.h&quot;

STDMETHODIMP CEncoder::EncodeString(const BSTR instring, BSTR *outstring)
{
     BSTR tempstring = ::SysAllocString(instring);
     wcscpy(tempstring, instring);

     for(UINT i = 0; i &lt; ::SysStringLen(tempstring); i++)
          tempstring[i] += m_Key;

     *outstring = ::SysAllocString(tempstring);

     ::SysFreeString(tempstring);

     return S_OK;
}</pre>
</td></tr>
</table>
</p>

<p>This code contains a couple of COM-specific features that were automatically added
to the method on your behalf by the Add Method to Interface Wizard.</p>

<p>This method uses the macro <b>STDMETHODIMP</b> as the return data type. You can find
this macro defined in the header file BASETYPS.H as:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HRESULT export stdcall</pre>
</td></tr>
</table>
</p>

<p>Because you have specified that the return value is to be an HRESULT, the Add Method
to Interface Wizard automatically inserts a line of code to return the constant S_OK.
This intrinsic constant meets the data structure format of an HRESULT and contains a
success return code embedded within that structure. For more information on the HRESULT
type, see <a href="ch13c.htm#480">Lesson 2</a> of Chapter 13.</p>

<A NAME="368"><H2>Global Entry-Point Functions</H2></A>

<p>On the <b>ClassView</b> tab of the Workspace view, you find a folder named Globals.
If you expand this folder, you will see several global functions (with the prefix 
<i>Dll</i>) and a single global object named <b>_Module</b>. These elements appear in the
file EncodeServer.cpp, and are added to your project by the ATL COM AppWizard to
provide entry point functions that are exported by the DLL and called by COM and other
system utilities. The following code is contained in EncodeServer.cpp:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;stdafx.h&quot;
#include &quot;resource.h&quot;
#include &lt;initguid.h&gt;
#include &quot;EncodeServer.h&quot;

#include &quot;EncodeServer_i.c&quot;
#include &quot;Encoder.h&quot;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Encoder, CEncoder)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern &quot;C&quot;
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
     if (dwReason == DLL_PROCESS_ATTACH)
     {
          _Module.Init(ObjectMap, hInstance, &amp;LIBID_ENCODESERVERLib);
          DisableThreadLibraryCalls(hInstance);
     }
     else if (dwReason == DLL_PROCESS_DETACH)
          _Module.Term();
     return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
     return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
     return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
     // registers object, typelib and all interfaces in typelib
     return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
     return _Module.UnregisterServer(TRUE);
}</pre>
</td></tr>
</table>
</p>

<p>Near the beginning of the file you can see the declaration of a single 
<b>CComModule</b> object named <b>_Module</b>. The <b>CComModule</b> class implements a
COM server module, allowing a client to access the module's components. 
<b>CComModule</b> supports both in-process and out-of-process modules. Out-of-process
(EXE) servers use an application-specific object that is <i>derived</i> from 
<b>CComModule</b>.</p>

<p>A <b>CComModule</b> instance uses a table called an <i>object map</i> to maintain a set
of class object definitions. Behind the scenes, this object map creates and maintains
an array of <b>_ATL_OBJMAP_ENTRY</b> structures, which include information used by the
framework to:</p>

<ul>
<p><li>Instantiate objects through a class factory.</li></p>

<p><li>Establish communication between a client and the root object in the component.</li></p>

<p><li>Perform lifetime management of class objects.</li></p>

<p><li>Enter and remove object descriptions in the system registry.</li></p>
</ul>

<p>An <b>OBJECT_ENTRY</b> macro is placed in the object map for each COM
object in the DLL. The <b>OBJECT_ENTRY</b> macro takes two parameters.
The first parameter is a GUID that uniquely identifies the COM object. The
second parameter is the name of the class that implements the COM object. Using this
information, the macro expansion creates a corresponding <b>_ATL_OBJMAP_ENTRY</b> for
the specified object.</p>

<p>When loading your DLL in response to a client request, COM executes your 
<b>DllGetClassObject()</b> function. This function calls the <b>CComModule::
GetClassObject()</b> base class function provided by the _Module global object to
access the class factory of the specified object. <b>CComModule::GetClassObject()</b>
accesses the table maintained by the object map to retrieve a pointer to the 
<b>CreateInstance()</b> method of the class factory. The <b>GetClassObject()</b> function
uses the pointer to create a COM object, executes the COM object's 
<b>QueryInterface()</b> function, and returns the interface pointer to COM.</p>

<p>EXE servers do not implement the <i>Dll&#8230;</i> functions; they call the COM run-time
function <b>CoRegisterClassObject()</b> on startup for each of the class factories that
the function implements. Pointers to the class factories are cached in an internally
maintained table.</p>

<p>The <b>DllRegisterServer()</b> and the <b>DllUnregisterServer()</b> functions provide
an in-process COM object with its self-registering capability. These functions can be
called by programs such as the command-line utility RegSvr32.exe to add or remove
information about your COM object to or from the registry. EXE servers check for the
command-line switches&#8212;RegServer or UnregServer&#8212;to determine whether they
should register or unregister the server. Both EXEs and DLLs end up calling the 
<b>CComModule::RegisterServer()</b> and <b>CComModule:: UnregisterServer()</b> functions.
These functions register or unregister all objects declared in the object map using
information contained in a registry script resource, which is described in the
following section.</p>

<A NAME="369"><H2>Registry Script Resource</H2></A>

<p>When a client application attempts to load a COM object, the COM run-time looks in
the registry for specific information. This information appears in the registry under
<b>HKEY_CLASSES_ROOT (HKCR)</b>. The ATL wizards create a registry script for your 
COM component that contains the required information.</p>

<p>The registry script is included as a resource in your project. The script file has
an .rgs extension, and can be found in your project folder. The following is the
Encoder.rgs file:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HKCR
{
     EncodeServer.Encoder.1 = s 'Encoder Class'
     {
          CLSID = s '{69F4B917-6641-11D3-934B-0080C7FA0C3E}'
     }
     EncodeServer.Encoder = s 'Encoder Class'
     {
          CLSID = s '{69F4B917-6641-11D3-934B-0080C7FA0C3E}'
          CurVer = s 'EncodeServer.Encoder.1'
}
NoRemove CLSID
{
     ForceRemove {69F4B917-6641-11D3-934B-0080C7FA0C3E} 
          = s 'Encoder Class'
     {
          ProgID = s 'EncodeServer.Encoder.1'
          VersionIndependentProgID = s 'EncodeServer.Encoder'
          InprocServer32 = s '%MODULE%'
          {
          }
          'TypeLib' = s '{69F4B91A-6641-11D3-934B-0080C7FA0C3E}'
}
}
}</pre>
</td></tr>
</table>
</p>

<p>The registry script just shown places data into the registry subtree 
<b>HKEY_CLASSES_ROOT</b>. Entries are created for the CLSID, the ProgID (both versioned and
version-independent forms), and the type library. As the Encoder object is hosted in a
DLL server, an InprocServer32 entry is created. This entry contains a variable called
%MODULE%. When the registry script is processed by Visual Studio, the actual name of
the project executable is inserted in place of this variable.</p>

<A NAME="370"><H2>IDL File</H2></A>

<p>An IDL file is compiled by the Microsoft IDL compiler (MIDL). MIDL creates the
following files in your project folder:</p>

<ul>
<p><li>Proxy/stub source code to implement standard marshaling.</li></p>

<p><li>A type library file.</li></p>

<p><li>A C file that defines the component and interface GUIDs.</li></p>

<p><li>A C/C++ header file that declares the interface methods exposed by the component.</li></p>
</ul>

<p>The proxy/stub code generated for the <b>Encoder</b> object is contained in the
files DllData.c and EncodeServer_p.c. You compile this code to create a <i>proxy/stub
DLL</i> which is used by COM to marshal data across process boundaries. The type 
library file EncodeServer.tlb is linked to the DLL when you build the component.</p>

<p>The GUID definition file (EncodeServer_i.c) and the interface declaration header file
(EncodeServer.h) are both used by the EncodeServer project. However, it is important to
know about these files because they can be included (using #include) in C/C++ client
code to create and use instances of the COM component. The CLSID <b>CLSID_Encoder</b>
and the IID <b>IID_IEncoder</b> declared in EncodeServer_i.c can be used as parameters
in a call to <b>CoCreateInstance()</b>. The EncodeServer.h file declares a class that
represents the <b>IEncoder</b> interface, which provides the compiler with the
signatures of the interface methods. You use an instance of this class to call the 
<b>IEncoder</b> methods when the <b>Encoder</b> object is instantiated.</p>

<p>You will learn how these files are used by client programs in <a href="ch10b.htm#380">Lesson 1</a> of Chapter 10.</p>

<p>The EncodeServer.idl file is as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>import &quot;oaidl.idl&quot;;
import &quot;ocidl.idl&quot;;
     [
          object,
          uuid(69F4B926-6641-11D3-934B-0080C7FA0C3E),
          helpstring(&quot;IEncoder Interface&quot;),
          pointer_default(unique)
     ]
     interface IEncoder : Iunknown
     {
          [helpstring(&quot;method EncodeString&quot;)] HRESULT 
          EncodeString([in] const BSTR instring, 
               [out, retval] BSTR * outstring);
          [propget, helpstring(&quot;property Key&quot;)] 
               HRESULT Key([out, retval] short *pVal);
          [propput, helpstring(&quot;property Key&quot;)] 
               HRESULT Key([in] short newVal);
     };

[
     uuid(69F4B91A-6641-11D3-934B-0080C7FA0C3E),
     version(1.0),
     helpstring(&quot;EncodeServer 1.0 Type Library&quot;)
]
library ENCODESERVERLib
{
     importlib(&quot;stdole32.tlb&quot;);
     importlib(&quot;stdole2.tlb&quot;);

     [
          uuid(69F4B917-6641-11D3-934B-0080C7FA0C3E),
          helpstring(&quot;Encoder Class&quot;)
     ]
     coclass Encoder
     {
          [default] interface IEncoder;
     };
};</pre>
</td></tr>
</table>
</p>

<p>This IDL file defines the <b>Encoder</b> COM object (coclass), the <b>IEncoder</b>
interface, and the ENCODESERVERLib type library. You can see from this example that
IDL syntax is very similar to C++, with the most noticeable difference being the
inclusion of attributes in square brackets in front of each object declaration.</p>

<p>MIDL attributes specify the characteristics of interfaces, coclasses, and libraries.
For example, [<b>uuid</b>] is a required attribute that specifies the unique identifier
(GUID) for each of these objects. The GUIDs that appear in this file are generated by
the ATL wizards. Notice the [<b>propput</b>] and [<b>propget</b>] attributes, which
inform languages such as Visual Basic that a method is to be treated as a property.</p>

<p>Notice that the coclass definition is enclosed within the type library definition. This
means that a description of the COM object will be included in the type
library. By declaring a coclass <i>outside</i> the library block you can prevent
information about the COM object appearing in the type library. You might want to do
this if you create COM objects that are used only internally&#8212;by other objects in
the same DLL, for example.</p>

<A NAME="371"><H2>Alternative Approaches To Development</H2></A>

<p>In addition to ATL, there are several other approaches to developing COM objects.
You can implement an object from scratch using C++. You can also use the Microsoft
Foundation Classes (MFC).</p>

<A NAME="372"><H3>C++</H3></A>

<p>Implementing a COM object from scratch in C++ requires extensive coding. To achieve
this you would perform the following process:</p>

<ol>
<p><li>Create a DLL for hosting an in-process COM server.</li></p>

<p><li>Derive an interface class from the <b>IUnknown</b> class.</li></p>

<p><li>Generate GUIDs for the object (CLSID) and the interface (IID).</li></p>

<p><li>Declare a component class derived from the interface class.</li></p>

<p><li>Implement the <b>IUnknown</b> methods for managing the lifetime of the COM
object.</li></p>

<p><li>Implement the component-specific methods for performing the real work of the COM
object.</li></p>

<p><li>Implement a class factory for creating the server inside the memory space of the
DLL.</li></p>

<p><li>Implement the methods <b>DllGetClassObject()</b> and <b>DllCanUnloadNow()</b> to
interface the DLL in-process server to COM.</li></p>

<p><li>Export the <b>DllGetClassObject()</b> and <b>DllCanUnloadNow()</b> methods to
the operating system.</li></p>

<p><li>Generate a registry script containing the object class and class interface
GUIDs.</li></p>

<p><li>Register the object using the registry script.</li></p>
</ol>

<p>Most of this process is concerned with the mechanics of generating the equivalent of
the COM boilerplate code that ATL provides automatically. While you can generate this
boilerplate by editing existing code, it's a tedious and error-prone task. Using
ATL saves you a lot of time, and generates efficient components that perform extremely
well.</p>

<A NAME="373"><H3>MFC</H3></A>

<p>It is perfectly possible to use MFC to generate a COM object. However, MFC is really
geared towards the creation of applications, and its COM support is framed in the
context of OLE. OLE (now largely rebranded as ActiveX) is the COM-based technology that
allows applications to export feature sets (aspects of their functionality) to other
applications. For example, it is OLE technology that allows you to embed a Microsoft
Excel spreadsheet inside a Microsoft Word document.</p>

<p>Because OLE features are generally implemented using dispatch interfaces, MFC COM
support is based around dispatch mapping technologies implemented by the <b>
CCmdTarget</b> class. If you want to create a component that exposes a custom
interface, you have to resort to using raw C++ code.</p>

<p>Another drawback of MFC COM is that you have to distribute the weighty MFC libraries
with your component. If you are distributing the component along with an application
that already installs the MFC DLLs, this is not such a big issue, but having to check
for and install the libraries for the sake of a single small component is tiresome. In
certain situations, statically linking the MFC libraries to your component can make
them unacceptably large. One of the reasons for the development of ATL was that MFC
components and controls were not found to be suitable for deployment and activation in
an Internet environment.</p>

<p>However, MFC is a perfectly good tool for the development of Automation-based
components in environments where the MFC libraries can be easily deployed. You can use
MFC to easily create ActiveX controls that can be reused many times in your MFC
applications. This will be the subject of <A HREF="ch11a.htm">Chapter 11</A>.</p>

<A NAME="374"><H2>Lesson Summary</H2></A>

<p>When you implement a COM server using the ATL wizards, you are provided with a
framework based on ATL templates and macros. Your component class inherits from two
base classes: <b>CComObjectRootEx</b> and <b>CComCoClass</b>. These classes are
templated base classes that provide you with the methods of <b>IUnknown</b> and a class
factory. The ATL wizards provide you with a set of
global entry point functions that register your component and allow COM to
create instances of your component to service client requests. An IDL file is created
that is compiled by the MIDL compiler; this generates proxy/stub code, a type library,
and C/C++ header files that define your component's GUIDs and declare the
interfaces exposed by your component. These header files can be used by clients to
create instances of your COM object and call its interface methods.</p>

<p>Although you can use straight C++ to implement your COM objects, the
easiest and safest approach is to use ATL and the ATL wizards. MFC COM
support is more geared towards the creation of larger-scale ActiveX applications and
Automation-based components operating in an MFC environment.</p>

</BODY>
</HTML>







