<HTML>
<HEAD>
<TITLE>Lesson 3: Accessing the Registry</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06c.htm", "ch06e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="252"><H1>Lesson 3: Accessing the Registry</H1></A>

<p>The Windows registry is a central, hierarchically organized database that holds
persistent configuration information for the operating system and for applications. On
Windows NT, Windows 95, and Windows 98, the registry provides a secure alternative to
the .ini configuration files used by 16-bit Windows platforms. In this lesson, you will
learn how to use the registry to save and retrieve user settings for a Windows
application.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>


<ul>
<p><li> Recognize the registry's basic organizational structure.</li></p>

<p><li> Understand how MFC supports programmatic access to the registry and how you can
use these features to store and retrieve application settings.</li></p>

<p><li> Describe the circumstances under which you might use the Win32 API to access the
registry, and the principal functions that enable you to perform this action.</li></p>
</ul>


<b>Estimated lesson time: 40 minutes</b>
</blockquote></div>
</p>


<A NAME="253"><H2>Registry Data</H2></A>

<p>The registry is used to store configuration information for the operating system and
settings for applications. It is used to store everything from the IP address of
installed network cards to the Regional Settings found in the Control Panel to the view
mode (Scientific or Standard) of the Windows calculator. As a result, the registry
typically contains at least several megabytes of data.</p>

<p>To facilitate manipulating such large amounts of data, the logical view of the
registry is that of a hierarchy. While the underlying physical structure of the files
constituting the registry is different under Windows NT than under Windows 95 and
Windows 98, the Win32 API hides these differences from users and developers by
providing a consistent interface for storing and retrieving registry settings. However,
before attempting to programmatically manipulate the registry, you should become
familiar with the registry hierarchy. A good way to do that is through the <i>registry
editor</i>.</p>

<p>The registry editor for Windows 95 and Windows 98 is <i>regedit.exe</i>, which can
be found in the Windows directory. Windows NT users will find an additional registry
editor&#8212;<i>regedt32.exe&#8212;</i>in the Winnt\System32 directory. Regedt32.exe has
some additional features useful under Windows NT. (It is able to set security for
registry keys and to view or edit the <b>REG_EXPAND_SZ</b> and <b>REG_MULTI_SZ</b> data
types.) Most users prefer the search features of regedit, but for exploration under
Windows NT, the read-only mode of regedt32 affords the beginning programmer an added
level of protection against accidentally corrupting the registry.</p>

<p>
<div class="caution"><blockquote><b>CAUTION</b><hr>
Improper editing of your registry entries could cause your
applications to stop working, and could even permanently cause your operating system to
become unavailable. Before editing the registry, you should first back up the registry
files. With Windows 95, you should make copies of System.dat and User.dat, both of
which are hidden files in the Windows folder. With Windows NT, you should create an
updated Emergency Repair Disk. Consult your operating system documentation for more
details.</blockquote></div>
</p>

<p><li> <b>To explore the
registry (Windows NT)</b></li></p>

<ol>

<p><li> On the <b>Start</b> menu, click <b>Run</b>.</li></p>

<p><li> In the <b>Open</b> box, type <b>regedt32</b> and click <b>OK</b>.</li></p>


<p>The registry editor opens as shown in Figure 6.2.</p>

<p>
<A HREF="javascript:fullSize('f06DA02x.htm')"> <img src="images/f06DA02.jpg" width=404 height=291 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 6.2</b> <i>Exploring the registry using RegEdt32</i><!-- /caption -->
</p>


<p><li> On the registry editor <b>Options</b> menu, select <b>Read Only Mode</b>.</li></p>
</ol>

<p><li><b>To explore the registry (Windows 95 and Windows 98)</b></li></p>
<ol>
<p><li> On the <b>Start</b> menu, click <b>Run</b>.</li></p>

<p><li> In the <b>Open</b> box, type <b>regedit</b> and click <b>OK</b>.</li></p>


<p>The registry editor opens as shown in Figure 6.3.</p>

<p>
<A HREF="javascript:fullSize('f06DA03x.htm')"> <img src="images/f06DA03.jpg" width=404 height=291 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 6.3</b> <i>Exploring the registry using RegEdit</i><!-- /caption -->
</p>
</ol>

<A NAME="254"><H3>Registry Organization</H3></A>

<p>The registry is organized as a hierarchically structured database. At the root of
the hierarchy is a set of predefined subtrees, which correspond to the most general
categories of the system's organization. Notice how the two editors differ in the
way they display the subtrees. <b>RegEdit</b> displays all of the subtrees in a single
window, descended from a common root. <b>RegEdt32</b> displays each subtree in its own
window.</p>

<p>Table 6.3 illustrates the five subtrees common to the Windows platforms.</p>

<p><b>Table 6.3</b> <i>Windows 95, Windows 98, and Windows NT Subtrees</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">

<tr>
<th>Key name </th><th>Purpose</th>
</tr>

<tr>
<td valign="top">HKEY_CLASSES_ROOT </td><td valign="top">Contains software configuration information. Includes file
name extension/application associations, drag and drop protocols, printing configurations, 
and COM configuration information.</td>
</tr>

<tr>
<td valign="top">HKEY_CURRENT_USER</td> <td valign="top">Contains user-specific settings for the system. This subtree is
created when the user logs on, loaded with information from the user's entry in <b>
HKEY_USERS</b>, and deleted when the user logs off.</td>
</tr>

<tr>
<td valign="top">HKEY_LOCAL_MACHINE </td><td valign="top">Contains specifications for the computer, drivers and other
system set- tings for installed hardware. Entries in this section are shared by all
users of the computer.</td>
</tr>

<tr>
<td valign="top">HKEY_USERS</td><td valign="top"> Contains information about all users who log on to the computer. Includes both user-specific information and generic user information. Generic system
settings are available to all users of the system.</td>
</tr>

<tr>
<td valign="top">HKEY_CURRENT_CONFIG </td><td valign="top">Contains configuration data for the hardware profile currently
in use on the computer.</td>
</tr>
</table></p>


<p>If you are working on a Windows 95 or Windows 98 computer, you will see the
additional subtree <b>HKEY_DYN_DATA</b>, used to store dynamic data such as performance
statistics and plug and play information.</p>

<p>The subtrees contain <i>keys</i> that can act as containers for other keys. Keys are
similar to directory folders in the way that they can be nested, and are referenced
using a similar notation. Figure 6.4 shows RegEdt32 being used to view the <b>
HKEY_CURRENT_USER\Software\MyCompany\MyApp\Settings</b> key.</p>

<p>
<A HREF="javascript:fullSize('f06DA04x.htm')"> <img src="images/f06DA04.jpg" width=404 height=291 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 6.4</b> <i>Exploring registry keys</i><!-- /caption -->
</p>

<p>Keys can contain values as well as subkeys. Values are terminating leaf nodes in the
registry hierarchy which are used to store registry data. Figure 6.4 shows the <i>User
Name</i> value contained within the <b>Settings</b> key.</p>

<p>A value has three parts&#8212;the name, the data type, and the value itself. A key
might contain a single unnamed value that serves as the default value for the key. For
the sake of clarity however, you should give your registry values names that give a
clear indication of their function.</p>

<p>Windows defines a special set of registry data types. Some of the more commonly used
registry data types are shown in Table 6.4.</p>

<p><b>Table 6.4</b> <i>Registry Data Types</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Data type  </th>
<th>Use  </th></tr>
<tr>
<td valign="top">REG_DWORD  </td>
<td valign="top">A 32-bit number.  </td></tr>
<tr>
<td valign="top">REG_BINARY  </td>
<td valign="top">Binary data in any form.  </td></tr>
<tr>
<td valign="top">REG_SZ  </td>
<td valign="top">A null-terminated string.  </td></tr>
<tr>
<td valign="top">REG_MULTI_SZ  </td>
<td valign="top">An array of null-terminated strings, terminated by two null
characters.  </td></tr>
<tr>
<td valign="top">REG_EXPAND_SZ  </td>
<td valign="top">A null-terminated string that contains unexpanded references to
environment variables.  </td></tr>
</table></p>

<p>You can see the complete list of registry data types by searching for
&quot;RegSetValueEx&quot;&#8212;the Windows API function used to set the value and data
type of a registry value&#8212;in the Visual C++ Help file.</p>

<A NAME="255"><H2>MFC Support for the Registry</H2></A>

<p>A document/view application generated by the MFC AppWizard creates the following registry entries:</p>

<ul>
<p><li> An entry that enables the Windows file manager to associate the application
document type with the application. This enables the user to launch an application by
double-clicking on a document icon.</li></p>

<p><li> An entry that determines the location of the application <i>user profile</i>. The
user profile is used to store a user's application settings in the registry, so
that the user settings can be preserved between application sessions.</li></p>
</ul>


<p>The following sections explain how these registry entries are created, and how they
can be used.</p>

<A NAME="256"><H3>Registering Document Types</H3></A>

<p>To register an application's document type with the Windows file manager, the
AppWizard adds the following line of code to your application object's <b>
InitInstance()</b> function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>RegisterShellFileTypes(TRUE);</pre>
</td></tr>
</table>
</p>

<p><b>CWinApp::RegisterShellFileTypes()</b> iterates through the list of document
templates that the application maintains and adds file association entries to the <b>
HKEY_CLASSES_ROOT</b> registry subtree for each document template. <b>
RegisterShellFileTypes()</b> also adds an entry specifying a default icon for the
document type.</p>

<p>Since the shell identifies a document type on the basis of its file name extension,
you must be sure to specify a document file name extension for your application on the
Advanced Options screen in Step 4 of the AppWizard. If you fail to specify an
extension, <b>RegisterShellFileTypes()</b> will not be called.</p>

<p><b>RegisterShellFileTypes()</b> is called with a TRUE parameter to specify that
registry entries should be added for the shell commands <b>Print</b> and <b>Print
To</b>, allowing a user to print files directly from the shell, or by dropping the file
on a printer object.</p>

<p>The AppWizard creates a registry file (with a .reg extension) that you can use in conjunction with a setup program to perform registry updates at installation
time. Using a registry file in this manner is advantageous because you can instruct the setup program to remove its registry entries if the program is
uninstalled, which contributes to more efficient application management. If you omit a
file name extension for your document type, no .reg file is created.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If you specify that your application should be Compound Document
Server, additional code is added to your application's <b>InitInstance()</b>
function to create OLE-related registry entries.</blockquote></div>
</p>

<A NAME="257"><H3>Application User Profile</H3></A>

<p>To specify the location of the application's user profile settings, the
AppWizard adds the following code line to your application object's <b>
InitInstance()</b> function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SetRegistryKey(_T(&quot;Local AppWizard-Generated Applications&quot;));</pre>
</td></tr>
</table>
</p>

<p><b>CWinApp::SetRegistryKey()</b> is called with a parameter that specifies the name
of the key under which your application settings will be stored. This key will be
created under the <b>HKEY_CURRENT_USER\Software</b> key. You should replace the default
key name (<b>Local AppWizard-Generated Applications</b>) with a suitable name for a key
containing user profile settings for all of your applications. Typically, this name is
the name of the company developing the application.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If you remove the call to <b>SetRegistryKey()</b> from your <b>
InitInstance()</b> function, the framework will create an .ini file in the Windows
directory and use it to store (non user-specific) profile information. The .ini files
are a feature of 16-bit Windows, and should not be used for 32-bit
applications.</blockquote></div>
</p>

<p>In the following exercise, you will specify a registry key for use in storing
application user profile settings for the MyApp application.</p>

<p><li> <b>To set the name of
the user profile registry key</b></li></p>

<ol>

<p><li> Open the MyApp project.</li></p>

<p><li> In ClassView, expand the <b>CMyAppApp</b> class icon.</li></p>

<p><li> Double-click the <b>InitInstance()</b> member function to edit the code.</li></p>

<p><li> Approximately 20 lines into the function, locate the code that reads:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SetRegistryKey(_T(&quot;Local AppWizard-Generated Applications&quot;));</pre>
</td></tr>
</table>
</p>


<p><li> Edit the line so that it reads:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SetRegistryKey(_T(&quot;MyCompany&quot;));</pre>
</td></tr>
</table>
</p>


<p><li> Build and run the MyApp application.</li></p>
</ol>

<p>Complete the following steps to check that the application has created the key
correctly.</p>

<p><li> <b>To locate the user
profile registry key</b></li></p>

<ol>

<p><li> Ensure that you have built and run the MyApp application at least once after
specifying a user profile registry key.</li></p>

<p><li> Close the MyApp application. On the <b>Start</b> menu, click <b>Run</b>.</li></p>

<p><li> In the <b>Open</b> box, type <b>RegEdt32</b> if you are using Windows NT or <b>
RegEdit</b> if you are using Windows 95 or Windows 98. Click <b>OK</b>.</li></p>

<p><li> Locate the <b>HKEY_CURRENT_USER</b> subtree.</li></p>

<p><li> Double-click the <b>Software</b> key to expand it. Verify that the following key
has been created by the MyApp application:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HKEY_CURRENT_USER\Software\MyCompany\MyApp\Settings</pre>
</td></tr>
</table>
</p>
</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The <b>SetRegistryKey()</b> function creates a registry key with
the same name as the application to serve as a root location for the application
settings.</blockquote></div>
</p>

<p>MFC applications write to the application user profile using the MFC profile
management functions. These functions, all members of the <b>CWinApp</b> class,
are:</p>

<ul>
<p><li> <b>WriteProfileString()</b> </li></p>

<p><li> <b>GetProfileString()</b> </li></p>

<p><li> <b>WriteProfileInt()</b> </li></p>

<p><li> <b>GetProfileInt()</b> </li></p>
</ul>


<p>These functions store and retrieve string and integer values to and from your
application's profile key in the registry. All of these functions take a section
name (a subkey of your profile key), and a value name as the first two arguments. If
the section or value names do not exist, they are created.</p>

<p><b>WriteProfileString()</b> creates a REG_SZ value. <b>WriteProfileInt()</b> creates
a REG_DWORD value. Both functions return a BOOL value to indicate the success or failure of the write operation. Both functions take a third argument
specifying the actual value to be written.</p>

<p>For example, the following line:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>WriteProfileString(&quot;Settings&quot;, &quot;User Name&quot;, &quot;Julian&quot;);</pre>
</td></tr>
</table>
</p>

<p>will create the <b>HKEY_CURRENT_USER\Software\MyCompany\MyApp\Settings\User Name</b> value, which is assigned the string &quot;Julian.&quot;
This value is illustrated in Figure 6.4.</p>

<p><b>GetProfileString()</b> and <b>GetProfileInt()</b> return a specified value from
the registry. Both functions take a third argument that specifies a default value to be
returned if the requested registry value cannot be found.</p>

<A NAME="258"><H2>Working with Application User Profile Settings</H2></A>

<p>In this exercise, you will learn how to use the MFC profile management functions to
save MyApp application settings to the <b>HKEY_CURRENT_USER\Software\MyCompany\MyApp</b> profile key that you created in the previous exercise. This exercise will work with the <b>Connect to Data Source</b> dialog box
that you created by completing the exercises in Chapters 4 and 5.</p>

<p>The <b>Connect to Data Source</b> dialog box contains a check box option that allows
users to specify if they want to attempt to connect at application startup.</p>

<p><li> <b>To implement the
Connect at Application Startup option</b></li></p>

<ol>

<p><li> Save the Data Source Name, the User ID, the Access level and the status of the
<b>Attempt to connect at application startup</b> check box to the registry. These
settings will be saved after the user clicks the <b>Connect</b> button.</li></p>

<p><li> Use the settings saved in the registry to initialize the <b>Connect to Data
Source</b> dialog box controls.</li></p>

<p><li> Alter the <b>InitInstance()</b> function to retrieve the <b>Attempt to connect
at application startup</b> check box status. If this check box has been selected,
display the <b>Connect to Data Source</b> dialog box to allow the user to connect to
the database.</li></p>
</ol>

<p><li> <b>To save the dialog box settings</b></li></p>

<ol>
<p><li> In the MyApp project, locate the <b>CMyAppApp::OnDataConnect()</b> function.</li></p>


<p><li> Inside the code branch that reads:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if(aCD.DoModal() == IDOK)</pre>
</td></tr>
</table>
</p>

<p>add the following lines beneath the call to <b>
AfxMessageBox()</b>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>WriteProfileString(&quot;Settings&quot;, &quot;User ID&quot;, aCD.m_strUserID);
WriteProfileInt(&quot;Settings&quot;, &quot;Access Level&quot;, aCD.m_nAccess);
WriteProfileInt(&quot;Settings&quot;, &quot;Connect at Startup&quot;, 
     aCD.m_bConnect ? 1 : 0);
WriteProfileString(&quot;Settings&quot;, &quot;DSN&quot;, m_strDSN);</pre>
</td></tr>
</table>
</p>

<p>m_strDSN is a member variable of the <b>CMyAppApp</b> class, which is set
by the <b>CConnectDialog::OnOK()</b> function.</p>
</ol>

<p><li> <b>To initialize the
Connect to Data Source dialog box controls</b></li></p>

<ol>

<p><li> Delete the following lines from the top of the <b>CMyAppApp::OnDataConnect()</b> function:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>aCD.m_nAccess = 1;
aCD.m_bConnect = TRUE;</pre>
</td></tr>
</table>
</p>


<p><li> Replace the deleted lines with the following code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>aCD.m_nAccess = GetProfileInt(&quot;Settings&quot;, &quot;Access Level&quot;, 1);
aCD.m_strUserID = GetProfileString(&quot;Settings&quot;, &quot;User ID&quot;, &quot;&quot;);
aCD.m_bConnect = BOOL(GetProfileInt(&quot;Settings&quot;, 
     &quot;Connect at Startup&quot;, 0));</pre>
</td></tr>
</table>
</p>

<p>The entire <b>OnDataConnect()</b> function should look as
follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppApp::OnDataConnect()
{
     CConnectDialog aCD;

     aCD.m_nAccess = GetProfileInt(&quot;Settings&quot;, &quot;Access Level&quot;, 1);
     aCD.m_strUserID = GetProfileString(&quot;Settings&quot;, &quot;User ID&quot;, &quot;&quot;);
     aCD.m_bConnect = BOOL(GetProfileInt(&quot;Settings&quot;, &quot;
          Connect at Startup&quot;, 0));

     if(aCD.DoModal() == IDOK)
     {
          CString strMessage;
          strMessage.Format(&quot;User %s logged in&quot;, aCD.m_strUserID);
          AfxMessageBox(strMessage);

          WriteProfileString(&quot;Settings&quot;, &quot;User ID&quot;, aCD.m_strUserID);
          WriteProfileInt(&quot;Settings&quot;, &quot;Access Level&quot;, aCD.m_nAccess);
          WriteProfileInt(&quot;Settings&quot;, &quot;Connect at Startup&quot;, 
               aCD.m_bConnect ? 1 : 0);
          WriteProfileString(&quot;Settings&quot;, &quot;DSN&quot;, m_strDSN);
     }
}</pre>
</td></tr>
</table>
</p>


<p><li> Locate the <b>CConnectDialog::OnInitDialog()</b> function. Add the code
indicated in bold text in the following code example:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BOOL CConnectDialog::OnInitDialog()
{
     CDialog::OnInitDialog();

     m_lbDSN.AddString(&quot;Accounts&quot;);
     m_lbDSN.AddString(&quot;Admin&quot;);
     m_lbDSN.AddString(&quot;Management&quot;);
 <b>    CMyAppApp * pApp = dynamic_cast&lt;CMyAppApp *&gt;(AfxGetApp());
     ASSERT_VALID(pApp);
     CString strDSN = pApp-&gt;GetProfileString(&quot;Settings&quot;, &quot;DSN&quot;, &quot;&quot;);
     int index = m_lbDSN.FindStringExact(-1, strDSN);
     m_lbDSN.SetCurSel(index);</b>
     OnUpdateUserid();
     return TRUE;  
     // return TRUE unless you set the focus to a control
     // EXCEPTION: OCX Property Pages should return FALSE
}</pre>
</td></tr>
</table>
</p>

<p>This code retrieves the data source name from the profile settings, and
uses it to set the list selection to the appropriate item.</p>
</ol>

<p><li> <b>To display the
Connect to Data Source dialog box (if required)</b></li></p>

<ol>

<p><li> Locate the <b>CMyAppApp::InitInstance()</b> function. Add the following code
just before the return statement near the end of the function string:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if(GetProfileInt(&quot;Settings&quot;, &quot;Connect at Startup&quot;, 0))
     OnDataConnect();</pre>
</td></tr>
</table>
</p>


<p><li> Build and run the MyApp application.</li></p>

<p><li> Select the <b>Connect</b> option from the <b>Data</b> menu, and fill in the <b>
Connect to Data Source</b> dialog box, making sure that the <b>Attempt to connect at
application startup</b> check box is selected.</li></p>

<p><li> Save the settings by clicking <b>Connect</b>.</li></p>

<p><li> Quit and restart the application to ensure that the <b>Attempt to connect at
application startup</b> dialog box appears as soon as the application has started, and
that the saved settings have been correctly restored. You can also use the registry
editor to check that the profile registry values have been created as expected.</li></p>
</ol>

<A NAME="259"><H2>Registry Support in the Win32 API</H2></A>

<p>The MFC registry functions make storing information in the registry easy, but they
are probably not flexible enough to meet all of your needs. The MFC profile functions
allow you to write only to a specified profile key under the <b>HKEY_CURRENT_USER</b>
subtree. If you wanted to store values at other registry locations, you have to use the
Win32 API registry functions. For example, you might want to store application settings
common to all users of a computer. To do this, you would need to create a registry key
under the key <b>HKEY_LOCAL_MACHINE\SOFTWARE</b>.</p>

<p>Also, the MFC functions allow you to store only string or integer values. The Win32 API
functions allow you to store information using any of the registry data formats.</p>

<p>Table 6.5 lists some of the Win32 API registry functions. You can search for the
functions in the Visual C++ Help file to find out more about how they are used.</p>

<p><b>Table 6.5</b> <i>Win32 API Registry Functions</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Function  </th>
<th>Purpose  </th></tr>
<tr>
<td valign="top">RegCreateKeyEx()  </td>
<td valign="top">Creates a registry key. If the key already exists in the registry,
the function will open it.  </td></tr>
<tr>
<td valign="top">RegOpenKeyEx()  </td>
<td valign="top">Opens an existing registry key.  </td></tr>
<tr>
<td valign="top">RegCloseKey()  </td>
<td valign="top">Closes an open handle to a registry key that has been returned by
the <b>RegCreateKeyEx()</b> or the <b>RegOpenKeyEx()</b> function. </td></tr>
<tr>
<td valign="top">RegDeleteKey()  </td>
<td valign="top">In Windows 95, deletes a subkey and all its descendants. In Windows NT, deletes a single subkey that cannot have
 descendants.  </td></tr>
<tr>
<td valign="top">RegSetValueEx()  </td>
<td valign="top">Sets the data and type of a value under an open registry key.  </td></tr>
<tr>
<td valign="top"><nobr>RegQueryValueEx()</nobr></td>
<td valign="top">Retrieves the type and data for a value associated with an open
registry key.  </td></tr>
<tr>
<td valign="top">RegDeleteValue()  </td>
<td valign="top">Removes a named value from a registry key.  </td></tr>
</table></p>



<A NAME="260"><H2>Lesson Summary</H2></A>

<p>The Windows registry is a central, hierarchically organized database that holds
persistent settings and configuration information for the operating system and
applications. Your applications can use Win32 API functions to store and retrieve
registry settings. You can use the registry editor to view and edit data stored in the
registry.</p>

<p>The registry is logically organized around five predefined subtrees that correspond
to the most general categories of the system's organization. These categories
are:</p>

<ul>
<p><li> <b>HKEY_CLASSES_ROOT</b> </li></p>

<p><li> <b>HKEY_CURRENT_USER</b> </li></p>

<p><li> <b>HKEY_LOCAL_MACHINE</b> </li></p>

<p><li> <b>HKEY_USERS</b> </li></p>

<p><li> <b>HKEY_CURRENT CONFIG</b> </li></p>
</ul>


<p>Subtrees contain keys that can act as containers for other keys and for <i>
values</i>, which are leaf nodes used to store registry data. A value has three parts:
a name, its data type, and the value itself. Windows defines a special set of data
types for registry values. These data types include:</p>

<ul>
<p><li> <b>REG_DWORD</b> </li></p>

<p><li> <b>REG_BINARY</b> </li></p>

<p><li> <b>REG_SZ</b> </li></p>

<p><li> <b>REG_MULTI_SZ</b> </li></p>

<p><li> <b>REG_EXPAND_SZ</b> </li></p>
</ul>


<p>A document/view application generated by the MFC AppWizard calls <b>
CWinApp::RegisterShellFileTypes()</b> to add an entry to the registry to associate the
application document type with the application. <b>RegisterShellFileTypes()</b> also
adds an entry to specify a default icon for the document type; and entries for the
shell commands <b>Print</b> and <b>Print To</b>, to allow a user to print files
directly from the shell.</p>

<p>The application calls the <b>CWinApp::SetRegistryKey()</b> function to add a
registry entry to specify the location of the application's <i>user profile</i>.
The user profile is used to store a user's application settings in the registry so
that the user settings can be preserved between application sessions. You should change
the name of the key specified by <b>SetRegistryKey()</b> to a name that is suitable for
a key that contains user profile settings for all of your applications&#8212;the name of
your company, for example. The <b>SetRegistryKey()</b> function creates a registry key
under your profile key with the same name as the application, to serve as a root
location for the application settings.</p>

<p>MFC applications write to the application user profile using the following MFC
profile management functions:</p>

<ul>
<p><li> <b>WriteProfileString()</b> </li></p>

<p><li> <b>GetProfileString()</b> </li></p>

<p><li> <b>WriteProfileInt()</b> </li></p>

<p><li> <b>GetProfileInt()</b> </li></p>
</ul>


<p>These functions are used to store and retrieve string and integer values to and from
your application's profile key in the registry.</p>

<p>In cases where the MFC profile management functions are not flexible enough for your
needs, you can use the Win32 API registry functions. For example, use these functions
when you need to write to a registry location not under the specified profile key. You
can also use these functions to create and delete registry keys, and to store and
retrieve values. The most commonly used Win32 API registry functions are:</p>

<ul>
<p><li> <b>RegCreateKeyEx()</b> </li></p>

<p><li> <b>RegOpenKeyEx()</b> </li></p>

<p><li> <b>RegCloseKey()</b> </li></p>

<p><li> <b>RegDeleteKey()</b> </li></p>

<p><li> <b>RegSetValueEx()</b> </li></p>

<p><li> <b>RegQueryValueEx()</b> </li></p>

<p><li> <b>RegDeleteValue()</b> </li></p>
</ul>


</BODY>
</HTML>







