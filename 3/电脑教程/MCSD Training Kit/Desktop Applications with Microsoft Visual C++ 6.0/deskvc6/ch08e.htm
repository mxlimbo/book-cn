<HTML>
<HEAD>
<TITLE>Lesson 4: Threading Models</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08d.htm", "ch08f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="333"><H1>Lesson 4: Threading Models</H1></A>

<p>In <A HREF="ch05a.htm">Chapter 5</A>, you learned how you can improve the performance of an application by
running concurrent tasks on multiple threads. Because a single instance of a COM object
can be accessed simultaneously by any number of client threads, you must make sure that
access to your COM object is properly synchronized.</p>

<p>Generally, object synchronization is handled by the operating system. It is
important to know how the operating system handles object synchronization so that you
can create components that perform efficiently in a multithreaded environment. COM
defines four <i>threading models</i> that simplify the issues surrounding multithreaded
component development.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>
<p><li>Describe the four COM threading models.</li></p>

<p><li>Describe the advantages and disadvantages of using each of the threading
models.</li></p>

<p><li>Identify the registry keys used to identify component threading models.</li></p>
</ul>

<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>

<A NAME="334"><H2>COM Threading Models</H2></A>

<p>A threading model describes the type and degree of thread safety implemented by a
component. A COM component can support one of the following four threading models:</p>

<ul>
<p><li>The single-threading model</li></p>

<p><li>The apartment-threading model</li></p>

<p><li>The free-threading (multi-threaded) model</li></p>

<p><li>The mixed-threading model (supports both apartment and free-threading)</li></p>
</ul>

<p>Before a client thread can use a COM object, it must initialize the COM libraries by
calling the <b>CoInitializeEx()</b> API function. When it does this, it can specify the
model it uses for calls to the objects that it creates. A client thread can specify
that it will use the apartment-threading model or the free-threading model.</p>

<p>Any client application, regardless of its own threading arrangement, can safely
access a COM component built from any threading model. If a client's threading is
not compatible with that of the server, the COM run-time library takes steps to ensure
that the client and server communicate in a thread-safe manner. However, these measures
can adversely affect the performance of the application.</p>

<A NAME="335"><H3>Single-Threading Model</H3></A>

<p>A COM server that supports the single-threading model requires that all client
requests for object services are queued on a single thread. Single-threaded COM servers
are suitable for use with only single-threaded applications&#8212;which means legacy
code. Access to a single-threaded component is very efficient for the thread that
actually creates the component. The thread that first creates the component can obtain
direct pointers to the interfaces exposed by the component. However, subsequent
requests from other threads cannot directly access the interface pointers because the
server process only supports a single thread. All subsequent threads must marshal
interface requests between a proxy on the client and a stub on the server main thread.
Calls made by external threads through the proxy/stub are placed in the server message
queue. External threads experience poor performance as a result of the overhead
involved in marshaling, and because the direct interface requests made by the creator
thread take priority over the requests waiting in the message queue.</p>

<A NAME="336"><H3>Apartment-Threading Model</H3></A>

<p>The apartment-threading model enables all clients to obtain a direct pointer to a
component interface, without going through proxy and stub services. An apartment is a
conceptual entity that provides a logical structure for thread concurrency. An
apartment is created when a thread calls the <b>CoInitializeEx()</b> API function to
initialize the COM libraries. An apartment is associated with one or more threads, and
one or more COM object instances. As long as the objects created within an apartment
support the apartment-threading model, all threads in an apartment can obtain direct
interface pointers to all objects in the apartment.</p>

<p>The terminology surrounding apartment threading can be confusing because there are
two types of apartments: <i>single-threaded apartments</i> (STAs) and <i>multithreaded
apartments</i> (MTAs). The distinction between the two is as follows:</p>

<ul>
<p><li>STAs implement the apartment-threading model.</li></p>

<p><li>MTAs implement the free-threading model.</li></p>
</ul>

<p>A process can contain any number of STAs (each one containing a single thread) but
only one MTA to which any number of threads can belong.</p>

<A NAME="337"><H3>Single-Threaded Apartments</H3></A>

<p>STAs have only one thread that creates and calls objects. Because only one thread
can access those objects in the apartment, the objects are effectively synchronized.</p>

<p>Components that support STAs perform better than those that support the single-threaded
model. You can use the STA model to write more efficient code. At the same time a
thread in one STA waits for an operation to finish, another STA can allow the interim
execution of a thread in still another STA.</p>

<p>When a thread calls <b>CoInitializeEx()</b> with the <i>COINIT_APARTMENTTHREADED</i>
parameter, the thread creates an STA. A thread that is initialized as an STA is known
as an STA thread type. A COM object that is instantiated by an STA thread type can be
accessed by that thread only. This protects COM objects 
from being accessed by multiple threads simultaneously.</p>

<A NAME="338"><H3>Synchronizing Threads</H3></A>

<p>Threads that want to use a COM object residing in another apartment must have the
interface pointers of the COM object marshaled to them. The threads cannot have a
direct interface pointer because this would allow multiple threads to access the
object, which violates the STA model rules.</p>

<p>By marshaling an interface pointer to other threads, COM uses window messages to
synchronize multiple threads. Each STA thread type has a message loop that receives
marshaled calls from other processes and other apartments in the same process. When a
client makes a call to a server object, the marshaling code places a corresponding
window message in the server thread's message queue. Multiple thread calls are
queued in the message queue while the object's STA thread type process each
message, one at a time.</p>

<A NAME="339"><H3>Passing Interface Pointers</H3></A>

<p>When interface pointers are passed between apartments, the pointers must be
marshaled. You use the <b>CoMarshalInterThreadInterfaceInStream()</b> COM API function
to marshal interface pointers between threads in the same process. For more information
about the <b>CoMarshalInterThreadInterfaceInStream()</b> function, refer to the Visual
Studio Help file.</p>

<A NAME="340"><H3>Multithreaded Apartments</H3></A>

<p>MTAs are also called free-threading models. This model differs from an STA 
in that multiple threads can reside in one apartment. MTAs provide the highest
performance.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The MTA model was introduced in Windows NT 4.0 and is also
available in Windows 95 with DCOM95 installed.</blockquote></div>
</p>

<p>All threads that call <b>CoInitalizeEx()</b> with the <i>COINIT_MULTITHREADED</i> 
parameter live in a single MTA and are known as MTA thread types. Unlike the STA
model, there is only one MTA per process. When additional MTA threads are initialized
as MTA thread types, they live in the same apartment. In addition, there is no need to
marshal between threads.</p>

<p>COM objects created by MTA thread types must be thread safe and must provide their own
synchronization code. By removing the bottleneck created by marshaling, MTAs provide
the highest performance and throughput on the server side.</p>

<p>In the MTA model, any thread can call a COM object concurrently, and COM does not
synchronize the calls. Because synchronization is not provided, COM objects written for
an MTA must be thread safe. Therefore, synchronization objects such as events, mutexes,
and semaphores (as described in <a href="ch05d.htm#202">Lesson 3</a> of Chapter 5) must be used to protect a
component's static and global data.</p>

<A NAME="341"><H2>Threading-Model Registry Keys</H2></A>

<p>In-process servers must enter their threading model in the registry because
in-process servers typically do not call <b>CoInitializeEx()</b>. When a client creates
an in-process server COM object, COM uses the threading-model registry key to determine
if marshaling code is necessary for the returned interface pointer.</p>

<p>To indicate the type of threading model in the registry, the named ThreadingModel
value is created under the following key:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HKEY_CLASSES_ROOT\CLSID\[component CLSID]\InProcServer32</pre>
</td></tr>
</table>
</p>

<p>ThreadingModel can contain one of the following values:</p>

<ul>
<p><li><b>None</b> Supports the single-threading model only</li></p>

<p><li><b>Apartment</b> Supports the STA model</li></p>

<p><li><b>Free</b> Supports the MTA model only</li></p>

<p><li><b>Both</b> Supports both the STA and MTA model</li></p>
</ul>


<A NAME="342"><H2>Lesson Summary</H2></A>

<p>COM defines four threading models that simplify the issues surrounding the
synchronization of access to components in a multithreaded environment. The
single-threading model requires that all client requests for object services are queued
on a single thread. The apartment-threading model uses an STA to define a logical
grouping of components that are only accessed by a single thread. The free-threading
model groups thread-safe components together in a single MTA. If a component supports
the mixed-threading model, threads in a single or a multi-threaded apartment can safely
access it.</p>

<p>An apartment is created when a thread calls the <b>CoInitializeEx()</b> API function
to initialize the COM libraries. Use arguments to the <b>CoInitializeEx()</b> function
to specify an STA or an MTA type thread. In-process servers typically do not call <b>
CoInitializeEx()</b>&#8212;they specify their threading model in a registry entry.</p>

<p>COM ensures that communication between clients and objects with different threading
models is conducted in a thread-safe manner, marshaling the data if necessary. When you
pass interface pointers between apartments, you must marshal the interface using the
<b>CoMarshalInterThreadInterfaceInStream()</b> COM API function.</p>

</BODY>
</HTML>







