<HTML>
<HEAD>
<TITLE>Lesson 3: Calling WIN32 APIs</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09c.htm", "ch09e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="469"><H1>Lesson 3: Calling Win32 APIs</H1></A>

<P>One advantage of using Visual Basic is that you can include functionality that is not directly provided by Visual Basic by accessing the Windows Application Programming Interface (Win32 API). The Win32 API consists of a group of special DLLs called <I>standard DLLs</I>. A standard DLL does not support a COM interface, so you cannot access the Windows API the same way you would Microsoft Word or Microsoft Excel. In this lesson, you will use standard DLLs to extend the functionality of your Visual Basic applications. </P>

<p><div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<UL>

<p><li>Explain the differences between the COM and the Win32 API.</li></p>

<p><li>Explain how to use the Win32 API.</li></p>

<p><li>Describe how to use the API Text Viewer.</li></p>

<p><li>Define and implement a Callback procedure.</li></p>

</UL>
<b>Estimated lesson time: 20 minutes</b>
</blockquote></div></P>

<A NAME="470"><H2>COM Components and Win32 DLLs</H2></A>

<P>When you use automation to execute methods and properties of an application such as Microsoft Word, you are using COM to call the procedures made available by Word. When using a standard DLL, such as the Win32 API, you are making direct function calls. There is no type library included with a standard DLL, and therefore features such as the Object Browser and Auto List Members are not supported. However, sometimes, you must use a standard DLL when a COM DLL is not available.</P>

<A NAME="471"><H3>Using Win32 API</H3></A>

<P>The Win32 API provides developers direct access to internal functions that are used by the Windows operating system. There are several advantages when using the Win32 API. You can:</P>

<ul>
<p><li>Accomplish tasks that are not possible in Visual Basic.</li></p>

<P>Visual Basic is a comprehensive and powerful programming language. Even with its extensive capablilities, there may be requirements within your application that Visual Basic does not support.</P>
<p><li>Obtain improved performance.</li></p>

<P>The development tools used to create DLLs, in many cases, can produce faster, more efficient code. This code often out-performs code written in Visual Basic.</P>
<p><li>Update independently of the application.</li></p>

<P>Because a DLL is a separate file, you can update the DLL without recompiling the application that calls the DLL. This is true for both standard and COM DLLs.</P>
</ul>

<P>Most applications use COM DLLs; Visual Basic DLLs are COM-based DLLs. You cannot create standard DLLs in Visual Basic. If you need standard DLLs, you can create them with third party development tool such as Microsoft Visual C++.</P>

<P>Although standard DLLs do not have type libraries, there are several tools that assist in the use of these APIs. These include:</P>

<ul>
<p><li>The documentation included with the API.</li></p>

<p><li>Third party API reference manuals.</li></p>

<p><li>The Visual Basic API Text Viewer.</li></p>
</ul>

<A NAME="472"><H2>Extending Applications with the Win32 API</H2></A>

<P>You can call three primary Windows DLLs from Visual Basic. The Windows API is composed of these DLLs. They provide most of the Windows API functionality.</P>

<P>The 32-bit versions of the Windows operating system (Windows 95 and Windows NT) consist of the User32, GDI32, and Kernel32 DLLs.</P>

<ul>
<p><li>The User32 DLL manages Windows menus, controls, and dialog boxes.</li></p>

<p><li>The GDI32 DLL provides graphical output, including drawing, fonts, and metafiles.</li></p>

<p><li>The Kernel32 DLL handles operating system tasks such as memory management, resource management and other lower level operating functions.</li></p>
</ul>

<P>In addition to these three DLLs, Windows 95 and Windows NT contain many other DLLs that provide extended functionality to Visual Basic. In this lesson, we will focus on using only the Win32 API DLLs.</P>

<P>Using Win32 API calls enhances the functionality and performance of your application. There are two steps when using these Win32 APIs in your Visual Basic code:</P>

<OL>
<P><LI>Declare the DLL function.</LI></P>

<P><LI>Call the DLL function.</LI></P>
</ol>

<p><div class="note"><blockquote><b>NOTE</b><HR>
Incorrect use or poorly designed DLLs can cause application or system failures. Always save your application before testing.
</blockquote></div></p>

<A NAME="473"><H3>Declaring DLLs</H3></A>

<P>Unlike COM DLLs, before using a standard DLL you must specify the location of the procedures; you also must identify the arguments with which they should be called. Use the Declare statement to provide this information. Typically, you use a standard module to make the appropriate declaration. DLLs declared in a standard module are public by default and can be called by code from anywhere in your Visual Basic application. To declare a DLL procedure in a form or class module, you must include the Private keyword in the declaration.</P>

<P>The DLL declare statement syntax is:</P>

<P>[<B>Public|Private</B>]<B> Declare Sub</B><I> name</I> <B>Lib</B> &quot;<I>libname</I>&quot; [Alias &quot;<I>aliasname</I>&quot;] [(arglist)]</P>

<P>To declare a DLL, type the DLLs declaration statement into the Visual Basic module or use the API Text Viewer, which is provided with Visual Basic. The API Text Viewer allows you to copy and paste the declaration into a module. This reduces the chance that a DLL function is declared incorrectly. Figure 9.9 illustrates the API Text Viewer.</P>

<P>
<A HREF="javascript:fullSize('F09xx09x.htm')"> <img src="images/F09xx09.JPG" width=404 height=375 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><B>Figure 9.9</B> <i>The API Text Viewer</i>  <!--/caption-->
</P>


<P><LI><B>To use the API Text Viewer to copy a declare statement.</B></LI></P>

<OL>
<P><LI>Click the Windows <B>Start</B> button. Then click the <B>Programs</B> menu and find the <B>Microsoft Visual Basic 6.0 Tools</B> menu in the <B>Microsoft Visual Basic 6.0</B> menu. On the <B>Microsoft Visual Basic 6.0 Tools</B> menu select <B>API Text Viewer</B>.</LI></P>

<P><LI>On the <B>File</B> menu, in the API Text Viewer, click <B>Load Text File...</B></LI></P>

<P>The API Text Viewer gives you the choice of searching the API text file or converting the text file to a database file. When you are prompted to create a database, and you respond Yes, the API Text Viewer will create an .mdb database file. You can then load the .mdb file whenever you use the API Viewer.</P>

<P><LI>On the <B>Select a Text API File</B> dialog box, click <B>Win32api.txt</B>.</LI></P>

<P><LI>On the <B>Available Items</B> list box, click the required procedure name. Then click the <B>Add</B> button to add the procedure to the <B>Selected Items</B> list box.</LI></P>

<P>The <B>Available Items</B> list box displays a list of the Win32 API. Change the way the API is declared by selecting <B>Declare Scope</B> under the <B>Add</B> button.</P>

<P><LI>Click the <B>Copy</B> button to copy the added APIs to the Clipboard.</LI></P>

<P><LI>Paste the Declare statements into the appropriate module.</LI></P>

<P>The following is an example of the pasted GetWindowsDirectory function:</P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Private Declare Function GetWindowsDirectory Lib &quot;kernel32&quot; Alias _
    &quot;GetWindowsDirectoryA&quot; (ByVal lpBuffer As String, _
    ByVal nSize As Long) As Long
</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="474"><H3>Calling DLLs</H3></A>

<P>After you declare a DLL procedure, you can use it in your code just like a native Visual Basic procedure. In the following example, the function GetWindowsDirectory finds the current Windows directory on the user's computer:</P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Private Declare Function GetWindowsDirectory Lib &quot;kernel32&quot; Alias _
    &quot;GetWindowsDirectoryA&quot; (ByVal lpBuffer As String, _
    ByVal nSize As Long) As Long

Private Sub cmdFindWindows_Click()
    Dim strWinDir As String
    Dim lngLen As Long
    'Pass the DLL a string variable filled with null characters
    strWinDir = String(255, 0)
    'Call the function and pass the strWinDir variable
    'and the length of the variable
    lngLen = GetWindowsDirectory(strWinDir, Len(strWinDir))
    'Remove any remaining Null charactors
    'using the return value of the GetWindowsDirectory 
    'and the Left function
    strWinDir = Left(strWinDir, lngLen)
    strWinDir = strWinDir &amp; &quot;\&quot;
    MsgBox &quot;Windows is in &quot; &amp; strWinDir 
End Sub
</pre>
</td></tr>
</table>
</p>

<P>When you call a DLL procedure, there are several issues to consider about how arguments are passed. For more information, search for &quot;Passing Strings to a DLL Procedure&quot; or &quot;Passing Other Types of Information to a DLL Procedure&quot; in MSDN Online Help.</P>

<A NAME="475"><H2>Creating Callback Procedures</H2></A>

<P>Some Windows API functions require a <I>function pointer</I> to be passed to them as an argument. A function pointer is a convention that enables you to pass the address of a user-defined, Visual Basic procedure as an argument to a Windows DLL. These Visual Basic procedures are referred to as <I>callback procedures</I>. A callback procedure is a procedure that will be called by the external DLL. The DLL can notify or give information to a client by using these procedures.</P>

<A NAME="476"><H3>Using the AddressOf Operator</H3></A>

<P>Visual Basic uses the AddressOf operator to pass a callback procedure to a DLL. The callback procedure must be located in a standard module, and it must have the correct syntax. Use the AddressOf operator to pass a pointer to the Window API. The pointer directs the API to the address of the callback procedure. Figure 9.10 illustrates how callback procedures work in Visual Basic. The CallTimer procedure calls SetTimer and uses the AddressOf operator to pass a pointer to the MyCallBack procedure. The timer then executes the MyCallBack procedure at the specified interval. The MyCallBack procedure then calls KillTimer, which stops the timer and frees the resource.</P>

<P>
<A HREF="javascript:fullSize('F09xx10x.htm')"> <img src="images/F09xx10.JPG" width=404 height=242 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><B>Figure 9.10</B> <i>Callback procedures in Visual Basic</i>  <!--/caption-->
</P>


<P>Another example of a Win32 API that requires a function pointer is EnumWindows. This function returns the handle of all windows that are owned by a particular task. The following is the declare statement of the EnumWindows function:</P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Declare Function EnumWindows lib &quot;user32&quot; _
    (ByVal lpEnumFunc as Long, ByVal lParam as Long ) As Long
</pre>
</td></tr>
</table>
</p>

<P>EnumWindows is an enumeration function, which means that it can list the handle of every open window on your system. EnumWindows works by repeatedly calling the function you pass to its first argument (lpEnumFunc). Each time EnumWindows calls your function, EnumWindows passes the function the handle of an open window.</P>

<P>EnumWindows is called from your code; you must pass the user-defined callback function as the first argument to handle the stream of values. For example, you might write a function to add the values to a list box, convert the hWnd values to window names, or take whatever action you choose.</P>

<p>
<img src="images/practice.gif" width=67 height=55 border=0>
</p>

<A NAME="477"><H2>Practice: Creating a Callback Procedure</H2></A>

<P>In this practice, you will first create a new Visual Basic project, then use the API Text Viewer to add the EnumChildWindows and GetWindowText procedures from the User32 DLL. You will then create and pass a callback procedure to the EnumChildWindows DLL. The application will display, in a list box, the names of all of the controls on the form.</P>

<P><LI><B>To add controls to Form1</B></LI></P>

<OL>
<P><LI>Open a new <B>Standard EXE</B> project.</LI></P>

<P><LI>Add the following controls to <B>Form1</B>:</LI></P>

<UL>
<P><LI>CommandButton</LI></P>

<P><LI>OptionButton</LI></P>

<P><LI>CheckBox</LI></P>

<P><LI>ListBox</LI></P>
</UL>

<P><LI>Set the Name property of the command button to <B>cmdListWindows</B> and the Caption property to <B>&amp;List Windows</B>.</LI></P>

<P>Your form should look like Figure 9.11. </P>

<P>
<img src="images/F09xx11.GIF" width=322 height=242 border="0">
</P><P>
<!--caption--><B>Figure 9.11</B> <i>Practice form layout</i>  <!--/caption-->
</P>

</ol>

<P><LI><B>To use the API Text Viewer to add Windows APIs</B></LI></P>

<OL>
<P><LI>On the <B>File</B> menu, in the <B>API Text Viewer</B>, click <B>Load Text File...</B></LI></P>

<P>The <B>Select a Text API File</B> dialog box appears.</P>

<P><LI>Click <B>Win32api.txt</B>.</LI></P>

<P>The <B>Available Items</B> list box appears.</P>

<P><LI>Click <B>EnumChildWindows, </B>click <B>Private </B>for<B> </B>the<B> Declare Scope, </B>and then click <B>Add</B> to add the procedure to the <B>Selected Items</B> list box.</LI></P>

<P><LI>Click <B>GetWindowText, </B>click <B>Private </B>for<B> </B>the<B> Declare Scope, </B>and then click <B>Add</B>.</LI></P>

<P><LI>Click the <B>Copy</B> button.</LI></P>

<P>This copies the selected Declare statements to the Clipboard.</P>

<P><LI>In Visual Basic, on the <B>Project</B> menu, click <B>Add Module, </B>click<B> Module</B>,<B> </B>then<B> </B>click<B> </B>the<B> Open </B>button. </LI></P>

<P><LI>In the <B>General Declarations</B> section of the new standard module, paste the copied declarations. To paste the declarations, use <B>CTRL+V</B> or, on the <B>Edit</B> menu, click <B>Paste</B>.</LI></P>

<P>The following declarations should appear in the General Declaration section:</P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Private Declare Function EnumChildWindows Lib &quot;user32&quot; _
    Alias &quot;EnumChildWindows&quot; (ByVal hWndParent As Public, _
    ByVal lpEnumFunc As Long, ByVal lParam As Long) As Long

Private Declare Function GetWindowText Lib &quot;user32&quot; _
    Alias &quot;GetWindowTextA&quot; (ByVal hwnd As Public, _
    ByVal lpString As String, ByVal cch As Long) As Long
</pre>
</td></tr>
</table>
</p>
</ol>

<P><LI><B>To create the callback procedure</B></LI></P>

<OL>
<P><LI>While in the new standard code module, click <B>Add Procedure...</B> from the <B>Tools</B> menu. </LI></P>

<P><LI>Create a <B>Public</B> function called <B>EnumCallBack</B>, then click <B>Ok</B>. The procedure should look like the following:</LI></P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Public Function EnumCallBack()

End Function
</pre>
</td></tr>
</table>
</p>

<P><LI>Add the following code to the <B>EnumCallBack</B> function:</LI></P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Public Function EnumCallBack(ByVal hWndChild As Long, ByVal lParam As Long) As Boolean
    Dim lngSize As Long
    Dim strPadString As String
    strPadString = String(255, 0)
    lngSize = GetWindowText(hWndChild, _
        strPadString, Len(strPadString))
    strPadString = Left$(strPadString, lngSize)
    Form1.List1.AddItem strPadString
    EnumCallBack = True
End Function
</pre>
</td></tr>
</table>
</p>
</ol>

<P><LI><B>To call the Windows API</B></LI></P>

<OL>
<P><LI>Double-click the command button in <B>Form1</B>. </LI></P>

<P><LI>In the <B>cmdListWindows_Click</B> event, add the following code:</LI></P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Private Sub cmdListWindows_Click()
    Dim blnRtn As Boolean
    blnRtn = EnumChildWindows(Form1.hwnd, AddressOf EnumCallBack, 0)
End Sub
</pre>
</td></tr>
</table>
</p>

<P><LI>Save your project as prjAPI.vbp in the \Practice\Ch09 folder, and then test your application.</LI></P>
</ol>

<A NAME="478"><H2>Lesson Summary</H2></A>

<P>The Windows Application Programming Interface (Win32 API) has standard DLLs. You can include functionality that is not directly provided by Visual Basic by accessing the Win32 API. Advantages to using the Win32 API include:</P>

<ul>
<p><li>Accomplishing tasks that are not possible in Visual Basic.</li></p>

<p><li>Improving performance.</li></p>

<p><li>Updating independently of the application.</li></p>
</ul>

<P>Although most applications use COM DLLs, you can create standard DLLs with third party development tool such as Microsoft Visual C++. </P>

<P>The 32-bit versions of the Windows operating system (Windows 95 and Windows NT) consist of the User32, GDI32, and Kernel32 DLLs.</P>

<P>The two steps to using these Win32 APIs in your Visual Basic code are:</P>

<OL>
<P><LI>Declare the DLL function.</LI></P>

<P><LI>Call the DLL function.</LI></P>
</ol>

<P>Some Windows API functions require a function pointer to be passed to them as an argument. These Visual Basic procedures are referred to as callback procedures. A callback procedure is a procedure that will be called by the external DLL. Visual Basic uses the AddressOf operator to pass a callback procedure to a DLL. </P>

</BODY>
</HTML>





