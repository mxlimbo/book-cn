<HTML>
<HEAD>
<TITLE>Lesson 2: Returning Records from a Data Source</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06b.htm", "ch06d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="235"><H1>Lesson 2: Returning Records from a Data Source</H1></A>

<P>In this lesson, you will learn how to use Recordset objects to return and manage records from a data source. You can create Recordsets from existing Connection objects or Command objects. In addition, a Recordset can create its own connection to a data source. Once the recordset has been generated, your application can present the records to the user for viewing or editing. You can add new records and delete existing records. </P>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>

<p><li>Return records from a data source.</li></p>

<p><li>Define and use cursors.</li></p>

<p><li>Return and manage multiple recordsets.</li></p>

</ul>
<b>Estimated lesson time: 20 minutes</b>
</blockquote></div>
</p>

<A NAME="236"><H2>Using the ADO Recordset Object</H2></A>

<P>A Recordset object represents results of a command executed on a data source. You can then use the object to manipulate the data. Once a connection has been established to the data source, you can return records using the Recordset object's Open method.</P>

<P>Use the following syntax to access records in a data source:</P>

<p><I>recordset</I>.Open <I>Source</I>, <I>ActiveConnection</I>, <I>CursorType</I>, <I>LockType</I>, <I>Options</I></p>

<P>The Open method uses the following arguments:</P>
<P>
<TABLE CELLPADDING=5 WIDTH="95%">
<TR>
<Th>Argument
</Th>
<Th>Description
</Th></TR>
<TR>
<TD VALIGN="TOP">Source
</TD>
<TD VALIGN="TOP"><I>Optional</I>. A Variant that evaluates to a valid Command object variable name, an SQL statement, a table name, a stored procedure call, or the file name of a persisted Recordset
</TD></TR>
<TR>
<TD VALIGN="TOP">ActiveConnection
</TD>
<TD VALIGN="TOP"><I>Optional</I>. Either a Variant that evaluates to a valid Connection object variable name or a String containing ConnectionString parameters.
</TD></TR>
<TR>
<TD VALIGN="TOP">CursorType
</TD>
<TD VALIGN="TOP"><I>Optional</I>. A value that determines the type of cursor that the provider should use when opening the recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">LockType
</TD>
<TD VALIGN="TOP"><I>Optional</I>. A value that determines what type of locking (concurrency) the provider should use when opening the recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">Options
</TD>
<TD VALIGN="TOP"><I>Optional</I>. A Long<B> </B>value that indicates how the provider should evaluate the Source argument if it represents something other than a Command object, or that indicates the recordset should be restored from a file where it was previously saved.
</TD></TR></TABLE></p>

<A NAME="237"><H3>Using an Explicit Connection Object</H3></A>

<P>You can build a Recordset object based on an active connection to a data source, which limits the number of connections and reduces the amount of client and server resources used by your application. Depending on the needs of the recordset, you may need to build an explicit Connection object or Command object first.</P>

<P>The following example opens a new recordset from an existing connection:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Dim cnPubs As Connection
Dim rsTitles As Recordset

' Instantiate the objects
Set cnPubs = New Connection
Set rsTitles = New Recordset

' Open the connection
cnPubs.ConnectionString = &quot;Provider=SQLOLEDB;&quot; &amp; _
    &quot;User ID=sa;&quot; &amp; _
    &quot;Data Source=VB6ENTSVR;&quot; &amp; _
    &quot;Initial Catalog=Pubs&quot;
cnPubs.Open

' Retrieve records from the data source
rsTitles.Open &quot;Select * from Titles&quot;, cnPubs
</pre></td></tr></table></p>

<A NAME="238"><H3>Using an Implicit Connection Object</H3></A>

<P>An alternative to using an existing Connection object is to open a new recordset using an implicit connection. One of the features of the ADO object model is the ability to call objects directly. When calling a Recordset object directly, ADO automatically creates a Connection object in the background. You cannot access this object programmatically. It is automatically closed when the recordset is closed.</P>

<P>The following example uses an implicit connection to return records from the Titles table:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cmdOpenRecordset_Click()
    Dim rsTitles As Recordset

    ' Instantiate the Recordset object
    Set rsTitles = New Recordset

    ' Open a new connection and return the appropriate records
    rsTitles.Open &quot;Select * from Titles&quot;, _
        &quot;Provider=SQLOLEDB;User ID=sa;&quot; &amp; _
        &quot;Data Source=VB6ENTSVR;&quot; &amp; _
        &quot;Initial Catalog=Pubs&quot;
End Sub
</pre></td></tr></table></p>

<P>As you can see, using this technique reduces the amount of code that you have to write. However, for each recordset that uses an implicit connection, a new connection is created on the data source. In most cases, these additional connections use valuable resources. It may be more efficient to create a single Connection object and open the required recordsets from that connection. You can create multiple recordsets from one connection without using additional connection resources.</P>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Using implicit connections causes scalability problems when programming enterprise-level applications, such as with Microsoft SQL Server. Consider using explicit Connection objects when accessing a data source.
</blockquote></div>
</p>

<A NAME="239"><H3>Locking the Recordset</H3></A>

<P>As you learned in Chapter 5, &quot;<A HREF="ch05a.htm#194">Introducing ActiveX Data Objects</A>,&quot; ADO creates cursors that are read-only. This provides for the best performance and lowest system resource requirements. In the event your application intends to add records, delete records, or edit existing records, you will need to specify a different locking option. In a multi-user environment, locking ensures that no two users can change the same record at the same time.</P>

<P>Use the LockType property to set the locking option for the recordset. The following table describes the possible values for the LockType property.</P>
<P>
<TABLE CELLPADDING=5 WIDTH="95%">
<TR>
<Th>Locking Value
</th>
<Th>Description
</Th></TR>
<TR>
<TD VALIGN="TOP">adLockReadOnly
</TD>
<TD VALIGN="TOP">The data is read-only and cannot be altered. This is the default option.
</TD></TR>
<TR>
<TD VALIGN="TOP">adLockPessimistic
</TD>
<TD VALIGN="TOP">The provider ensures successful editing of the records, usually by locking records at the data source immediately upon editing.
</TD></TR>
<TR>
<TD VALIGN="TOP">adLockOptimistic
</TD>
<TD VALIGN="TOP">The provider uses optimistic locking, which locks records only when you call the Update method.
</TD></TR>
<TR>
<TD VALIGN="TOP">adLockBatchOptimistic
</TD>
<TD VALIGN="TOP">The records are locked in batch update mode, as opposed to immediate update mode. This option is required for client-side cursors, including disconnected recordsets.
</TD></TR></TABLE></p>

<P>The following example creates a dynamic recordset using optimistic locking:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
rsTitles.Open &quot;Select * from Titles&quot;, cnPubs, adOpenDynamic,
adLockOptimistic
</pre></td></tr></table></p>

<A NAME="240"><H2>Accessing Records in a Recordset</H2></A>

<P>Once a recordset has been created, you can access the fields of each record in one of the following ways:</P>

<ul>
<p><li>Reference the name of the field</li></p>

<p>If you know the name of the field you want to access, you can use the following syntax to access the current value of the field:</p>
</ul>

<p><I>RecordsetObject</I>!<I>FieldName</I></p>

<ul>
<p>This is the most efficient of the two techniques for referencing a field.</p>

<p><li>Use the Fields collection</li></p>

<p>You can also use the Recordset object's Fields collection. This technique is not as efficient when accessing a recordset. Use the following syntax to access the value of a field using the Fields collection:</p>
</ul>

<p><I>recordsetobject</I>.Fields(0) or <I>recordsetobject</I>.Fields(&quot;<I>FieldName</I>&quot;)</p>

<P>The following examples display the <I>Title</I> field in the Immediate window:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Debug.Print rsTitles!Title
</pre></td></tr></table></p>

<P>-or-</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Debug.Print rsTitles.Fields(0)
</pre></td></tr></table></p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The Title field is the first field in the collection.
</blockquote></div>
</p>

<A NAME="241"><H2>Binding Controls to ADO Recordsets</H2></A>

<P>Visual Basic provides the ability to bind controls such as text boxes to ADO recordsets. When a control is bound to a recordset, the control automatically reflects the current record's data, allowing a convenient way for users to edit the data contained in a record's fields. To bind a control to a recordset, you must set the control's DataSource and DataField properties. DataSource is an object property that requires the use of the Set statement. The DataField is a string that references the field in the recordset by its name. The following example binds a text box to the rsAuthor recordset:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Set txtAuthor.DataSource = rsAuthor
txtAuthor.DataField = &quot;au_fname&quot;
</pre></td></tr></table></p>

<P>You can also bind more complex controls to a recordset. The following code opens a connection to a SQL Server. The recordset, rsTitles, is opened using the cnPubs Connection object, and the Hierarchical Flexgrid's DataSource property is defined as the rsTitles recordset.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Dim cnPubs As ADODB.Connection
Dim rsTitles As ADODB.Recordset
Dim strConnect As String
strConnect = &quot;Provider=SQLOLEDB;User ID=sa;&quot; &amp; _
    &quot;Data Source=VB6ENTSVR;&quot; &amp; _
    &quot;Initial Catalog=Pubs&quot;

' Instantiate a Connection object
Set cnPubs = New Connection

' Open a new connection
cnPubs.Open strConnect, &quot;sa&quot;, &quot;&quot;

' Instantiate the Recordset object
Set rsTitles = New Recordset

' Open a new recordset using the 
' cn connection and return the appropriate records
rsTitles.Open &quot;SELECT * From Titles&quot;, cnPubs

' Fill the Hierarchial Flexgrid control with 
' data from the Titles table

Set flexTitles.DataSource = rsTitles
</pre></td></tr></table></p>

<A NAME="242"><H2>Creating Multiple Recordsets</H2></A>

<P>Using ADO you can define a command statement that contains multiple Select statements. As a result, the single command returns more than one recordset, which is more efficient than calling a data source multiple times. Multiple recordsets can be created using the Execute method of a Command object or the Open method of a Recordset object. The following example creates two recordsets from a single Open statement:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
rsInfo.Open &quot;SELECT * From Titles;SELECT * From Authors&quot;, cnPubs
</pre></td></tr></table></p>

<p><b>Obtaining the Next Recordset </b></p>

<P>Each statement in the compound command is executed in the order entered, and only one recordset is returned at a time. Use the NextRecordset method to move to the next recordset when multiple recordsets can be returned. Since the NextRecordset method executes only the next command in the statement, if you explicitly close the Recordset object before stepping through the entire command statement, ADO never executes the remaining commands.</P>

<P>NextRecordset is a function and requires the use of a Recordset object variable. Therefore, you must use the Set statement with NextRecordset. The following example creates the next recordset from the data source and placed into the rsInfo recordset object variable:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Set rsInfo = rsInfo.NextRecordset
</pre></td></tr></table></p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
NextRecordset discards the current recordset. You need to re-query the data source to access the previous recordset after NextRecordset is called.
</blockquote></div>
</p>

<P>When the last recordset has been reached, the NextRecordset method returns a value of Nothing. Using the Is Nothing<B> </B>keyword, you can determine if the end of the recordsets have been reached.</P>

<P>Note that the NextRecordset cannot be called while an edit is in progress. If your application attempts to do this, an error is generated. To avoid this error, use the Update or CancelUpdate method first. You will learn more details about modifying records with a Recordset object in Lesson 4 of this chapter.</P>

<P>The following example uses the NextRecordset method to view the data in a recordset that uses a compound command statement made up of three separate SELECT statements.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cmdCompoundRecordsets_Click()

    Dim rsCompound As Recordset
    Dim Count As Integer
    Dim strConnect As String
    Dim strSQL As String


strConnect = &quot;Provider=SQLOLEDB;&quot; &amp; _
        &quot;Data Source=VB6ENTSVR;&quot; &amp; _
        &quot;Initial Catalog=pubs;&quot; &amp; _
        &quot;User Id=sa;Password=;&quot;
    strSQL = &quot;SELECT * FROM authors; &quot; &amp; _
        &quot;SELECT * FROM stores; &quot; &amp; _
        &quot;SELECT * FROM jobs&quot;
    Set rsCompound = New Recordset
    rsCompound.CursorLocation = adUseClient
    rsCompound.Open strSQL, strConnect, _
        adOpenUnspecified, _
        adLockUnspecified

    Do Until rsCompound Is Nothing
        Debug.Print &quot;Recordset #&quot; &amp; Count
        Do While Not rsCompound.EOF
            Debug.Print , rsCompound.Fields(0), _
            rsCompound.Fields(1)
            rsCompound.MoveNext
        Loop
        Set rsCompound = rsCompound.NextRecordset
        Count = Count + 1
    Loop
End Sub
</pre></td></tr></table></p>

<A NAME="243"><H2>Creating Programmatic Recordsets</H2></A>

<P>ADO also allows an application to programmatically create a recordset without requiring a data source. One of the benefits of using this technique is being able to create a single recordset object that contains data located from multiple sources. Because a recordset created programmatically is also populated programmatically, the recordset data can come from OLE DB and non-OLE DB data sources.</P>

<P>A programmatic recordset is created by instantiating a new recordset object and then building the recordset using the Append method of the recordset Fields collection. The Append method of the Fields collection requires that the CursorLocation be set to adUseClient. The following example uses the Append method to programmatically create an ADO recordset:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Function Create() As Recordset
    Dim rsTitles As Recordset
    Set rsTitles = New Recordset
    rsTitles.CursorLocation = adUseClient
    rsTitles.LockType = adLockBatchOptimistic

    ' Add the columns to the recordset
    With rsTitles.Fields
        .Append &quot;title_id&quot;, adVarChar, 6, adFldUpdatable
        .Append &quot;title&quot;, adVarChar, 80, adFldUpdatable
        .Append &quot;pub_id&quot;, adChar, 12, adFldUpdatable
        .Append &quot;price&quot;, adCurrency, attrib:=adFldIsNullable _ 
            +adFldUpdatable
        .Append &quot;advance&quot;, adCurrency, attrib:=adFldIsNullable _
            + adFldUpdatable
        .Append &quot;royalty&quot;, adInteger, attrib:=adFldIsNullable _
            + adFldUpdatable
        .Append &quot;ytd_sales&quot;, adInteger, _
            attrib:=adFldIsNullable + adFldUpdatable
        .Append &quot;notes&quot;, adVarChar, 200, adFldIsNullable + _
            adFldUpdatable
        .Append &quot;pubdate&quot;, adDBTimeStamp, _
            attrib:=adFldIsNullable + adFldUpdatable
    End With

    ' Need to open the recordset before we can work with it
    rsTitles.Open

    ' The function returns the newly created recordset
    Set Create = rsTitles
End Function

</pre></td></tr></table></p>

<P>In addition to creating a new programmatic recordset, you can also use the Append method to add additional fields to an existing recordset. Developers that create components can use this functionality to return a single recordset containing data from multiple sources. Use the following general steps to create a custom recordset object:</P>

<ol>
<p><li>Create and populate the recordset.</li></p>

<p><li>Programmatically alter the recordset.</li></p>

<p><li>Update the values from an additional OLE DB or non-OLE DB data source.</li></p>
</ol>

<A NAME="244"><H2>Lesson Summary </H2></A>

<P>In this lesson, you learned how to return records from a data source using a Recordset object. The use of explicit and implicit connections were discussed. You learned how to access records in a recordset and bind the results to controls on a form. The advanced concept of returning multiple recordsets using the NextRecordset method was also discussed. This lesson concluded by describing how to create programmatic recordsets that do not necessarily require a data source. Using the Append method, you can create fields on a Recordset object in order to build a custom recordset for use with different data sources at the same time.</P>

</BODY>
</HTML>



