<HTML>
<HEAD>
<TITLE>Lesson 3: Asynchronous Operations</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07c.htm", "ch07e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="292"><H1>Lesson 3: Asynchronous Operations</H1></A>

<P>Operations involving a database can often take some time to process. For example, a query, a connection to the data source, or the retrieval of results to the client can be lengthy operations. ADO provides a way to perform these operations <I>asynchronously</I>. An asynchronous operation is a task initiated by code (such as a query) that allows other tasks to continue before it is complete. In contrast, a synchronous operation is a task initiated by code that completes before another operation starts.</P>

<P>Asynchronous operations allow you to perform other operations while a time-consuming task is being performed in the background. For example, you can display a progress dialog box, continue painting a form, or start other asynchronous operations while an asynchronous operation is being performed. This makes your application more flexible and responsive to the user.</P>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson you will be able to:</b>
<ul>

<p><li>Connect to a data source asynchronously.</li></p>

<p><li>Use ADO Events for asynchronous operations.</li></p>

<p><li>Explain the differences between a will event and a complete event.</li></p>

<p><li>Execute commands asynchronously.</li></p>

<p><li>Perform database operations asynchronously</li></p>

</ul>
<b>Estimated lesson time: 25 minutes</b>
</blockquote></div>
</p>

<A NAME="293"><H2>Connecting Asynchronously to a Data Source</H2></A>

<P>In an n-tier architecture, the COM components in the business tier typically contain the data access code, as illustrated in Figure 7.3.</P>

<P>
<A HREF="javascript:fullSize('F07xx03x.htm')"> <img src="images/F07xx03.JPG" width=404 height=318 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 7.3</b> <i>Data access components in the business tier</i><!--/caption-->
</P>


<P>By writing your data access components to perform asynchronous operations, end-users working with the presentation tier are not prevented from performing other tasks while a data access component executes a method, such as Connection.Open. Instead, the application can continue to be used while the data access component works on a task. You specify the start of an asynchronous connection by setting the Options parameter in the Open method of an ADO Connection object. ADO implements the asynchronous connection operation internally, and does not rely on support from the OLE DB provider being used. Therefore, you will always be able to asynchronously connect to a data source using ADO.</P>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Asynchronous connection can be done only from the ADO Connection object. ADO allows the user to connect to a data source directly from the Command or Recordset object, but these objects cannot be used to asynchronously connect.
</blockquote></div>
</p>

<P>In the following example, there is no code to determine when the connection operation has completed. Most applications need to verify a database connection because operations on the connection will fail unless it was successful.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Dim cn As New ADODB.Connection

cn.ConnectionString = _
    &quot;Provider=SQLOLEDB;Data Source=VB6ENTSVR;&quot; _
    &amp; &quot;User ID=sa;Initial Catalog=pubs&quot;
cn.Open , , , adAsyncConnect
</pre></td></tr></table></p>

<P>You can test whether or not a connection was successful by evaluating the ADO Connection object's State property, or by using ADO Events.</P>

<A NAME="294"><H3>Testing the State Property</H3></A>

<P>A property exposed on the ADO objects that support asynchronous operations is the State property. You can use this property to determine the status of a Connection object-that is, whether it is closed or open (adStateClosed, adStateOpen). The State property can also tell you what asynchronous operation is occurring (adStateConnecting, adStateExecuting, adStateFetching). For example:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
If cn.State = adStateConnecting Then Debug.Print &quot;Still Connecting&quot;
</pre></td></tr></table></p>

<P>Use the State property in a loop to determine when an operation has completed. If an error occurs during the asynchronous operation, testing the State property may generate an error. State was implemented in this way so that the user can in some way be notified that an error occurred during the asynchronous operation. </P>

<A NAME="295"><H2>Using ADO Events</H2></A>

<P>The ADO event model supports certain synchronous and asynchronous ADO operations that issue events, or notifications, before the operation starts or after it completes. An event is actually a call to an event handler routine that you define in your application. You can use ADO events to execute specific tasks when a connection is made. To use the events associated with an ADO object, you must declare that object using the WithEvents keyword. For example:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private WithEvents cnNorthWind As Connection
</pre></td></tr></table></p>

<A NAME="296"><H3>Types of ADO Events</H3></A>

<P>In ADO, there are events that are called either after an ADO operation completes or before an operation starts. Event handlers that are called after an operation completes are especially important when performing asynchronous operations because these events notify you when a task, such as the Connection.Open method, has completed. For example, an application that starts an asynchronous Connection.Open operation is notified by the execution of the ConnectComplete event when the operation concludes. These types of events are called <I>complete</I> <I>events</I>. Conversely, events that are called before an operation starts allow you to examine or modify the operation parameters and then either cancel the operation or allow it to complete the operation. These events are called <I>will</I> <I>events</I>. </P>

<A NAME="297"><H3>Using Complete Events</H3></A>

<P>As an alternative to checking the State property of a Connection object, you can use the ConnectComplete event procedure to check for any errors that might have occurred during a connection to a data source. You can do this by evaluating the adStatus argument of the ConnectComplete event procedure. If the value of the adStatus argument is set to adStatusErrorsOccurred, an error has occurred. You can then use the pError argument, an ADO Error object that describes the error, to find out the error type. The following example attempts to connect to an invalid data source. Because the Initial Catalog is set to northwind2, the connection will fail.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cmdConnect_Click()
    Set cnNorthWind = New Connection
    ' Establish a connection
    With cnNorthWind
        .Provider = &quot;SQLOLEDB&quot;
        .ConnectionString = &quot;User ID=sa;&quot; &amp; _
                &quot;Data Source=vb6entsvr;&quot; &amp; _
                &quot;Initial Catalog=northwind2&quot;
        ' Connection will fail because northwind2 is
        ' an invalid catalog
        .Open , , , adAsyncConnect
    End With
End Sub
</pre></td></tr></table></p>

<P>When the ConnectComplete event fires, the adStatus argument is set to adStatusErrorOccurred, and therefore you can check the Description property of the pError argument, as shown in the following example.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cnNorthWind_ConnectComplete(ByVal pError As ADODB.Error, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pConnection As ADODB.Connection)

    If adStatus = adStatusErrorsOccurred Then
        ' Display a message box containing the error description
        MsgBox &quot;Error during connection: &quot; &amp; pError.Description
    Else
        blnConnectionValid = True
    End If
End Sub
</pre></td></tr></table></p>

<P>In the previous example, a message box displays containing the description of the pError ADO object, as illustrated in Figure 7.4.</P>

<P>
<A HREF="javascript:fullSize('F07xx04x.htm')"> <img src="images/F07xx04.JPG" width=404 height=202 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 7.4</b> <i>The ConnectComplete event displaying an error for a failed connection</i><!--/caption-->
</P>


<A NAME="298"><H3>Using Will Events</H3></A>

<P>Will events and complete events are typically used in pairs. For example, you can use the WillConnect and ConnectComplete events together to first validate connection parameters and then verify that the connection succeeded. One possible use for the WillConnect event procedure could be to verify that a valid connection string has been provided, as shown in the following example:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cnNorthWind_WillConnect(ConnectionString As String, _
    UserID As String, Password As String, Options As Long, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pConnection As ADODB.Connection)

    ' Check the connection string
    ' Initial Catalog=northwind2 is invalid and
    ' must be changed to northwind
    ConnectionString = &quot;User ID=sa;&quot; &amp; _
                        &quot;Data Source=vb6entsvr;&quot; &amp; _
                        &quot;Initial Catalog=northwind&quot;
End Sub
</pre></td></tr></table></p>

<P>Because the connection parameters have been correctly set in the WillConnection event procedure, the connection to the Northwind database will be successful.</P>

<A NAME="299"><H2>Asynchronously Executing a Command</H2></A>

<P>In addition to connecting to a data source, execution of a command is another operation that can take a significant amount of time. There are two places in which ADO allows asynchronous execution: the Connection.Execute method and the Command.Execute method.</P>

<P>Asynchronous execution covers the time from when the data source is requested to begin an operation to when the first record is available (assuming a record-returning result). Performing an asynchronous execution is similar to performing an asynchronous connection. The Options parameter to ADO execute methods must include the value adAsyncExecute.</P>

<P>The following example connects to the Northwind database in the cmdConnectAndExecute_Click event procedure: </P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private WithEvents cnNorthWind As ADODB.Connection
Private cmdNorthWind As ADODB.Command

Sub cmdConnectAndExecute_click()
    Set cnNorthWind = New Connection
    ' Establish a connection
    With cnNorthWind
        .Provider = &quot;SQLOLEDB&quot;
        .ConnectionString = &quot;User ID=sa;&quot; &amp; _
                            &quot;Data Source=vb6entsvr;&quot; &amp; _
                            &quot;Initial Catalog=northwind&quot;
        .Open , , , adAsyncConnect
    End With
End Sub
</pre></td></tr></table></p>

<P>When the connection has been made, the Connection object's ConnectComplete event procedure fires. In the ConnectComplete event procedure, a Command object is created based on the cnNorthWind Connection object and is used to query all records from the Orders table. A message is printed in the Debug window to acknowledge the start of the Command's execution.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cnNorthWind_ConnectComplete(ByVal pError As ADODB.Error, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pConnection As ADODB.Connection)

    ' Check for errors
    ' ...
    ' Execute a command
    Set cmdNorthWind = New ADODB.Command
    Set cmdNorthWind.ActiveConnection = cnNorthWind
    cmdNorthWind.Execute &quot;select * from Orders&quot;, , adAsyncExecute
    Debug.Print &quot;Command Execution Started.&quot;
End Sub
</pre></td></tr></table></p>

<P>When the Command object finishes executing, the cnNorthWind Connection object's ExecuteComplete event procedure fires and a message is printed in the Debug window indicating that the Command has finished executing.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cnNorthWind_ExecuteComplete(ByVal RecordsAffected As Long, _
    ByVal pError As ADODB.Error, adStatus As ADODB.EventStatusEnum, _
    ByVal pCommand As ADODB.Command, _
    ByVal pRecordset As ADODB.Recordset, _
    ByVal pConnection As ADODB.Connection)

    Debug.Print &quot;Completed Executing the Command.&quot;
End Sub
</pre></td></tr></table></p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Note that most options parameters take more than one value, so adAsyncExecute could be joined with another option by using an Or operation.
</blockquote></div>
</p>

<A NAME="300"><H2>Asynchronously Fetching Results</H2></A>

<P>You can utilize ADO events that are fired when you navigate through the rows of a Recordset object or make any changes in the Recordset. The following table describes the ADO events associated with the Recordset object:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%">
<TR>
<Th>Recordset Event
</Th>
<Th>Description
</Th></TR>
<TR>
<TD VALIGN="TOP">FetchProgress
</TD>
<TD VALIGN="TOP">Call the FetchProgress method periodically during a lengthy asynchronous operation to report how many more rows have currently been retrieved (fetched) into the Recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">FetchComplete
</TD>
<TD VALIGN="TOP">Call the FetchComplete method after all the records in a lengthy asynchronous operation have been retrieved (fetched) into the Recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">WillChangeField
</TD>
<TD VALIGN="TOP">Call the WillChangeField method before a pending operation changes the value of one or more Field objects in the Recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">FieldChangeComplete
</TD>
<TD VALIGN="TOP">Call the FieldChangeComplete method after the value of one or more Field objects has changed.
</TD></TR>
<TR>
<TD VALIGN="TOP">WillMove
</TD>
<TD VALIGN="TOP">Call the WillMove method before a pending operation changes the current position in the Recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">MoveComplete
</TD>
<TD VALIGN="TOP">Call the MoveComplete method after the current position in the Recordset changes.
</TD></TR>
<TR>
<TD VALIGN="TOP">EndOfRecordset
</TD>
<TD VALIGN="TOP">Call the EndOfRecordset method when there is an attempt to move to a row past the end of the Recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">WillChangeRecord
</TD>
<TD VALIGN="TOP">Call the WillChangeRecord method before one or more records (rows) in the Recordset change.
</TD></TR>
<TR>
<TD VALIGN="TOP">RecordChangeComplete
</TD>
<TD VALIGN="TOP">Call the RecordChangeComplete method after one or more records change.
</TD></TR>
<TR>
<TD VALIGN="TOP">WillChangeRecordset
</TD>
<TD VALIGN="TOP">Call the WillChangeRecordset method before a pending operation changes the Recordset.
</TD></TR>
<TR>
<TD VALIGN="TOP">RecordsetChangeComplete
</TD>
<TD VALIGN="TOP">Call the RecordsetChangeComplete method after the Recordset has changed.
</TD></TR></TABLE></p>

<P>With large recordsets, fetching records can take a long time. With asynchronous Recordset operations, the user can be shown some of the records almost immediately, and then the rest can be retrieved in the background. Asynchronous fetching in ADO is implemented only for client cursors (CursorLocation = adUseClient).</P>

<A NAME="301"><H3>Blocking and Nonblocking Fetches</H3></A>

<P>There are two types of asynchronous fetches: blocking and nonblocking. The difference between blocking and nonblocking is in how operations that attempt to refer to unfetched rows are handled. In the blocking case, a function such as MoveLast is executed, and ADO waits until all records are available in the Recordset. ADO then returns control to the application. In a nonblocking scenario, the MoveLast operation returns control to the application immediately, and the current record in the Recordset is marked as the last record in the recordset. The user is placed on the last row that was fetched, not on the actual last record that will eventually be fetched into the Recordset. This way the user can see records gradually until all records are returned instead of having to wait until all records have been fetched.</P>

<P>By default, 50 rows are fetched before control is returned to the developer. The value 50 was chosen to represent approximately what might be displayed in a grid on a form. Setting the Initial Fetch Size property in the Recordset Properties collection can control the number of records that are initially fetched. For example:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
rs.Properties(&quot;Initial Fetch Size&quot;) = 10
</pre></td></tr></table></p>

<P>The Recordset object can only request asynchronous fetching through the Open method's Options parameter. This is demonstrated in the following example code by using a blocking (adAsyncFetch) asynchronous fetch:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private cnNorthwind As ADODB.Connection
Private WithEvents rsOrders As ADODB.Recordset

Private Sub cmdFetch_Click()
    Set cnNorthwind = New Connection
    ' Establish a connection
    With cnNorthwind
        .Provider = &quot;SQLOLEDB&quot;
        .ConnectionString = &quot;User ID=sa;&quot; &amp; _
                            &quot;Data Source=vb6entsvr;&quot; &amp; _
                            &quot;Initial Catalog=northwind&quot;
        .Open
    End With

    Set rsOrders = New ADODB.Recordset
    Set rsOrders.ActiveConnection = cnNorthwind
    With rsOrders
        .CursorLocation = adUseClient
        .Properties(&quot;Initial Fetch Size&quot;) = 1
        .Open &quot;select * from Orders&quot;, , , , adAsyncFetch
    End With

    ' Print first record to the Debug window
    Debug.Print rsOrders![CustomerID] &amp; _
        &quot; &quot; &amp; rsOrders![ShippedDate] &amp; _
        &quot;   : First field, Fetching Started.&quot;
End Sub

Private Sub rsOrders_FetchComplete(ByVal pError As ADODB.Error, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)

    Debug.Print &quot;Completed Fetching Results.&quot;

End Sub
</pre></td></tr></table></p>

<A NAME="302"><H2>Lesson Summary </H2></A>

<P>Some database operations such as queries, data source connections, and retrieval of records can take a long time to process. ADO provides a way to carry out these operations asynchronously. Asynchronous operations allow you to perform other operations while a time-consuming task is being performed in the background.</P>

<P>In ADO, there are events that are called either after an ADO operation completes or before an operation starts. Complete events are called after an operation completes. Will events are called before an operation starts, allowing you to examine or modify the operation parameters. You can then either cancel the operation or allow it to complete. </P>

<P>You can specify the start of an asynchronous connection by setting the Options parameter in the Open method of an ADO Connection object. In addition to connecting to a data source, executing a command is an operation that can take a significant amount of time. You can specify an asynchronous command in the Command.Execute method by using the adAsyncExecute option.</P>

<P>You can also retrieve records from a data source asynchronously. With large recordsets, fetching records can take a long time. With asynchronous Recordset operations, the user can be shown some of the records almost immediately and the rest can be retrieved in the background.</P>

</BODY>
</HTML>



