<HTML>
<HEAD>
<TITLE>Lesson 1: Creating Custom Interfaces</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04a.htm", "ch04c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="166"><H1>Lesson 1: Creating Custom Interfaces</H1></A>

<P>Component software development is currently one of the most prominent trends in the software industry. Most of the software development tools that you can buy today support component software development, including Microsoft Visual Basic, Microsoft Visual C++, Delphi, and Microsoft Visual J++. </P>

<P>Microsoft's effort to define an open, extensible standard for software component development and interoperability resulted in COM. COM is a specification that describes how software components can be built. COM enables software components that you create to work with software components that are available commercially. Because COM components created by different software developers can be combined into a variety of applications, you can reuse code. </P>

<P>As a Visual Basic developer, you create COM components with ActiveX controls, ActiveX Documents, ActiveX EXE, and ActiveX DLL projects. Because Visual Basic was designed to provide developers with a high level of productivity and rapid application development, Visual Basic hides most of the complexities of COM. However, to effectively develop COM components with Visual Basic, you must have a fundamental understanding of how Visual Basic utilizes COM.</P>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson you will be able to:</b>
<ul>
<p><li> Explain how interface-based programming relates to component-based software development.</li></p>

<p><li> Describe the role of interfaces in COM.</li></p>

<p><li> Define default interfaces and their purpose.</li></p>

<p><li> Describe the benefits of creating custom interfaces.</li></p>

</ul>
<b>Estimated lesson time: 50 minutes</b>
</blockquote></div>
</p>


<A NAME="167"><H2>Interface-Based Programming</H2></A>

<P>Interface-based programming is a concept created by the computer science academia and companies that needed to develop enterprise software and information systems. Conceptually, interface-based programming defines two separate but related elements: an <I>interface</I> and a <I>coclass</I>.</P>

<P>An interface is a data type that contains definitions of public methods without containing any code. The coclass contains the code for the methods defined by the interface, as illustrated in Figure 4.1.</P>

<P>
<A HREF="javascript:fullSize('F04xx01x.htm')"> <img src="images/F04xx01.JPG" width=404 height=255 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.1</b> <i>Relationship between an interface and a coclass</i><!--/caption-->
</P>


<P>As you can see in Figure 4.1, the interface contains the declaration of three methods but does not contain any code. The coclass, however, contains code defined by the interface. In interface-based programming, this is known as &quot;separating <I>definition</I> from <I>implementation</I>.&quot; In this statement, definition is the interface containing the method declarations, and implementation is the class containing code for the methods.</P>

<P>COM provides the ability for objects to communicate with each other both in-process and out-of-process. Out-of-process objects can be located either on the same computer or different computers on a network. <I>Interface pointers</I> achieve this communication. For example, when a client application calls a method of a COM object, the client points to a location in memory where the COM object's interface resides, as illustrated in Figure 4.2.</P>

<P>
<A HREF="javascript:fullSize('F04xx02x.htm')"> <img src="images/F04xx02.JPG" width=404 height=157 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.2</b> <i>How an interface pointer is used in COM</i><!--/caption-->
</P>


<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Because object interaction and communication in COM is a very complex subject, it cannot be completely covered in this chapter. For more information,  search on &quot;The Component Object Model: A Technical Overview&quot; in the MSDN Online Help. For additional information about COM, visit the COM web site at <a href="http://www.microsoft.com/com/" target="_window2">http://www.microsoft.com/com/</a>.
</blockquote></div>
</p>

<P>All COM components communicate through interfaces, whether they are created in Visual C++, Visual Basic, or any other COM-enabled development tool. This being the case, you should understand how interfaces are created and used in Visual Basic.</P>

<A NAME="168"><H2>Interfaces and Visual Basic</H2></A>

<P>Visual Basic manages many of the underlying complexities of COM for you when you create components. When you create a COM DLL, for example, you do not have to create a coclass and an interface to leverage the power of COM. Instead, you can simply create class modules within an ActiveX DLL project, and Visual Basic creates the interfaces and coclasses for you. </P>

<P>When you develop COM components such as ActiveX DLL projects with Visual Basic, public createable class modules are translated into coclasses in the type library (.tlb file) of the components. In addition, a <I>default interface</I> is created automatically and is assigned the same name as the class module with an underscore (_) prefix. For example, if you create a COM DLL that contains a public createable class named Hotel, a default interface is created named _Hotel.</P>

<A NAME="169"><H3>Using the OLE View Tool</H3></A>

<P>You can view interfaces and coclasses created by Visual Basic using the OLE View tool installed with Visual Studio. The OLE View tool allows you to open a component's type library and view information about the component. In a type library, any name that begins with an underscore, such as the _Hotel interface, is marked as hidden in the type library. This means that you can't see it in the Object Browser or through IntelliSense. The illustration in Figure 4.3 shows the coclass and default interface created by Visual Basic for the Hotel class within the Chateau COM DLL.</P>

<P>
<A HREF="javascript:fullSize('F04xx03x.htm')"> <img src="images/F04xx03.JPG" width=404 height=309 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.3</b> <i>Viewing the Chateau.dll type library the OLE View tool</i><!--/caption-->
</P>


<P>As you can see in the preceding illustration, the Hotel coclass uses, or <I>implements</I>, the _Hotel default interface. This information is defined in the type library created for the Chateau.dll component. The Hotel class module's coclass and default interface is defined in the type library using the following interface definition language (IDL) syntax.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>coclass Hotel {
    [default] interface _Hotel;
};</PRE>
</TD></TR></TABLE>
</P>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
IDL is a language, with has syntax similar to C, that is used by COM to provide a way for components to publish information about their interfaces and coclasses in a type library. Visual Basic creates the IDL in a type library for you. C++ and Java developers create type libraries by writing IDL and then compiling it using the Microsoft IDL compiler. For more information, search on &quot;Anatomy of an IDL File&quot; in the MSDN Online Help.
</blockquote></div>
</p>

<P>Globally unique identifiers (GUIDs)  identify interfaces and coclasses in a COM component. GUIDs are 128-bit values that can also be expressed as string values, just as they are in the Windows registry. A GUID associated with a COM interface is called an <I>interface</I> <I>identifier</I> (IID). A GUID associated with a coclass is called a <I>class</I> <I>identifier</I> (CLSID). In a type library, each interface and coclass in the component has a Universally Unique Identifier (UUID) attribute. These UUID attributes are the same as GUIDs. The following is an example of a GUID identified as a UUID attribute for an interface in a type library: </P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>uuid(2880ACE0-E44A-11D2-A69F-0000C0DD68F5)</PRE>
</TD></TR></TABLE>
</P>

<A NAME="170"><H3>How Visual Basic Creates a COM Object</H3></A>

<P>When you instantiate a COM object using the CreateObject function, or New keyword, Visual Basic performs a number of steps to create the object.</P>

<ol>
<p><li> Visual Basic looks up a CLSID in the registry related to the programmatic identifier (ProgID) you provide in a Set statement.</li></p>

<p>The following is an example of a ProgID used in a Set statement:</p>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' Use Chateau.Hotel as a ProgID in this Set statement
Set objHotel = CreateObject(&quot;Chateau.Hotel&quot;)</PRE>
</TD></TR></TABLE>
</P>

<P>Because COM classes can only be created from CLSIDs, Visual Basic must first convert the ProgID into its associated CLSID. To convert the ProgID into a CLSID, Visual Basic calls the CLSIDFromProgID function from the COM Library. The CLSIDFromProgID function will find the CLSID associated with the ProgID in the Windows registry, as illustrated in Figure 4.4. When you use the New operator, Visual Basic skips this step by obtaining the CLSID at design time. This makes the New operator slightly faster than the CreateObject function.</P>

<p><li> Visual Basic calls the CoCreateInstance function of the COM library passing the CLSID.</li></p>

<p>CoCreateInstance searches the registry for the given CLSID. Once found, COM searches for the subkey InprocServer32 or LocalServer32. Whichever one is present provides the location of the .dll or .exe file that contains the class. If both InprocServer32 and LocalServer32 subkeys are present, Visual Basic always selects the InprocServer32 entry. The InprocServer32 registry subkey is illustrated in Figure 4.4.</p>

<P>
<A HREF="javascript:fullSize('F04xx04x.htm')"> <img src="images/F04xx04.JPG" width=404 height=173 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.4</b> <i>Chateau.Hotel component information stored in the Windows Registry</i><!--/caption-->
</P>


<p><li> Once COM has the location of the component server, it launches the server.</li></p>

<p>If the server is a DLL, the DLL is loaded into the Visual Basic application's address space. If the server is an EXE, the EXE is launched with a call to the CreateProcess Windows application programming interface (API) function. After the server is loaded, COM requests an instance of the object.</p>

<p><li> Visual Basic assigns an interface pointer to the object variable in the Set statement. In the example code shown in step 1, objHotel is the object variable that is assigned the returned interface pointer. Once the interface pointer is assigned, you can begin using it by calling methods and properties on the object variable.</li></p>
</ol>
<P>
<img src="images/practice.gif" width=67 height=55 border="0">
</P>

<A NAME="171"><H2>Practice: Viewing a Type Library with the OLE View Tool </H2></A>

<P>In this practice, you will create a simple COM DLL and use the OLE View tool to read the IDL code created automatically by Visual Basic. You will then unregister the COM DLL because you will no longer use it.</P>

<P><li><B> To create a COM DLL</B></li></P>
<ol>
<p><li> Start Visual Basic and create a new ActiveX DLL project.</li></p>

<p><li> Change the name of the project to <B>OLEViewTest</B>.</li></p>

<p><li> In <B>Class1</B>, type the following code to create a method.</li></p>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>Public Sub Method1()

End Sub</PRE>
</TD></TR></TABLE>
</P>

<p><li>On the <B>File</B> menu, click <B>Make OLEViewTest.dll...</B></li></p>

<p>The Make Project dialog appears.</p>

<p><li> In the <B>Make Project</B> dialog, choose a file location to save the DLL, then click <B>OK</B>.</li></p>

<p>Visual Basic compiles the OLEViewTest project.</p>
</ol>

<P><li><B> To view the IDL in the OLEViewTest.dll type library</B></li></P>
<ol>
<p><li> Run the OLE View tool (Oleview.exe).</li></p>

<p><li> From the <B>File</B> menu, click <B>View TypeLib...</B></li></p>

<p>The Open dialog appears.</p>

<p><li> In the <B>Open</B> dialog, browse to the OLEViewTest.dll file compiled by Visual Basic, select it, and then click <B>Open</B>.</li></p>

<p>The IDL code for the OLEViewTest.dll file is shown in the right pane of the ITypeLib Viewer window. Notice that a default interface named _Class1 is created for the Class1 module, and is defined in the IDL using the following syntax.</p>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>coclass Class1 {
    [default] interface _Class1;
};</PRE>
</TD></TR></TABLE>
</P>

<p><li> Close the <B>ITypeLib Viewer</B> window.</li></p>

<p><li> Close the <B>OLE View</B> tool.</li></p>
</ol>

<P><li><B> To unregister the OLEViewTest.dll component</B></li></P>
<ol>
<p><li> From the <B>Windows Start</B> menu, click <B>Run</B>.</li></p>

<p><li> In the <B>Run</B> dialog box, type the following command and click <B>OK</B>.</li></p>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>regsvr32 /u &lt;DLL Path&gt;\oleviewtest.dll</PRE>
</TD></TR></TABLE>
</P>

<p><li> Click <B>OK</B> to close the RegSvr32 dialog box to indicate that the unregister succeeded.</li></p>

<p><li> The OLEViewTest.dll component is now unregistered.</li></p>
</ol>

<A NAME="172"><H2>Creating Your Own Interfaces</H2></A>

<P>Although Visual Basic creates default interfaces for class modules that you develop in COM components, you can also create your own custom interfaces. Creating and using a custom interface in Visual Basic involves two main steps:</P>
<ol>
<p><li>Include a class module that defines the interface.</li></p>

<p>If your project is an ActiveX DLL or ActiveX EXE, you should set the Instancing property of the class module to PublicNotCreatable. This is because the interface does not contain any code.</p>

<p><li> Include one or more public createable class modules that implement the interface.</li></p>

<p>You implement an interface in a class module by using the <I>Implements</I> keyword.</p>
</ol>

<P>An example of a custom interface would be to create a class module named IEmployee with its Instancing property set to PublicNotCreatable, and then using the following method declaration:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' IEmployee interface
Public Sub IncreaseSalary()

End Sub</PRE>
</TD></TR></TABLE>
</P>

<P>As you can see, the IncreaseSalary subroutine does not contain any code. This is because an interface defines only <I>signatures</I>. Signatures define the calling syntax that clients use to request services from the COM component. In addition to not containing code, interfaces cannot include data properties. When you create this type of class module in Visual Basic, it is known as creating an <I>abstract class</I>, or <I>abstract data type</I>. IEmployee is an abstract data type that simply defines an interface, - it is not a creatable entity. You can only create objects from creatable classes, or <I>concrete data types</I>.</P>

<P>Once the interface has been created, you then implement the interface in public createable (a class module with its Instancing property set to MultiUse) class modules. For example, you could implement the IEmployee interface in a class module named CManager using the following statement:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' CManager class module
Implements IEmployee</PRE>
</TD></TR></TABLE>
</P>


<P>An interface is like a contract. By implementing the IEmployee interface, the CManager class agrees to respond when any method of the interface is invoked. Therefore, you must implement all of the methods of an interface. In this case, there is only one method to implement: IncreaseSalary.</P>

<P>Because Visual Basic recognizes that the CManager class implements the IEmployee interface, IEmployee is included in the Object list box of the CManager code window, as illustrated in Figure 4.5.</P>

<P>
<A HREF="javascript:fullSize('F04xx05x.htm')"> <img src="images/F04xx05.JPG" width=404 height=169 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.5</b> <i>The IEmployee interface listed in the Object list box</i><!--/caption-->
</P>


<P>In addition, the IncreaseSalary method associated with the IEmployee interface appears in the Procedure list box, as illustrated in Figure 4.6.</P>

<P>
<A HREF="javascript:fullSize('F04xx06x.htm')"> <img src="images/F04xx06.JPG" width=404 height=168 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.6</b> <i>The IncreaseSalary method appearing in the Procedure list box</i><!--/caption-->
</P>


<P>In the IEmployee_IncreaseSalary method of the CManager class, you can include implementation code. For example, you could write the appropriate Visual Basic code to increase a manager's salary by 10 percent. When you do this, you have successfully separated the interface from the implementation, as illustrated in Figure 4.7.</P>

<P>
<A HREF="javascript:fullSize('F04xx07x.htm')"> <img src="images/F04xx07.JPG" width=404 height=295 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.7</b> <i>Separating the interface from the implementation</i><!--/caption-->
</P>


<A NAME="173"><H2>Polymorphism</H2></A>

<P>Because more than one class can implement the same interface, you can make each object respond differently to the same method. For example, you could create a CSupervisor and CStaff class that both implement the IEmployee interface. Because CSupervisor and CStaff implement IEmployee, they must both contain an IEmployee_IncreaseSalary method. The IEmployee_IncreaseSalary method for the CSupervisor class could behave much differently than the IEmployee_IncreaseSalary method for the CStaff class. For example, the CSupervisor class could have code to increase a supervisor's salary by 3 percent, whereas the CStaff class could increase a secretary's salary by 5 percent, as shown in the following code:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' CSupervisor class module
Implements IEmployee

Private Sub IEmployee_IncreaseSalary()
    Dim Salary As Double

    Salary = GetSalaryFromDatabase(m_EmployeeID)
    ' Increase salary by 3%
    Salary = Salary * 1.03
    UpdateSalary m_EmployeeID, Salary
End Sub

' CStaff class module
Implements IEmployee

Private Sub IEmployee_IncreaseSalary()
    Dim Salary As Double

    Salary = GetSalaryFromDatabase(m_EmployeeID)
    ' Increase salary by 5%
    Salary = Salary * 1.05
    UpdateSalary m_EmployeeID, Salary
End Sub</PRE>
</TD></TR></TABLE>
</P>


<P>Because you separated the IEmployee interface from the implementation in the CManager, CSupervisor, and CStaff classes, you have provided the opportunity for clients of your component to use <I>polymorphism</I>. Polymorphism means that many classes can provide the same method and the client calling the method does not have to know which class an object belongs to before calling the method. For example, the CManager, CSupervisor, and CStaff classes each have an IncreaseSalary method. Polymorphism allows you to invoke IncreaseSalary without knowing whether an object is a manager, supervisor, or staff employee.</P>

<P>In the client application, you simply declare a variable as an interface. Then you can set that variable to any type of class that implements the interface, as shown in the following code:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' Standard EXE client application
Private Sub cmdPayEmployees_Click()
    Dim emp As IEmployee
    
    ' Get user input to determine
    ' what type of employee is being paid
    Select Case UserInput
	Case &quot;Manager&quot;
	   ' Make the emp object a manager
           Set emp = New CManager
	Case &quot;Supervisor&quot;
	   ' Make the emp object a supervisor
	   Set emp = New CSupervisor
	Case &quot;Staff&quot;
	   ' Make the emp object a Staff employee
	   Set emp = New CStaff
    End Select
    
    ' Pay the employee
    emp.IncreaseSalary
End Sub</PRE>
</TD></TR></TABLE>
</P>
		


<P>As you can see in this example, when the emp.IncreaseSalary statement is called, you do not know at design time what type of employee is being paid. Instead, the user of the client application makes this decision at run-time.</P>

<P>By creating custom interfaces and implementing them in multiple creatable classes provided by one or more components, you can take advantage of polymorphism in your applications.</P>

<A NAME="174"><H2>Version Compatibility</H2></A>

<P>Sometimes when you develop COM components, you may want to make changes to methods, property procedures, and events. For example, you might want to change the IncreaseSalary method to accept an EmployeeID argument, or return a Boolean value to let the calling application know whether or not the method was successful. However, by doing this, you change the method's signature. The IID for your interface will change when you modify the method signature. This is called &quot;breaking version compatibility.&quot;</P>

<P>When a developer compiles a program that uses your component, the CLSIDs and IIDs of any objects the program creates are included in the executable. The program uses the CLSID to request that your component create an object, and then queries the object for the IID. An error occurs if the interface ID no longer exists. According to the COM specification (a document that describes COM), you should never change an interface once it is in use by other applications. If you want to extend your object by adding methods, you must create a new interface.</P>

<A NAME="175"><H3>IID Forwarding</H3></A>

<P>Visual Basic allows you to break one of the rules defined by the COM specification. In Visual Basic, you can extend your interface by adding new methods, as long as you do not change the signatures of any of the existing methods. To allow for this, Visual Basic uses a technique known as <I>IID forwarding</I>.</P>

<P>Whenever a new interface is created in a component, Visual Basic creates its IID. If you add methods to the interface, Visual Basic creates another IID for it. Client applications can access your object using either IID because Visual Basic modifies the original IID stored in the Windows registry by adding a key named Forward that contains the new IID, as illustrated in Figure 4.8.</P>

<P>
<A HREF="javascript:fullSize('F04xx08x.htm')"> <img src="images/F04xx08.JPG" width=404 height=172 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.8</b> <i>The Forward registry key and its value</i><!--/caption-->
</P>


<P>When developing custom interfaces, the best solution is to create a new interface if you want to enhance an existing method-for example, to enhance the IncreaseSalary method to return a Boolean value. The following steps explain how to create a new interface and add it to an interface:</P>
<ol>
<p><li> Create a new interface.</li></p>

<p>For example, you could create a PublicNotCreatable class module and name it IEmployee2.</p>

<p><li> Add the new enhanced method to the interface.</li></p>

<p>To continue with the IEmployee2 example, you would add the new IncreaseSalary method to the IEmployee2 interface, as shown in the following code:</p>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' IEmployee2 interface
Public Function IncreaseSalary() As Boolean

End Function</PRE>
</TD></TR></TABLE>
</P>

<p><li> Implement the new interface in a public creatable class.</li></p>

<p>Use the Implements keyword in the CManager, CSupervisor, and CStaff classes to provide the IncreaseSalary method defined by the IEmployee2 interface in the CManager class. The following code implements the IEmployee2 interface in the CManager class.</p>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>' CManager class module
Implements IEmployee
' Implement the new interface
Implements IEmployee2

Private Function IEmployee2_IncreaseSalary() As Boolean

End Function</PRE>
</TD></TR></TABLE>
</P>
</ol>

<A NAME="176"><H3>Using the TypeOf Statement</H3></A>

<P>Enabling a single class to implement multiple interfaces is another powerful design technique that you can use. This technique preserves compatibility between clients and components because it allows clients that implement the old interface to continue to use it without errors, while allowing newer applications to use the new interface.</P>

<P>In your client applications, you can test an object to see whether or not an interface is supported using the TypeOf statement, as shown in the following example.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>If TypeOf emp Is IEmployee Then
    emp.IncreaseSalary
End If

If TypeOf emp Is IEmployee2 Then
    bln = emp.IncreaseSalary()
End If</PRE>
</TD></TR></TABLE>
</P>

<P>When you create COM DLLs without creating custom interfaces, extending objects often requires modifying all client applications. By using the techniques of creating custom interfaces that you learned in this lesson, you can avoid versioning problems. Interface-based programming allows you to make changes to a component without impacting code that is currently in production.</P>

<A NAME="177"><H3>Setting Version Compatibility Options in Visual Basic</H3></A>

<P>Visual Basic's Version Compatibility feature lets you enhance your components while maintaining backward compatibility with programs that were compiled using earlier versions of the components. The Version Compatibility box, located on the Component tab of the Project Properties dialog box, contains three options, shown in Figure 4.9.</P>

<P>
<A HREF="javascript:fullSize('F04xx09x.htm')"> <img src="images/F04xx09.JPG" width=404 height=364 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.9</b> <i>The three version compatibility options</i><!--/caption-->
</P>


<p><b>Using the No Compatibility Option</b></p>

<P>When you set the No Compatibility option, a new type library is created each time you compile the component. New type library information is generated, including new CLSIDs and IIDs. When this option is set, programs compiled to use a particular version of a component cannot use any version other than that which they were originally compiled to use.</P>

<P>When you begin working on a new version of an existing component, you may decide that the only way to make necessary enhancements is to break backward compatibility. In this case, set No Compatibility the first time you compile your project. This guarantees that your component will obtain a new set of identifiers and that existing programs won't mistakenly try to use the new incompatible version of the component.</P>

<p><b>Using the Project Compatibility Option</b></p>

<P>Project compatibility is useful when working with multiple projects running in the Visual Basic integrated development environment (IDE). It is not meant to assure compatibility between compiled projects.</P>

<P>Project compatibility allows other instances of the Visual Basic development environment to maintain references to an ActiveX EXE or ActiveX DLL project while allowing modifications to the component interfaces. For example, you can use deletion methods or modify method arguments. Visual Basic maintains a valid reference to a component by reusing the type library's UUID attribute. Each time you compile the component, the CLSIDs and IIDs are recreated; therefore each compilation of a component is not backward compatible with existing clients.</P>

<P>Use the Project Compatibility option when you are developing the first version of a component. The Project Compatibility option preserves the type library identifier, so you do not have to continually set references from your test projects to your component projects because of a missing reference, as illustrated in Figure 4.10.</P>

<P>
<A HREF="javascript:fullSize('F04xx10x.htm')"> <img src="images/F04xx10.JPG" width=404 height=321 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 4.10</b> <i>A missing reference listed in the References dialog box</i><!--/caption-->
</P>


<p><b>Using the Binary Compatibility Option</b></p>

<P>When you use the Binary Compatibility option, Visual Basic keeps the type library's UUID attribute, CLSIDs, and IIDs the same each time you compile a component. This maintains backward compatibility with existing clients. </P>

<P>However, if you attempt to change a method's signature&#8212;for example, if you delete a method from a class or change a method's name or parameter types&#8212;Visual Basic warns you that your changes will make the new version incompatible with previously compiled applications. If you ignore the warning about version incompatibility resulting from changes made, Visual Basic creates new CLSIDs and IIDs for the component, breaking its backward compatibility.</P>

<P>Use Binary Compatibility when you begin development on the new version of a component if you want client applications compiled using the earlier version to continue to work with the new version.</P>

<A NAME="178"><H2>Lesson Summary </H2></A>

<P>Interface-based programming conceptually defines two separate, related elements: an interface, and a coclass. An interface contains the declaration of the methods and does not contain any code. The coclass contains the code defined by the interface. In interface-based programming, this is known as &quot;separating definition from implementation.&quot;</P>

<P>When you develop COM components with Visual Basic, class modules are translated into coclasses in the component's type library. A default interface is also created automatically, and is assigned the same name as the class module with an underscore (_) prefix. Although Visual Basic creates default interfaces for class modules that you develop in COM components, you can also create your own custom interfaces. Once a custom interface has been created, you can then implement it in other class modules. Polymorphism means that while many classes can provide the same method, the client calling the method does not have to know which class an object belongs to before calling the method. Polymorphism is useful when an object type will not be set until run time.</P>

<P>In Visual Basic, you can extend custom interfaces by adding new methods, as long as you do not change the signatures of any of the existing methods. To allow for this, Visual Basic uses a technique known as IID forwarding.</P>

<P>Using a single class to implement multiple interfaces is another powerful design technique that you can use. This technique also preserves compatibility between clients and components.</P>

<P>You can maintain backward compatibility when you enhance software components by using Visual Basic's Version Compatibility feature. When you use the No Compatibility option, a new type library is created each time you compile the component. When this option is set, programs compiled to use a particular version of a component cannot use any version other than that which they were compiled to use. The Project Compatibility option allows other instances of the Visual Basic development environment to maintain references to an ActiveX EXE or ActiveX DLL project, while allowing modifications to the component interfaces. Use the Project Compatibility option when you are developing the first version of a component. Use the Binary Compatibility option when you begin development on the new version of a component, if you want client applications compiled using the earlier version to continue to work with the new version.</P>

</BODY>
</HTML>



