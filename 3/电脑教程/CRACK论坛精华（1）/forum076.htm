<html>
<head>
<title>看雪学苑</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<style type="text/css">
<!--
.p8 {  font-size: 8pt}
.p9 {  font-size: 9pt}
a:hover {  color: #00FF00}
a {  text-decoration: none}
.p12 {  font-size: 12pt; font-weight: bold; color: #FF3333}
-->
</style>
</head>

<body bgcolor="#FFFFFF">
<p><span class="p9">有谁可以解掉update now 2.0?把过程POST出来？ </span></p>
<p><span class="p9"><font color=blue>标 题:</font>解了，如下 (4千字)<br>
  <font color=blue>发信人:</font>guest<br>
  <font color=blue>时 间:</font>2000-6-2 15:17:50 <br>
  <font color=blue>详细信息:</font><br>
  </span></p>
<blockquote><span class="p9"> 1、这个东西似乎用Aspack压缩的，脱壳很容易。咱不讨论这个。 <br>
  2、它用MeltICE的方法来检测SoftICE，即 <br>
  &nbsp; &nbsp; &nbsp; CreateFileA("\\\\.\\SICE", ...) <br>
  &nbsp; &nbsp; &nbsp; CreateFileA("\\\\.\\NTICE", ...) <br>
  &nbsp; 所以只要用bpx CreateFileA do "d *(esp+4)"设断点，等看见它欲打开SoftICE的driver时，把上面的文件名改掉糊弄它即可。用FrogsICE欺骗也行。 
  <br>
  3、输入注册码之后它并不立即判断，而是用WritePrivateProfileStringA( )写入c:\windows\update.ini中，下次启动的时候再判断。 
  <br>
  4、用bpx GetPrivateProfileStringA do "d *(esp+8)"设断点，然后再启动它，等看见它读NAME和SERIAL时，让它读出来，然后用BPR监视读出来的NAME和SERIAL，就会看见判断注册码的整个过程。 
  <br>
  &nbsp; 它先计算NAME的累加和，然后每次用wsprintfA( )生成注册码中的两个字符，总共有12字符。 <br>
  <br>
  0167:0042EBD6&nbsp; MOV&nbsp; &nbsp; &nbsp; BL,[EAX+ESP+1C] <br>
  0167:0042EBDA&nbsp; ADD&nbsp; &nbsp; &nbsp; DL,BL&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; //求累加和 <br>
  0167:0042EBDC&nbsp; INC&nbsp; &nbsp; &nbsp; EAX <br>
  0167:0042EBDD&nbsp; CMP&nbsp; &nbsp; &nbsp; EAX,ECX <br>
  0167:0042EBDF&nbsp; JL&nbsp; &nbsp; &nbsp; &nbsp; 0042EBD6 <br>
  0167:0042EBE1&nbsp; MOV&nbsp; &nbsp; &nbsp; [ESP+10],DL <br>
  ...... <br>
  0167:0042EC2B&nbsp; MOV&nbsp; &nbsp; &nbsp; ESI,[ESP+10] <br>
  0167:0042EC2F&nbsp; MOV&nbsp; &nbsp; &nbsp; EDI,[ESP+18] <br>
  0167:0042EC33&nbsp; MOV&nbsp; &nbsp; &nbsp; ECX,[ESP+14] <br>
  0167:0042EC37&nbsp; LEA&nbsp; &nbsp; &nbsp; EAX,[EBX+ESP+1C] <br>
  0167:0042EC3B&nbsp; XOR&nbsp; &nbsp; &nbsp; EDX,EDX <br>
  0167:0042EC3D&nbsp; MOV&nbsp; &nbsp; &nbsp; DL,[EAX+ECX] <br>
  0167:0042EC40&nbsp; XOR&nbsp; &nbsp; &nbsp; ECX,ECX <br>
  0167:0042EC42&nbsp; MOV&nbsp; &nbsp; &nbsp; CL,[EAX] <br>
  0167:0042EC44&nbsp; XOR&nbsp; &nbsp; &nbsp; EDX,ECX <br>
  0167:0042EC46&nbsp; XOR&nbsp; &nbsp; &nbsp; EDX,EDI <br>
  0167:0042EC48&nbsp; XOR&nbsp; &nbsp; &nbsp; EDX,ESI <br>
  0167:0042EC4A&nbsp; PUSH&nbsp; &nbsp; &nbsp; EDX <br>
  0167:0042EC4B&nbsp; LEA&nbsp; &nbsp; &nbsp; EDX,[ESP+00000120] <br>
  0167:0042EC52&nbsp; PUSH&nbsp; &nbsp; &nbsp; 0047E198&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; //格式字符串 "%02x" <br>
  0167:0042EC57&nbsp; PUSH&nbsp; &nbsp; &nbsp; EDX <br>
  0167:0042EC58&nbsp; CALL&nbsp; &nbsp; &nbsp; [USER32!wsprintfA] <br>
  0167:0042EC5E&nbsp; LEA&nbsp; &nbsp; &nbsp; EDI,[ESP+00000128] <br>
  0167:0042EC65&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; ECX,-01 <br>
  0167:0042EC68&nbsp; XOR&nbsp; &nbsp; &nbsp; EAX,EAX <br>
  0167:0042EC6A&nbsp; ADD&nbsp; &nbsp; &nbsp; ESP,0C <br>
  0167:0042EC6D&nbsp; REPNZ SCASB <br>
  0167:0042EC6F&nbsp; NOT&nbsp; &nbsp; &nbsp; ECX <br>
  0167:0042EC71&nbsp; SUB&nbsp; &nbsp; &nbsp; EDI,ECX <br>
  0167:0042EC73&nbsp; MOV&nbsp; &nbsp; &nbsp; ESI,EDI <br>
  0167:0042EC75&nbsp; MOV&nbsp; &nbsp; &nbsp; EDI,[ESP+00000224] <br>
  0167:0042EC7C&nbsp; MOV&nbsp; &nbsp; &nbsp; EDX,ECX <br>
  0167:0042EC7E&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; ECX,-01 <br>
  0167:0042EC81&nbsp; REPNZ SCASB <br>
  0167:0042EC83&nbsp; MOV&nbsp; &nbsp; &nbsp; ECX,EDX <br>
  0167:0042EC85&nbsp; DEC&nbsp; &nbsp; &nbsp; EDI <br>
  0167:0042EC86&nbsp; SHR&nbsp; &nbsp; &nbsp; ECX,02 <br>
  0167:0042EC89&nbsp; REPZ MOVSD <br>
  0167:0042EC8B&nbsp; MOV&nbsp; &nbsp; &nbsp; ECX,EDX <br>
  0167:0042EC8D&nbsp; AND&nbsp; &nbsp; &nbsp; ECX,03 <br>
  0167:0042EC90&nbsp; INC&nbsp; &nbsp; &nbsp; EBX <br>
  0167:0042EC91&nbsp; CMP&nbsp; &nbsp; &nbsp; EBX,EBP <br>
  0167:0042EC93&nbsp; REPZ MOVSB <br>
  0167:0042EC95&nbsp; JL&nbsp; &nbsp; &nbsp; &nbsp; 0042EC2B&nbsp; &nbsp; //循环 
  <br>
  &nbsp; &nbsp; <br>
  &nbsp; 它还要将这12个字符中的首字符用相邻两字符交换位置的方法放到第8个字符的位置上。并将这12个字符中的前7个字符都与0x67相或。 <br>
  0167:0042ECA2&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; ESI,-01 <br>
  0167:0042ECA5&nbsp; LEA&nbsp; &nbsp; &nbsp; EAX,[ECX+01] <br>
  0167:0042ECA8&nbsp; SUB&nbsp; &nbsp; &nbsp; ESI,ECX <br>
  0167:0042ECAA&nbsp; MOV&nbsp; &nbsp; &nbsp; DL,[EAX] <br>
  0167:0042ECAC&nbsp; MOV&nbsp; &nbsp; &nbsp; CL,[EAX-01] <br>
  0167:0042ECAF&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; DL,67 <br>
  0167:0042ECB2&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; CL,67 <br>
  0167:0042ECB5&nbsp; MOV&nbsp; &nbsp; &nbsp; [EAX-01],DL&nbsp; &nbsp; //交换位置 
  <br>
  0167:0042ECB8&nbsp; MOV&nbsp; &nbsp; &nbsp; [EAX],CL&nbsp; &nbsp; &nbsp; &nbsp; 
  //交换位置 <br>
  0167:0042ECBA&nbsp; INC&nbsp; &nbsp; &nbsp; EAX <br>
  0167:0042ECBB&nbsp; LEA&nbsp; &nbsp; &nbsp; ECX,[EAX+ESI] <br>
  0167:0042ECBE&nbsp; CMP&nbsp; &nbsp; &nbsp; ECX,EBP <br>
  0167:0042ECC0&nbsp; JL&nbsp; &nbsp; &nbsp; &nbsp; 0042ECAA <br>
  <br>
  &nbsp; 再把你输入的假注册码的前7个字符也与0x67相或，然后就比较。 <br>
  0167:00428862&nbsp; REPNZ SCASB <br>
  0167:00428864&nbsp; NOT&nbsp; &nbsp; &nbsp; ECX <br>
  0167:00428866&nbsp; DEC&nbsp; &nbsp; &nbsp; ECX <br>
  0167:00428867&nbsp; LEA&nbsp; &nbsp; &nbsp; EDI,[ESP+00000164] <br>
  0167:0042886E&nbsp; MOV&nbsp; &nbsp; &nbsp; EDX,ECX <br>
  0167:00428870&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; ECX,-01 <br>
  0167:00428873&nbsp; REPNZ SCASB <br>
  0167:00428875&nbsp; NOT&nbsp; &nbsp; &nbsp; ECX <br>
  0167:00428877&nbsp; DEC&nbsp; &nbsp; &nbsp; ECX <br>
  0167:00428878&nbsp; CMP&nbsp; &nbsp; &nbsp; ECX,EDX&nbsp; //比较真假注册码的长度，为12 <br>
  0167:0042887A&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 004288A6 <br>
  0167:0042887C&nbsp; PUSH&nbsp; &nbsp; &nbsp; 6C <br>
  0167:0042887E&nbsp; CALL&nbsp; &nbsp; &nbsp; 004531B7 <br>
  .............. <br>
  0167:004288BA&nbsp; MOV&nbsp; &nbsp; &nbsp; AL,[ECX+ESP+000000E4] <br>
  0167:004288C1&nbsp; MOV&nbsp; &nbsp; &nbsp; DL,[ECX+ESP+00000164] <br>
  0167:004288C8&nbsp; CMP&nbsp; &nbsp; &nbsp; AL,DL&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; //比较 <br>
  0167:004288CA&nbsp; JNZ&nbsp; &nbsp; &nbsp; 004288CF <br>
  0167:004288CC&nbsp; DEC&nbsp; &nbsp; &nbsp; ECX <br>
  0167:004288CD&nbsp; JNS&nbsp; &nbsp; &nbsp; 004288BA <br>
  0167:004288CF&nbsp; LEA&nbsp; &nbsp; &nbsp; EDI,[ESP+000000E4] <br>
  0167:004288D6&nbsp; OR&nbsp; &nbsp; &nbsp; &nbsp; ECX,-01 <br>
  0167:004288D9&nbsp; XOR&nbsp; &nbsp; &nbsp; EAX,EAX <br>
  0167:004288DB&nbsp; XOR&nbsp; &nbsp; &nbsp; EDX,EDX <br>
  0167:004288DD&nbsp; REPNZ SCASB <br>
  0167:004288DF&nbsp; NOT&nbsp; &nbsp; &nbsp; ECX <br>
  0167:004288E1&nbsp; DEC&nbsp; &nbsp; &nbsp; ECX <br>
  0167:004288E2&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 00428977 <br>
  0167:004288E8&nbsp; MOV&nbsp; &nbsp; &nbsp; CL,[EDX+ESP+00000164] <br>
  0167:004288EF&nbsp; MOV&nbsp; &nbsp; &nbsp; AL,[EDX+ESP+000000E4] <br>
  0167:004288F6&nbsp; CMP&nbsp; &nbsp; &nbsp; CL,AL&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; //比较 <br>
  0167:004288F8&nbsp; JNZ&nbsp; &nbsp; &nbsp; 00428912 <br>
  <br>
  &nbsp; 也就是说，它不是直接比较注册码，而是把真假注册码都与0x67相或之后再进行比较。 <br>
  <br>
  Name:&nbsp; Netguy/CrackingForFun <br>
  Code:&nbsp; 3c8d99e3dfc0 </span></blockquote>
<hr>
<p><span class="p9"><font color=blue>标 题:</font>key generator (1千字)<br>
  <font color=blue>发信人:</font>guest<br>
  <font color=blue>时 间:</font>2000-6-2 16:44:12 <br>
  <font color=blue>详细信息:</font><br>
  </span></p>
<blockquote><span class="p9"> #include &lt;stdio.h> <br>
  #include &lt;string.h> <br>
  <br>
  void main(void) <br>
  { <br>
  &nbsp; &nbsp; char Buf[128]; <br>
  &nbsp; &nbsp; char Name[128]; <br>
  &nbsp; &nbsp; char Serial[13]; <br>
  &nbsp; &nbsp; int&nbsp; k, len; <br>
  &nbsp; &nbsp; char sum, repeat; <br>
  &nbsp; &nbsp; const char home[]="www.pcchina.net"; <br>
  <br>
  &nbsp; &nbsp; printf("KeyGen for Update NOW! 2.0.\n"); <br>
  &nbsp; &nbsp; printf("coded by Netguy.\n"); <br>
  <br>
  &nbsp; &nbsp; printf("Input your name: "); <br>
  &nbsp; &nbsp; gets(Name); <br>
  <br>
  &nbsp; &nbsp; strcpy(Buf, Name); <br>
  <br>
  &nbsp; &nbsp; len = strlen(Name); <br>
  &nbsp; &nbsp; for(k = 0; k &lt; 6; k++) <br>
  &nbsp; &nbsp; { <br>
  &nbsp; &nbsp; &nbsp; &nbsp; Name[k] &amp;= 0x7F; <br>
  &nbsp; &nbsp; } <br>
  <br>
  &nbsp; &nbsp; repeat = 6 / len; <br>
  &nbsp; &nbsp; for (k = 0; k &lt; repeat; k++) <br>
  &nbsp; &nbsp; { <br>
  &nbsp; &nbsp; &nbsp; &nbsp; strcat(Name, Buf); <br>
  &nbsp; &nbsp; } <br>
  &nbsp; &nbsp; <br>
  &nbsp; &nbsp; len = strlen(Name); <br>
  &nbsp; &nbsp; sum = 0; <br>
  &nbsp; &nbsp; for(k = 0; k &lt; len; k++) <br>
  &nbsp; &nbsp; { <br>
  &nbsp; &nbsp; &nbsp; &nbsp; sum += Name[k]; <br>
  &nbsp; &nbsp; } <br>
  <br>
  &nbsp; &nbsp; Serial[0] = '\0'; <br>
  &nbsp; &nbsp; for(k = 0; k &lt; 6; k++) <br>
  &nbsp; &nbsp; { <br>
  &nbsp; &nbsp; &nbsp; &nbsp; Name[k] ^= sum; <br>
  &nbsp; &nbsp; &nbsp; &nbsp; Name[k] ^= 0xC7; <br>
  &nbsp; &nbsp; &nbsp; &nbsp; Name[k] ^= home[k]; <br>
  &nbsp; &nbsp; &nbsp; &nbsp; sprintf(Buf, "%02x", Name[k] &amp; 0xFF); <br>
  &nbsp; &nbsp; &nbsp; &nbsp; strcat(Serial, Buf); <br>
  &nbsp; &nbsp; } <br>
  <br>
  &nbsp; &nbsp; printf("Your registration code is: "); <br>
  &nbsp; &nbsp; for (k = 1; k &lt;= 6; k++) putchar(Serial[k]); <br>
  &nbsp; &nbsp; putchar(Serial[0]); <br>
  &nbsp; &nbsp; puts(&amp;Serial[7]); <br>
  } </span></blockquote>
<hr>
<p>&nbsp; </p>
</body>
</html>
